var VD = Object.defineProperty;
var BD = (t, e, n) => e in t ? VD(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var De = (t, e, n) => (BD(t, typeof e != "symbol" ? e + "" : e, n), n);
import { defineComponent as Te, ref as re, computed as J, watch as gt, openBlock as _, createElementBlock as Z, mergeProps as wt, h as ir, getCurrentInstance as Ip, inject as fs, onMounted as Et, onUnmounted as to, shallowRef as vd, onBeforeMount as ZD, Fragment as Qe, createVNode as fe, Text as Xx, normalizeClass as Ae, unref as E, createCommentVNode as W, renderSlot as ne, reactive as Bs, useSlots as zo, toRef as Ca, nextTick as nn, isRef as G0, createSlots as un, renderList as Ge, withCtx as H, normalizeProps as Ct, guardReactiveProps as Zt, createBlock as ue, resolveDynamicComponent as ar, Teleport as My, Transition as Fn, normalizeStyle as pt, createElementVNode as X, withModifiers as Tt, toDisplayString as Pe, render as K0, useAttrs as zx, createTextVNode as He, onBeforeUpdate as jx, withDirectives as yt, vShow as sc, withKeys as ai, getCurrentScope as Ey, onScopeDispose as Ay, resolveComponent as Ce, provide as ua, mergeModels as FD, useModel as qD, resolveDirective as vr, Comment as WD, readonly as Yx, toValue as Ro, customRef as Hx, onBeforeUnmount as Zs, vModelText as Lr, onUpdated as XD, TransitionGroup as Ux, toRefs as zD, shallowReadonly as Ga, watchEffect as jD, markRaw as YD } from "vue";
const HD = (t, e) => {
  const n = t[e];
  return n ? typeof n == "function" ? n() : Promise.resolve(n) : new Promise((i, r) => {
    (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(r.bind(null, new Error("Unknown variable dynamic import: " + e)));
  });
}, UD = ["aria-hidden", "data-testid", "innerHTML"], mt = /* @__PURE__ */ Te({
  __name: "mt-icon",
  props: {
    name: {},
    color: {},
    decorative: { type: Boolean, default: !1 },
    size: { default: void 0 }
  },
  setup(t) {
    const e = t, n = re(`<svg id="meteor-icon-kit__${e.name}"></svg>`), i = J(() => {
      const r = {
        color: e.color
      };
      if (e.size) {
        let o = e.size;
        !Number.isNaN(parseFloat(o)) && !Number.isNaN(o - 0) && (o = `${o}px`), r.width = o, r.height = o;
      }
      return r;
    });
    return gt(
      () => e.name,
      (r) => {
        const [o] = r.split("-"), s = r.split("-").slice(1).join("-");
        HD(/* @__PURE__ */ Object.assign({ "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/3d.svg": () => import("../3d-c68e14ed.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/AR.svg": () => import("../AR-15958086.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/activity.svg": () => import("../activity-8ed3beb4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/align-center-xs.svg": () => import("../align-center-xs-5e43b6ff.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/align-center.svg": () => import("../align-center-a40a3e3a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/align-justify.svg": () => import("../align-justify-c54bb43c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/align-left-xs.svg": () => import("../align-left-xs-024ed17c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/align-left.svg": () => import("../align-left-aed68bb2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/align-right-xs.svg": () => import("../align-right-xs-4e34632b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/align-right.svg": () => import("../align-right-ac88d176.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/analytics.svg": () => import("../analytics-4a50d905.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/archive.svg": () => import("../archive-9ad55beb.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/arrows.svg": () => import("../arrows-9be25b74.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/artificial-intelligence.svg": () => import("../artificial-intelligence-b85d1a36.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/audio-description.svg": () => import("../audio-description-2cd59a15.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/balance-scale.svg": () => import("../balance-scale-d08fb7fd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/ban.svg": () => import("../ban-a24151b7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/barcode-scan.svg": () => import("../barcode-scan-4786b7f1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/barcode.svg": () => import("../barcode-76ed3f42.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bars-alt-s.svg": () => import("../bars-alt-s-bead6284.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bars-circle-s.svg": () => import("../bars-circle-s-76b0e18e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bars-circle.svg": () => import("../bars-circle-2a34d282.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bars-s.svg": () => import("../bars-s-408a3b58.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bars-square-s.svg": () => import("../bars-square-s-dfec3675.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bars-square.svg": () => import("../bars-square-ddc3fb7d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bars.svg": () => import("../bars-d1603b6f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/beer.svg": () => import("../beer-f7572356.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bell-slash.svg": () => import("../bell-slash-0f062df4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bell.svg": () => import("../bell-6cd59134.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/blocked-circle.svg": () => import("../blocked-circle-e8028660.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bold-xs.svg": () => import("../bold-xs-e68c81ca.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bold.svg": () => import("../bold-dd5bd8e5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/book-user.svg": () => import("../book-user-60413937.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bookmark.svg": () => import("../bookmark-6fee6518.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/books.svg": () => import("../books-575deb7f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/box-alt.svg": () => import("../box-alt-cf3ab2b8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/box.svg": () => import("../box-4e50d1b6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/boxes.svg": () => import("../boxes-c2419d8c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/brands.svg": () => import("../brands-c52d6848.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/briefcase.svg": () => import("../briefcase-be6cdb85.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bug.svg": () => import("../bug-42a0f768.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/bulk-edit.svg": () => import("../bulk-edit-cab0ce0a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/calendar.svg": () => import("../calendar-89d00a7e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/camera.svg": () => import("../camera-f0e02203.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chart-bar.svg": () => import("../chart-bar-4c67f4a4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chart-line-arrow.svg": () => import("../chart-line-arrow-fc4d86cf.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chart-line-down-s.svg": () => import("../chart-line-down-s-ce2d2b24.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chart-line-up-s.svg": () => import("../chart-line-up-s-6a582c5e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chart-line.svg": () => import("../chart-line-cdbf3ac5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chart-pie.svg": () => import("../chart-pie-0fd958e1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/check-circle-s.svg": () => import("../check-circle-s-cf013654.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/check-circle.svg": () => import("../check-circle-b7de1f6f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/check-square-s.svg": () => import("../check-square-s-d3700e1d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/check-square.svg": () => import("../check-square-2d70a5e5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/checkmark-s.svg": () => import("../checkmark-s-46ed6aeb.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/checkmark-xs.svg": () => import("../checkmark-xs-d7060eba.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/checkmark-xxs.svg": () => import("../checkmark-xxs-b77f07bd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/checkmark.svg": () => import("../checkmark-99cc8496.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-circle-down.svg": () => import("../chevron-circle-down-fa1fa413.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-circle-left.svg": () => import("../chevron-circle-left-7e633f88.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-circle-right.svg": () => import("../chevron-circle-right-e13303a7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-circle-up.svg": () => import("../chevron-circle-up-9e98ed00.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-down-s.svg": () => import("../chevron-down-s-8c128720.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-down-xs.svg": () => import("../chevron-down-xs-e69c01c2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-down-xxs.svg": () => import("../chevron-down-xxs-03b6fcdc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-down.svg": () => import("../chevron-down-0e4cf03a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-left-s.svg": () => import("../chevron-left-s-bbceda23.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-left-xs.svg": () => import("../chevron-left-xs-ebe14878.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-left-xxs.svg": () => import("../chevron-left-xxs-306dff4b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-left.svg": () => import("../chevron-left-3ea01bda.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-right-s.svg": () => import("../chevron-right-s-f402dbf1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-right-xs.svg": () => import("../chevron-right-xs-556bd2d3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-right-xxs.svg": () => import("../chevron-right-xxs-a3cfff1b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-right.svg": () => import("../chevron-right-fee05363.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-up-s.svg": () => import("../chevron-up-s-0a321475.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-up-xs.svg": () => import("../chevron-up-xs-4b384503.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-up-xxs.svg": () => import("../chevron-up-xxs-e890f7d1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/chevron-up.svg": () => import("../chevron-up-924ed4b6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/circle-download.svg": () => import("../circle-download-798553f6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/circle-s.svg": () => import("../circle-s-78a14598.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/circle-upload.svg": () => import("../circle-upload-94cad584.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/circle-xs.svg": () => import("../circle-xs-abbd9264.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/circle-xxs.svg": () => import("../circle-xxs-f9d0c3c1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/circle-xxxs.svg": () => import("../circle-xxxs-505b1b7d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/circle.svg": () => import("../circle-aba81447.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/clipboard.svg": () => import("../clipboard-7ecdc393.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/clock.svg": () => import("../clock-06572e84.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/closed-captioning.svg": () => import("../closed-captioning-c957be4b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/cloud-download.svg": () => import("../cloud-download-51a41513.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/cloud-upload.svg": () => import("../cloud-upload-5d779946.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/cloud.svg": () => import("../cloud-f9bc3930.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/code-xs.svg": () => import("../code-xs-dc5c492b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/code.svg": () => import("../code-f12f5d90.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/cog-s.svg": () => import("../cog-s-6f085942.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/cog.svg": () => import("../cog-bd33d99d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/comment.svg": () => import("../comment-2c9a9d63.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/comments.svg": () => import("../comments-0957bcab.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/compress-arrows-s.svg": () => import("../compress-arrows-s-0b9f65e9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/compress-arrows-xs.svg": () => import("../compress-arrows-xs-4cd49ca1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/compress-arrows.svg": () => import("../compress-arrows-0b2add33.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/compress.svg": () => import("../compress-da617945.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/content.svg": () => import("../content-dba103bd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/copy-s.svg": () => import("../copy-s-61113ae3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/copy.svg": () => import("../copy-734b7061.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/copyright.svg": () => import("../copyright-8305393a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/credit-card.svg": () => import("../credit-card-032b9b7f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/crosshair-block.svg": () => import("../crosshair-block-9ca58633.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/crosshair.svg": () => import("../crosshair-a988d78f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/crossselling.svg": () => import("../crossselling-2588ffaf.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/dashboard.svg": () => import("../dashboard-6adf8949.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/database.svg": () => import("../database-9b0ee240.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/delete-column.svg": () => import("../delete-column-ac65e5a0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/delete-row.svg": () => import("../delete-row-af4840f7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/desktop-slash.svg": () => import("../desktop-slash-bb2ab7f6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/desktop.svg": () => import("../desktop-9687609c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/discord.svg": () => import("../discord-fbba0f25.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/discount.svg": () => import("../discount-dff696b2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/dolly.svg": () => import("../dolly-329d08fd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/double-chevron-down-s.svg": () => import("../double-chevron-down-s-d5103a07.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/double-chevron-down-xs.svg": () => import("../double-chevron-down-xs-f64b8bf6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/double-chevron-down-xxs.svg": () => import("../double-chevron-down-xxs-520b8950.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/double-chevron-left-s.svg": () => import("../double-chevron-left-s-a80f714a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/double-chevron-left-xs.svg": () => import("../double-chevron-left-xs-c1e7dff3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/double-chevron-left-xxs.svg": () => import("../double-chevron-left-xxs-e4db2c28.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/double-chevron-right-s.svg": () => import("../double-chevron-right-s-e45c086e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/double-chevron-right-xs.svg": () => import("../double-chevron-right-xs-2a544340.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/double-chevron-right-xxs.svg": () => import("../double-chevron-right-xxs-1ac7512d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/double-chevron-up-s.svg": () => import("../double-chevron-up-s-d3e4815e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/double-chevron-up-xs.svg": () => import("../double-chevron-up-xs-491480c5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/double-chevron-up-xxs.svg": () => import("../double-chevron-up-xxs-05e04b56.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/down-circle.svg": () => import("../down-circle-38720d64.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/down-left-circle.svg": () => import("../down-left-circle-071ff6a8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/down-right-circle.svg": () => import("../down-right-circle-f5c90901.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/download.svg": () => import("../download-4b93146a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/dribbble.svg": () => import("../dribbble-0c15c5f5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/duplicate.svg": () => import("../duplicate-7f603192.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/e-scooter.svg": () => import("../e-scooter-443a7a6c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/ellipsis-h-s.svg": () => import("../ellipsis-h-s-ecb649ab.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/ellipsis-h.svg": () => import("../ellipsis-h-64e48378.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/ellipsis-v.svg": () => import("../ellipsis-v-84dabe91.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/envelope.svg": () => import("../envelope-be11a9f8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/euro.svg": () => import("../euro-e8a44ff5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/exchange-alt-s.svg": () => import("../exchange-alt-s-cfbc50f7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/exchange-s.svg": () => import("../exchange-s-b6a6eda2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/exclamation-circle.svg": () => import("../exclamation-circle-b8eb9753.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/exclamation-s.svg": () => import("../exclamation-s-61c78997.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/exclamation-triangle.svg": () => import("../exclamation-triangle-0dbc2e38.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/expand-arrows-s.svg": () => import("../expand-arrows-s-2b62e752.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/expand-arrows-xs.svg": () => import("../expand-arrows-xs-f766f8cc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/expand-arrows.svg": () => import("../expand-arrows-c3a96c4a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/expand.svg": () => import("../expand-69d0180c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/external-link-s.svg": () => import("../external-link-s-c19699e6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/external-link.svg": () => import("../external-link-5583ba06.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/eye-dropper.svg": () => import("../eye-dropper-5c6c32f7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/eye-s.svg": () => import("../eye-s-847bacbd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/eye-slash.svg": () => import("../eye-slash-c946e7e0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/eye.svg": () => import("../eye-d50e34f0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/facebook.svg": () => import("../facebook-a0a9be76.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/factory.svg": () => import("../factory-b5c1c5b1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/figma.svg": () => import("../figma-961654f5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/file-edit-s.svg": () => import("../file-edit-s-0eb7c024.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/file-edit.svg": () => import("../file-edit-37af2ff6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/file-export.svg": () => import("../file-export-a613770b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/file-search.svg": () => import("../file-search-4886146b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/file-signature.svg": () => import("../file-signature-2e9c9cbb.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/file-text.svg": () => import("../file-text-d570a647.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/file.svg": () => import("../file-06953e0e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/files.svg": () => import("../files-8c666bd5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/filter-s.svg": () => import("../filter-s-46d25922.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/filter.svg": () => import("../filter-4a3fde3b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/fingerprint.svg": () => import("../fingerprint-bfeed11f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/flag.svg": () => import("../flag-880161a0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/flask.svg": () => import("../flask-bdb30893.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/flow.svg": () => import("../flow-db57f278.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/folder-open.svg": () => import("../folder-open-7629bc75.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/folder.svg": () => import("../folder-64eaf4e1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/forklift.svg": () => import("../forklift-748735ef.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/forward.svg": () => import("../forward-a8fee962.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/gamecontroller.svg": () => import("../gamecontroller-784f3d33.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/genderless.svg": () => import("../genderless-e830d789.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/gift.svg": () => import("../gift-b8705ed7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/github.svg": () => import("../github-63970d89.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/globe-stand.svg": () => import("../globe-stand-d56a8b49.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/globe.svg": () => import("../globe-9c3f0de5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/google.svg": () => import("../google-91f16a6b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/graduation-cap.svg": () => import("../graduation-cap-ce3fdbcd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/grip-horizontal-s.svg": () => import("../grip-horizontal-s-413ed42a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/grip-horizontal.svg": () => import("../grip-horizontal-6c924942.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/grip-lines.svg": () => import("../grip-lines-db56c807.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/grip-vertical-s.svg": () => import("../grip-vertical-s-0e6452f2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/grip-vertical.svg": () => import("../grip-vertical-67e161e7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/guide.svg": () => import("../guide-5c26bb10.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/harddisk.svg": () => import("../harddisk-ce5e78c7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/hashtag.svg": () => import("../hashtag-03f405d6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/headset.svg": () => import("../headset-9f00d90c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/heart-s.svg": () => import("../heart-s-e0917e02.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/heart.svg": () => import("../heart-0fbc0fc6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/highlight.svg": () => import("../highlight-77ea2e19.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/history.svg": () => import("../history-7a61378c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/home-simple.svg": () => import("../home-simple-9f56f527.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/home.svg": () => import("../home-61ec5aa8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/hourglass.svg": () => import("../hourglass-cecb10b3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/image-s.svg": () => import("../image-s-c99b4e96.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/image-text.svg": () => import("../image-text-aa662daa.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/image-xs.svg": () => import("../image-xs-c857e901.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/image.svg": () => import("../image-9182b4b8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/inbox.svg": () => import("../inbox-ca1cff51.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/infinity.svg": () => import("../infinity-daf8cdfc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/info-circle.svg": () => import("../info-circle-152d69c1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/insert-column-after.svg": () => import("../insert-column-after-767ee294.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/insert-column-before.svg": () => import("../insert-column-before-621b98a5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/insert-row-after.svg": () => import("../insert-row-after-bfe128ca.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/insert-row-before.svg": () => import("../insert-row-before-2f633587.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/instagram.svg": () => import("../instagram-b9f55269.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/inventory.svg": () => import("../inventory-856d3fb9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/iot-connection.svg": () => import("../iot-connection-9dacad38.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/iot.svg": () => import("../iot-449458cc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/italic-xs.svg": () => import("../italic-xs-a9e59d50.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/italic.svg": () => import("../italic-a653164a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/key.svg": () => import("../key-9a139943.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/keyboard.svg": () => import("../keyboard-2d40b17d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/language-alt.svg": () => import("../language-alt-72b0e6fb.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/language.svg": () => import("../language-9f899310.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/laptop.svg": () => import("../laptop-edfb8720.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/layer-group.svg": () => import("../layer-group-fa919fa2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/layout.svg": () => import("../layout-7b6d649d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/left-circle.svg": () => import("../left-circle-b28a257f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/lightbulb.svg": () => import("../lightbulb-796bbad2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/line-column-xs.svg": () => import("../line-column-xs-c9ca6c40.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/line-column.svg": () => import("../line-column-da14a46b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/link-horizontal-slash.svg": () => import("../link-horizontal-slash-99392d2c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/link-horizontal.svg": () => import("../link-horizontal-394d4583.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/link-xs.svg": () => import("../link-xs-6890e0fe.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/link.svg": () => import("../link-910c9673.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/linkedin.svg": () => import("../linkedin-a426f5cd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/list-alphabetical-xs.svg": () => import("../list-alphabetical-xs-a0305583.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/list-numbered-xs.svg": () => import("../list-numbered-xs-675f5a7b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/list-unordered-xs.svg": () => import("../list-unordered-xs-575e7ea9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/list-xs.svg": () => import("../list-xs-d09f8170.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/list.svg": () => import("../list-3fc44f8b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/location-arrow.svg": () => import("../location-arrow-c96fa969.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/lock-open-s.svg": () => import("../lock-open-s-17fb4ecc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/lock-open.svg": () => import("../lock-open-0d61c714.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/lock-s.svg": () => import("../lock-s-c426bba7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/lock.svg": () => import("../lock-34ba33c4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/long-arrow-down-left.svg": () => import("../long-arrow-down-left-e5bd7a12.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/long-arrow-down-right-s.svg": () => import("../long-arrow-down-right-s-90eaf133.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/long-arrow-down-right.svg": () => import("../long-arrow-down-right-59250239.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/long-arrow-down-xs.svg": () => import("../long-arrow-down-xs-b4b1cb34.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/long-arrow-down.svg": () => import("../long-arrow-down-1cf25593.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/long-arrow-left.svg": () => import("../long-arrow-left-526d086b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/long-arrow-right.svg": () => import("../long-arrow-right-e44ad141.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/long-arrow-up-left.svg": () => import("../long-arrow-up-left-11c61c6d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/long-arrow-up-right.svg": () => import("../long-arrow-up-right-f1453cf6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/long-arrow-up.svg": () => import("../long-arrow-up-0f193bc3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/low-vision.svg": () => import("../low-vision-ab565d8f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/map-marker.svg": () => import("../map-marker-7631e622.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/map.svg": () => import("../map-71b46544.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/marker.svg": () => import("../marker-9568dff2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/marketplace-stall.svg": () => import("../marketplace-stall-66c49a9e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/mars-double.svg": () => import("../mars-double-d75ccbd7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/mars-stroke-h.svg": () => import("../mars-stroke-h-a787a8a5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/mars-stroke-v.svg": () => import("../mars-stroke-v-b8207201.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/mars-stroke.svg": () => import("../mars-stroke-3d5de26e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/mars.svg": () => import("../mars-1cc48b4b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/medal.svg": () => import("../medal-e31867df.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/medium.svg": () => import("../medium-836f3d8b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/megaphone.svg": () => import("../megaphone-d6a606be.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/mercury.svg": () => import("../mercury-f312e192.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/messanger.svg": () => import("../messanger-b6ec5fd4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/microphone-slash.svg": () => import("../microphone-slash-1c330510.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/microphone.svg": () => import("../microphone-6050d362.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/minus-circle-s.svg": () => import("../minus-circle-s-ae3aa0c4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/minus-circle.svg": () => import("../minus-circle-27479330.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/minus-s.svg": () => import("../minus-s-1ebb7af8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/minus-square-s.svg": () => import("../minus-square-s-1e10151a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/minus-square.svg": () => import("../minus-square-3bacc601.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/minus-xs.svg": () => import("../minus-xs-ca846af1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/minus-xxs.svg": () => import("../minus-xxs-c8799424.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/minus.svg": () => import("../minus-52c9dbae.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/mobile-slash.svg": () => import("../mobile-slash-681aab6e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/mobile.svg": () => import("../mobile-4e411cc1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/money-bill.svg": () => import("../money-bill-47181244.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/moon.svg": () => import("../moon-b0c0382c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/officebuilding.svg": () => import("../officebuilding-5e77f3f8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/paper-plane.svg": () => import("../paper-plane-3b20b618.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/paperclip.svg": () => import("../paperclip-38c80fdb.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/party-horn.svg": () => import("../party-horn-9f52ec82.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/pause-s.svg": () => import("../pause-s-6c24c90a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/pause.svg": () => import("../pause-d9bf1bcc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/pawn.svg": () => import("../pawn-426664fa.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/pencil-s.svg": () => import("../pencil-s-42516d48.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/phone-slash.svg": () => import("../phone-slash-27f6c5cf.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/phone.svg": () => import("../phone-c703e4c3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/pinterest.svg": () => import("../pinterest-fddfa033.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/plans.svg": () => import("../plans-75584972.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/play-s.svg": () => import("../play-s-fc61e78c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/play.svg": () => import("../play-a4d35de0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/plug.svg": () => import("../plug-893b7247.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/plus-circle-s.svg": () => import("../plus-circle-s-75b84ec6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/plus-circle.svg": () => import("../plus-circle-cdb26164.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/plus-s.svg": () => import("../plus-s-bdff38b6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/plus-square-s.svg": () => import("../plus-square-s-f3102b1a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/plus-square.svg": () => import("../plus-square-427a14ad.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/plus-xs.svg": () => import("../plus-xs-f2ceca9b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/plus-xxs.svg": () => import("../plus-xxs-5bab5c58.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/plus.svg": () => import("../plus-091c8e4b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/printer-s.svg": () => import("../printer-s-296799d8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/printer.svg": () => import("../printer-5006ca84.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/products-s.svg": () => import("../products-s-d9689271.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/products.svg": () => import("../products-34c762ed.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/puzzle-piece.svg": () => import("../puzzle-piece-e37c58f5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/question-circle-s.svg": () => import("../question-circle-s-c493b6b7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/question-circle.svg": () => import("../question-circle-6482827d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/questionmark-s.svg": () => import("../questionmark-s-0b997501.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/quote.svg": () => import("../quote-a0d70f9b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/receipt.svg": () => import("../receipt-82aef3bb.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/recycle.svg": () => import("../recycle-135e59ea.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/redo-s.svg": () => import("../redo-s-6819eacb.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/redo-xs.svg": () => import("../redo-xs-cf9381ba.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/redo.svg": () => import("../redo-16932d28.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/register.svg": () => import("../register-99eb1849.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/repeat.svg": () => import("../repeat-bdf939cc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/reply.svg": () => import("../reply-c2582dce.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/right-circle.svg": () => import("../right-circle-94d61e03.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/rocket.svg": () => import("../rocket-e2f6e597.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/rule-s.svg": () => import("../rule-s-ed7d04dc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/rule.svg": () => import("../rule-232c0264.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/save.svg": () => import("../save-fa76b899.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/scanner.svg": () => import("../scanner-5fdbcaa9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/screen-share.svg": () => import("../screen-share-175140d6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/search-s.svg": () => import("../search-s-3ab6d732.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/search.svg": () => import("../search-99f269ff.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/server.svg": () => import("../server-4ee2090d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/share-s.svg": () => import("../share-s-780f38b7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/share.svg": () => import("../share-9f2f073e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/shield.svg": () => import("../shield-5b1609e7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/shopping-bag-alt.svg": () => import("../shopping-bag-alt-a5dec649.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/shopping-bag-product.svg": () => import("../shopping-bag-product-ba3a269d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/shopping-bag.svg": () => import("../shopping-bag-c3c55092.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/shopping-basket.svg": () => import("../shopping-basket-34475250.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/shopping-cart.svg": () => import("../shopping-cart-470de59b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/shopware.svg": () => import("../shopware-f465581b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/shuffle.svg": () => import("../shuffle-45c0d383.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/sidebar-overlay.svg": () => import("../sidebar-overlay-8d76f26b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/sidebar.svg": () => import("../sidebar-50d9d5bd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/sign-in.svg": () => import("../sign-in-a1144141.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/sign-out.svg": () => import("../sign-out-3c4b04c7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/sitemap.svg": () => import("../sitemap-dc112c52.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/slack.svg": () => import("../slack-c186cfac.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/sliders-v.svg": () => import("../sliders-v-cc74ef6c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/smile-beam.svg": () => import("../smile-beam-30a770f0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/sofa.svg": () => import("../sofa-5d1475b5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/sort.svg": () => import("../sort-318636a3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/sparkle.svg": () => import("../sparkle-3ff9a789.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/sparkles.svg": () => import("../sparkles-82c5e99a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/spinner-star.svg": () => import("../spinner-star-d3b52f8d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/square-s.svg": () => import("../square-s-3716ada4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/square.svg": () => import("../square-b57da07d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/stackoverflow.svg": () => import("../stackoverflow-89042be9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/star-half.svg": () => import("../star-half-05becb19.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/star.svg": () => import("../star-a002966d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/storefront.svg": () => import("../storefront-f5c27b64.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/strikethrough-xs.svg": () => import("../strikethrough-xs-52fce65b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/style-alt-xs.svg": () => import("../style-alt-xs-70cf1f03.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/style-xs.svg": () => import("../style-xs-97e3f841.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/subscript-xs.svg": () => import("../subscript-xs-5c8f9d19.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/sun.svg": () => import("../sun-91eedf53.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/superscript-xs.svg": () => import("../superscript-xs-a66fbb24.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/sync.svg": () => import("../sync-f0065e6f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/table-xs.svg": () => import("../table-xs-0f07a84b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/table.svg": () => import("../table-24220ada.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/tablet-slash.svg": () => import("../tablet-slash-52baa66c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/tablet.svg": () => import("../tablet-5f08f512.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/tachometer.svg": () => import("../tachometer-ef0d0c43.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/tag.svg": () => import("../tag-74dc43bc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/thumbs-down-s.svg": () => import("../thumbs-down-s-e429c020.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/thumbs-down.svg": () => import("../thumbs-down-7de29cca.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/thumbs-up-s.svg": () => import("../thumbs-up-s-caab494d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/thumbs-up.svg": () => import("../thumbs-up-694e5660.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/thumbtack.svg": () => import("../thumbtack-f9667e6b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/tiktok.svg": () => import("../tiktok-4cd3379a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/times-circle-s.svg": () => import("../times-circle-s-3d8310f5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/times-circle.svg": () => import("../times-circle-9f50ca57.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/times-hexagon.svg": () => import("../times-hexagon-024b3c25.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/times-s.svg": () => import("../times-s-1c9ab4d9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/times-square-s.svg": () => import("../times-square-s-9812d905.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/times-square.svg": () => import("../times-square-499ea93b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/times-xs.svg": () => import("../times-xs-40a52ac1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/times-xxs.svg": () => import("../times-xxs-adb168bd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/times.svg": () => import("../times-df30cf25.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/tools-alt.svg": () => import("../tools-alt-5bb7f889.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/tools.svg": () => import("../tools-b883e40e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/trademark.svg": () => import("../trademark-65a05e81.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/traffic-pawn.svg": () => import("../traffic-pawn-95a37274.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/transgender.svg": () => import("../transgender-00984b19.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/trash-s.svg": () => import("../trash-s-515df521.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/trash.svg": () => import("../trash-162fa881.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/triangle.svg": () => import("../triangle-f736ada1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/trophy.svg": () => import("../trophy-25992c40.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/truck.svg": () => import("../truck-c04fa62a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/tshirt.svg": () => import("../tshirt-a6b5a8be.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/turn-left.svg": () => import("../turn-left-1f0946ca.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/turn-right.svg": () => import("../turn-right-2e86d022.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/twitter.svg": () => import("../twitter-0d818150.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/underline-xs.svg": () => import("../underline-xs-6b73400c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/underline.svg": () => import("../underline-d3e5f532.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/undo-s.svg": () => import("../undo-s-51052f4e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/undo-xs.svg": () => import("../undo-xs-a01c182a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/undo.svg": () => import("../undo-41d58d79.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/universal-access.svg": () => import("../universal-access-99317401.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/up-circle.svg": () => import("../up-circle-a6e87c18.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/up-left-circle.svg": () => import("../up-left-circle-aa1e6193.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/up-right-circle.svg": () => import("../up-right-circle-948655c0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/upload.svg": () => import("../upload-f048d502.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/user-minus.svg": () => import("../user-minus-3f9114e9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/user-plus.svg": () => import("../user-plus-c67719be.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/user-shield.svg": () => import("../user-shield-2a3fba91.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/user.svg": () => import("../user-c7e7f64d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/users.svg": () => import("../users-dd4b78e1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/variables-xs.svg": () => import("../variables-xs-e89df37b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/variants.svg": () => import("../variants-9fd8c723.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/venus-double.svg": () => import("../venus-double-a23c3a12.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/venus-mars.svg": () => import("../venus-mars-eed8b862.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/venus.svg": () => import("../venus-7e5079ba.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/video-slash.svg": () => import("../video-slash-4cbc8e1a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/video.svg": () => import("../video-34cdf9fe.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/view-compact.svg": () => import("../view-compact-cfe684e0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/view-grid.svg": () => import("../view-grid-90c21b41.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/view-normal.svg": () => import("../view-normal-9d7e4a77.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/vimeo.svg": () => import("../vimeo-6eaf0d02.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/volume-mute.svg": () => import("../volume-mute-a5b0ffd9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/volume-up.svg": () => import("../volume-up-be12babd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/wallet.svg": () => import("../wallet-9755e4e6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/wand-magic-sparkles.svg": () => import("../wand-magic-sparkles-9604348f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/wand-magic.svg": () => import("../wand-magic-3c9ff829.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/warehouse.svg": () => import("../warehouse-2f387b88.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/watch.svg": () => import("../watch-26896ffc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/whatsapp.svg": () => import("../whatsapp-6b44e56c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/window-eye.svg": () => import("../window-eye-1996551a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/window-terminal.svg": () => import("../window-terminal-72e60932.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/window.svg": () => import("../window-e76655e2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/wrap-s.svg": () => import("../wrap-s-b869dd5f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/x.svg": () => import("../x-9c70a01e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/xing.svg": () => import("../xing-5f340243.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/regular/youtube.svg": () => import("../youtube-d44e7eed.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/3d.svg": () => import("../3d-32ab6b65.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/AR.svg": () => import("../AR-c6142864.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/activity.svg": () => import("../activity-bd183fc6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/align-center.svg": () => import("../align-center-d02d910e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/align-justify.svg": () => import("../align-justify-4aaabac2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/align-left.svg": () => import("../align-left-1175a64a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/align-right.svg": () => import("../align-right-12fa9dda.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/analytics.svg": () => import("../analytics-f0cfecb4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/archive.svg": () => import("../archive-d0089d2b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/arrows.svg": () => import("../arrows-d5e82fc6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/artificial-intelligence.svg": () => import("../artificial-intelligence-6f3e690b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/audio-description.svg": () => import("../audio-description-254db46b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/balance-scale.svg": () => import("../balance-scale-b318e147.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/ban.svg": () => import("../ban-d1768b2c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/barcode-scan.svg": () => import("../barcode-scan-1434cb0d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/barcode.svg": () => import("../barcode-f8112667.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/bars-alt-s.svg": () => import("../bars-alt-s-80723c30.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/bars-circle-s.svg": () => import("../bars-circle-s-c165db2b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/bars-circle.svg": () => import("../bars-circle-022ca330.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/bars-s.svg": () => import("../bars-s-9f385709.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/bars-square-s.svg": () => import("../bars-square-s-2996072f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/bars-square.svg": () => import("../bars-square-f6b1f2c4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/bars.svg": () => import("../bars-61441b41.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/beer.svg": () => import("../beer-c58f2377.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/bell-slash.svg": () => import("../bell-slash-a8d0a284.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/bell.svg": () => import("../bell-e82ca9f0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/blocked-circle.svg": () => import("../blocked-circle-285cd2ce.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/bold.svg": () => import("../bold-90ea9da4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/book-user.svg": () => import("../book-user-b0d33fd9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/bookmark.svg": () => import("../bookmark-0be22c75.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/books.svg": () => import("../books-2c1ffea4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/box-alt.svg": () => import("../box-alt-89b65262.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/box.svg": () => import("../box-ecc6777b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/boxes.svg": () => import("../boxes-81b3ed99.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/brands.svg": () => import("../brands-27192c52.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/briefcase.svg": () => import("../briefcase-8b5b7d9a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/bug.svg": () => import("../bug-f29373ba.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/bulk-edit.svg": () => import("../bulk-edit-8b45602d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/calendar.svg": () => import("../calendar-848e5560.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/camera.svg": () => import("../camera-7068e49a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chart-bar.svg": () => import("../chart-bar-2b014291.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chart-line-arrow.svg": () => import("../chart-line-arrow-30467f0c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chart-line.svg": () => import("../chart-line-d6e06bc5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chart-pie.svg": () => import("../chart-pie-89c3c8a7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/check-circle-s.svg": () => import("../check-circle-s-f6fbff8e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/check-circle.svg": () => import("../check-circle-5f17f131.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/check-square-s.svg": () => import("../check-square-s-9d6f3d72.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/check-square.svg": () => import("../check-square-b434f0b3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/checkmark-s.svg": () => import("../checkmark-s-73de1891.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/checkmark-xs.svg": () => import("../checkmark-xs-3f8e52a9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/checkmark-xxs.svg": () => import("../checkmark-xxs-9431e985.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/checkmark.svg": () => import("../checkmark-94947228.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-circle-down.svg": () => import("../chevron-circle-down-00bd185f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-circle-left.svg": () => import("../chevron-circle-left-795bb792.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-circle-right.svg": () => import("../chevron-circle-right-afb47f3b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-circle-up.svg": () => import("../chevron-circle-up-9f2eb289.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-down-s.svg": () => import("../chevron-down-s-5ae1e714.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-down-xs.svg": () => import("../chevron-down-xs-8b46d4c0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-down-xxs.svg": () => import("../chevron-down-xxs-db23f539.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-down.svg": () => import("../chevron-down-26896766.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-left-s.svg": () => import("../chevron-left-s-7c467eb3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-left-xs.svg": () => import("../chevron-left-xs-501d14dd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-left-xxs.svg": () => import("../chevron-left-xxs-86a37902.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-left.svg": () => import("../chevron-left-e3baf776.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-right-s.svg": () => import("../chevron-right-s-2c9eaa10.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-right-xs.svg": () => import("../chevron-right-xs-8ccf2f3b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-right-xxs.svg": () => import("../chevron-right-xxs-81637a6e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-right.svg": () => import("../chevron-right-88a7384a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-up-s.svg": () => import("../chevron-up-s-8b52dcce.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-up-xs.svg": () => import("../chevron-up-xs-e026a884.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-up-xxs.svg": () => import("../chevron-up-xxs-6a7d4b0f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/chevron-up.svg": () => import("../chevron-up-f1db6c44.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/circle-download.svg": () => import("../circle-download-8d343348.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/circle-s.svg": () => import("../circle-s-b03bc2d6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/circle-upload.svg": () => import("../circle-upload-89f2351e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/circle-xs.svg": () => import("../circle-xs-a9ad4f12.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/circle-xxs.svg": () => import("../circle-xxs-503fa945.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/circle-xxxs.svg": () => import("../circle-xxxs-25a06e55.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/circle.svg": () => import("../circle-ecbb409c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/clipboard.svg": () => import("../clipboard-11a6f838.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/clock.svg": () => import("../clock-95439b47.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/closed-captioning.svg": () => import("../closed-captioning-07334dbe.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/cloud-download.svg": () => import("../cloud-download-3abefb52.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/cloud-upload.svg": () => import("../cloud-upload-889fdc3e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/cloud.svg": () => import("../cloud-180b36ce.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/code.svg": () => import("../code-876595e5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/cog-s.svg": () => import("../cog-s-c53c1309.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/cog.svg": () => import("../cog-91a8745a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/comment.svg": () => import("../comment-c43705bf.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/comments.svg": () => import("../comments-6d111534.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/compress-arrows-s.svg": () => import("../compress-arrows-s-7b02b42e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/compress-arrows.svg": () => import("../compress-arrows-398ee3ef.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/compress.svg": () => import("../compress-d781a9cb.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/content.svg": () => import("../content-4fa6a9d4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/copy-s.svg": () => import("../copy-s-8c22eb9d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/copy.svg": () => import("../copy-5cb41e44.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/copyright.svg": () => import("../copyright-0443e6d1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/credit-card.svg": () => import("../credit-card-eac485a3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/crosshair-block.svg": () => import("../crosshair-block-b14e2411.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/crosshair.svg": () => import("../crosshair-4afd5341.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/crossselling.svg": () => import("../crossselling-421d9335.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/dashboard.svg": () => import("../dashboard-b1020873.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/database.svg": () => import("../database-14adcf6b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/desktop-slash.svg": () => import("../desktop-slash-99d45d34.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/desktop.svg": () => import("../desktop-5dc7282d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/discord.svg": () => import("../discord-e8bd7426.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/discount.svg": () => import("../discount-f9e67583.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/dolly.svg": () => import("../dolly-b14f8616.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/double-chevron-down-s.svg": () => import("../double-chevron-down-s-71fe4344.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/double-chevron-down-xs.svg": () => import("../double-chevron-down-xs-e2738aba.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/double-chevron-down-xxs.svg": () => import("../double-chevron-down-xxs-39636fff.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/double-chevron-left-s.svg": () => import("../double-chevron-left-s-74277ace.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/double-chevron-left-xs.svg": () => import("../double-chevron-left-xs-781d7a09.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/double-chevron-left-xxs.svg": () => import("../double-chevron-left-xxs-11c95c85.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/double-chevron-right-s.svg": () => import("../double-chevron-right-s-a9c8a7b7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/double-chevron-right-xs.svg": () => import("../double-chevron-right-xs-8e6e68f0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/double-chevron-right-xxs.svg": () => import("../double-chevron-right-xxs-aad21099.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/double-chevron-up-s.svg": () => import("../double-chevron-up-s-bbcf389c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/double-chevron-up-xs.svg": () => import("../double-chevron-up-xs-28456a64.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/double-chevron-up-xxs.svg": () => import("../double-chevron-up-xxs-d641a3f2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/down-circle.svg": () => import("../down-circle-5951fd32.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/down-left-circle.svg": () => import("../down-left-circle-55d99696.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/down-right-circle.svg": () => import("../down-right-circle-30223a5a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/download.svg": () => import("../download-84bd6aaf.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/dribbble.svg": () => import("../dribbble-ed4686b8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/duplicate.svg": () => import("../duplicate-7f32611b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/e-scooter.svg": () => import("../e-scooter-daf5d7fd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/ellipsis-h-s.svg": () => import("../ellipsis-h-s-76a744a8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/ellipsis-h.svg": () => import("../ellipsis-h-3cff63d8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/ellipsis-v.svg": () => import("../ellipsis-v-676e0a72.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/envelope.svg": () => import("../envelope-7b34ea56.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/euro.svg": () => import("../euro-465fe2e2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/exchange-alt-s.svg": () => import("../exchange-alt-s-7ef014b9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/exchange-s.svg": () => import("../exchange-s-d591b71b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/exclamation-circle.svg": () => import("../exclamation-circle-ce8e1391.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/exclamation-triangle.svg": () => import("../exclamation-triangle-4d4d348f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/expand-arrows.svg": () => import("../expand-arrows-a3a52ff3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/expand-s.svg": () => import("../expand-s-8483a2f2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/expand.svg": () => import("../expand-de41e9fd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/external-link-s.svg": () => import("../external-link-s-635e6c31.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/external-link.svg": () => import("../external-link-777aa088.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/eye-dropper.svg": () => import("../eye-dropper-b6a995f9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/eye-s.svg": () => import("../eye-s-0d7f347b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/eye-slash.svg": () => import("../eye-slash-fbea6b4c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/eye.svg": () => import("../eye-a4991340.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/facebook.svg": () => import("../facebook-f5d1ef8a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/factory.svg": () => import("../factory-a1e98063.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/figma.svg": () => import("../figma-b0c5583d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/file-edit.svg": () => import("../file-edit-8cc5a93b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/file-export.svg": () => import("../file-export-fe501b74.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/file-search.svg": () => import("../file-search-0aad7a37.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/file-signature.svg": () => import("../file-signature-301f52f3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/file-text.svg": () => import("../file-text-33dea337.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/file.svg": () => import("../file-567e5730.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/files.svg": () => import("../files-d82f07b2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/filter-s.svg": () => import("../filter-s-79e4ddbe.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/filter.svg": () => import("../filter-85e09b80.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/fingerprint.svg": () => import("../fingerprint-4c1d1c18.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/flag.svg": () => import("../flag-76b93592.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/flask.svg": () => import("../flask-4b172feb.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/flow.svg": () => import("../flow-15c0a4d8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/folder-open.svg": () => import("../folder-open-1bea8cc1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/folder.svg": () => import("../folder-349da77a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/forklift.svg": () => import("../forklift-904a700a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/forward.svg": () => import("../forward-8e3f65e1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/gamecontroller.svg": () => import("../gamecontroller-418e668f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/genderless.svg": () => import("../genderless-3ffc709d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/gift.svg": () => import("../gift-85c0275d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/github.svg": () => import("../github-8977955f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/globe-stand.svg": () => import("../globe-stand-dab03202.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/globe.svg": () => import("../globe-94388f56.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/google.svg": () => import("../google-8c49c712.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/graduation-cap.svg": () => import("../graduation-cap-75df096d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/grip-horizontal-s.svg": () => import("../grip-horizontal-s-afa48442.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/grip-horizontal.svg": () => import("../grip-horizontal-00503bf1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/grip-lines.svg": () => import("../grip-lines-485a9074.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/grip-vertical-s.svg": () => import("../grip-vertical-s-1a6efcab.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/grip-vertical.svg": () => import("../grip-vertical-ccbf8094.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/guide.svg": () => import("../guide-7594763c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/harddisk.svg": () => import("../harddisk-43aba643.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/hashtag.svg": () => import("../hashtag-5cdaf569.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/headset.svg": () => import("../headset-83e54d3e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/heart-s.svg": () => import("../heart-s-9e00ae4d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/heart.svg": () => import("../heart-f4e35af0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/highlight.svg": () => import("../highlight-981f63e8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/history.svg": () => import("../history-2c0bc210.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/home-simple.svg": () => import("../home-simple-dde2d93b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/home.svg": () => import("../home-3422064d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/hourglass.svg": () => import("../hourglass-ce9657fc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/image-s.svg": () => import("../image-s-74c4cb55.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/image-text.svg": () => import("../image-text-cce79968.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/image.svg": () => import("../image-cf8e44f6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/inbox.svg": () => import("../inbox-8906a69e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/infinity.svg": () => import("../infinity-d5067af3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/info-circle.svg": () => import("../info-circle-b8da1f14.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/instagram.svg": () => import("../instagram-27e86344.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/inventory.svg": () => import("../inventory-68cd2735.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/iot-connection.svg": () => import("../iot-connection-8af09e25.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/iot.svg": () => import("../iot-85217690.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/italic.svg": () => import("../italic-d058c288.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/key.svg": () => import("../key-6cfe5c1c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/keyboard.svg": () => import("../keyboard-89b3fbe6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/language-alt.svg": () => import("../language-alt-0407ebf9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/language.svg": () => import("../language-01ff966a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/laptop.svg": () => import("../laptop-ecb90331.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/layer-group.svg": () => import("../layer-group-fce22a59.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/layout.svg": () => import("../layout-9b735c47.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/left-circle.svg": () => import("../left-circle-cb81b0fa.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/lightbulb.svg": () => import("../lightbulb-2c14cabb.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/line-column.svg": () => import("../line-column-04776331.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/link-horizontal-slash.svg": () => import("../link-horizontal-slash-42ecc88a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/link-horizontal.svg": () => import("../link-horizontal-9d8da0bc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/link.svg": () => import("../link-aa4fd6ac.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/linkedin.svg": () => import("../linkedin-9f7f4c25.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/list.svg": () => import("../list-809f9f47.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/location-arrow.svg": () => import("../location-arrow-ee95ddb4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/lock-open-s.svg": () => import("../lock-open-s-4b24960f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/lock-open.svg": () => import("../lock-open-f9a3327d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/lock-s.svg": () => import("../lock-s-427e3b6a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/lock.svg": () => import("../lock-ae2c2f18.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/long-arrow-down-left.svg": () => import("../long-arrow-down-left-dabbb76d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/long-arrow-down-right-s.svg": () => import("../long-arrow-down-right-s-6a5bdc9b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/long-arrow-down-right.svg": () => import("../long-arrow-down-right-79491143.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/long-arrow-down-xs.svg": () => import("../long-arrow-down-xs-4331f9e1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/long-arrow-down.svg": () => import("../long-arrow-down-1235cf5a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/long-arrow-left.svg": () => import("../long-arrow-left-be7b2a85.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/long-arrow-right.svg": () => import("../long-arrow-right-bdf45d81.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/long-arrow-up-left.svg": () => import("../long-arrow-up-left-416f416f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/long-arrow-up-right.svg": () => import("../long-arrow-up-right-0b3aca57.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/long-arrow-up.svg": () => import("../long-arrow-up-4b3479dd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/low-vision.svg": () => import("../low-vision-e580fd88.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/map-marker.svg": () => import("../map-marker-419f4831.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/map.svg": () => import("../map-1d7705aa.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/marker.svg": () => import("../marker-80fdb05a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/marketplace-stall.svg": () => import("../marketplace-stall-155a6d99.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/mars-double.svg": () => import("../mars-double-99205ca7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/mars-stroke-h.svg": () => import("../mars-stroke-h-8b8f8899.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/mars-stroke-v.svg": () => import("../mars-stroke-v-fe5782d3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/mars-stroke.svg": () => import("../mars-stroke-12e6ab20.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/mars.svg": () => import("../mars-b9fa2f2f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/medal.svg": () => import("../medal-948f8c2c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/medium.svg": () => import("../medium-00e8bed4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/megaphone.svg": () => import("../megaphone-38e420c4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/mercury.svg": () => import("../mercury-64e30eb4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/messanger.svg": () => import("../messanger-fdef2a0f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/microphone-slash.svg": () => import("../microphone-slash-7589f7dd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/microphone.svg": () => import("../microphone-d9af711c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/minus-circle-s.svg": () => import("../minus-circle-s-162e05d3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/minus-circle.svg": () => import("../minus-circle-80859f48.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/minus-s.svg": () => import("../minus-s-ddacd60f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/minus-square-s.svg": () => import("../minus-square-s-31c1919b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/minus-square.svg": () => import("../minus-square-4e4eb540.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/minus-xs.svg": () => import("../minus-xs-eed4f70a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/minus-xxs.svg": () => import("../minus-xxs-9df20424.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/minus.svg": () => import("../minus-4e7d1a89.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/mobile-slash.svg": () => import("../mobile-slash-2f5e0210.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/mobile.svg": () => import("../mobile-432e241a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/money-bill.svg": () => import("../money-bill-ce814790.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/moon.svg": () => import("../moon-54d55c09.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/officebuilding.svg": () => import("../officebuilding-04024793.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/paper-plane.svg": () => import("../paper-plane-b662fd64.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/paperclip.svg": () => import("../paperclip-d1966c7d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/party-horn.svg": () => import("../party-horn-89f8f76c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/pause-s.svg": () => import("../pause-s-3dc7a270.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/pause.svg": () => import("../pause-bef29479.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/pawn.svg": () => import("../pawn-90dc7851.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/pencil-s.svg": () => import("../pencil-s-f4b874b7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/phone-slash.svg": () => import("../phone-slash-c437fed4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/phone.svg": () => import("../phone-ec11b49b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/pinterest.svg": () => import("../pinterest-e0f39295.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/plans.svg": () => import("../plans-c25a9554.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/play-s.svg": () => import("../play-s-c9777d94.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/play.svg": () => import("../play-d3eff2be.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/plug.svg": () => import("../plug-e5b67173.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/plus-circle-s.svg": () => import("../plus-circle-s-cf189722.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/plus-circle.svg": () => import("../plus-circle-57dcd1c2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/plus-s.svg": () => import("../plus-s-06a1c01e.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/plus-square-s.svg": () => import("../plus-square-s-41f705e4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/plus-square.svg": () => import("../plus-square-4cb9f006.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/plus-xs.svg": () => import("../plus-xs-d1f9677c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/plus-xxs.svg": () => import("../plus-xxs-e158af41.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/plus.svg": () => import("../plus-5f7871ef.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/printer-s.svg": () => import("../printer-s-fe975904.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/printer.svg": () => import("../printer-bae4ff21.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/products-s.svg": () => import("../products-s-1a5d2037.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/products.svg": () => import("../products-5b739596.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/puzzle-piece.svg": () => import("../puzzle-piece-c95e4032.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/question-circle-s.svg": () => import("../question-circle-s-8511a0dc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/question-circle.svg": () => import("../question-circle-f760bb35.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/quote.svg": () => import("../quote-81e2c01b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/receipt.svg": () => import("../receipt-e9a14a3a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/recycle.svg": () => import("../recycle-15f01c04.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/redo-s.svg": () => import("../redo-s-82e32750.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/redo.svg": () => import("../redo-ea14ff97.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/register.svg": () => import("../register-a7251016.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/repeat.svg": () => import("../repeat-471c0a70.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/reply.svg": () => import("../reply-ee6967a9.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/right-circle.svg": () => import("../right-circle-14f4426d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/rocket.svg": () => import("../rocket-3c8ba3e6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/rule-s.svg": () => import("../rule-s-774e0d42.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/rule.svg": () => import("../rule-b51959dc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/save.svg": () => import("../save-d13b2a8d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/scanner.svg": () => import("../scanner-007878bd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/screen-share.svg": () => import("../screen-share-cf9fe5d8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/search-s.svg": () => import("../search-s-1bab8cf7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/search.svg": () => import("../search-bf2e2bc7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/server.svg": () => import("../server-de49bccd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/share-s.svg": () => import("../share-s-5d7b9abd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/share.svg": () => import("../share-174e362b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/shield.svg": () => import("../shield-556d33bc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/shopping-bag-alt.svg": () => import("../shopping-bag-alt-a1f388f2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/shopping-bag-product.svg": () => import("../shopping-bag-product-86f3be8c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/shopping-bag.svg": () => import("../shopping-bag-09aa229b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/shopping-basket.svg": () => import("../shopping-basket-e74c7f04.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/shopping-cart.svg": () => import("../shopping-cart-abdb2585.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/shopware.svg": () => import("../shopware-4ab6b4e2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/shuffle.svg": () => import("../shuffle-97f60ee1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/sidebar-overlay.svg": () => import("../sidebar-overlay-eff4b21a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/sidebar.svg": () => import("../sidebar-5fc15dfd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/sign-in.svg": () => import("../sign-in-f48058cb.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/sign-out.svg": () => import("../sign-out-bf393636.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/sitemap.svg": () => import("../sitemap-783d715b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/slack.svg": () => import("../slack-24c0bcf6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/sliders-v.svg": () => import("../sliders-v-92d57bc3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/smile-beam.svg": () => import("../smile-beam-9fb761ce.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/sofa.svg": () => import("../sofa-f3bb3d0c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/sort.svg": () => import("../sort-f1203239.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/sparkle.svg": () => import("../sparkle-9b0a2f2b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/sparkles.svg": () => import("../sparkles-c7da6298.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/spinner-star.svg": () => import("../spinner-star-602552c3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/square-s.svg": () => import("../square-s-7ed86b7d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/square.svg": () => import("../square-f1e1ae63.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/stackoverflow.svg": () => import("../stackoverflow-345fd990.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/star-half.svg": () => import("../star-half-5485dfe3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/star.svg": () => import("../star-00e52073.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/storefront.svg": () => import("../storefront-4d015c56.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/sun.svg": () => import("../sun-32104d32.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/sync.svg": () => import("../sync-e9ea3a4d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/table.svg": () => import("../table-d762e2e8.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/tablet-slash.svg": () => import("../tablet-slash-9618dfa1.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/tablet.svg": () => import("../tablet-17846614.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/tachometer.svg": () => import("../tachometer-df1b256a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/tag.svg": () => import("../tag-2e9b0549.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/thumbs-down-s.svg": () => import("../thumbs-down-s-f23fb37b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/thumbs-down.svg": () => import("../thumbs-down-a67bb0a3.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/thumbs-up-s.svg": () => import("../thumbs-up-s-5f3b3eb5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/thumbs-up.svg": () => import("../thumbs-up-c04bc610.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/thumbtack.svg": () => import("../thumbtack-5a174459.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/tiktok.svg": () => import("../tiktok-e180ef33.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/times-circle-s.svg": () => import("../times-circle-s-7263c56c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/times-circle.svg": () => import("../times-circle-2c290922.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/times-hexagon.svg": () => import("../times-hexagon-9eac1237.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/times-s.svg": () => import("../times-s-e1a86929.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/times-square-s.svg": () => import("../times-square-s-31fc6c0b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/times-square.svg": () => import("../times-square-e77657b6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/times-xs.svg": () => import("../times-xs-894c8646.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/times-xxs.svg": () => import("../times-xxs-3f275e24.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/times.svg": () => import("../times-00bbdeb6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/tools-alt.svg": () => import("../tools-alt-ca84979d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/tools.svg": () => import("../tools-c63cadce.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/trademark.svg": () => import("../trademark-0115bc58.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/traffic-pawn.svg": () => import("../traffic-pawn-71b11a03.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/transgender.svg": () => import("../transgender-da14956c.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/trash-s.svg": () => import("../trash-s-a5cb20f2.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/trash.svg": () => import("../trash-fc906060.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/triangle.svg": () => import("../triangle-f1048f5d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/trophy.svg": () => import("../trophy-8fe89d95.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/truck.svg": () => import("../truck-022892ee.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/tshirt.svg": () => import("../tshirt-38b81cb6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/turn-left.svg": () => import("../turn-left-c60bba5a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/turn-right.svg": () => import("../turn-right-7d24a26a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/twitter.svg": () => import("../twitter-eef5b9cc.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/underline.svg": () => import("../underline-5a78c6b5.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/undo-s.svg": () => import("../undo-s-4749b8f6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/undo.svg": () => import("../undo-bfddd3f4.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/universal-access.svg": () => import("../universal-access-f8e0b343.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/up-circle.svg": () => import("../up-circle-b7258305.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/up-left-circle.svg": () => import("../up-left-circle-553fdeb0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/up-right-circle.svg": () => import("../up-right-circle-3441ff63.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/upload.svg": () => import("../upload-8a1a57bd.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/user-minus.svg": () => import("../user-minus-aa1be705.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/user-plus.svg": () => import("../user-plus-4ead0b68.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/user-shield.svg": () => import("../user-shield-57a7a1f7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/user.svg": () => import("../user-2cc17900.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/users.svg": () => import("../users-f3b83e3b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/variants.svg": () => import("../variants-46490836.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/venus-double.svg": () => import("../venus-double-a4b761ff.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/venus-mars.svg": () => import("../venus-mars-4bccc49a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/venus.svg": () => import("../venus-c519d690.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/video-slash.svg": () => import("../video-slash-1ad34d5f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/video.svg": () => import("../video-229f47c6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/view-compact.svg": () => import("../view-compact-250bce38.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/view-grid.svg": () => import("../view-grid-6b74041f.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/view-normal.svg": () => import("../view-normal-47242b89.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/vimeo.svg": () => import("../vimeo-e633ec58.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/volume-mute.svg": () => import("../volume-mute-1aaaf73d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/volume-up.svg": () => import("../volume-up-6e196b59.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/wallet.svg": () => import("../wallet-428121e0.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/wand-magic-sparkles.svg": () => import("../wand-magic-sparkles-5938097b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/wand-magic.svg": () => import("../wand-magic-4b6ced1a.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/warehouse.svg": () => import("../warehouse-6f68c313.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/watch.svg": () => import("../watch-fbe3e251.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/whatsapp.svg": () => import("../whatsapp-2393a5a7.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/window-eye.svg": () => import("../window-eye-1d73fd7b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/window-terminal.svg": () => import("../window-terminal-22184e3d.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/window.svg": () => import("../window-31e13e45.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/wrap-s.svg": () => import("../wrap-s-a98aaaeb.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/x.svg": () => import("../x-b08be40b.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/xing.svg": () => import("../xing-6f1841f6.mjs"), "../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/solid/youtube.svg": () => import("../youtube-db44ed24.mjs") }), `../../../../node_modules/@shopware-ag/meteor-icon-kit/icons/${o}/${s}.svg`).then((a) => {
          if (a.default) {
            n.value = a.default;
            return;
          }
          console.error(`The SVG file for the icon name ${r} could not be found and loaded.`), n.value = "";
        });
      },
      { immediate: !0 }
    ), (r, o) => (_(), Z("span", wt({
      class: ["mt-icon", [
        `icon--${e.name}`,
        {
          "mt-icon--custom-size": !!e.size
        }
      ]],
      style: i.value,
      "aria-hidden": r.decorative,
      "data-testid": "mt-icon__" + r.name
    }, r.$attrs, { innerHTML: n.value }), null, 16, UD));
  }
});
/*!
  * shared v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const Io = typeof window < "u";
let Li, Ta;
if (process.env.NODE_ENV !== "production") {
  const t = Io && window.performance;
  t && t.mark && t.measure && t.clearMarks && // @ts-ignore browser compat
  t.clearMeasures && (Li = (e) => {
    t.mark(e);
  }, Ta = (e, n, i) => {
    t.measure(e, n, i), t.clearMarks(n), t.clearMarks(i);
  });
}
const GD = /\{([0-9a-zA-Z]+)\}/g;
function Ry(t, ...e) {
  return e.length === 1 && _t(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), t.replace(GD, (n, i) => e.hasOwnProperty(i) ? e[i] : "");
}
const jo = (t, e = !1) => e ? Symbol.for(t) : Symbol(t), KD = (t, e, n) => JD({ l: t, k: e, s: n }), JD = (t) => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), jn = (t) => typeof t == "number" && isFinite(t), eQ = (t) => Kx(t) === "[object Date]", Al = (t) => Kx(t) === "[object RegExp]", Lp = (t) => vt(t) && Object.keys(t).length === 0, Un = Object.assign;
let J0;
const Po = () => J0 || (J0 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function ew(t) {
  return t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const tQ = Object.prototype.hasOwnProperty;
function nf(t, e) {
  return tQ.call(t, e);
}
const wn = Array.isArray, jt = (t) => typeof t == "function", We = (t) => typeof t == "string", Dt = (t) => typeof t == "boolean", _t = (t) => t !== null && typeof t == "object", nQ = (t) => _t(t) && jt(t.then) && jt(t.catch), Gx = Object.prototype.toString, Kx = (t) => Gx.call(t), vt = (t) => {
  if (!_t(t))
    return !1;
  const e = Object.getPrototypeOf(t);
  return e === null || e.constructor === Object;
}, iQ = (t) => t == null ? "" : wn(t) || vt(t) && t.toString === Gx ? JSON.stringify(t, null, 2) : String(t);
function rQ(t, e = "") {
  return t.reduce((n, i, r) => r === 0 ? n + i : n + e + i, "");
}
const tw = 2;
function oQ(t, e = 0, n = t.length) {
  const i = t.split(/\r?\n/);
  let r = 0;
  const o = [];
  for (let s = 0; s < i.length; s++)
    if (r += i[s].length + 1, r >= e) {
      for (let a = s - tw; a <= s + tw || n > r; a++) {
        if (a < 0 || a >= i.length)
          continue;
        const l = a + 1;
        o.push(`${l}${" ".repeat(3 - String(l).length)}|  ${i[a]}`);
        const u = i[a].length;
        if (a === s) {
          const c = e - (r - u) + 1, d = Math.max(1, n > r ? u - c : n - e);
          o.push("   |  " + " ".repeat(c) + "^".repeat(d));
        } else if (a > s) {
          if (n > r) {
            const c = Math.max(Math.min(n - r, u), 1);
            o.push("   |  " + "^".repeat(c));
          }
          r += u + 1;
        }
      }
      break;
    }
  return o.join(`
`);
}
function Vp(t) {
  let e = t;
  return () => ++e;
}
function Yo(t, e) {
  typeof console < "u" && (console.warn("[intlify] " + t), e && console.warn(e.stack));
}
const nw = {};
function Jx(t) {
  nw[t] || (nw[t] = !0, Yo(t));
}
function sQ() {
  const t = /* @__PURE__ */ new Map();
  return {
    events: t,
    on(n, i) {
      const r = t.get(n);
      r && r.push(i) || t.set(n, [i]);
    },
    off(n, i) {
      const r = t.get(n);
      r && r.splice(r.indexOf(i) >>> 0, 1);
    },
    emit(n, i) {
      (t.get(n) || []).slice().map((r) => r(i)), (t.get("*") || []).slice().map((r) => r(n, i));
    }
  };
}
const Fd = (t) => !_t(t) || wn(t);
function Eh(t, e) {
  if (Fd(t) || Fd(e))
    throw new Error("Invalid value");
  const n = [{ src: t, des: e }];
  for (; n.length; ) {
    const { src: i, des: r } = n.pop();
    Object.keys(i).forEach((o) => {
      Fd(i[o]) || Fd(r[o]) ? r[o] = i[o] : n.push({ src: i[o], des: r[o] });
    });
  }
}
/*!
  * message-compiler v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function aQ(t, e, n) {
  return { line: t, column: e, offset: n };
}
function rf(t, e, n) {
  const i = { start: t, end: e };
  return n != null && (i.source = n), i;
}
const lQ = /\{([0-9a-zA-Z]+)\}/g;
function eC(t, ...e) {
  return e.length === 1 && uQ(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), t.replace(lQ, (n, i) => e.hasOwnProperty(i) ? e[i] : "");
}
const tC = Object.assign, iw = (t) => typeof t == "string", uQ = (t) => t !== null && typeof t == "object";
function nC(t, e = "") {
  return t.reduce((n, i, r) => r === 0 ? n + i : n + e + i, "");
}
const Bp = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
}, cQ = {
  [Bp.USE_MODULO_SYNTAX]: "Use modulo before '{{0}}'."
};
function dQ(t, e, ...n) {
  const i = eC(cQ[t] || "", ...n || []), r = { message: String(i), code: t };
  return e && (r.location = e), r;
}
const nt = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
}, hQ = {
  // tokenizer error messages
  [nt.EXPECTED_TOKEN]: "Expected token: '{0}'",
  [nt.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
  [nt.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
  [nt.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
  [nt.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
  [nt.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
  [nt.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
  [nt.EMPTY_PLACEHOLDER]: "Empty placeholder",
  [nt.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
  [nt.INVALID_LINKED_FORMAT]: "Invalid linked format",
  // parser error messages
  [nt.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
  [nt.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
  [nt.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
  [nt.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
  // generator error messages
  [nt.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
  // minimizer error messages
  [nt.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
};
function pu(t, e, n = {}) {
  const { domain: i, messages: r, args: o } = n, s = eC((r || hQ)[t] || "", ...o || []), a = new SyntaxError(String(s));
  return a.code = t, e && (a.location = e), a.domain = i, a;
}
function fQ(t) {
  throw t;
}
const pQ = /<\/?[\w\s="/.':;#-\/]+>/, mQ = (t) => pQ.test(t), Oo = " ", gQ = "\r", ii = `
`, OQ = String.fromCharCode(8232), vQ = String.fromCharCode(8233);
function yQ(t) {
  const e = t;
  let n = 0, i = 1, r = 1, o = 0;
  const s = (S) => e[S] === gQ && e[S + 1] === ii, a = (S) => e[S] === ii, l = (S) => e[S] === vQ, u = (S) => e[S] === OQ, c = (S) => s(S) || a(S) || l(S) || u(S), d = () => n, h = () => i, f = () => r, p = () => o, m = (S) => s(S) || l(S) || u(S) ? ii : e[S], g = () => m(n), O = () => m(n + o);
  function y() {
    return o = 0, c(n) && (i++, r = 0), s(n) && n++, n++, r++, e[n];
  }
  function b() {
    return s(n + o) && o++, o++, e[n + o];
  }
  function v() {
    n = 0, i = 1, r = 1, o = 0;
  }
  function k(S = 0) {
    o = S;
  }
  function w() {
    const S = n + o;
    for (; S !== n; )
      y();
    o = 0;
  }
  return {
    index: d,
    line: h,
    column: f,
    peekOffset: p,
    charAt: m,
    currentChar: g,
    currentPeek: O,
    next: y,
    peek: b,
    reset: v,
    resetPeek: k,
    skipToPeek: w
  };
}
const Go = void 0, bQ = ".", rw = "'", wQ = "tokenizer";
function kQ(t, e = {}) {
  const n = e.location !== !1, i = yQ(t), r = () => i.index(), o = () => aQ(i.line(), i.column(), i.index()), s = o(), a = r(), l = {
    currentType: 14,
    offset: a,
    startLoc: s,
    endLoc: s,
    lastType: 14,
    lastOffset: a,
    lastStartLoc: s,
    lastEndLoc: s,
    braceNest: 0,
    inLinked: !1,
    text: ""
  }, u = () => l, { onError: c } = e;
  function d(D, x, U, ...K) {
    const ke = u();
    if (x.column += U, x.offset += U, c) {
      const Ve = n ? rf(ke.startLoc, x) : null, be = pu(D, Ve, {
        domain: wQ,
        args: K
      });
      c(be);
    }
  }
  function h(D, x, U) {
    D.endLoc = o(), D.currentType = x;
    const K = { type: x };
    return n && (K.loc = rf(D.startLoc, D.endLoc)), U != null && (K.value = U), K;
  }
  const f = (D) => h(
    D,
    14
    /* TokenTypes.EOF */
  );
  function p(D, x) {
    return D.currentChar() === x ? (D.next(), x) : (d(nt.EXPECTED_TOKEN, o(), 0, x), "");
  }
  function m(D) {
    let x = "";
    for (; D.currentPeek() === Oo || D.currentPeek() === ii; )
      x += D.currentPeek(), D.peek();
    return x;
  }
  function g(D) {
    const x = m(D);
    return D.skipToPeek(), x;
  }
  function O(D) {
    if (D === Go)
      return !1;
    const x = D.charCodeAt(0);
    return x >= 97 && x <= 122 || // a-z
    x >= 65 && x <= 90 || // A-Z
    x === 95;
  }
  function y(D) {
    if (D === Go)
      return !1;
    const x = D.charCodeAt(0);
    return x >= 48 && x <= 57;
  }
  function b(D, x) {
    const { currentType: U } = x;
    if (U !== 2)
      return !1;
    m(D);
    const K = O(D.currentPeek());
    return D.resetPeek(), K;
  }
  function v(D, x) {
    const { currentType: U } = x;
    if (U !== 2)
      return !1;
    m(D);
    const K = D.currentPeek() === "-" ? D.peek() : D.currentPeek(), ke = y(K);
    return D.resetPeek(), ke;
  }
  function k(D, x) {
    const { currentType: U } = x;
    if (U !== 2)
      return !1;
    m(D);
    const K = D.currentPeek() === rw;
    return D.resetPeek(), K;
  }
  function w(D, x) {
    const { currentType: U } = x;
    if (U !== 8)
      return !1;
    m(D);
    const K = D.currentPeek() === ".";
    return D.resetPeek(), K;
  }
  function S(D, x) {
    const { currentType: U } = x;
    if (U !== 9)
      return !1;
    m(D);
    const K = O(D.currentPeek());
    return D.resetPeek(), K;
  }
  function $(D, x) {
    const { currentType: U } = x;
    if (!(U === 8 || U === 12))
      return !1;
    m(D);
    const K = D.currentPeek() === ":";
    return D.resetPeek(), K;
  }
  function C(D, x) {
    const { currentType: U } = x;
    if (U !== 10)
      return !1;
    const K = () => {
      const Ve = D.currentPeek();
      return Ve === "{" ? O(D.peek()) : Ve === "@" || Ve === "%" || Ve === "|" || Ve === ":" || Ve === "." || Ve === Oo || !Ve ? !1 : Ve === ii ? (D.peek(), K()) : P(D, !1);
    }, ke = K();
    return D.resetPeek(), ke;
  }
  function L(D) {
    m(D);
    const x = D.currentPeek() === "|";
    return D.resetPeek(), x;
  }
  function j(D) {
    const x = m(D), U = D.currentPeek() === "%" && D.peek() === "{";
    return D.resetPeek(), {
      isModulo: U,
      hasSpace: x.length > 0
    };
  }
  function P(D, x = !0) {
    const U = (ke = !1, Ve = "", be = !1) => {
      const se = D.currentPeek();
      return se === "{" ? Ve === "%" ? !1 : ke : se === "@" || !se ? Ve === "%" ? !0 : ke : se === "%" ? (D.peek(), U(ke, "%", !0)) : se === "|" ? Ve === "%" || be ? !0 : !(Ve === Oo || Ve === ii) : se === Oo ? (D.peek(), U(!0, Oo, be)) : se === ii ? (D.peek(), U(!0, ii, be)) : !0;
    }, K = U();
    return x && D.resetPeek(), K;
  }
  function A(D, x) {
    const U = D.currentChar();
    return U === Go ? Go : x(U) ? (D.next(), U) : null;
  }
  function T(D) {
    const x = D.charCodeAt(0);
    return x >= 97 && x <= 122 || // a-z
    x >= 65 && x <= 90 || // A-Z
    x >= 48 && x <= 57 || // 0-9
    x === 95 || // _
    x === 36;
  }
  function N(D) {
    return A(D, T);
  }
  function Q(D) {
    const x = D.charCodeAt(0);
    return x >= 97 && x <= 122 || // a-z
    x >= 65 && x <= 90 || // A-Z
    x >= 48 && x <= 57 || // 0-9
    x === 95 || // _
    x === 36 || // $
    x === 45;
  }
  function Y(D) {
    return A(D, Q);
  }
  function V(D) {
    const x = D.charCodeAt(0);
    return x >= 48 && x <= 57;
  }
  function q(D) {
    return A(D, V);
  }
  function B(D) {
    const x = D.charCodeAt(0);
    return x >= 48 && x <= 57 || // 0-9
    x >= 65 && x <= 70 || // A-F
    x >= 97 && x <= 102;
  }
  function pe(D) {
    return A(D, B);
  }
  function oe(D) {
    let x = "", U = "";
    for (; x = q(D); )
      U += x;
    return U;
  }
  function te(D) {
    g(D);
    const x = D.currentChar();
    return x !== "%" && d(nt.EXPECTED_TOKEN, o(), 0, x), D.next(), "%";
  }
  function M(D) {
    let x = "";
    for (; ; ) {
      const U = D.currentChar();
      if (U === "{" || U === "}" || U === "@" || U === "|" || !U)
        break;
      if (U === "%")
        if (P(D))
          x += U, D.next();
        else
          break;
      else if (U === Oo || U === ii)
        if (P(D))
          x += U, D.next();
        else {
          if (L(D))
            break;
          x += U, D.next();
        }
      else
        x += U, D.next();
    }
    return x;
  }
  function G(D) {
    g(D);
    let x = "", U = "";
    for (; x = Y(D); )
      U += x;
    return D.currentChar() === Go && d(nt.UNTERMINATED_CLOSING_BRACE, o(), 0), U;
  }
  function ce(D) {
    g(D);
    let x = "";
    return D.currentChar() === "-" ? (D.next(), x += `-${oe(D)}`) : x += oe(D), D.currentChar() === Go && d(nt.UNTERMINATED_CLOSING_BRACE, o(), 0), x;
  }
  function F(D) {
    return D !== rw && D !== ii;
  }
  function xe(D) {
    g(D), p(D, "'");
    let x = "", U = "";
    for (; x = A(D, F); )
      x === "\\" ? U += Be(D) : U += x;
    const K = D.currentChar();
    return K === ii || K === Go ? (d(nt.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, o(), 0), K === ii && (D.next(), p(D, "'")), U) : (p(D, "'"), U);
  }
  function Be(D) {
    const x = D.currentChar();
    switch (x) {
      case "\\":
      case "'":
        return D.next(), `\\${x}`;
      case "u":
        return lt(D, x, 4);
      case "U":
        return lt(D, x, 6);
      default:
        return d(nt.UNKNOWN_ESCAPE_SEQUENCE, o(), 0, x), "";
    }
  }
  function lt(D, x, U) {
    p(D, x);
    let K = "";
    for (let ke = 0; ke < U; ke++) {
      const Ve = pe(D);
      if (!Ve) {
        d(nt.INVALID_UNICODE_ESCAPE_SEQUENCE, o(), 0, `\\${x}${K}${D.currentChar()}`);
        break;
      }
      K += Ve;
    }
    return `\\${x}${K}`;
  }
  function de(D) {
    return D !== "{" && D !== "}" && D !== Oo && D !== ii;
  }
  function ye(D) {
    g(D);
    let x = "", U = "";
    for (; x = A(D, de); )
      U += x;
    return U;
  }
  function me(D) {
    let x = "", U = "";
    for (; x = N(D); )
      U += x;
    return U;
  }
  function ie(D) {
    const x = (U) => {
      const K = D.currentChar();
      return K === "{" || K === "%" || K === "@" || K === "|" || K === "(" || K === ")" || !K || K === Oo ? U : (U += K, D.next(), x(U));
    };
    return x("");
  }
  function I(D) {
    g(D);
    const x = p(
      D,
      "|"
      /* TokenChars.Pipe */
    );
    return g(D), x;
  }
  function ge(D, x) {
    let U = null;
    switch (D.currentChar()) {
      case "{":
        return x.braceNest >= 1 && d(nt.NOT_ALLOW_NEST_PLACEHOLDER, o(), 0), D.next(), U = h(
          x,
          2,
          "{"
          /* TokenChars.BraceLeft */
        ), g(D), x.braceNest++, U;
      case "}":
        return x.braceNest > 0 && x.currentType === 2 && d(nt.EMPTY_PLACEHOLDER, o(), 0), D.next(), U = h(
          x,
          3,
          "}"
          /* TokenChars.BraceRight */
        ), x.braceNest--, x.braceNest > 0 && g(D), x.inLinked && x.braceNest === 0 && (x.inLinked = !1), U;
      case "@":
        return x.braceNest > 0 && d(nt.UNTERMINATED_CLOSING_BRACE, o(), 0), U = ze(D, x) || f(x), x.braceNest = 0, U;
      default: {
        let ke = !0, Ve = !0, be = !0;
        if (L(D))
          return x.braceNest > 0 && d(nt.UNTERMINATED_CLOSING_BRACE, o(), 0), U = h(x, 1, I(D)), x.braceNest = 0, x.inLinked = !1, U;
        if (x.braceNest > 0 && (x.currentType === 5 || x.currentType === 6 || x.currentType === 7))
          return d(nt.UNTERMINATED_CLOSING_BRACE, o(), 0), x.braceNest = 0, Se(D, x);
        if (ke = b(D, x))
          return U = h(x, 5, G(D)), g(D), U;
        if (Ve = v(D, x))
          return U = h(x, 6, ce(D)), g(D), U;
        if (be = k(D, x))
          return U = h(x, 7, xe(D)), g(D), U;
        if (!ke && !Ve && !be)
          return U = h(x, 13, ye(D)), d(nt.INVALID_TOKEN_IN_PLACEHOLDER, o(), 0, U.value), g(D), U;
        break;
      }
    }
    return U;
  }
  function ze(D, x) {
    const { currentType: U } = x;
    let K = null;
    const ke = D.currentChar();
    switch ((U === 8 || U === 9 || U === 12 || U === 10) && (ke === ii || ke === Oo) && d(nt.INVALID_LINKED_FORMAT, o(), 0), ke) {
      case "@":
        return D.next(), K = h(
          x,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        ), x.inLinked = !0, K;
      case ".":
        return g(D), D.next(), h(
          x,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        return g(D), D.next(), h(
          x,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        return L(D) ? (K = h(x, 1, I(D)), x.braceNest = 0, x.inLinked = !1, K) : w(D, x) || $(D, x) ? (g(D), ze(D, x)) : S(D, x) ? (g(D), h(x, 12, me(D))) : C(D, x) ? (g(D), ke === "{" ? ge(D, x) || K : h(x, 11, ie(D))) : (U === 8 && d(nt.INVALID_LINKED_FORMAT, o(), 0), x.braceNest = 0, x.inLinked = !1, Se(D, x));
    }
  }
  function Se(D, x) {
    let U = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (x.braceNest > 0)
      return ge(D, x) || f(x);
    if (x.inLinked)
      return ze(D, x) || f(x);
    switch (D.currentChar()) {
      case "{":
        return ge(D, x) || f(x);
      case "}":
        return d(nt.UNBALANCED_CLOSING_BRACE, o(), 0), D.next(), h(
          x,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return ze(D, x) || f(x);
      default: {
        if (L(D))
          return U = h(x, 1, I(D)), x.braceNest = 0, x.inLinked = !1, U;
        const { isModulo: ke, hasSpace: Ve } = j(D);
        if (ke)
          return Ve ? h(x, 0, M(D)) : h(x, 4, te(D));
        if (P(D))
          return h(x, 0, M(D));
        break;
      }
    }
    return U;
  }
  function st() {
    const { currentType: D, offset: x, startLoc: U, endLoc: K } = l;
    return l.lastType = D, l.lastOffset = x, l.lastStartLoc = U, l.lastEndLoc = K, l.offset = r(), l.startLoc = o(), i.currentChar() === Go ? h(
      l,
      14
      /* TokenTypes.EOF */
    ) : Se(i, l);
  }
  return {
    nextToken: st,
    currentOffset: r,
    currentPosition: o,
    context: u
  };
}
const SQ = "parser", _Q = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function xQ(t, e, n) {
  switch (t) {
    case "\\\\":
      return "\\";
    case "\\'":
      return "'";
    default: {
      const i = parseInt(e || n, 16);
      return i <= 55295 || i >= 57344 ? String.fromCodePoint(i) : "�";
    }
  }
}
function CQ(t = {}) {
  const e = t.location !== !1, { onError: n, onWarn: i } = t;
  function r(b, v, k, w, ...S) {
    const $ = b.currentPosition();
    if ($.offset += w, $.column += w, n) {
      const C = e ? rf(k, $) : null, L = pu(v, C, {
        domain: SQ,
        args: S
      });
      n(L);
    }
  }
  function o(b, v, k, w, ...S) {
    const $ = b.currentPosition();
    if ($.offset += w, $.column += w, i) {
      const C = e ? rf(k, $) : null;
      i(dQ(v, C, S));
    }
  }
  function s(b, v, k) {
    const w = { type: b };
    return e && (w.start = v, w.end = v, w.loc = { start: k, end: k }), w;
  }
  function a(b, v, k, w) {
    w && (b.type = w), e && (b.end = v, b.loc && (b.loc.end = k));
  }
  function l(b, v) {
    const k = b.context(), w = s(3, k.offset, k.startLoc);
    return w.value = v, a(w, b.currentOffset(), b.currentPosition()), w;
  }
  function u(b, v) {
    const k = b.context(), { lastOffset: w, lastStartLoc: S } = k, $ = s(5, w, S);
    return $.index = parseInt(v, 10), b.nextToken(), a($, b.currentOffset(), b.currentPosition()), $;
  }
  function c(b, v, k) {
    const w = b.context(), { lastOffset: S, lastStartLoc: $ } = w, C = s(4, S, $);
    return C.key = v, k === !0 && (C.modulo = !0), b.nextToken(), a(C, b.currentOffset(), b.currentPosition()), C;
  }
  function d(b, v) {
    const k = b.context(), { lastOffset: w, lastStartLoc: S } = k, $ = s(9, w, S);
    return $.value = v.replace(_Q, xQ), b.nextToken(), a($, b.currentOffset(), b.currentPosition()), $;
  }
  function h(b) {
    const v = b.nextToken(), k = b.context(), { lastOffset: w, lastStartLoc: S } = k, $ = s(8, w, S);
    return v.type !== 12 ? (r(b, nt.UNEXPECTED_EMPTY_LINKED_MODIFIER, k.lastStartLoc, 0), $.value = "", a($, w, S), {
      nextConsumeToken: v,
      node: $
    }) : (v.value == null && r(b, nt.UNEXPECTED_LEXICAL_ANALYSIS, k.lastStartLoc, 0, dr(v)), $.value = v.value || "", a($, b.currentOffset(), b.currentPosition()), {
      node: $
    });
  }
  function f(b, v) {
    const k = b.context(), w = s(7, k.offset, k.startLoc);
    return w.value = v, a(w, b.currentOffset(), b.currentPosition()), w;
  }
  function p(b) {
    const v = b.context(), k = s(6, v.offset, v.startLoc);
    let w = b.nextToken();
    if (w.type === 9) {
      const S = h(b);
      k.modifier = S.node, w = S.nextConsumeToken || b.nextToken();
    }
    switch (w.type !== 10 && r(b, nt.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, dr(w)), w = b.nextToken(), w.type === 2 && (w = b.nextToken()), w.type) {
      case 11:
        w.value == null && r(b, nt.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, dr(w)), k.key = f(b, w.value || "");
        break;
      case 5:
        w.value == null && r(b, nt.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, dr(w)), k.key = c(b, w.value || "");
        break;
      case 6:
        w.value == null && r(b, nt.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, dr(w)), k.key = u(b, w.value || "");
        break;
      case 7:
        w.value == null && r(b, nt.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, dr(w)), k.key = d(b, w.value || "");
        break;
      default: {
        r(b, nt.UNEXPECTED_EMPTY_LINKED_KEY, v.lastStartLoc, 0);
        const S = b.context(), $ = s(7, S.offset, S.startLoc);
        return $.value = "", a($, S.offset, S.startLoc), k.key = $, a(k, S.offset, S.startLoc), {
          nextConsumeToken: w,
          node: k
        };
      }
    }
    return a(k, b.currentOffset(), b.currentPosition()), {
      node: k
    };
  }
  function m(b) {
    const v = b.context(), k = v.currentType === 1 ? b.currentOffset() : v.offset, w = v.currentType === 1 ? v.endLoc : v.startLoc, S = s(2, k, w);
    S.items = [];
    let $ = null, C = null;
    do {
      const P = $ || b.nextToken();
      switch ($ = null, P.type) {
        case 0:
          P.value == null && r(b, nt.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, dr(P)), S.items.push(l(b, P.value || ""));
          break;
        case 6:
          P.value == null && r(b, nt.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, dr(P)), S.items.push(u(b, P.value || ""));
          break;
        case 4:
          C = !0;
          break;
        case 5:
          P.value == null && r(b, nt.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, dr(P)), S.items.push(c(b, P.value || "", !!C)), C && (o(b, Bp.USE_MODULO_SYNTAX, v.lastStartLoc, 0, dr(P)), C = null);
          break;
        case 7:
          P.value == null && r(b, nt.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, dr(P)), S.items.push(d(b, P.value || ""));
          break;
        case 8: {
          const A = p(b);
          S.items.push(A.node), $ = A.nextConsumeToken || null;
          break;
        }
      }
    } while (v.currentType !== 14 && v.currentType !== 1);
    const L = v.currentType === 1 ? v.lastOffset : b.currentOffset(), j = v.currentType === 1 ? v.lastEndLoc : b.currentPosition();
    return a(S, L, j), S;
  }
  function g(b, v, k, w) {
    const S = b.context();
    let $ = w.items.length === 0;
    const C = s(1, v, k);
    C.cases = [], C.cases.push(w);
    do {
      const L = m(b);
      $ || ($ = L.items.length === 0), C.cases.push(L);
    } while (S.currentType !== 14);
    return $ && r(b, nt.MUST_HAVE_MESSAGES_IN_PLURAL, k, 0), a(C, b.currentOffset(), b.currentPosition()), C;
  }
  function O(b) {
    const v = b.context(), { offset: k, startLoc: w } = v, S = m(b);
    return v.currentType === 14 ? S : g(b, k, w, S);
  }
  function y(b) {
    const v = kQ(b, tC({}, t)), k = v.context(), w = s(0, k.offset, k.startLoc);
    return e && w.loc && (w.loc.source = b), w.body = O(v), t.onCacheKey && (w.cacheKey = t.onCacheKey(b)), k.currentType !== 14 && r(v, nt.UNEXPECTED_LEXICAL_ANALYSIS, k.lastStartLoc, 0, b[k.offset] || ""), a(w, v.currentOffset(), v.currentPosition()), w;
  }
  return { parse: y };
}
function dr(t) {
  if (t.type === 14)
    return "EOF";
  const e = (t.value || "").replace(/\r?\n/gu, "\\n");
  return e.length > 10 ? e.slice(0, 9) + "…" : e;
}
function TQ(t, e = {}) {
  const n = {
    ast: t,
    helpers: /* @__PURE__ */ new Set()
  };
  return { context: () => n, helper: (o) => (n.helpers.add(o), o) };
}
function ow(t, e) {
  for (let n = 0; n < t.length; n++)
    Dy(t[n], e);
}
function Dy(t, e) {
  switch (t.type) {
    case 1:
      ow(t.cases, e), e.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      ow(t.items, e);
      break;
    case 6: {
      Dy(t.key, e), e.helper(
        "linked"
        /* HelperNameMap.LINKED */
      ), e.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), e.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), e.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function $Q(t, e = {}) {
  const n = TQ(t);
  n.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  ), t.body && Dy(t.body, n);
  const i = n.context();
  t.helpers = Array.from(i.helpers);
}
function PQ(t) {
  const e = t.body;
  return e.type === 2 ? sw(e) : e.cases.forEach((n) => sw(n)), t;
}
function sw(t) {
  if (t.items.length === 1) {
    const e = t.items[0];
    (e.type === 3 || e.type === 9) && (t.static = e.value, delete e.value);
  } else {
    const e = [];
    for (let n = 0; n < t.items.length; n++) {
      const i = t.items[n];
      if (!(i.type === 3 || i.type === 9) || i.value == null)
        break;
      e.push(i.value);
    }
    if (e.length === t.items.length) {
      t.static = nC(e);
      for (let n = 0; n < t.items.length; n++) {
        const i = t.items[n];
        (i.type === 3 || i.type === 9) && delete i.value;
      }
    }
  }
}
const MQ = "minifier";
function ol(t) {
  switch (t.t = t.type, t.type) {
    case 0: {
      const e = t;
      ol(e.body), e.b = e.body, delete e.body;
      break;
    }
    case 1: {
      const e = t, n = e.cases;
      for (let i = 0; i < n.length; i++)
        ol(n[i]);
      e.c = n, delete e.cases;
      break;
    }
    case 2: {
      const e = t, n = e.items;
      for (let i = 0; i < n.length; i++)
        ol(n[i]);
      e.i = n, delete e.items, e.static && (e.s = e.static, delete e.static);
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const e = t;
      e.value && (e.v = e.value, delete e.value);
      break;
    }
    case 6: {
      const e = t;
      ol(e.key), e.k = e.key, delete e.key, e.modifier && (ol(e.modifier), e.m = e.modifier, delete e.modifier);
      break;
    }
    case 5: {
      const e = t;
      e.i = e.index, delete e.index;
      break;
    }
    case 4: {
      const e = t;
      e.k = e.key, delete e.key;
      break;
    }
    default:
      throw pu(nt.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: MQ,
        args: [t.type]
      });
  }
  delete t.type;
}
const EQ = "parser";
function AQ(t, e) {
  const { sourceMap: n, filename: i, breakLineCode: r, needIndent: o } = e, s = e.location !== !1, a = {
    filename: i,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode: r,
    needIndent: o,
    indentLevel: 0
  };
  s && t.loc && (a.source = t.loc.source);
  const l = () => a;
  function u(g, O) {
    a.code += g;
  }
  function c(g, O = !0) {
    const y = O ? r : "";
    u(o ? y + "  ".repeat(g) : y);
  }
  function d(g = !0) {
    const O = ++a.indentLevel;
    g && c(O);
  }
  function h(g = !0) {
    const O = --a.indentLevel;
    g && c(O);
  }
  function f() {
    c(a.indentLevel);
  }
  return {
    context: l,
    push: u,
    indent: d,
    deindent: h,
    newline: f,
    helper: (g) => `_${g}`,
    needIndent: () => a.needIndent
  };
}
function RQ(t, e) {
  const { helper: n } = t;
  t.push(`${n(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`), Rl(t, e.key), e.modifier ? (t.push(", "), Rl(t, e.modifier), t.push(", _type")) : t.push(", undefined, _type"), t.push(")");
}
function DQ(t, e) {
  const { helper: n, needIndent: i } = t;
  t.push(`${n(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`), t.indent(i());
  const r = e.items.length;
  for (let o = 0; o < r && (Rl(t, e.items[o]), o !== r - 1); o++)
    t.push(", ");
  t.deindent(i()), t.push("])");
}
function QQ(t, e) {
  const { helper: n, needIndent: i } = t;
  if (e.cases.length > 1) {
    t.push(`${n(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`), t.indent(i());
    const r = e.cases.length;
    for (let o = 0; o < r && (Rl(t, e.cases[o]), o !== r - 1); o++)
      t.push(", ");
    t.deindent(i()), t.push("])");
  }
}
function NQ(t, e) {
  e.body ? Rl(t, e.body) : t.push("null");
}
function Rl(t, e) {
  const { helper: n } = t;
  switch (e.type) {
    case 0:
      NQ(t, e);
      break;
    case 1:
      QQ(t, e);
      break;
    case 2:
      DQ(t, e);
      break;
    case 6:
      RQ(t, e);
      break;
    case 8:
      t.push(JSON.stringify(e.value), e);
      break;
    case 7:
      t.push(JSON.stringify(e.value), e);
      break;
    case 5:
      t.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "list"
        /* HelperNameMap.LIST */
      )}(${e.index}))`, e);
      break;
    case 4:
      t.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(e.key)}))`, e);
      break;
    case 9:
      t.push(JSON.stringify(e.value), e);
      break;
    case 3:
      t.push(JSON.stringify(e.value), e);
      break;
    default:
      throw pu(nt.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: EQ,
        args: [e.type]
      });
  }
}
const IQ = (t, e = {}) => {
  const n = iw(e.mode) ? e.mode : "normal", i = iw(e.filename) ? e.filename : "message.intl", r = !!e.sourceMap, o = e.breakLineCode != null ? e.breakLineCode : n === "arrow" ? ";" : `
`, s = e.needIndent ? e.needIndent : n !== "arrow", a = t.helpers || [], l = AQ(t, {
    mode: n,
    filename: i,
    sourceMap: r,
    breakLineCode: o,
    needIndent: s
  });
  l.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), l.indent(s), a.length > 0 && (l.push(`const { ${nC(a.map((d) => `${d}: _${d}`), ", ")} } = ctx`), l.newline()), l.push("return "), Rl(l, t), l.deindent(s), l.push("}"), delete t.helpers;
  const { code: u, map: c } = l.context();
  return {
    ast: t,
    code: u,
    map: c ? c.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function LQ(t, e = {}) {
  const n = tC({}, e), i = !!n.jit, r = !!n.minify, o = n.optimize == null ? !0 : n.optimize, a = CQ(n).parse(t);
  return i ? (o && PQ(a), r && ol(a), { ast: a, code: "" }) : ($Q(a, n), IQ(a, n));
}
/*!
  * core-base v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function VQ() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Po().__INTLIFY_PROD_DEVTOOLS__ = !1), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (Po().__INTLIFY_JIT_COMPILATION__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Po().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1);
}
const Fs = [];
Fs[
  0
  /* States.BEFORE_PATH */
] = {
  w: [
    0
    /* States.BEFORE_PATH */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
Fs[
  1
  /* States.IN_PATH */
] = {
  w: [
    1
    /* States.IN_PATH */
  ],
  ".": [
    2
    /* States.BEFORE_IDENT */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
Fs[
  2
  /* States.BEFORE_IDENT */
] = {
  w: [
    2
    /* States.BEFORE_IDENT */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ]
};
Fs[
  3
  /* States.IN_IDENT */
] = {
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ],
  w: [
    1,
    1
    /* Actions.PUSH */
  ],
  ".": [
    2,
    1
    /* Actions.PUSH */
  ],
  "[": [
    4,
    1
    /* Actions.PUSH */
  ],
  o: [
    7,
    1
    /* Actions.PUSH */
  ]
};
Fs[
  4
  /* States.IN_SUB_PATH */
] = {
  "'": [
    5,
    0
    /* Actions.APPEND */
  ],
  '"': [
    6,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  "]": [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  o: 8,
  l: [
    4,
    0
    /* Actions.APPEND */
  ]
};
Fs[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  "'": [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    5,
    0
    /* Actions.APPEND */
  ]
};
Fs[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  '"': [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const BQ = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function ZQ(t) {
  return BQ.test(t);
}
function FQ(t) {
  const e = t.charCodeAt(0), n = t.charCodeAt(t.length - 1);
  return e === n && (e === 34 || e === 39) ? t.slice(1, -1) : t;
}
function qQ(t) {
  if (t == null)
    return "o";
  switch (t.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return t;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function WQ(t) {
  const e = t.trim();
  return t.charAt(0) === "0" && isNaN(parseInt(t)) ? !1 : ZQ(e) ? FQ(e) : "*" + e;
}
function XQ(t) {
  const e = [];
  let n = -1, i = 0, r = 0, o, s, a, l, u, c, d;
  const h = [];
  h[
    0
    /* Actions.APPEND */
  ] = () => {
    s === void 0 ? s = a : s += a;
  }, h[
    1
    /* Actions.PUSH */
  ] = () => {
    s !== void 0 && (e.push(s), s = void 0);
  }, h[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    h[
      0
      /* Actions.APPEND */
    ](), r++;
  }, h[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (r > 0)
      r--, i = 4, h[
        0
        /* Actions.APPEND */
      ]();
    else {
      if (r = 0, s === void 0 || (s = WQ(s), s === !1))
        return !1;
      h[
        1
        /* Actions.PUSH */
      ]();
    }
  };
  function f() {
    const p = t[n + 1];
    if (i === 5 && p === "'" || i === 6 && p === '"')
      return n++, a = "\\" + p, h[
        0
        /* Actions.APPEND */
      ](), !0;
  }
  for (; i !== null; )
    if (n++, o = t[n], !(o === "\\" && f())) {
      if (l = qQ(o), d = Fs[i], u = d[l] || d.l || 8, u === 8 || (i = u[0], u[1] !== void 0 && (c = h[u[1]], c && (a = o, c() === !1))))
        return;
      if (i === 7)
        return e;
    }
}
const aw = /* @__PURE__ */ new Map();
function zQ(t, e) {
  return _t(t) ? t[e] : null;
}
function jQ(t, e) {
  if (!_t(t))
    return null;
  let n = aw.get(e);
  if (n || (n = XQ(e), n && aw.set(e, n)), !n)
    return null;
  const i = n.length;
  let r = t, o = 0;
  for (; o < i; ) {
    const s = r[n[o]];
    if (s === void 0 || jt(r))
      return null;
    r = s, o++;
  }
  return r;
}
const YQ = (t) => t, HQ = (t) => "", UQ = "text", GQ = (t) => t.length === 0 ? "" : rQ(t), KQ = iQ;
function lw(t, e) {
  return t = Math.abs(t), e === 2 ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0;
}
function JQ(t) {
  const e = jn(t.pluralIndex) ? t.pluralIndex : -1;
  return t.named && (jn(t.named.count) || jn(t.named.n)) ? jn(t.named.count) ? t.named.count : jn(t.named.n) ? t.named.n : e : e;
}
function e2(t, e) {
  e.count || (e.count = t), e.n || (e.n = t);
}
function t2(t = {}) {
  const e = t.locale, n = JQ(t), i = _t(t.pluralRules) && We(e) && jt(t.pluralRules[e]) ? t.pluralRules[e] : lw, r = _t(t.pluralRules) && We(e) && jt(t.pluralRules[e]) ? lw : void 0, o = (O) => O[i(n, O.length, r)], s = t.list || [], a = (O) => s[O], l = t.named || {};
  jn(t.pluralIndex) && e2(n, l);
  const u = (O) => l[O];
  function c(O) {
    const y = jt(t.messages) ? t.messages(O) : _t(t.messages) ? t.messages[O] : !1;
    return y || (t.parent ? t.parent.message(O) : HQ);
  }
  const d = (O) => t.modifiers ? t.modifiers[O] : YQ, h = vt(t.processor) && jt(t.processor.normalize) ? t.processor.normalize : GQ, f = vt(t.processor) && jt(t.processor.interpolate) ? t.processor.interpolate : KQ, p = vt(t.processor) && We(t.processor.type) ? t.processor.type : UQ, g = {
    list: a,
    named: u,
    plural: o,
    linked: (O, ...y) => {
      const [b, v] = y;
      let k = "text", w = "";
      y.length === 1 ? _t(b) ? (w = b.modifier || w, k = b.type || k) : We(b) && (w = b || w) : y.length === 2 && (We(b) && (w = b || w), We(v) && (k = v || k));
      const S = c(O)(g), $ = (
        // The message in vnode resolved with linked are returned as an array by processor.nomalize
        k === "vnode" && wn(S) && w ? S[0] : S
      );
      return w ? d(w)($, k) : $;
    },
    message: c,
    type: p,
    interpolate: f,
    normalize: h,
    values: Un({}, s, l)
  };
  return g;
}
let Mc = null;
function n2(t) {
  Mc = t;
}
function i2(t, e, n) {
  Mc && Mc.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: t,
    version: e,
    meta: n
  });
}
const r2 = /* @__PURE__ */ o2(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function o2(t) {
  return (e) => Mc && Mc.emit(t, e);
}
const iC = Bp.__EXTEND_POINT__, Js = Vp(iC), ri = {
  NOT_FOUND_KEY: iC,
  // 2
  FALLBACK_TO_TRANSLATE: Js(),
  // 3
  CANNOT_FORMAT_NUMBER: Js(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: Js(),
  // 5
  CANNOT_FORMAT_DATE: Js(),
  // 6
  FALLBACK_TO_DATE_FORMAT: Js(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: Js(),
  // 8
  __EXTEND_POINT__: Js()
  // 9
}, s2 = {
  [ri.NOT_FOUND_KEY]: "Not found '{key}' key in '{locale}' locale messages.",
  [ri.FALLBACK_TO_TRANSLATE]: "Fall back to translate '{key}' key with '{target}' locale.",
  [ri.CANNOT_FORMAT_NUMBER]: "Cannot format a number value due to not supported Intl.NumberFormat.",
  [ri.FALLBACK_TO_NUMBER_FORMAT]: "Fall back to number format '{key}' key with '{target}' locale.",
  [ri.CANNOT_FORMAT_DATE]: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
  [ri.FALLBACK_TO_DATE_FORMAT]: "Fall back to datetime format '{key}' key with '{target}' locale.",
  [ri.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: "This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future."
};
function $a(t, ...e) {
  return Ry(s2[t], ...e);
}
const rC = nt.__EXTEND_POINT__, ea = Vp(rC), Pn = {
  INVALID_ARGUMENT: rC,
  // 17
  INVALID_DATE_ARGUMENT: ea(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: ea(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: ea(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: ea(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: ea(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: ea(),
  // 23
  __EXTEND_POINT__: ea()
  // 24
};
function Yr(t) {
  return pu(t, null, process.env.NODE_ENV !== "production" ? { messages: a2 } : void 0);
}
const a2 = {
  [Pn.INVALID_ARGUMENT]: "Invalid arguments",
  [Pn.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [Pn.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [Pn.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [Pn.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [Pn.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [Pn.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function Qy(t, e) {
  return e.locale != null ? uw(e.locale) : uw(t.locale);
}
let Vm;
function uw(t) {
  if (We(t))
    return t;
  if (jt(t)) {
    if (t.resolvedOnce && Vm != null)
      return Vm;
    if (t.constructor.name === "Function") {
      const e = t();
      if (nQ(e))
        throw Yr(Pn.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return Vm = e;
    } else
      throw Yr(Pn.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
  } else
    throw Yr(Pn.NOT_SUPPORT_LOCALE_TYPE);
}
function l2(t, e, n) {
  return [.../* @__PURE__ */ new Set([
    n,
    ...wn(e) ? e : _t(e) ? Object.keys(e) : We(e) ? [e] : [n]
  ])];
}
function oC(t, e, n) {
  const i = We(n) ? n : Ec, r = t;
  r.__localeChainCache || (r.__localeChainCache = /* @__PURE__ */ new Map());
  let o = r.__localeChainCache.get(i);
  if (!o) {
    o = [];
    let s = [n];
    for (; wn(s); )
      s = cw(o, s, e);
    const a = wn(e) || !vt(e) ? e : e.default ? e.default : null;
    s = We(a) ? [a] : a, wn(s) && cw(o, s, !1), r.__localeChainCache.set(i, o);
  }
  return o;
}
function cw(t, e, n) {
  let i = !0;
  for (let r = 0; r < e.length && Dt(i); r++) {
    const o = e[r];
    We(o) && (i = u2(t, e[r], n));
  }
  return i;
}
function u2(t, e, n) {
  let i;
  const r = e.split("-");
  do {
    const o = r.join("-");
    i = c2(t, o, n), r.splice(-1, 1);
  } while (r.length && i === !0);
  return i;
}
function c2(t, e, n) {
  let i = !1;
  if (!t.includes(e) && (i = !0, e)) {
    i = e[e.length - 1] !== "!";
    const r = e.replace(/!/g, "");
    t.push(r), (wn(n) || vt(n)) && n[r] && (i = n[r]);
  }
  return i;
}
const d2 = "9.13.1", Zp = -1, Ec = "en-US", of = "", dw = (t) => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;
function h2() {
  return {
    upper: (t, e) => e === "text" && We(t) ? t.toUpperCase() : e === "vnode" && _t(t) && "__v_isVNode" in t ? t.children.toUpperCase() : t,
    lower: (t, e) => e === "text" && We(t) ? t.toLowerCase() : e === "vnode" && _t(t) && "__v_isVNode" in t ? t.children.toLowerCase() : t,
    capitalize: (t, e) => e === "text" && We(t) ? dw(t) : e === "vnode" && _t(t) && "__v_isVNode" in t ? dw(t.children) : t
  };
}
let sC;
function hw(t) {
  sC = t;
}
let aC;
function f2(t) {
  aC = t;
}
let lC;
function p2(t) {
  lC = t;
}
let uC = null;
const m2 = /* @__NO_SIDE_EFFECTS__ */ (t) => {
  uC = t;
}, g2 = /* @__NO_SIDE_EFFECTS__ */ () => uC;
let cC = null;
const fw = (t) => {
  cC = t;
}, O2 = () => cC;
let pw = 0;
function v2(t = {}) {
  const e = jt(t.onWarn) ? t.onWarn : Yo, n = We(t.version) ? t.version : d2, i = We(t.locale) || jt(t.locale) ? t.locale : Ec, r = jt(i) ? Ec : i, o = wn(t.fallbackLocale) || vt(t.fallbackLocale) || We(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : r, s = vt(t.messages) ? t.messages : { [r]: {} }, a = vt(t.datetimeFormats) ? t.datetimeFormats : { [r]: {} }, l = vt(t.numberFormats) ? t.numberFormats : { [r]: {} }, u = Un({}, t.modifiers || {}, h2()), c = t.pluralRules || {}, d = jt(t.missing) ? t.missing : null, h = Dt(t.missingWarn) || Al(t.missingWarn) ? t.missingWarn : !0, f = Dt(t.fallbackWarn) || Al(t.fallbackWarn) ? t.fallbackWarn : !0, p = !!t.fallbackFormat, m = !!t.unresolving, g = jt(t.postTranslation) ? t.postTranslation : null, O = vt(t.processor) ? t.processor : null, y = Dt(t.warnHtmlMessage) ? t.warnHtmlMessage : !0, b = !!t.escapeParameter, v = jt(t.messageCompiler) ? t.messageCompiler : sC;
  process.env.NODE_ENV !== "production" && jt(t.messageCompiler) && Jx($a(ri.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  const k = jt(t.messageResolver) ? t.messageResolver : aC || zQ, w = jt(t.localeFallbacker) ? t.localeFallbacker : lC || l2, S = _t(t.fallbackContext) ? t.fallbackContext : void 0, $ = t, C = _t($.__datetimeFormatters) ? $.__datetimeFormatters : /* @__PURE__ */ new Map(), L = _t($.__numberFormatters) ? $.__numberFormatters : /* @__PURE__ */ new Map(), j = _t($.__meta) ? $.__meta : {};
  pw++;
  const P = {
    version: n,
    cid: pw,
    locale: i,
    fallbackLocale: o,
    messages: s,
    modifiers: u,
    pluralRules: c,
    missing: d,
    missingWarn: h,
    fallbackWarn: f,
    fallbackFormat: p,
    unresolving: m,
    postTranslation: g,
    processor: O,
    warnHtmlMessage: y,
    escapeParameter: b,
    messageCompiler: v,
    messageResolver: k,
    localeFallbacker: w,
    fallbackContext: S,
    onWarn: e,
    __meta: j
  };
  return P.datetimeFormats = a, P.numberFormats = l, P.__datetimeFormatters = C, P.__numberFormatters = L, process.env.NODE_ENV !== "production" && (P.__v_emitter = $.__v_emitter != null ? $.__v_emitter : void 0), (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) && i2(P, n, j), P;
}
function Fp(t, e) {
  return t instanceof RegExp ? t.test(e) : t;
}
function dC(t, e) {
  return t instanceof RegExp ? t.test(e) : t;
}
function Ny(t, e, n, i, r) {
  const { missing: o, onWarn: s } = t;
  if (process.env.NODE_ENV !== "production") {
    const a = t.__v_emitter;
    a && a.emit("missing", {
      locale: n,
      key: e,
      type: r,
      groupId: `${r}:${e}`
    });
  }
  if (o !== null) {
    const a = o(t, n, e, r);
    return We(a) ? a : e;
  } else
    return process.env.NODE_ENV !== "production" && dC(i, e) && s($a(ri.NOT_FOUND_KEY, { key: e, locale: n })), e;
}
function Cu(t, e, n) {
  const i = t;
  i.__localeChainCache = /* @__PURE__ */ new Map(), t.localeFallbacker(t, n, e);
}
function hC(t, e) {
  return t === e ? !1 : t.split("-")[0] === e.split("-")[0];
}
function y2(t, e) {
  const n = e.indexOf(t);
  if (n === -1)
    return !1;
  for (let i = n + 1; i < e.length; i++)
    if (hC(t, e[i]))
      return !0;
  return !1;
}
function Bm(t) {
  return (n) => b2(n, t);
}
function b2(t, e) {
  const n = e.b || e.body;
  if ((n.t || n.type) === 1) {
    const i = n, r = i.c || i.cases;
    return t.plural(r.reduce((o, s) => [
      ...o,
      mw(t, s)
    ], []));
  } else
    return mw(t, n);
}
function mw(t, e) {
  const n = e.s || e.static;
  if (n)
    return t.type === "text" ? n : t.normalize([n]);
  {
    const i = (e.i || e.items).reduce((r, o) => [...r, OO(t, o)], []);
    return t.normalize(i);
  }
}
function OO(t, e) {
  const n = e.t || e.type;
  switch (n) {
    case 3: {
      const i = e;
      return i.v || i.value;
    }
    case 9: {
      const i = e;
      return i.v || i.value;
    }
    case 4: {
      const i = e;
      return t.interpolate(t.named(i.k || i.key));
    }
    case 5: {
      const i = e;
      return t.interpolate(t.list(i.i != null ? i.i : i.index));
    }
    case 6: {
      const i = e, r = i.m || i.modifier;
      return t.linked(OO(t, i.k || i.key), r ? OO(t, r) : void 0, t.type);
    }
    case 7: {
      const i = e;
      return i.v || i.value;
    }
    case 8: {
      const i = e;
      return i.v || i.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${n}`);
  }
}
const w2 = "Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.";
function fC(t, e) {
  e && mQ(t) && Yo(Ry(w2, { source: t }));
}
const pC = (t) => t;
let pl = /* @__PURE__ */ Object.create(null);
function mC(t) {
  t.code === Bp.USE_MODULO_SYNTAX && Yo(`The use of named interpolation with modulo syntax is deprecated. It will be removed in v10.
reference: https://vue-i18n.intlify.dev/guide/essentials/syntax#rails-i18n-format 
(message compiler warning message: ${t.message})`);
}
const Pa = (t) => _t(t) && (t.t === 0 || t.type === 0) && ("b" in t || "body" in t);
function gC(t, e = {}) {
  let n = !1;
  const i = e.onError || fQ;
  return e.onError = (r) => {
    n = !0, i(r);
  }, { ...LQ(t, e), detectError: n };
}
const k2 = /* @__NO_SIDE_EFFECTS__ */ (t, e) => {
  if (!We(t))
    throw Yr(Pn.NOT_SUPPORT_NON_STRING_MESSAGE);
  process.env.NODE_ENV !== "production" && (e.onWarn = mC);
  {
    const n = Dt(e.warnHtmlMessage) ? e.warnHtmlMessage : !0;
    process.env.NODE_ENV !== "production" && fC(t, n);
    const r = (e.onCacheKey || pC)(t), o = pl[r];
    if (o)
      return o;
    const { code: s, detectError: a } = gC(t, e), l = new Function(`return ${s}`)();
    return a ? l : pl[r] = l;
  }
};
function S2(t, e) {
  if (process.env.NODE_ENV !== "production" && (e.onWarn = mC), __INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && We(t)) {
    const n = Dt(e.warnHtmlMessage) ? e.warnHtmlMessage : !0;
    process.env.NODE_ENV !== "production" && fC(t, n);
    const r = (e.onCacheKey || pC)(t), o = pl[r];
    if (o)
      return o;
    const { ast: s, detectError: a } = gC(t, {
      ...e,
      location: process.env.NODE_ENV !== "production",
      jit: !0
    }), l = Bm(s);
    return a ? l : pl[r] = l;
  } else {
    if (process.env.NODE_ENV !== "production" && !Pa(t))
      return Yo(`the message that is resolve with key '${e.key}' is not supported for jit compilation`), () => t;
    const n = t.cacheKey;
    if (n) {
      const i = pl[n];
      return i || (pl[n] = Bm(t));
    } else
      return Bm(t);
  }
}
const gw = () => "", Yi = (t) => jt(t);
function Ow(t, ...e) {
  const { fallbackFormat: n, postTranslation: i, unresolving: r, messageCompiler: o, fallbackLocale: s, messages: a } = t, [l, u] = vO(...e), c = Dt(u.missingWarn) ? u.missingWarn : t.missingWarn, d = Dt(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn, h = Dt(u.escapeParameter) ? u.escapeParameter : t.escapeParameter, f = !!u.resolvedMessage, p = We(u.default) || Dt(u.default) ? Dt(u.default) ? o ? l : () => l : u.default : n ? o ? l : () => l : "", m = n || p !== "", g = Qy(t, u);
  h && _2(u);
  let [O, y, b] = f ? [
    l,
    g,
    a[g] || {}
  ] : OC(t, l, g, s, d, c), v = O, k = l;
  if (!f && !(We(v) || Pa(v) || Yi(v)) && m && (v = p, k = v), !f && (!(We(v) || Pa(v) || Yi(v)) || !We(y)))
    return r ? Zp : l;
  if (process.env.NODE_ENV !== "production" && We(v) && t.messageCompiler == null)
    return Yo(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${l}'.`), l;
  let w = !1;
  const S = () => {
    w = !0;
  }, $ = Yi(v) ? v : vC(t, l, y, v, k, S);
  if (w)
    return v;
  const C = $2(t, y, b, u), L = t2(C), j = x2(t, $, L), P = i ? i(j, l) : j;
  if (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) {
    const A = {
      timestamp: Date.now(),
      key: We(l) ? l : Yi(v) ? v.key : "",
      locale: y || (Yi(v) ? v.locale : ""),
      format: We(v) ? v : Yi(v) ? v.source : "",
      message: P
    };
    A.meta = Un({}, t.__meta, /* @__PURE__ */ g2() || {}), r2(A);
  }
  return P;
}
function _2(t) {
  wn(t.list) ? t.list = t.list.map((e) => We(e) ? ew(e) : e) : _t(t.named) && Object.keys(t.named).forEach((e) => {
    We(t.named[e]) && (t.named[e] = ew(t.named[e]));
  });
}
function OC(t, e, n, i, r, o) {
  const { messages: s, onWarn: a, messageResolver: l, localeFallbacker: u } = t, c = u(t, i, n);
  let d = {}, h, f = null, p = n, m = null;
  const g = "translate";
  for (let O = 0; O < c.length; O++) {
    if (h = m = c[O], process.env.NODE_ENV !== "production" && n !== h && !hC(n, h) && Fp(r, e) && a($a(ri.FALLBACK_TO_TRANSLATE, {
      key: e,
      target: h
    })), process.env.NODE_ENV !== "production" && n !== h) {
      const k = t.__v_emitter;
      k && k.emit("fallback", {
        type: g,
        key: e,
        from: p,
        to: m,
        groupId: `${g}:${e}`
      });
    }
    d = s[h] || {};
    let y = null, b, v;
    if (process.env.NODE_ENV !== "production" && Io && (y = window.performance.now(), b = "intlify-message-resolve-start", v = "intlify-message-resolve-end", Li && Li(b)), (f = l(d, e)) === null && (f = d[e]), process.env.NODE_ENV !== "production" && Io) {
      const k = window.performance.now(), w = t.__v_emitter;
      w && y && f && w.emit("message-resolve", {
        type: "message-resolve",
        key: e,
        message: f,
        time: k - y,
        groupId: `${g}:${e}`
      }), b && v && Li && Ta && (Li(v), Ta("intlify message resolve", b, v));
    }
    if (We(f) || Pa(f) || Yi(f))
      break;
    if (!y2(h, c)) {
      const k = Ny(
        t,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        e,
        h,
        o,
        g
      );
      k !== e && (f = k);
    }
    p = m;
  }
  return [f, h, d];
}
function vC(t, e, n, i, r, o) {
  const { messageCompiler: s, warnHtmlMessage: a } = t;
  if (Yi(i)) {
    const h = i;
    return h.locale = h.locale || n, h.key = h.key || e, h;
  }
  if (s == null) {
    const h = () => i;
    return h.locale = n, h.key = e, h;
  }
  let l = null, u, c;
  process.env.NODE_ENV !== "production" && Io && (l = window.performance.now(), u = "intlify-message-compilation-start", c = "intlify-message-compilation-end", Li && Li(u));
  const d = s(i, C2(t, n, r, i, a, o));
  if (process.env.NODE_ENV !== "production" && Io) {
    const h = window.performance.now(), f = t.__v_emitter;
    f && l && f.emit("message-compilation", {
      type: "message-compilation",
      message: i,
      time: h - l,
      groupId: `translate:${e}`
    }), u && c && Li && Ta && (Li(c), Ta("intlify message compilation", u, c));
  }
  return d.locale = n, d.key = e, d.source = i, d;
}
function x2(t, e, n) {
  let i = null, r, o;
  process.env.NODE_ENV !== "production" && Io && (i = window.performance.now(), r = "intlify-message-evaluation-start", o = "intlify-message-evaluation-end", Li && Li(r));
  const s = e(n);
  if (process.env.NODE_ENV !== "production" && Io) {
    const a = window.performance.now(), l = t.__v_emitter;
    l && i && l.emit("message-evaluation", {
      type: "message-evaluation",
      value: s,
      time: a - i,
      groupId: `translate:${e.key}`
    }), r && o && Li && Ta && (Li(o), Ta("intlify message evaluation", r, o));
  }
  return s;
}
function vO(...t) {
  const [e, n, i] = t, r = {};
  if (!We(e) && !jn(e) && !Yi(e) && !Pa(e))
    throw Yr(Pn.INVALID_ARGUMENT);
  const o = jn(e) ? String(e) : (Yi(e), e);
  return jn(n) ? r.plural = n : We(n) ? r.default = n : vt(n) && !Lp(n) ? r.named = n : wn(n) && (r.list = n), jn(i) ? r.plural = i : We(i) ? r.default = i : vt(i) && Un(r, i), [o, r];
}
function C2(t, e, n, i, r, o) {
  return {
    locale: e,
    key: n,
    warnHtmlMessage: r,
    onError: (s) => {
      if (o && o(s), process.env.NODE_ENV !== "production") {
        const a = T2(i), l = `Message compilation error: ${s.message}`, u = s.location && a && oQ(a, s.location.start.offset, s.location.end.offset), c = t.__v_emitter;
        c && a && c.emit("compile-error", {
          message: a,
          error: s.message,
          start: s.location && s.location.start.offset,
          end: s.location && s.location.end.offset,
          groupId: `translate:${n}`
        }), console.error(u ? `${l}
${u}` : l);
      } else
        throw s;
    },
    onCacheKey: (s) => KD(e, n, s)
  };
}
function T2(t) {
  if (We(t))
    return t;
  if (t.loc && t.loc.source)
    return t.loc.source;
}
function $2(t, e, n, i) {
  const { modifiers: r, pluralRules: o, messageResolver: s, fallbackLocale: a, fallbackWarn: l, missingWarn: u, fallbackContext: c } = t, h = {
    locale: e,
    modifiers: r,
    pluralRules: o,
    messages: (f) => {
      let p = s(n, f);
      if (p == null && c) {
        const [, , m] = OC(c, f, e, a, l, u);
        p = s(m, f);
      }
      if (We(p) || Pa(p)) {
        let m = !1;
        const O = vC(t, f, e, p, f, () => {
          m = !0;
        });
        return m ? gw : O;
      } else
        return Yi(p) ? p : gw;
    }
  };
  return t.processor && (h.processor = t.processor), i.list && (h.list = i.list), i.named && (h.named = i.named), jn(i.plural) && (h.pluralIndex = i.plural), h;
}
const vw = typeof Intl < "u", yC = {
  dateTimeFormat: vw && typeof Intl.DateTimeFormat < "u",
  numberFormat: vw && typeof Intl.NumberFormat < "u"
};
function yw(t, ...e) {
  const { datetimeFormats: n, unresolving: i, fallbackLocale: r, onWarn: o, localeFallbacker: s } = t, { __datetimeFormatters: a } = t;
  if (process.env.NODE_ENV !== "production" && !yC.dateTimeFormat)
    return o($a(ri.CANNOT_FORMAT_DATE)), of;
  const [l, u, c, d] = yO(...e), h = Dt(c.missingWarn) ? c.missingWarn : t.missingWarn, f = Dt(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn, p = !!c.part, m = Qy(t, c), g = s(
    t,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    r,
    m
  );
  if (!We(l) || l === "")
    return new Intl.DateTimeFormat(m, d).format(u);
  let O = {}, y, b = null, v = m, k = null;
  const w = "datetime format";
  for (let C = 0; C < g.length; C++) {
    if (y = k = g[C], process.env.NODE_ENV !== "production" && m !== y && Fp(f, l) && o($a(ri.FALLBACK_TO_DATE_FORMAT, {
      key: l,
      target: y
    })), process.env.NODE_ENV !== "production" && m !== y) {
      const L = t.__v_emitter;
      L && L.emit("fallback", {
        type: w,
        key: l,
        from: v,
        to: k,
        groupId: `${w}:${l}`
      });
    }
    if (O = n[y] || {}, b = O[l], vt(b))
      break;
    Ny(t, l, y, h, w), v = k;
  }
  if (!vt(b) || !We(y))
    return i ? Zp : l;
  let S = `${y}__${l}`;
  Lp(d) || (S = `${S}__${JSON.stringify(d)}`);
  let $ = a.get(S);
  return $ || ($ = new Intl.DateTimeFormat(y, Un({}, b, d)), a.set(S, $)), p ? $.formatToParts(u) : $.format(u);
}
const bC = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function yO(...t) {
  const [e, n, i, r] = t, o = {};
  let s = {}, a;
  if (We(e)) {
    const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!l)
      throw Yr(Pn.INVALID_ISO_DATE_ARGUMENT);
    const u = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
    a = new Date(u);
    try {
      a.toISOString();
    } catch {
      throw Yr(Pn.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (eQ(e)) {
    if (isNaN(e.getTime()))
      throw Yr(Pn.INVALID_DATE_ARGUMENT);
    a = e;
  } else if (jn(e))
    a = e;
  else
    throw Yr(Pn.INVALID_ARGUMENT);
  return We(n) ? o.key = n : vt(n) && Object.keys(n).forEach((l) => {
    bC.includes(l) ? s[l] = n[l] : o[l] = n[l];
  }), We(i) ? o.locale = i : vt(i) && (s = i), vt(r) && (s = r), [o.key || "", a, o, s];
}
function bw(t, e, n) {
  const i = t;
  for (const r in n) {
    const o = `${e}__${r}`;
    i.__datetimeFormatters.has(o) && i.__datetimeFormatters.delete(o);
  }
}
function ww(t, ...e) {
  const { numberFormats: n, unresolving: i, fallbackLocale: r, onWarn: o, localeFallbacker: s } = t, { __numberFormatters: a } = t;
  if (process.env.NODE_ENV !== "production" && !yC.numberFormat)
    return o($a(ri.CANNOT_FORMAT_NUMBER)), of;
  const [l, u, c, d] = bO(...e), h = Dt(c.missingWarn) ? c.missingWarn : t.missingWarn, f = Dt(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn, p = !!c.part, m = Qy(t, c), g = s(
    t,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    r,
    m
  );
  if (!We(l) || l === "")
    return new Intl.NumberFormat(m, d).format(u);
  let O = {}, y, b = null, v = m, k = null;
  const w = "number format";
  for (let C = 0; C < g.length; C++) {
    if (y = k = g[C], process.env.NODE_ENV !== "production" && m !== y && Fp(f, l) && o($a(ri.FALLBACK_TO_NUMBER_FORMAT, {
      key: l,
      target: y
    })), process.env.NODE_ENV !== "production" && m !== y) {
      const L = t.__v_emitter;
      L && L.emit("fallback", {
        type: w,
        key: l,
        from: v,
        to: k,
        groupId: `${w}:${l}`
      });
    }
    if (O = n[y] || {}, b = O[l], vt(b))
      break;
    Ny(t, l, y, h, w), v = k;
  }
  if (!vt(b) || !We(y))
    return i ? Zp : l;
  let S = `${y}__${l}`;
  Lp(d) || (S = `${S}__${JSON.stringify(d)}`);
  let $ = a.get(S);
  return $ || ($ = new Intl.NumberFormat(y, Un({}, b, d)), a.set(S, $)), p ? $.formatToParts(u) : $.format(u);
}
const wC = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function bO(...t) {
  const [e, n, i, r] = t, o = {};
  let s = {};
  if (!jn(e))
    throw Yr(Pn.INVALID_ARGUMENT);
  const a = e;
  return We(n) ? o.key = n : vt(n) && Object.keys(n).forEach((l) => {
    wC.includes(l) ? s[l] = n[l] : o[l] = n[l];
  }), We(i) ? o.locale = i : vt(i) && (s = i), vt(r) && (s = r), [o.key || "", a, o, s];
}
function kw(t, e, n) {
  const i = t;
  for (const r in n) {
    const o = `${e}__${r}`;
    i.__numberFormatters.has(o) && i.__numberFormatters.delete(o);
  }
}
VQ();
/*!
  * vue-i18n v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const P2 = "9.13.1";
function M2() {
  typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (Po().__VUE_I18N_FULL_INSTALL__ = !0), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (Po().__VUE_I18N_LEGACY_API__ = !0), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (Po().__INTLIFY_JIT_COMPILATION__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Po().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Po().__INTLIFY_PROD_DEVTOOLS__ = !1);
}
const kC = ri.__EXTEND_POINT__, vo = Vp(kC), vi = {
  FALLBACK_TO_ROOT: kC,
  // 9
  NOT_SUPPORTED_PRESERVE: vo(),
  // 10
  NOT_SUPPORTED_FORMATTER: vo(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: vo(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: vo(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: vo(),
  // 14
  NOT_FOUND_PARENT_SCOPE: vo(),
  // 15
  IGNORE_OBJ_FLATTEN: vo(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: vo(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: vo()
  // 18
}, E2 = {
  [vi.FALLBACK_TO_ROOT]: "Fall back to {type} '{key}' with root locale.",
  [vi.NOT_SUPPORTED_PRESERVE]: "Not supported 'preserve'.",
  [vi.NOT_SUPPORTED_FORMATTER]: "Not supported 'formatter'.",
  [vi.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: "Not supported 'preserveDirectiveContent'.",
  [vi.NOT_SUPPORTED_GET_CHOICE_INDEX]: "Not supported 'getChoiceIndex'.",
  [vi.COMPONENT_NAME_LEGACY_COMPATIBLE]: "Component name legacy compatible: '{name}' -> 'i18n'",
  [vi.NOT_FOUND_PARENT_SCOPE]: "Not found parent scope. use the global scope.",
  [vi.IGNORE_OBJ_FLATTEN]: "Ignore object flatten: '{key}' key has an string value",
  [vi.NOTICE_DROP_ALLOW_COMPOSITION]: "'allowComposition' option will be dropped in the next major version. For more information, please see 👉 https://tinyurl.com/2p97mcze",
  [vi.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG]: "'translateExistCompatible' option will be dropped in the next major version."
};
function sf(t, ...e) {
  return Ry(E2[t], ...e);
}
const SC = Pn.__EXTEND_POINT__, gi = Vp(SC), Kt = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: SC,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: gi(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: gi(),
  // 26
  NOT_INSTALLED: gi(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: gi(),
  // 28
  // directive module errors
  REQUIRED_VALUE: gi(),
  // 29
  INVALID_VALUE: gi(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: gi(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: gi(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: gi(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: gi(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: gi(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: gi(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: gi(),
  // 37
  // for enhancement
  __EXTEND_POINT__: gi()
  // 38
};
function ks(t, ...e) {
  return pu(t, null, process.env.NODE_ENV !== "production" ? { messages: A2, args: e } : void 0);
}
const A2 = {
  [Kt.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [Kt.INVALID_ARGUMENT]: "Invalid argument",
  [Kt.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [Kt.NOT_INSTALLED]: "Need to install with `app.use` function",
  [Kt.UNEXPECTED_ERROR]: "Unexpected error",
  [Kt.NOT_AVAILABLE_IN_LEGACY_MODE]: "Not available in legacy mode",
  [Kt.REQUIRED_VALUE]: "Required in value: {0}",
  [Kt.INVALID_VALUE]: "Invalid value",
  [Kt.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: "Cannot setup vue-devtools plugin",
  [Kt.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [Kt.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [Kt.BRIDGE_SUPPORT_VUE_2_ONLY]: "vue-i18n-bridge support Vue 2.x only",
  [Kt.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: "Must define ‘i18n’ option or custom block in Composition API with using local scope in Legacy API mode",
  [Kt.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
}, wO = /* @__PURE__ */ jo("__translateVNode"), kO = /* @__PURE__ */ jo("__datetimeParts"), SO = /* @__PURE__ */ jo("__numberParts"), _O = /* @__PURE__ */ jo("__enableEmitter"), xO = /* @__PURE__ */ jo("__disableEmitter"), R2 = jo("__setPluralRules"), _C = /* @__PURE__ */ jo("__injectWithOption"), CO = /* @__PURE__ */ jo("__dispose");
function Ac(t) {
  if (!_t(t))
    return t;
  for (const e in t)
    if (nf(t, e))
      if (!e.includes("."))
        _t(t[e]) && Ac(t[e]);
      else {
        const n = e.split("."), i = n.length - 1;
        let r = t, o = !1;
        for (let s = 0; s < i; s++) {
          if (n[s] in r || (r[n[s]] = {}), !_t(r[n[s]])) {
            process.env.NODE_ENV !== "production" && Yo(sf(vi.IGNORE_OBJ_FLATTEN, {
              key: n[s]
            })), o = !0;
            break;
          }
          r = r[n[s]];
        }
        o || (r[n[i]] = t[e], delete t[e]), _t(r[n[i]]) && Ac(r[n[i]]);
      }
  return t;
}
function Iy(t, e) {
  const { messages: n, __i18n: i, messageResolver: r, flatJson: o } = e, s = vt(n) ? n : wn(i) ? {} : { [t]: {} };
  if (wn(i) && i.forEach((a) => {
    if ("locale" in a && "resource" in a) {
      const { locale: l, resource: u } = a;
      l ? (s[l] = s[l] || {}, Eh(u, s[l])) : Eh(u, s);
    } else
      We(a) && Eh(JSON.parse(a), s);
  }), r == null && o)
    for (const a in s)
      nf(s, a) && Ac(s[a]);
  return s;
}
function xC(t) {
  return t.type;
}
function D2(t, e, n) {
  let i = _t(e.messages) ? e.messages : {};
  "__i18nGlobal" in n && (i = Iy(t.locale.value, {
    messages: i,
    __i18n: n.__i18nGlobal
  }));
  const r = Object.keys(i);
  r.length && r.forEach((o) => {
    t.mergeLocaleMessage(o, i[o]);
  });
  {
    if (_t(e.datetimeFormats)) {
      const o = Object.keys(e.datetimeFormats);
      o.length && o.forEach((s) => {
        t.mergeDateTimeFormat(s, e.datetimeFormats[s]);
      });
    }
    if (_t(e.numberFormats)) {
      const o = Object.keys(e.numberFormats);
      o.length && o.forEach((s) => {
        t.mergeNumberFormat(s, e.numberFormats[s]);
      });
    }
  }
}
function Sw(t) {
  return fe(Xx, null, t, 0);
}
const _w = "__INTLIFY_META__", xw = () => [], Q2 = () => !1;
let Cw = 0;
function Tw(t) {
  return (e, n, i, r) => t(n, i, Ip() || void 0, r);
}
const N2 = /* @__NO_SIDE_EFFECTS__ */ () => {
  const t = Ip();
  let e = null;
  return t && (e = xC(t)[_w]) ? { [_w]: e } : null;
};
function I2(t = {}, e) {
  const { __root: n, __injectWithOption: i } = t, r = n === void 0, o = t.flatJson, s = Io ? re : vd, a = !!t.translateExistCompatible;
  process.env.NODE_ENV !== "production" && a && Jx(sf(vi.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG));
  let l = Dt(t.inheritLocale) ? t.inheritLocale : !0;
  const u = s(
    // prettier-ignore
    n && l ? n.locale.value : We(t.locale) ? t.locale : Ec
  ), c = s(
    // prettier-ignore
    n && l ? n.fallbackLocale.value : We(t.fallbackLocale) || wn(t.fallbackLocale) || vt(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : u.value
  ), d = s(Iy(u.value, t)), h = s(vt(t.datetimeFormats) ? t.datetimeFormats : { [u.value]: {} }), f = s(vt(t.numberFormats) ? t.numberFormats : { [u.value]: {} });
  let p = n ? n.missingWarn : Dt(t.missingWarn) || Al(t.missingWarn) ? t.missingWarn : !0, m = n ? n.fallbackWarn : Dt(t.fallbackWarn) || Al(t.fallbackWarn) ? t.fallbackWarn : !0, g = n ? n.fallbackRoot : Dt(t.fallbackRoot) ? t.fallbackRoot : !0, O = !!t.fallbackFormat, y = jt(t.missing) ? t.missing : null, b = jt(t.missing) ? Tw(t.missing) : null, v = jt(t.postTranslation) ? t.postTranslation : null, k = n ? n.warnHtmlMessage : Dt(t.warnHtmlMessage) ? t.warnHtmlMessage : !0, w = !!t.escapeParameter;
  const S = n ? n.modifiers : vt(t.modifiers) ? t.modifiers : {};
  let $ = t.pluralRules || n && n.pluralRules, C;
  C = (() => {
    r && fw(null);
    const se = {
      version: P2,
      locale: u.value,
      fallbackLocale: c.value,
      messages: d.value,
      modifiers: S,
      pluralRules: $,
      missing: b === null ? void 0 : b,
      missingWarn: p,
      fallbackWarn: m,
      fallbackFormat: O,
      unresolving: !0,
      postTranslation: v === null ? void 0 : v,
      warnHtmlMessage: k,
      escapeParameter: w,
      messageResolver: t.messageResolver,
      messageCompiler: t.messageCompiler,
      __meta: { framework: "vue" }
    };
    se.datetimeFormats = h.value, se.numberFormats = f.value, se.__datetimeFormatters = vt(C) ? C.__datetimeFormatters : void 0, se.__numberFormatters = vt(C) ? C.__numberFormatters : void 0, process.env.NODE_ENV !== "production" && (se.__v_emitter = vt(C) ? C.__v_emitter : void 0);
    const Oe = v2(se);
    return r && fw(Oe), Oe;
  })(), Cu(C, u.value, c.value);
  function j() {
    return [
      u.value,
      c.value,
      d.value,
      h.value,
      f.value
    ];
  }
  const P = J({
    get: () => u.value,
    set: (se) => {
      u.value = se, C.locale = u.value;
    }
  }), A = J({
    get: () => c.value,
    set: (se) => {
      c.value = se, C.fallbackLocale = c.value, Cu(C, u.value, se);
    }
  }), T = J(() => d.value), N = /* @__PURE__ */ J(() => h.value), Q = /* @__PURE__ */ J(() => f.value);
  function Y() {
    return jt(v) ? v : null;
  }
  function V(se) {
    v = se, C.postTranslation = se;
  }
  function q() {
    return y;
  }
  function B(se) {
    se !== null && (b = Tw(se)), y = se, C.missing = b;
  }
  function pe(se, Oe) {
    return se !== "translate" || !Oe.resolvedMessage;
  }
  const oe = (se, Oe, at, $t, Qn, qi) => {
    j();
    let Mi;
    try {
      process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__, r || (C.fallbackContext = n ? O2() : void 0), Mi = se(C);
    } finally {
      process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__, r || (C.fallbackContext = void 0);
    }
    if (at !== "translate exists" && // for not `te` (e.g `t`)
    jn(Mi) && Mi === Zp || at === "translate exists" && !Mi) {
      const [R, le] = Oe();
      if (process.env.NODE_ENV !== "production" && n && We(R) && pe(at, le) && (g && (Fp(m, R) || dC(p, R)) && Yo(sf(vi.FALLBACK_TO_ROOT, {
        key: R,
        type: at
      })), process.env.NODE_ENV !== "production")) {
        const { __v_emitter: $e } = C;
        $e && g && $e.emit("fallback", {
          type: at,
          key: R,
          to: "global",
          groupId: `${at}:${R}`
        });
      }
      return n && g ? $t(n) : Qn(R);
    } else {
      if (qi(Mi))
        return Mi;
      throw ks(Kt.UNEXPECTED_RETURN_TYPE);
    }
  };
  function te(...se) {
    return oe((Oe) => Reflect.apply(Ow, null, [Oe, ...se]), () => vO(...se), "translate", (Oe) => Reflect.apply(Oe.t, Oe, [...se]), (Oe) => Oe, (Oe) => We(Oe));
  }
  function M(...se) {
    const [Oe, at, $t] = se;
    if ($t && !_t($t))
      throw ks(Kt.INVALID_ARGUMENT);
    return te(Oe, at, Un({ resolvedMessage: !0 }, $t || {}));
  }
  function G(...se) {
    return oe((Oe) => Reflect.apply(yw, null, [Oe, ...se]), () => yO(...se), "datetime format", (Oe) => Reflect.apply(Oe.d, Oe, [...se]), () => of, (Oe) => We(Oe));
  }
  function ce(...se) {
    return oe((Oe) => Reflect.apply(ww, null, [Oe, ...se]), () => bO(...se), "number format", (Oe) => Reflect.apply(Oe.n, Oe, [...se]), () => of, (Oe) => We(Oe));
  }
  function F(se) {
    return se.map((Oe) => We(Oe) || jn(Oe) || Dt(Oe) ? Sw(String(Oe)) : Oe);
  }
  const Be = {
    normalize: F,
    interpolate: (se) => se,
    type: "vnode"
  };
  function lt(...se) {
    return oe(
      (Oe) => {
        let at;
        const $t = Oe;
        try {
          $t.processor = Be, at = Reflect.apply(Ow, null, [$t, ...se]);
        } finally {
          $t.processor = null;
        }
        return at;
      },
      () => vO(...se),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (Oe) => Oe[wO](...se),
      (Oe) => [Sw(Oe)],
      (Oe) => wn(Oe)
    );
  }
  function de(...se) {
    return oe(
      (Oe) => Reflect.apply(ww, null, [Oe, ...se]),
      () => bO(...se),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (Oe) => Oe[SO](...se),
      xw,
      (Oe) => We(Oe) || wn(Oe)
    );
  }
  function ye(...se) {
    return oe(
      (Oe) => Reflect.apply(yw, null, [Oe, ...se]),
      () => yO(...se),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (Oe) => Oe[kO](...se),
      xw,
      (Oe) => We(Oe) || wn(Oe)
    );
  }
  function me(se) {
    $ = se, C.pluralRules = $;
  }
  function ie(se, Oe) {
    return oe(() => {
      if (!se)
        return !1;
      const at = We(Oe) ? Oe : u.value, $t = ze(at), Qn = C.messageResolver($t, se);
      return a ? Qn != null : Pa(Qn) || Yi(Qn) || We(Qn);
    }, () => [se], "translate exists", (at) => Reflect.apply(at.te, at, [se, Oe]), Q2, (at) => Dt(at));
  }
  function I(se) {
    let Oe = null;
    const at = oC(C, c.value, u.value);
    for (let $t = 0; $t < at.length; $t++) {
      const Qn = d.value[at[$t]] || {}, qi = C.messageResolver(Qn, se);
      if (qi != null) {
        Oe = qi;
        break;
      }
    }
    return Oe;
  }
  function ge(se) {
    const Oe = I(se);
    return Oe ?? (n ? n.tm(se) || {} : {});
  }
  function ze(se) {
    return d.value[se] || {};
  }
  function Se(se, Oe) {
    if (o) {
      const at = { [se]: Oe };
      for (const $t in at)
        nf(at, $t) && Ac(at[$t]);
      Oe = at[se];
    }
    d.value[se] = Oe, C.messages = d.value;
  }
  function st(se, Oe) {
    d.value[se] = d.value[se] || {};
    const at = { [se]: Oe };
    if (o)
      for (const $t in at)
        nf(at, $t) && Ac(at[$t]);
    Oe = at[se], Eh(Oe, d.value[se]), C.messages = d.value;
  }
  function D(se) {
    return h.value[se] || {};
  }
  function x(se, Oe) {
    h.value[se] = Oe, C.datetimeFormats = h.value, bw(C, se, Oe);
  }
  function U(se, Oe) {
    h.value[se] = Un(h.value[se] || {}, Oe), C.datetimeFormats = h.value, bw(C, se, Oe);
  }
  function K(se) {
    return f.value[se] || {};
  }
  function ke(se, Oe) {
    f.value[se] = Oe, C.numberFormats = f.value, kw(C, se, Oe);
  }
  function Ve(se, Oe) {
    f.value[se] = Un(f.value[se] || {}, Oe), C.numberFormats = f.value, kw(C, se, Oe);
  }
  Cw++, n && Io && (gt(n.locale, (se) => {
    l && (u.value = se, C.locale = se, Cu(C, u.value, c.value));
  }), gt(n.fallbackLocale, (se) => {
    l && (c.value = se, C.fallbackLocale = se, Cu(C, u.value, c.value));
  }));
  const be = {
    id: Cw,
    locale: P,
    fallbackLocale: A,
    get inheritLocale() {
      return l;
    },
    set inheritLocale(se) {
      l = se, se && n && (u.value = n.locale.value, c.value = n.fallbackLocale.value, Cu(C, u.value, c.value));
    },
    get availableLocales() {
      return Object.keys(d.value).sort();
    },
    messages: T,
    get modifiers() {
      return S;
    },
    get pluralRules() {
      return $ || {};
    },
    get isGlobal() {
      return r;
    },
    get missingWarn() {
      return p;
    },
    set missingWarn(se) {
      p = se, C.missingWarn = p;
    },
    get fallbackWarn() {
      return m;
    },
    set fallbackWarn(se) {
      m = se, C.fallbackWarn = m;
    },
    get fallbackRoot() {
      return g;
    },
    set fallbackRoot(se) {
      g = se;
    },
    get fallbackFormat() {
      return O;
    },
    set fallbackFormat(se) {
      O = se, C.fallbackFormat = O;
    },
    get warnHtmlMessage() {
      return k;
    },
    set warnHtmlMessage(se) {
      k = se, C.warnHtmlMessage = se;
    },
    get escapeParameter() {
      return w;
    },
    set escapeParameter(se) {
      w = se, C.escapeParameter = se;
    },
    t: te,
    getLocaleMessage: ze,
    setLocaleMessage: Se,
    mergeLocaleMessage: st,
    getPostTranslationHandler: Y,
    setPostTranslationHandler: V,
    getMissingHandler: q,
    setMissingHandler: B,
    [R2]: me
  };
  return be.datetimeFormats = N, be.numberFormats = Q, be.rt = M, be.te = ie, be.tm = ge, be.d = G, be.n = ce, be.getDateTimeFormat = D, be.setDateTimeFormat = x, be.mergeDateTimeFormat = U, be.getNumberFormat = K, be.setNumberFormat = ke, be.mergeNumberFormat = Ve, be[_C] = i, be[wO] = lt, be[kO] = ye, be[SO] = de, process.env.NODE_ENV !== "production" && (be[_O] = (se) => {
    C.__v_emitter = se;
  }, be[xO] = () => {
    C.__v_emitter = void 0;
  }), be;
}
const Ly = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (t) => t === "parent" || t === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function L2({ slots: t }, e) {
  return e.length === 1 && e[0] === "default" ? (t.default ? t.default() : []).reduce((i, r) => [
    ...i,
    // prettier-ignore
    ...r.type === Qe ? r.children : [r]
  ], []) : e.reduce((n, i) => {
    const r = t[i];
    return r && (n[i] = r()), n;
  }, {});
}
function CC(t) {
  return Qe;
}
Un({
  keypath: {
    type: String,
    required: !0
  },
  plural: {
    type: [Number, String],
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    validator: (t) => jn(t) || !isNaN(t)
  }
}, Ly);
function V2(t) {
  return wn(t) && !We(t[0]);
}
function TC(t, e, n, i) {
  const { slots: r, attrs: o } = e;
  return () => {
    const s = { part: !0 };
    let a = {};
    t.locale && (s.locale = t.locale), We(t.format) ? s.key = t.format : _t(t.format) && (We(t.format.key) && (s.key = t.format.key), a = Object.keys(t.format).reduce((h, f) => n.includes(f) ? Un({}, h, { [f]: t.format[f] }) : h, {}));
    const l = i(t.value, s, a);
    let u = [s.key];
    wn(l) ? u = l.map((h, f) => {
      const p = r[h.type], m = p ? p({ [h.type]: h.value, index: f, parts: l }) : [h.value];
      return V2(m) && (m[0].key = `${h.type}-${f}`), m;
    }) : We(l) && (u = [l]);
    const c = Un({}, o), d = We(t.tag) || _t(t.tag) ? t.tag : CC();
    return ir(d, c, u);
  };
}
Un({
  value: {
    type: Number,
    required: !0
  },
  format: {
    type: [String, Object]
  }
}, Ly);
Un({
  value: {
    type: [Number, Date],
    required: !0
  },
  format: {
    type: [String, Object]
  }
}, Ly);
function $w(t, e) {
}
const B2 = /* @__PURE__ */ jo("global-vue-i18n");
function Lt(t = {}) {
  const e = Ip();
  if (e == null)
    throw ks(Kt.MUST_BE_CALL_SETUP_TOP);
  if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__)
    throw ks(Kt.NOT_INSTALLED);
  const n = Z2(e), i = q2(n), r = xC(e), o = F2(t, r);
  if (__VUE_I18N_LEGACY_API__ && n.mode === "legacy" && !t.__useComponent) {
    if (!n.allowComposition)
      throw ks(Kt.NOT_AVAILABLE_IN_LEGACY_MODE);
    return j2(e, o, i, t);
  }
  if (o === "global")
    return D2(i, t, r), i;
  if (o === "parent") {
    let l = W2(n, e, t.__useComponent);
    return l == null && (process.env.NODE_ENV !== "production" && Yo(sf(vi.NOT_FOUND_PARENT_SCOPE)), l = i), l;
  }
  const s = n;
  let a = s.__getInstance(e);
  if (a == null) {
    const l = Un({}, t);
    "__i18n" in r && (l.__i18n = r.__i18n), i && (l.__root = i), a = I2(l), s.__composerExtend && (a[CO] = s.__composerExtend(a)), z2(s, e, a), s.__setInstance(e, a);
  }
  return a;
}
function Z2(t) {
  {
    const e = fs(t.isCE ? B2 : t.appContext.app.__VUE_I18N_SYMBOL__);
    if (!e)
      throw ks(t.isCE ? Kt.NOT_INSTALLED_WITH_PROVIDE : Kt.UNEXPECTED_ERROR);
    return e;
  }
}
function F2(t, e) {
  return Lp(t) ? "__i18n" in e ? "local" : "global" : t.useScope ? t.useScope : "local";
}
function q2(t) {
  return t.mode === "composition" ? t.global : t.global.__composer;
}
function W2(t, e, n = !1) {
  let i = null;
  const r = e.root;
  let o = X2(e, n);
  for (; o != null; ) {
    const s = t;
    if (t.mode === "composition")
      i = s.__getInstance(o);
    else if (__VUE_I18N_LEGACY_API__) {
      const a = s.__getInstance(o);
      a != null && (i = a.__composer, n && i && !i[_C] && (i = null));
    }
    if (i != null || r === o)
      break;
    o = o.parent;
  }
  return i;
}
function X2(t, e = !1) {
  return t == null ? null : e && t.vnode.ctx || t.parent;
}
function z2(t, e, n) {
  let i = null;
  Et(() => {
    if (process.env.NODE_ENV !== "production" && e.vnode.el) {
      e.vnode.el.__VUE_I18N__ = n, i = sQ();
      const r = n;
      r[_O] && r[_O](i), i.on("*", $w);
    }
  }, e), to(() => {
    const r = n;
    process.env.NODE_ENV !== "production" && e.vnode.el && e.vnode.el.__VUE_I18N__ && (i && i.off("*", $w), r[xO] && r[xO](), delete e.vnode.el.__VUE_I18N__), t.__deleteInstance(e);
    const o = r[CO];
    o && (o(), delete r[CO]);
  }, e);
}
function j2(t, e, n, i = {}) {
  const r = e === "local", o = vd(null);
  if (r && t.proxy && !(t.proxy.$options.i18n || t.proxy.$options.__i18n))
    throw ks(Kt.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  const s = Dt(i.inheritLocale) ? i.inheritLocale : !We(i.locale), a = re(
    // prettier-ignore
    !r || s ? n.locale.value : We(i.locale) ? i.locale : Ec
  ), l = re(
    // prettier-ignore
    !r || s ? n.fallbackLocale.value : We(i.fallbackLocale) || wn(i.fallbackLocale) || vt(i.fallbackLocale) || i.fallbackLocale === !1 ? i.fallbackLocale : a.value
  ), u = re(Iy(a.value, i)), c = re(vt(i.datetimeFormats) ? i.datetimeFormats : { [a.value]: {} }), d = re(vt(i.numberFormats) ? i.numberFormats : { [a.value]: {} }), h = r ? n.missingWarn : Dt(i.missingWarn) || Al(i.missingWarn) ? i.missingWarn : !0, f = r ? n.fallbackWarn : Dt(i.fallbackWarn) || Al(i.fallbackWarn) ? i.fallbackWarn : !0, p = r ? n.fallbackRoot : Dt(i.fallbackRoot) ? i.fallbackRoot : !0, m = !!i.fallbackFormat, g = jt(i.missing) ? i.missing : null, O = jt(i.postTranslation) ? i.postTranslation : null, y = r ? n.warnHtmlMessage : Dt(i.warnHtmlMessage) ? i.warnHtmlMessage : !0, b = !!i.escapeParameter, v = r ? n.modifiers : vt(i.modifiers) ? i.modifiers : {}, k = i.pluralRules || r && n.pluralRules;
  function w() {
    return [
      a.value,
      l.value,
      u.value,
      c.value,
      d.value
    ];
  }
  const S = J({
    get: () => o.value ? o.value.locale.value : a.value,
    set: (ie) => {
      o.value && (o.value.locale.value = ie), a.value = ie;
    }
  }), $ = J({
    get: () => o.value ? o.value.fallbackLocale.value : l.value,
    set: (ie) => {
      o.value && (o.value.fallbackLocale.value = ie), l.value = ie;
    }
  }), C = J(() => o.value ? o.value.messages.value : u.value), L = J(() => c.value), j = J(() => d.value);
  function P() {
    return o.value ? o.value.getPostTranslationHandler() : O;
  }
  function A(ie) {
    o.value && o.value.setPostTranslationHandler(ie);
  }
  function T() {
    return o.value ? o.value.getMissingHandler() : g;
  }
  function N(ie) {
    o.value && o.value.setMissingHandler(ie);
  }
  function Q(ie) {
    return w(), ie();
  }
  function Y(...ie) {
    return o.value ? Q(() => Reflect.apply(o.value.t, null, [...ie])) : Q(() => "");
  }
  function V(...ie) {
    return o.value ? Reflect.apply(o.value.rt, null, [...ie]) : "";
  }
  function q(...ie) {
    return o.value ? Q(() => Reflect.apply(o.value.d, null, [...ie])) : Q(() => "");
  }
  function B(...ie) {
    return o.value ? Q(() => Reflect.apply(o.value.n, null, [...ie])) : Q(() => "");
  }
  function pe(ie) {
    return o.value ? o.value.tm(ie) : {};
  }
  function oe(ie, I) {
    return o.value ? o.value.te(ie, I) : !1;
  }
  function te(ie) {
    return o.value ? o.value.getLocaleMessage(ie) : {};
  }
  function M(ie, I) {
    o.value && (o.value.setLocaleMessage(ie, I), u.value[ie] = I);
  }
  function G(ie, I) {
    o.value && o.value.mergeLocaleMessage(ie, I);
  }
  function ce(ie) {
    return o.value ? o.value.getDateTimeFormat(ie) : {};
  }
  function F(ie, I) {
    o.value && (o.value.setDateTimeFormat(ie, I), c.value[ie] = I);
  }
  function xe(ie, I) {
    o.value && o.value.mergeDateTimeFormat(ie, I);
  }
  function Be(ie) {
    return o.value ? o.value.getNumberFormat(ie) : {};
  }
  function lt(ie, I) {
    o.value && (o.value.setNumberFormat(ie, I), d.value[ie] = I);
  }
  function de(ie, I) {
    o.value && o.value.mergeNumberFormat(ie, I);
  }
  const ye = {
    get id() {
      return o.value ? o.value.id : -1;
    },
    locale: S,
    fallbackLocale: $,
    messages: C,
    datetimeFormats: L,
    numberFormats: j,
    get inheritLocale() {
      return o.value ? o.value.inheritLocale : s;
    },
    set inheritLocale(ie) {
      o.value && (o.value.inheritLocale = ie);
    },
    get availableLocales() {
      return o.value ? o.value.availableLocales : Object.keys(u.value);
    },
    get modifiers() {
      return o.value ? o.value.modifiers : v;
    },
    get pluralRules() {
      return o.value ? o.value.pluralRules : k;
    },
    get isGlobal() {
      return o.value ? o.value.isGlobal : !1;
    },
    get missingWarn() {
      return o.value ? o.value.missingWarn : h;
    },
    set missingWarn(ie) {
      o.value && (o.value.missingWarn = ie);
    },
    get fallbackWarn() {
      return o.value ? o.value.fallbackWarn : f;
    },
    set fallbackWarn(ie) {
      o.value && (o.value.missingWarn = ie);
    },
    get fallbackRoot() {
      return o.value ? o.value.fallbackRoot : p;
    },
    set fallbackRoot(ie) {
      o.value && (o.value.fallbackRoot = ie);
    },
    get fallbackFormat() {
      return o.value ? o.value.fallbackFormat : m;
    },
    set fallbackFormat(ie) {
      o.value && (o.value.fallbackFormat = ie);
    },
    get warnHtmlMessage() {
      return o.value ? o.value.warnHtmlMessage : y;
    },
    set warnHtmlMessage(ie) {
      o.value && (o.value.warnHtmlMessage = ie);
    },
    get escapeParameter() {
      return o.value ? o.value.escapeParameter : b;
    },
    set escapeParameter(ie) {
      o.value && (o.value.escapeParameter = ie);
    },
    t: Y,
    getPostTranslationHandler: P,
    setPostTranslationHandler: A,
    getMissingHandler: T,
    setMissingHandler: N,
    rt: V,
    d: q,
    n: B,
    tm: pe,
    te: oe,
    getLocaleMessage: te,
    setLocaleMessage: M,
    mergeLocaleMessage: G,
    getDateTimeFormat: ce,
    setDateTimeFormat: F,
    mergeDateTimeFormat: xe,
    getNumberFormat: Be,
    setNumberFormat: lt,
    mergeNumberFormat: de
  };
  function me(ie) {
    ie.locale.value = a.value, ie.fallbackLocale.value = l.value, Object.keys(u.value).forEach((I) => {
      ie.mergeLocaleMessage(I, u.value[I]);
    }), Object.keys(c.value).forEach((I) => {
      ie.mergeDateTimeFormat(I, c.value[I]);
    }), Object.keys(d.value).forEach((I) => {
      ie.mergeNumberFormat(I, d.value[I]);
    }), ie.escapeParameter = b, ie.fallbackFormat = m, ie.fallbackRoot = p, ie.fallbackWarn = f, ie.missingWarn = h, ie.warnHtmlMessage = y;
  }
  return ZD(() => {
    if (t.proxy == null || t.proxy.$i18n == null)
      throw ks(Kt.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    const ie = o.value = t.proxy.$i18n.__composer;
    e === "global" ? (a.value = ie.locale.value, l.value = ie.fallbackLocale.value, u.value = ie.messages.value, c.value = ie.datetimeFormats.value, d.value = ie.numberFormats.value) : r && me(ie);
  }), ye;
}
M2();
__INTLIFY_JIT_COMPILATION__ ? hw(S2) : hw(k2);
f2(jQ);
p2(oC);
if (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) {
  const t = Po();
  t.__INTLIFY__ = !0, n2(t.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
process.env.NODE_ENV;
const Y2 = ["for"], H2 = ["aria-label"], U2 = /* @__PURE__ */ Te({
  __name: "mt-field-label",
  props: {
    id: {},
    hasError: { type: Boolean },
    required: { type: Boolean },
    inheritance: { default: "none" }
  },
  emits: ["update:inheritance"],
  setup(t) {
    const { t: e } = Lt({
      messages: {
        en: {
          linkInheritance: "Link inheritance",
          unlinkInheritance: "Unlink inheritance"
        },
        de: {
          linkInheritance: "Vererbung verknüpfen",
          unlinkInheritance: "Vererbung trennen"
        }
      }
    }), n = t, i = J(() => [
      "mt-field-label",
      {
        "mt-field-label--with-error": n.hasError,
        "mt-field-label--is-required": n.required,
        "mt-field-label--has-linked-inheritance": n.inheritance === "linked"
      }
    ]);
    return (r, o) => (_(), Z("label", {
      for: r.id,
      class: Ae(i.value)
    }, [
      r.inheritance !== "none" ? (_(), Z("button", {
        key: 0,
        class: "mt-field-label__inheritance-switch",
        "aria-label": r.inheritance === "linked" ? E(e)("unlinkInheritance") : E(e)("linkInheritance"),
        onClick: o[0] || (o[0] = (s) => r.$emit("update:inheritance", r.inheritance === "linked" ? "unlinked" : "linked"))
      }, [
        fe(mt, {
          size: "1rem",
          "aria-hidden": "true",
          name: r.inheritance === "linked" ? "regular-link-horizontal" : "regular-link-horizontal-slash"
        }, null, 8, ["name"])
      ], 8, H2)) : W("", !0),
      ne(r.$slots, "default", {}, void 0, !0)
    ], 10, Y2));
  }
});
const je = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [i, r] of e)
    n[i] = r;
  return n;
}, $C = /* @__PURE__ */ je(U2, [["__scopeId", "data-v-893b8616"]]), PC = 6048e5, G2 = 864e5, K2 = 6e4, MC = 36e5, J2 = 1e3, Pw = Symbol.for("constructDateFrom");
function Mt(t, e) {
  return typeof t == "function" ? t(e) : t && typeof t == "object" && Pw in t ? t[Pw](e) : t instanceof Date ? new t.constructor(e) : new Date(e);
}
function et(t, e) {
  return Mt(e || t, t);
}
function mr(t, e, n) {
  const i = et(t, n == null ? void 0 : n.in);
  return isNaN(e) ? Mt((n == null ? void 0 : n.in) || t, NaN) : (e && i.setDate(i.getDate() + e), i);
}
function br(t, e, n) {
  const i = et(t, n == null ? void 0 : n.in);
  if (isNaN(e))
    return Mt((n == null ? void 0 : n.in) || t, NaN);
  if (!e)
    return i;
  const r = i.getDate(), o = Mt((n == null ? void 0 : n.in) || t, i.getTime());
  o.setMonth(i.getMonth() + e + 1, 0);
  const s = o.getDate();
  return r >= s ? o : (i.setFullYear(
    o.getFullYear(),
    o.getMonth(),
    r
  ), i);
}
function EC(t, e, n) {
  const {
    years: i = 0,
    months: r = 0,
    weeks: o = 0,
    days: s = 0,
    hours: a = 0,
    minutes: l = 0,
    seconds: u = 0
  } = e, c = et(t, n == null ? void 0 : n.in), d = r || i ? br(c, r + i * 12) : c, h = s || o ? mr(d, s + o * 7) : d, f = l + a * 60, m = (u + f * 60) * 1e3;
  return Mt((n == null ? void 0 : n.in) || t, +h + m);
}
function eN(t, e, n) {
  return Mt((n == null ? void 0 : n.in) || t, +et(t) + e);
}
function tN(t, e, n) {
  return eN(t, e * MC, n);
}
let nN = {};
function Xa() {
  return nN;
}
function kr(t, e) {
  var a, l, u, c;
  const n = Xa(), i = (e == null ? void 0 : e.weekStartsOn) ?? ((l = (a = e == null ? void 0 : e.locale) == null ? void 0 : a.options) == null ? void 0 : l.weekStartsOn) ?? n.weekStartsOn ?? ((c = (u = n.locale) == null ? void 0 : u.options) == null ? void 0 : c.weekStartsOn) ?? 0, r = et(t, e == null ? void 0 : e.in), o = r.getDay(), s = (o < i ? 7 : 0) + o - i;
  return r.setDate(r.getDate() - s), r.setHours(0, 0, 0, 0), r;
}
function Dl(t, e) {
  return kr(t, { ...e, weekStartsOn: 1 });
}
function AC(t, e) {
  const n = et(t, e == null ? void 0 : e.in), i = n.getFullYear(), r = Mt(n, 0);
  r.setFullYear(i + 1, 0, 4), r.setHours(0, 0, 0, 0);
  const o = Dl(r), s = Mt(n, 0);
  s.setFullYear(i, 0, 4), s.setHours(0, 0, 0, 0);
  const a = Dl(s);
  return n.getTime() >= o.getTime() ? i + 1 : n.getTime() >= a.getTime() ? i : i - 1;
}
function af(t) {
  const e = et(t), n = new Date(
    Date.UTC(
      e.getFullYear(),
      e.getMonth(),
      e.getDate(),
      e.getHours(),
      e.getMinutes(),
      e.getSeconds(),
      e.getMilliseconds()
    )
  );
  return n.setUTCFullYear(e.getFullYear()), +t - +n;
}
function yd(t, ...e) {
  const n = Mt.bind(
    null,
    t || e.find((i) => typeof i == "object")
  );
  return e.map(n);
}
function Mw(t, e) {
  const n = et(t, e == null ? void 0 : e.in);
  return n.setHours(0, 0, 0, 0), n;
}
function RC(t, e, n) {
  const [i, r] = yd(
    n == null ? void 0 : n.in,
    t,
    e
  ), o = Mw(i), s = Mw(r), a = +o - af(o), l = +s - af(s);
  return Math.round((a - l) / G2);
}
function iN(t, e) {
  const n = AC(t, e), i = Mt((e == null ? void 0 : e.in) || t, 0);
  return i.setFullYear(n, 0, 4), i.setHours(0, 0, 0, 0), Dl(i);
}
function rN(t, e, n) {
  return br(t, e * 3, n);
}
function Vy(t, e, n) {
  return br(t, e * 12, n);
}
function Ew(t, e) {
  const n = +et(t) - +et(e);
  return n < 0 ? -1 : n > 0 ? 1 : n;
}
function DC(t) {
  return t instanceof Date || typeof t == "object" && Object.prototype.toString.call(t) === "[object Date]";
}
function ac(t) {
  return !(!DC(t) && typeof t != "number" || isNaN(+et(t)));
}
function Aw(t, e) {
  const n = et(t, e == null ? void 0 : e.in);
  return Math.trunc(n.getMonth() / 3) + 1;
}
function oN(t, e, n) {
  const [i, r] = yd(
    n == null ? void 0 : n.in,
    t,
    e
  );
  return i.getFullYear() - r.getFullYear();
}
function sN(t, e, n) {
  const [i, r] = yd(
    n == null ? void 0 : n.in,
    t,
    e
  ), o = Ew(i, r), s = Math.abs(oN(i, r));
  i.setFullYear(1584), r.setFullYear(1584);
  const a = Ew(i, r) === -o, l = o * (s - +a);
  return l === 0 ? 0 : l;
}
function QC(t, e) {
  const [n, i] = yd(t, e.start, e.end);
  return { start: n, end: i };
}
function NC(t, e) {
  const { start: n, end: i } = QC(e == null ? void 0 : e.in, t);
  let r = +n > +i;
  const o = r ? +n : +i, s = r ? i : n;
  s.setHours(0, 0, 0, 0);
  let a = (e == null ? void 0 : e.step) ?? 1;
  if (!a)
    return [];
  a < 0 && (a = -a, r = !r);
  const l = [];
  for (; +s <= o; )
    l.push(Mt(n, s)), s.setDate(s.getDate() + a), s.setHours(0, 0, 0, 0);
  return r ? l.reverse() : l;
}
function ca(t, e) {
  const n = et(t, e == null ? void 0 : e.in), i = n.getMonth(), r = i - i % 3;
  return n.setMonth(r, 1), n.setHours(0, 0, 0, 0), n;
}
function aN(t, e) {
  const { start: n, end: i } = QC(e == null ? void 0 : e.in, t);
  let r = +n > +i;
  const o = r ? +ca(n) : +ca(i);
  let s = ca(r ? i : n), a = (e == null ? void 0 : e.step) ?? 1;
  if (!a)
    return [];
  a < 0 && (a = -a, r = !r);
  const l = [];
  for (; +s <= o; )
    l.push(Mt(n, s)), s = rN(s, a);
  return r ? l.reverse() : l;
}
function lN(t, e) {
  const n = et(t, e == null ? void 0 : e.in);
  return n.setDate(1), n.setHours(0, 0, 0, 0), n;
}
function IC(t, e) {
  const n = et(t, e == null ? void 0 : e.in), i = n.getFullYear();
  return n.setFullYear(i + 1, 0, 0), n.setHours(23, 59, 59, 999), n;
}
function Rc(t, e) {
  const n = et(t, e == null ? void 0 : e.in);
  return n.setFullYear(n.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n;
}
function LC(t, e) {
  var a, l, u, c;
  const n = Xa(), i = (e == null ? void 0 : e.weekStartsOn) ?? ((l = (a = e == null ? void 0 : e.locale) == null ? void 0 : a.options) == null ? void 0 : l.weekStartsOn) ?? n.weekStartsOn ?? ((c = (u = n.locale) == null ? void 0 : u.options) == null ? void 0 : c.weekStartsOn) ?? 0, r = et(t, e == null ? void 0 : e.in), o = r.getDay(), s = (o < i ? -7 : 0) + 6 - (o - i);
  return r.setDate(r.getDate() + s), r.setHours(23, 59, 59, 999), r;
}
function Rw(t, e) {
  const n = et(t, e == null ? void 0 : e.in), i = n.getMonth(), r = i - i % 3 + 3;
  return n.setMonth(r, 0), n.setHours(23, 59, 59, 999), n;
}
const uN = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, cN = (t, e, n) => {
  let i;
  const r = uN[t];
  return typeof r == "string" ? i = r : e === 1 ? i = r.one : i = r.other.replace("{{count}}", e.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + i : i + " ago" : i;
};
function Zm(t) {
  return (e = {}) => {
    const n = e.width ? String(e.width) : t.defaultWidth;
    return t.formats[n] || t.formats[t.defaultWidth];
  };
}
const dN = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, hN = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, fN = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, pN = {
  date: Zm({
    formats: dN,
    defaultWidth: "full"
  }),
  time: Zm({
    formats: hN,
    defaultWidth: "full"
  }),
  dateTime: Zm({
    formats: fN,
    defaultWidth: "full"
  })
}, mN = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, gN = (t, e, n, i) => mN[t];
function Tu(t) {
  return (e, n) => {
    const i = n != null && n.context ? String(n.context) : "standalone";
    let r;
    if (i === "formatting" && t.formattingValues) {
      const s = t.defaultFormattingWidth || t.defaultWidth, a = n != null && n.width ? String(n.width) : s;
      r = t.formattingValues[a] || t.formattingValues[s];
    } else {
      const s = t.defaultWidth, a = n != null && n.width ? String(n.width) : t.defaultWidth;
      r = t.values[a] || t.values[s];
    }
    const o = t.argumentCallback ? t.argumentCallback(e) : e;
    return r[o];
  };
}
const ON = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, vN = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, yN = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, bN = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, wN = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, kN = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, SN = (t, e) => {
  const n = Number(t), i = n % 100;
  if (i > 20 || i < 10)
    switch (i % 10) {
      case 1:
        return n + "st";
      case 2:
        return n + "nd";
      case 3:
        return n + "rd";
    }
  return n + "th";
}, _N = {
  ordinalNumber: SN,
  era: Tu({
    values: ON,
    defaultWidth: "wide"
  }),
  quarter: Tu({
    values: vN,
    defaultWidth: "wide",
    argumentCallback: (t) => t - 1
  }),
  month: Tu({
    values: yN,
    defaultWidth: "wide"
  }),
  day: Tu({
    values: bN,
    defaultWidth: "wide"
  }),
  dayPeriod: Tu({
    values: wN,
    defaultWidth: "wide",
    formattingValues: kN,
    defaultFormattingWidth: "wide"
  })
};
function $u(t) {
  return (e, n = {}) => {
    const i = n.width, r = i && t.matchPatterns[i] || t.matchPatterns[t.defaultMatchWidth], o = e.match(r);
    if (!o)
      return null;
    const s = o[0], a = i && t.parsePatterns[i] || t.parsePatterns[t.defaultParseWidth], l = Array.isArray(a) ? CN(a, (d) => d.test(s)) : (
      // [TODO] -- I challenge you to fix the type
      xN(a, (d) => d.test(s))
    );
    let u;
    u = t.valueCallback ? t.valueCallback(l) : l, u = n.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      n.valueCallback(u)
    ) : u;
    const c = e.slice(s.length);
    return { value: u, rest: c };
  };
}
function xN(t, e) {
  for (const n in t)
    if (Object.prototype.hasOwnProperty.call(t, n) && e(t[n]))
      return n;
}
function CN(t, e) {
  for (let n = 0; n < t.length; n++)
    if (e(t[n]))
      return n;
}
function TN(t) {
  return (e, n = {}) => {
    const i = e.match(t.matchPattern);
    if (!i)
      return null;
    const r = i[0], o = e.match(t.parsePattern);
    if (!o)
      return null;
    let s = t.valueCallback ? t.valueCallback(o[0]) : o[0];
    s = n.valueCallback ? n.valueCallback(s) : s;
    const a = e.slice(r.length);
    return { value: s, rest: a };
  };
}
const $N = /^(\d+)(th|st|nd|rd)?/i, PN = /\d+/i, MN = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, EN = {
  any: [/^b/i, /^(a|c)/i]
}, AN = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, RN = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, DN = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, QN = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, NN = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, IN = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, LN = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, VN = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, BN = {
  ordinalNumber: TN({
    matchPattern: $N,
    parsePattern: PN,
    valueCallback: (t) => parseInt(t, 10)
  }),
  era: $u({
    matchPatterns: MN,
    defaultMatchWidth: "wide",
    parsePatterns: EN,
    defaultParseWidth: "any"
  }),
  quarter: $u({
    matchPatterns: AN,
    defaultMatchWidth: "wide",
    parsePatterns: RN,
    defaultParseWidth: "any",
    valueCallback: (t) => t + 1
  }),
  month: $u({
    matchPatterns: DN,
    defaultMatchWidth: "wide",
    parsePatterns: QN,
    defaultParseWidth: "any"
  }),
  day: $u({
    matchPatterns: NN,
    defaultMatchWidth: "wide",
    parsePatterns: IN,
    defaultParseWidth: "any"
  }),
  dayPeriod: $u({
    matchPatterns: LN,
    defaultMatchWidth: "any",
    parsePatterns: VN,
    defaultParseWidth: "any"
  })
}, VC = {
  code: "en-US",
  formatDistance: cN,
  formatLong: pN,
  formatRelative: gN,
  localize: _N,
  match: BN,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function ZN(t, e) {
  const n = et(t, e == null ? void 0 : e.in);
  return RC(n, Rc(n)) + 1;
}
function By(t, e) {
  const n = et(t, e == null ? void 0 : e.in), i = +Dl(n) - +iN(n);
  return Math.round(i / PC) + 1;
}
function Zy(t, e) {
  var c, d, h, f;
  const n = et(t, e == null ? void 0 : e.in), i = n.getFullYear(), r = Xa(), o = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((d = (c = e == null ? void 0 : e.locale) == null ? void 0 : c.options) == null ? void 0 : d.firstWeekContainsDate) ?? r.firstWeekContainsDate ?? ((f = (h = r.locale) == null ? void 0 : h.options) == null ? void 0 : f.firstWeekContainsDate) ?? 1, s = Mt((e == null ? void 0 : e.in) || t, 0);
  s.setFullYear(i + 1, 0, o), s.setHours(0, 0, 0, 0);
  const a = kr(s, e), l = Mt((e == null ? void 0 : e.in) || t, 0);
  l.setFullYear(i, 0, o), l.setHours(0, 0, 0, 0);
  const u = kr(l, e);
  return +n >= +a ? i + 1 : +n >= +u ? i : i - 1;
}
function FN(t, e) {
  var a, l, u, c;
  const n = Xa(), i = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((l = (a = e == null ? void 0 : e.locale) == null ? void 0 : a.options) == null ? void 0 : l.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((c = (u = n.locale) == null ? void 0 : u.options) == null ? void 0 : c.firstWeekContainsDate) ?? 1, r = Zy(t, e), o = Mt((e == null ? void 0 : e.in) || t, 0);
  return o.setFullYear(r, 0, i), o.setHours(0, 0, 0, 0), kr(o, e);
}
function Fy(t, e) {
  const n = et(t, e == null ? void 0 : e.in), i = +kr(n, e) - +FN(n, e);
  return Math.round(i / PC) + 1;
}
function Pt(t, e) {
  const n = t < 0 ? "-" : "", i = Math.abs(t).toString().padStart(e, "0");
  return n + i;
}
const Ko = {
  // Year
  y(t, e) {
    const n = t.getFullYear(), i = n > 0 ? n : 1 - n;
    return Pt(e === "yy" ? i % 100 : i, e.length);
  },
  // Month
  M(t, e) {
    const n = t.getMonth();
    return e === "M" ? String(n + 1) : Pt(n + 1, 2);
  },
  // Day of the month
  d(t, e) {
    return Pt(t.getDate(), e.length);
  },
  // AM or PM
  a(t, e) {
    const n = t.getHours() / 12 >= 1 ? "pm" : "am";
    switch (e) {
      case "a":
      case "aa":
        return n.toUpperCase();
      case "aaa":
        return n;
      case "aaaaa":
        return n[0];
      case "aaaa":
      default:
        return n === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(t, e) {
    return Pt(t.getHours() % 12 || 12, e.length);
  },
  // Hour [0-23]
  H(t, e) {
    return Pt(t.getHours(), e.length);
  },
  // Minute
  m(t, e) {
    return Pt(t.getMinutes(), e.length);
  },
  // Second
  s(t, e) {
    return Pt(t.getSeconds(), e.length);
  },
  // Fraction of second
  S(t, e) {
    const n = e.length, i = t.getMilliseconds(), r = Math.trunc(
      i * Math.pow(10, n - 3)
    );
    return Pt(r, e.length);
  }
}, Ka = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, Dw = {
  // Era
  G: function(t, e, n) {
    const i = t.getFullYear() > 0 ? 1 : 0;
    switch (e) {
      case "G":
      case "GG":
      case "GGG":
        return n.era(i, { width: "abbreviated" });
      case "GGGGG":
        return n.era(i, { width: "narrow" });
      case "GGGG":
      default:
        return n.era(i, { width: "wide" });
    }
  },
  // Year
  y: function(t, e, n) {
    if (e === "yo") {
      const i = t.getFullYear(), r = i > 0 ? i : 1 - i;
      return n.ordinalNumber(r, { unit: "year" });
    }
    return Ko.y(t, e);
  },
  // Local week-numbering year
  Y: function(t, e, n, i) {
    const r = Zy(t, i), o = r > 0 ? r : 1 - r;
    if (e === "YY") {
      const s = o % 100;
      return Pt(s, 2);
    }
    return e === "Yo" ? n.ordinalNumber(o, { unit: "year" }) : Pt(o, e.length);
  },
  // ISO week-numbering year
  R: function(t, e) {
    const n = AC(t);
    return Pt(n, e.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(t, e) {
    const n = t.getFullYear();
    return Pt(n, e.length);
  },
  // Quarter
  Q: function(t, e, n) {
    const i = Math.ceil((t.getMonth() + 1) / 3);
    switch (e) {
      case "Q":
        return String(i);
      case "QQ":
        return Pt(i, 2);
      case "Qo":
        return n.ordinalNumber(i, { unit: "quarter" });
      case "QQQ":
        return n.quarter(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return n.quarter(i, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return n.quarter(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(t, e, n) {
    const i = Math.ceil((t.getMonth() + 1) / 3);
    switch (e) {
      case "q":
        return String(i);
      case "qq":
        return Pt(i, 2);
      case "qo":
        return n.ordinalNumber(i, { unit: "quarter" });
      case "qqq":
        return n.quarter(i, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return n.quarter(i, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return n.quarter(i, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(t, e, n) {
    const i = t.getMonth();
    switch (e) {
      case "M":
      case "MM":
        return Ko.M(t, e);
      case "Mo":
        return n.ordinalNumber(i + 1, { unit: "month" });
      case "MMM":
        return n.month(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return n.month(i, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return n.month(i, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(t, e, n) {
    const i = t.getMonth();
    switch (e) {
      case "L":
        return String(i + 1);
      case "LL":
        return Pt(i + 1, 2);
      case "Lo":
        return n.ordinalNumber(i + 1, { unit: "month" });
      case "LLL":
        return n.month(i, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return n.month(i, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return n.month(i, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(t, e, n, i) {
    const r = Fy(t, i);
    return e === "wo" ? n.ordinalNumber(r, { unit: "week" }) : Pt(r, e.length);
  },
  // ISO week of year
  I: function(t, e, n) {
    const i = By(t);
    return e === "Io" ? n.ordinalNumber(i, { unit: "week" }) : Pt(i, e.length);
  },
  // Day of the month
  d: function(t, e, n) {
    return e === "do" ? n.ordinalNumber(t.getDate(), { unit: "date" }) : Ko.d(t, e);
  },
  // Day of year
  D: function(t, e, n) {
    const i = ZN(t);
    return e === "Do" ? n.ordinalNumber(i, { unit: "dayOfYear" }) : Pt(i, e.length);
  },
  // Day of week
  E: function(t, e, n) {
    const i = t.getDay();
    switch (e) {
      case "E":
      case "EE":
      case "EEE":
        return n.day(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return n.day(i, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return n.day(i, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return n.day(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(t, e, n, i) {
    const r = t.getDay(), o = (r - i.weekStartsOn + 8) % 7 || 7;
    switch (e) {
      case "e":
        return String(o);
      case "ee":
        return Pt(o, 2);
      case "eo":
        return n.ordinalNumber(o, { unit: "day" });
      case "eee":
        return n.day(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return n.day(r, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return n.day(r, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return n.day(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(t, e, n, i) {
    const r = t.getDay(), o = (r - i.weekStartsOn + 8) % 7 || 7;
    switch (e) {
      case "c":
        return String(o);
      case "cc":
        return Pt(o, e.length);
      case "co":
        return n.ordinalNumber(o, { unit: "day" });
      case "ccc":
        return n.day(r, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return n.day(r, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return n.day(r, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return n.day(r, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(t, e, n) {
    const i = t.getDay(), r = i === 0 ? 7 : i;
    switch (e) {
      case "i":
        return String(r);
      case "ii":
        return Pt(r, e.length);
      case "io":
        return n.ordinalNumber(r, { unit: "day" });
      case "iii":
        return n.day(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return n.day(i, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return n.day(i, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return n.day(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(t, e, n) {
    const r = t.getHours() / 12 >= 1 ? "pm" : "am";
    switch (e) {
      case "a":
      case "aa":
        return n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return n.dayPeriod(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(t, e, n) {
    const i = t.getHours();
    let r;
    switch (i === 12 ? r = Ka.noon : i === 0 ? r = Ka.midnight : r = i / 12 >= 1 ? "pm" : "am", e) {
      case "b":
      case "bb":
        return n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return n.dayPeriod(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(t, e, n) {
    const i = t.getHours();
    let r;
    switch (i >= 17 ? r = Ka.evening : i >= 12 ? r = Ka.afternoon : i >= 4 ? r = Ka.morning : r = Ka.night, e) {
      case "B":
      case "BB":
      case "BBB":
        return n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return n.dayPeriod(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(t, e, n) {
    if (e === "ho") {
      let i = t.getHours() % 12;
      return i === 0 && (i = 12), n.ordinalNumber(i, { unit: "hour" });
    }
    return Ko.h(t, e);
  },
  // Hour [0-23]
  H: function(t, e, n) {
    return e === "Ho" ? n.ordinalNumber(t.getHours(), { unit: "hour" }) : Ko.H(t, e);
  },
  // Hour [0-11]
  K: function(t, e, n) {
    const i = t.getHours() % 12;
    return e === "Ko" ? n.ordinalNumber(i, { unit: "hour" }) : Pt(i, e.length);
  },
  // Hour [1-24]
  k: function(t, e, n) {
    let i = t.getHours();
    return i === 0 && (i = 24), e === "ko" ? n.ordinalNumber(i, { unit: "hour" }) : Pt(i, e.length);
  },
  // Minute
  m: function(t, e, n) {
    return e === "mo" ? n.ordinalNumber(t.getMinutes(), { unit: "minute" }) : Ko.m(t, e);
  },
  // Second
  s: function(t, e, n) {
    return e === "so" ? n.ordinalNumber(t.getSeconds(), { unit: "second" }) : Ko.s(t, e);
  },
  // Fraction of second
  S: function(t, e) {
    return Ko.S(t, e);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(t, e, n) {
    const i = t.getTimezoneOffset();
    if (i === 0)
      return "Z";
    switch (e) {
      case "X":
        return Nw(i);
      case "XXXX":
      case "XX":
        return na(i);
      case "XXXXX":
      case "XXX":
      default:
        return na(i, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(t, e, n) {
    const i = t.getTimezoneOffset();
    switch (e) {
      case "x":
        return Nw(i);
      case "xxxx":
      case "xx":
        return na(i);
      case "xxxxx":
      case "xxx":
      default:
        return na(i, ":");
    }
  },
  // Timezone (GMT)
  O: function(t, e, n) {
    const i = t.getTimezoneOffset();
    switch (e) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + Qw(i, ":");
      case "OOOO":
      default:
        return "GMT" + na(i, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(t, e, n) {
    const i = t.getTimezoneOffset();
    switch (e) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + Qw(i, ":");
      case "zzzz":
      default:
        return "GMT" + na(i, ":");
    }
  },
  // Seconds timestamp
  t: function(t, e, n) {
    const i = Math.trunc(+t / 1e3);
    return Pt(i, e.length);
  },
  // Milliseconds timestamp
  T: function(t, e, n) {
    return Pt(+t, e.length);
  }
};
function Qw(t, e = "") {
  const n = t > 0 ? "-" : "+", i = Math.abs(t), r = Math.trunc(i / 60), o = i % 60;
  return o === 0 ? n + String(r) : n + String(r) + e + Pt(o, 2);
}
function Nw(t, e) {
  return t % 60 === 0 ? (t > 0 ? "-" : "+") + Pt(Math.abs(t) / 60, 2) : na(t, e);
}
function na(t, e = "") {
  const n = t > 0 ? "-" : "+", i = Math.abs(t), r = Pt(Math.trunc(i / 60), 2), o = Pt(i % 60, 2);
  return n + r + e + o;
}
const Iw = (t, e) => {
  switch (t) {
    case "P":
      return e.date({ width: "short" });
    case "PP":
      return e.date({ width: "medium" });
    case "PPP":
      return e.date({ width: "long" });
    case "PPPP":
    default:
      return e.date({ width: "full" });
  }
}, BC = (t, e) => {
  switch (t) {
    case "p":
      return e.time({ width: "short" });
    case "pp":
      return e.time({ width: "medium" });
    case "ppp":
      return e.time({ width: "long" });
    case "pppp":
    default:
      return e.time({ width: "full" });
  }
}, qN = (t, e) => {
  const n = t.match(/(P+)(p+)?/) || [], i = n[1], r = n[2];
  if (!r)
    return Iw(t, e);
  let o;
  switch (i) {
    case "P":
      o = e.dateTime({ width: "short" });
      break;
    case "PP":
      o = e.dateTime({ width: "medium" });
      break;
    case "PPP":
      o = e.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      o = e.dateTime({ width: "full" });
      break;
  }
  return o.replace("{{date}}", Iw(i, e)).replace("{{time}}", BC(r, e));
}, TO = {
  p: BC,
  P: qN
}, WN = /^D+$/, XN = /^Y+$/, zN = ["D", "DD", "YY", "YYYY"];
function ZC(t) {
  return WN.test(t);
}
function FC(t) {
  return XN.test(t);
}
function $O(t, e, n) {
  const i = jN(t, e, n);
  if (console.warn(i), zN.includes(t))
    throw new RangeError(i);
}
function jN(t, e, n) {
  const i = t[0] === "Y" ? "years" : "days of the month";
  return `Use \`${t.toLowerCase()}\` instead of \`${t}\` (in \`${e}\`) for formatting ${i} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const YN = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, HN = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, UN = /^'([^]*?)'?$/, GN = /''/g, KN = /[a-zA-Z]/;
function no(t, e, n) {
  var c, d, h, f, p, m, g, O;
  const i = Xa(), r = (n == null ? void 0 : n.locale) ?? i.locale ?? VC, o = (n == null ? void 0 : n.firstWeekContainsDate) ?? ((d = (c = n == null ? void 0 : n.locale) == null ? void 0 : c.options) == null ? void 0 : d.firstWeekContainsDate) ?? i.firstWeekContainsDate ?? ((f = (h = i.locale) == null ? void 0 : h.options) == null ? void 0 : f.firstWeekContainsDate) ?? 1, s = (n == null ? void 0 : n.weekStartsOn) ?? ((m = (p = n == null ? void 0 : n.locale) == null ? void 0 : p.options) == null ? void 0 : m.weekStartsOn) ?? i.weekStartsOn ?? ((O = (g = i.locale) == null ? void 0 : g.options) == null ? void 0 : O.weekStartsOn) ?? 0, a = et(t, n == null ? void 0 : n.in);
  if (!ac(a))
    throw new RangeError("Invalid time value");
  let l = e.match(HN).map((y) => {
    const b = y[0];
    if (b === "p" || b === "P") {
      const v = TO[b];
      return v(y, r.formatLong);
    }
    return y;
  }).join("").match(YN).map((y) => {
    if (y === "''")
      return { isToken: !1, value: "'" };
    const b = y[0];
    if (b === "'")
      return { isToken: !1, value: JN(y) };
    if (Dw[b])
      return { isToken: !0, value: y };
    if (b.match(KN))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + b + "`"
      );
    return { isToken: !1, value: y };
  });
  r.localize.preprocessor && (l = r.localize.preprocessor(a, l));
  const u = {
    firstWeekContainsDate: o,
    weekStartsOn: s,
    locale: r
  };
  return l.map((y) => {
    if (!y.isToken)
      return y.value;
    const b = y.value;
    (!(n != null && n.useAdditionalWeekYearTokens) && FC(b) || !(n != null && n.useAdditionalDayOfYearTokens) && ZC(b)) && $O(b, e, String(t));
    const v = Dw[b[0]];
    return v(a, b, r.localize, u);
  }).join("");
}
function JN(t) {
  const e = t.match(UN);
  return e ? e[1].replace(GN, "'") : t;
}
function eI(t, e) {
  return et(t, e == null ? void 0 : e.in).getDay();
}
function tI(t, e) {
  const n = et(t, e == null ? void 0 : e.in), i = n.getFullYear(), r = n.getMonth(), o = Mt(n, 0);
  return o.setFullYear(i, r + 1, 0), o.setHours(0, 0, 0, 0), o.getDate();
}
function nI() {
  return Object.assign({}, Xa());
}
function Lo(t, e) {
  return et(t, e == null ? void 0 : e.in).getHours();
}
function iI(t, e) {
  const n = et(t, e == null ? void 0 : e.in).getDay();
  return n === 0 ? 7 : n;
}
function Es(t, e) {
  return et(t, e == null ? void 0 : e.in).getMinutes();
}
function ft(t, e) {
  return et(t, e == null ? void 0 : e.in).getMonth();
}
function Ql(t) {
  return et(t).getSeconds();
}
function rt(t, e) {
  return et(t, e == null ? void 0 : e.in).getFullYear();
}
function Nl(t, e) {
  return +et(t) > +et(e);
}
function Dc(t, e) {
  return +et(t) < +et(e);
}
function ml(t, e) {
  return +et(t) == +et(e);
}
function rI(t, e) {
  const n = oI(e) ? new e(0) : Mt(e, 0);
  return n.setFullYear(t.getFullYear(), t.getMonth(), t.getDate()), n.setHours(
    t.getHours(),
    t.getMinutes(),
    t.getSeconds(),
    t.getMilliseconds()
  ), n;
}
function oI(t) {
  var e;
  return typeof t == "function" && ((e = t.prototype) == null ? void 0 : e.constructor) === t;
}
const sI = 10;
class qC {
  constructor() {
    De(this, "subPriority", 0);
  }
  validate(e, n) {
    return !0;
  }
}
class aI extends qC {
  constructor(e, n, i, r, o) {
    super(), this.value = e, this.validateValue = n, this.setValue = i, this.priority = r, o && (this.subPriority = o);
  }
  validate(e, n) {
    return this.validateValue(e, this.value, n);
  }
  set(e, n, i) {
    return this.setValue(e, n, this.value, i);
  }
}
class lI extends qC {
  constructor(n, i) {
    super();
    De(this, "priority", sI);
    De(this, "subPriority", -1);
    this.context = n || ((r) => Mt(i, r));
  }
  set(n, i) {
    return i.timestampIsSet ? n : Mt(n, rI(n, this.context));
  }
}
let xt = class {
  run(e, n, i, r) {
    const o = this.parse(e, n, i, r);
    return o ? {
      setter: new aI(
        o.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: o.rest
    } : null;
  }
  validate(e, n, i) {
    return !0;
  }
};
class uI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 140);
    De(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(n, i, r) {
    switch (i) {
      case "G":
      case "GG":
      case "GGG":
        return r.era(n, { width: "abbreviated" }) || r.era(n, { width: "narrow" });
      case "GGGGG":
        return r.era(n, { width: "narrow" });
      case "GGGG":
      default:
        return r.era(n, { width: "wide" }) || r.era(n, { width: "abbreviated" }) || r.era(n, { width: "narrow" });
    }
  }
  set(n, i, r) {
    return i.era = r, n.setFullYear(r, 0, 1), n.setHours(0, 0, 0, 0), n;
  }
}
const On = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
}, qr = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function vn(t, e) {
  return t && {
    value: e(t.value),
    rest: t.rest
  };
}
function en(t, e) {
  const n = e.match(t);
  return n ? {
    value: parseInt(n[0], 10),
    rest: e.slice(n[0].length)
  } : null;
}
function Wr(t, e) {
  const n = e.match(t);
  if (!n)
    return null;
  if (n[0] === "Z")
    return {
      value: 0,
      rest: e.slice(1)
    };
  const i = n[1] === "+" ? 1 : -1, r = n[2] ? parseInt(n[2], 10) : 0, o = n[3] ? parseInt(n[3], 10) : 0, s = n[5] ? parseInt(n[5], 10) : 0;
  return {
    value: i * (r * MC + o * K2 + s * J2),
    rest: e.slice(n[0].length)
  };
}
function WC(t) {
  return en(On.anyDigitsSigned, t);
}
function cn(t, e) {
  switch (t) {
    case 1:
      return en(On.singleDigit, e);
    case 2:
      return en(On.twoDigits, e);
    case 3:
      return en(On.threeDigits, e);
    case 4:
      return en(On.fourDigits, e);
    default:
      return en(new RegExp("^\\d{1," + t + "}"), e);
  }
}
function lf(t, e) {
  switch (t) {
    case 1:
      return en(On.singleDigitSigned, e);
    case 2:
      return en(On.twoDigitsSigned, e);
    case 3:
      return en(On.threeDigitsSigned, e);
    case 4:
      return en(On.fourDigitsSigned, e);
    default:
      return en(new RegExp("^-?\\d{1," + t + "}"), e);
  }
}
function qy(t) {
  switch (t) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function XC(t, e) {
  const n = e > 0, i = n ? e : 1 - e;
  let r;
  if (i <= 50)
    r = t || 100;
  else {
    const o = i + 50, s = Math.trunc(o / 100) * 100, a = t >= o % 100;
    r = t + s - (a ? 100 : 0);
  }
  return n ? r : 1 - r;
}
function zC(t) {
  return t % 400 === 0 || t % 4 === 0 && t % 100 !== 0;
}
class cI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 130);
    De(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(n, i, r) {
    const o = (s) => ({
      year: s,
      isTwoDigitYear: i === "yy"
    });
    switch (i) {
      case "y":
        return vn(cn(4, n), o);
      case "yo":
        return vn(
          r.ordinalNumber(n, {
            unit: "year"
          }),
          o
        );
      default:
        return vn(cn(i.length, n), o);
    }
  }
  validate(n, i) {
    return i.isTwoDigitYear || i.year > 0;
  }
  set(n, i, r) {
    const o = n.getFullYear();
    if (r.isTwoDigitYear) {
      const a = XC(
        r.year,
        o
      );
      return n.setFullYear(a, 0, 1), n.setHours(0, 0, 0, 0), n;
    }
    const s = !("era" in i) || i.era === 1 ? r.year : 1 - r.year;
    return n.setFullYear(s, 0, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class dI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 130);
    De(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(n, i, r) {
    const o = (s) => ({
      year: s,
      isTwoDigitYear: i === "YY"
    });
    switch (i) {
      case "Y":
        return vn(cn(4, n), o);
      case "Yo":
        return vn(
          r.ordinalNumber(n, {
            unit: "year"
          }),
          o
        );
      default:
        return vn(cn(i.length, n), o);
    }
  }
  validate(n, i) {
    return i.isTwoDigitYear || i.year > 0;
  }
  set(n, i, r, o) {
    const s = Zy(n, o);
    if (r.isTwoDigitYear) {
      const l = XC(
        r.year,
        s
      );
      return n.setFullYear(
        l,
        0,
        o.firstWeekContainsDate
      ), n.setHours(0, 0, 0, 0), kr(n, o);
    }
    const a = !("era" in i) || i.era === 1 ? r.year : 1 - r.year;
    return n.setFullYear(a, 0, o.firstWeekContainsDate), n.setHours(0, 0, 0, 0), kr(n, o);
  }
}
class hI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 130);
    De(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, i) {
    return lf(i === "R" ? 4 : i.length, n);
  }
  set(n, i, r) {
    const o = Mt(n, 0);
    return o.setFullYear(r, 0, 4), o.setHours(0, 0, 0, 0), Dl(o);
  }
}
class fI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 130);
    De(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(n, i) {
    return lf(i === "u" ? 4 : i.length, n);
  }
  set(n, i, r) {
    return n.setFullYear(r, 0, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class pI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 120);
    De(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, i, r) {
    switch (i) {
      case "Q":
      case "QQ":
        return cn(i.length, n);
      case "Qo":
        return r.ordinalNumber(n, { unit: "quarter" });
      case "QQQ":
        return r.quarter(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return r.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return r.quarter(n, {
          width: "wide",
          context: "formatting"
        }) || r.quarter(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(n, i) {
    return i >= 1 && i <= 4;
  }
  set(n, i, r) {
    return n.setMonth((r - 1) * 3, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class mI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 120);
    De(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, i, r) {
    switch (i) {
      case "q":
      case "qq":
        return cn(i.length, n);
      case "qo":
        return r.ordinalNumber(n, { unit: "quarter" });
      case "qqq":
        return r.quarter(n, {
          width: "abbreviated",
          context: "standalone"
        }) || r.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return r.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return r.quarter(n, {
          width: "wide",
          context: "standalone"
        }) || r.quarter(n, {
          width: "abbreviated",
          context: "standalone"
        }) || r.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(n, i) {
    return i >= 1 && i <= 4;
  }
  set(n, i, r) {
    return n.setMonth((r - 1) * 3, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class gI extends xt {
  constructor() {
    super(...arguments);
    De(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    De(this, "priority", 110);
  }
  parse(n, i, r) {
    const o = (s) => s - 1;
    switch (i) {
      case "M":
        return vn(
          en(On.month, n),
          o
        );
      case "MM":
        return vn(cn(2, n), o);
      case "Mo":
        return vn(
          r.ordinalNumber(n, {
            unit: "month"
          }),
          o
        );
      case "MMM":
        return r.month(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.month(n, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return r.month(n, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return r.month(n, { width: "wide", context: "formatting" }) || r.month(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.month(n, { width: "narrow", context: "formatting" });
    }
  }
  validate(n, i) {
    return i >= 0 && i <= 11;
  }
  set(n, i, r) {
    return n.setMonth(r, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class OI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 110);
    De(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, i, r) {
    const o = (s) => s - 1;
    switch (i) {
      case "L":
        return vn(
          en(On.month, n),
          o
        );
      case "LL":
        return vn(cn(2, n), o);
      case "Lo":
        return vn(
          r.ordinalNumber(n, {
            unit: "month"
          }),
          o
        );
      case "LLL":
        return r.month(n, {
          width: "abbreviated",
          context: "standalone"
        }) || r.month(n, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return r.month(n, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return r.month(n, { width: "wide", context: "standalone" }) || r.month(n, {
          width: "abbreviated",
          context: "standalone"
        }) || r.month(n, { width: "narrow", context: "standalone" });
    }
  }
  validate(n, i) {
    return i >= 0 && i <= 11;
  }
  set(n, i, r) {
    return n.setMonth(r, 1), n.setHours(0, 0, 0, 0), n;
  }
}
function vI(t, e, n) {
  const i = et(t, n == null ? void 0 : n.in), r = Fy(i, n) - e;
  return i.setDate(i.getDate() - r * 7), et(i, n == null ? void 0 : n.in);
}
class yI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 100);
    De(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(n, i, r) {
    switch (i) {
      case "w":
        return en(On.week, n);
      case "wo":
        return r.ordinalNumber(n, { unit: "week" });
      default:
        return cn(i.length, n);
    }
  }
  validate(n, i) {
    return i >= 1 && i <= 53;
  }
  set(n, i, r, o) {
    return kr(vI(n, r, o), o);
  }
}
function bI(t, e, n) {
  const i = et(t, n == null ? void 0 : n.in), r = By(i, n) - e;
  return i.setDate(i.getDate() - r * 7), i;
}
class wI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 100);
    De(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, i, r) {
    switch (i) {
      case "I":
        return en(On.week, n);
      case "Io":
        return r.ordinalNumber(n, { unit: "week" });
      default:
        return cn(i.length, n);
    }
  }
  validate(n, i) {
    return i >= 1 && i <= 53;
  }
  set(n, i, r) {
    return Dl(bI(n, r));
  }
}
const kI = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], SI = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
class _I extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 90);
    De(this, "subPriority", 1);
    De(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, i, r) {
    switch (i) {
      case "d":
        return en(On.date, n);
      case "do":
        return r.ordinalNumber(n, { unit: "date" });
      default:
        return cn(i.length, n);
    }
  }
  validate(n, i) {
    const r = n.getFullYear(), o = zC(r), s = n.getMonth();
    return o ? i >= 1 && i <= SI[s] : i >= 1 && i <= kI[s];
  }
  set(n, i, r) {
    return n.setDate(r), n.setHours(0, 0, 0, 0), n;
  }
}
class xI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 90);
    De(this, "subpriority", 1);
    De(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, i, r) {
    switch (i) {
      case "D":
      case "DD":
        return en(On.dayOfYear, n);
      case "Do":
        return r.ordinalNumber(n, { unit: "date" });
      default:
        return cn(i.length, n);
    }
  }
  validate(n, i) {
    const r = n.getFullYear();
    return zC(r) ? i >= 1 && i <= 366 : i >= 1 && i <= 365;
  }
  set(n, i, r) {
    return n.setMonth(0, r), n.setHours(0, 0, 0, 0), n;
  }
}
function Wy(t, e, n) {
  var d, h, f, p;
  const i = Xa(), r = (n == null ? void 0 : n.weekStartsOn) ?? ((h = (d = n == null ? void 0 : n.locale) == null ? void 0 : d.options) == null ? void 0 : h.weekStartsOn) ?? i.weekStartsOn ?? ((p = (f = i.locale) == null ? void 0 : f.options) == null ? void 0 : p.weekStartsOn) ?? 0, o = et(t, n == null ? void 0 : n.in), s = o.getDay(), l = (e % 7 + 7) % 7, u = 7 - r, c = e < 0 || e > 6 ? e - (s + u) % 7 : (l + u) % 7 - (s + u) % 7;
  return mr(o, c, n);
}
class CI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 90);
    De(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(n, i, r) {
    switch (i) {
      case "E":
      case "EE":
      case "EEE":
        return r.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.day(n, { width: "short", context: "formatting" }) || r.day(n, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return r.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return r.day(n, { width: "short", context: "formatting" }) || r.day(n, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return r.day(n, { width: "wide", context: "formatting" }) || r.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.day(n, { width: "short", context: "formatting" }) || r.day(n, { width: "narrow", context: "formatting" });
    }
  }
  validate(n, i) {
    return i >= 0 && i <= 6;
  }
  set(n, i, r, o) {
    return n = Wy(n, r, o), n.setHours(0, 0, 0, 0), n;
  }
}
class TI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 90);
    De(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, i, r, o) {
    const s = (a) => {
      const l = Math.floor((a - 1) / 7) * 7;
      return (a + o.weekStartsOn + 6) % 7 + l;
    };
    switch (i) {
      case "e":
      case "ee":
        return vn(cn(i.length, n), s);
      case "eo":
        return vn(
          r.ordinalNumber(n, {
            unit: "day"
          }),
          s
        );
      case "eee":
        return r.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.day(n, { width: "short", context: "formatting" }) || r.day(n, { width: "narrow", context: "formatting" });
      case "eeeee":
        return r.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return r.day(n, { width: "short", context: "formatting" }) || r.day(n, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return r.day(n, { width: "wide", context: "formatting" }) || r.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.day(n, { width: "short", context: "formatting" }) || r.day(n, { width: "narrow", context: "formatting" });
    }
  }
  validate(n, i) {
    return i >= 0 && i <= 6;
  }
  set(n, i, r, o) {
    return n = Wy(n, r, o), n.setHours(0, 0, 0, 0), n;
  }
}
class $I extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 90);
    De(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(n, i, r, o) {
    const s = (a) => {
      const l = Math.floor((a - 1) / 7) * 7;
      return (a + o.weekStartsOn + 6) % 7 + l;
    };
    switch (i) {
      case "c":
      case "cc":
        return vn(cn(i.length, n), s);
      case "co":
        return vn(
          r.ordinalNumber(n, {
            unit: "day"
          }),
          s
        );
      case "ccc":
        return r.day(n, {
          width: "abbreviated",
          context: "standalone"
        }) || r.day(n, { width: "short", context: "standalone" }) || r.day(n, { width: "narrow", context: "standalone" });
      case "ccccc":
        return r.day(n, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return r.day(n, { width: "short", context: "standalone" }) || r.day(n, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return r.day(n, { width: "wide", context: "standalone" }) || r.day(n, {
          width: "abbreviated",
          context: "standalone"
        }) || r.day(n, { width: "short", context: "standalone" }) || r.day(n, { width: "narrow", context: "standalone" });
    }
  }
  validate(n, i) {
    return i >= 0 && i <= 6;
  }
  set(n, i, r, o) {
    return n = Wy(n, r, o), n.setHours(0, 0, 0, 0), n;
  }
}
function PI(t, e, n) {
  const i = et(t, n == null ? void 0 : n.in), r = iI(i, n), o = e - r;
  return mr(i, o, n);
}
class MI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 90);
    De(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, i, r) {
    const o = (s) => s === 0 ? 7 : s;
    switch (i) {
      case "i":
      case "ii":
        return cn(i.length, n);
      case "io":
        return r.ordinalNumber(n, { unit: "day" });
      case "iii":
        return vn(
          r.day(n, {
            width: "abbreviated",
            context: "formatting"
          }) || r.day(n, {
            width: "short",
            context: "formatting"
          }) || r.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          o
        );
      case "iiiii":
        return vn(
          r.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          o
        );
      case "iiiiii":
        return vn(
          r.day(n, {
            width: "short",
            context: "formatting"
          }) || r.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          o
        );
      case "iiii":
      default:
        return vn(
          r.day(n, {
            width: "wide",
            context: "formatting"
          }) || r.day(n, {
            width: "abbreviated",
            context: "formatting"
          }) || r.day(n, {
            width: "short",
            context: "formatting"
          }) || r.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          o
        );
    }
  }
  validate(n, i) {
    return i >= 1 && i <= 7;
  }
  set(n, i, r) {
    return n = PI(n, r), n.setHours(0, 0, 0, 0), n;
  }
}
class EI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 80);
    De(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(n, i, r) {
    switch (i) {
      case "a":
      case "aa":
      case "aaa":
        return r.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return r.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return r.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || r.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(n, i, r) {
    return n.setHours(qy(r), 0, 0, 0), n;
  }
}
class AI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 80);
    De(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(n, i, r) {
    switch (i) {
      case "b":
      case "bb":
      case "bbb":
        return r.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return r.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return r.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || r.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(n, i, r) {
    return n.setHours(qy(r), 0, 0, 0), n;
  }
}
class RI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 80);
    De(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(n, i, r) {
    switch (i) {
      case "B":
      case "BB":
      case "BBB":
        return r.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return r.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return r.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || r.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || r.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(n, i, r) {
    return n.setHours(qy(r), 0, 0, 0), n;
  }
}
class DI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 70);
    De(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(n, i, r) {
    switch (i) {
      case "h":
        return en(On.hour12h, n);
      case "ho":
        return r.ordinalNumber(n, { unit: "hour" });
      default:
        return cn(i.length, n);
    }
  }
  validate(n, i) {
    return i >= 1 && i <= 12;
  }
  set(n, i, r) {
    const o = n.getHours() >= 12;
    return o && r < 12 ? n.setHours(r + 12, 0, 0, 0) : !o && r === 12 ? n.setHours(0, 0, 0, 0) : n.setHours(r, 0, 0, 0), n;
  }
}
class QI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 70);
    De(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(n, i, r) {
    switch (i) {
      case "H":
        return en(On.hour23h, n);
      case "Ho":
        return r.ordinalNumber(n, { unit: "hour" });
      default:
        return cn(i.length, n);
    }
  }
  validate(n, i) {
    return i >= 0 && i <= 23;
  }
  set(n, i, r) {
    return n.setHours(r, 0, 0, 0), n;
  }
}
class NI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 70);
    De(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(n, i, r) {
    switch (i) {
      case "K":
        return en(On.hour11h, n);
      case "Ko":
        return r.ordinalNumber(n, { unit: "hour" });
      default:
        return cn(i.length, n);
    }
  }
  validate(n, i) {
    return i >= 0 && i <= 11;
  }
  set(n, i, r) {
    return n.getHours() >= 12 && r < 12 ? n.setHours(r + 12, 0, 0, 0) : n.setHours(r, 0, 0, 0), n;
  }
}
class II extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 70);
    De(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(n, i, r) {
    switch (i) {
      case "k":
        return en(On.hour24h, n);
      case "ko":
        return r.ordinalNumber(n, { unit: "hour" });
      default:
        return cn(i.length, n);
    }
  }
  validate(n, i) {
    return i >= 1 && i <= 24;
  }
  set(n, i, r) {
    const o = r <= 24 ? r % 24 : r;
    return n.setHours(o, 0, 0, 0), n;
  }
}
class LI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 60);
    De(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(n, i, r) {
    switch (i) {
      case "m":
        return en(On.minute, n);
      case "mo":
        return r.ordinalNumber(n, { unit: "minute" });
      default:
        return cn(i.length, n);
    }
  }
  validate(n, i) {
    return i >= 0 && i <= 59;
  }
  set(n, i, r) {
    return n.setMinutes(r, 0, 0), n;
  }
}
class VI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 50);
    De(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(n, i, r) {
    switch (i) {
      case "s":
        return en(On.second, n);
      case "so":
        return r.ordinalNumber(n, { unit: "second" });
      default:
        return cn(i.length, n);
    }
  }
  validate(n, i) {
    return i >= 0 && i <= 59;
  }
  set(n, i, r) {
    return n.setSeconds(r, 0), n;
  }
}
class BI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 30);
    De(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(n, i) {
    const r = (o) => Math.trunc(o * Math.pow(10, -i.length + 3));
    return vn(cn(i.length, n), r);
  }
  set(n, i, r) {
    return n.setMilliseconds(r), n;
  }
}
class ZI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 10);
    De(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(n, i) {
    switch (i) {
      case "X":
        return Wr(
          qr.basicOptionalMinutes,
          n
        );
      case "XX":
        return Wr(qr.basic, n);
      case "XXXX":
        return Wr(
          qr.basicOptionalSeconds,
          n
        );
      case "XXXXX":
        return Wr(
          qr.extendedOptionalSeconds,
          n
        );
      case "XXX":
      default:
        return Wr(qr.extended, n);
    }
  }
  set(n, i, r) {
    return i.timestampIsSet ? n : Mt(
      n,
      n.getTime() - af(n) - r
    );
  }
}
class FI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 10);
    De(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(n, i) {
    switch (i) {
      case "x":
        return Wr(
          qr.basicOptionalMinutes,
          n
        );
      case "xx":
        return Wr(qr.basic, n);
      case "xxxx":
        return Wr(
          qr.basicOptionalSeconds,
          n
        );
      case "xxxxx":
        return Wr(
          qr.extendedOptionalSeconds,
          n
        );
      case "xxx":
      default:
        return Wr(qr.extended, n);
    }
  }
  set(n, i, r) {
    return i.timestampIsSet ? n : Mt(
      n,
      n.getTime() - af(n) - r
    );
  }
}
class qI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 40);
    De(this, "incompatibleTokens", "*");
  }
  parse(n) {
    return WC(n);
  }
  set(n, i, r) {
    return [Mt(n, r * 1e3), { timestampIsSet: !0 }];
  }
}
class WI extends xt {
  constructor() {
    super(...arguments);
    De(this, "priority", 20);
    De(this, "incompatibleTokens", "*");
  }
  parse(n) {
    return WC(n);
  }
  set(n, i, r) {
    return [Mt(n, r), { timestampIsSet: !0 }];
  }
}
const XI = {
  G: new uI(),
  y: new cI(),
  Y: new dI(),
  R: new hI(),
  u: new fI(),
  Q: new pI(),
  q: new mI(),
  M: new gI(),
  L: new OI(),
  w: new yI(),
  I: new wI(),
  d: new _I(),
  D: new xI(),
  E: new CI(),
  e: new TI(),
  c: new $I(),
  i: new MI(),
  a: new EI(),
  b: new AI(),
  B: new RI(),
  h: new DI(),
  H: new QI(),
  K: new NI(),
  k: new II(),
  m: new LI(),
  s: new VI(),
  S: new BI(),
  X: new ZI(),
  x: new FI(),
  t: new qI(),
  T: new WI()
}, zI = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, jI = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, YI = /^'([^]*?)'?$/, HI = /''/g, UI = /\S/, GI = /[a-zA-Z]/;
function PO(t, e, n, i) {
  var g, O, y, b, v, k, w, S;
  const r = () => Mt((i == null ? void 0 : i.in) || n, NaN), o = nI(), s = (i == null ? void 0 : i.locale) ?? o.locale ?? VC, a = (i == null ? void 0 : i.firstWeekContainsDate) ?? ((O = (g = i == null ? void 0 : i.locale) == null ? void 0 : g.options) == null ? void 0 : O.firstWeekContainsDate) ?? o.firstWeekContainsDate ?? ((b = (y = o.locale) == null ? void 0 : y.options) == null ? void 0 : b.firstWeekContainsDate) ?? 1, l = (i == null ? void 0 : i.weekStartsOn) ?? ((k = (v = i == null ? void 0 : i.locale) == null ? void 0 : v.options) == null ? void 0 : k.weekStartsOn) ?? o.weekStartsOn ?? ((S = (w = o.locale) == null ? void 0 : w.options) == null ? void 0 : S.weekStartsOn) ?? 0;
  if (!e)
    return t ? r() : et(n, i == null ? void 0 : i.in);
  const u = {
    firstWeekContainsDate: a,
    weekStartsOn: l,
    locale: s
  }, c = [new lI(i == null ? void 0 : i.in, n)], d = e.match(jI).map(($) => {
    const C = $[0];
    if (C in TO) {
      const L = TO[C];
      return L($, s.formatLong);
    }
    return $;
  }).join("").match(zI), h = [];
  for (let $ of d) {
    !(i != null && i.useAdditionalWeekYearTokens) && FC($) && $O($, e, t), !(i != null && i.useAdditionalDayOfYearTokens) && ZC($) && $O($, e, t);
    const C = $[0], L = XI[C];
    if (L) {
      const { incompatibleTokens: j } = L;
      if (Array.isArray(j)) {
        const A = h.find(
          (T) => j.includes(T.token) || T.token === C
        );
        if (A)
          throw new RangeError(
            `The format string mustn't contain \`${A.fullToken}\` and \`${$}\` at the same time`
          );
      } else if (L.incompatibleTokens === "*" && h.length > 0)
        throw new RangeError(
          `The format string mustn't contain \`${$}\` and any other token at the same time`
        );
      h.push({ token: C, fullToken: $ });
      const P = L.run(
        t,
        $,
        s.match,
        u
      );
      if (!P)
        return r();
      c.push(P.setter), t = P.rest;
    } else {
      if (C.match(GI))
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + C + "`"
        );
      if ($ === "''" ? $ = "'" : C === "'" && ($ = KI($)), t.indexOf($) === 0)
        t = t.slice($.length);
      else
        return r();
    }
  }
  if (t.length > 0 && UI.test(t))
    return r();
  const f = c.map(($) => $.priority).sort(($, C) => C - $).filter(($, C, L) => L.indexOf($) === C).map(
    ($) => c.filter((C) => C.priority === $).sort((C, L) => L.subPriority - C.subPriority)
  ).map(($) => $[0]);
  let p = et(n, i == null ? void 0 : i.in);
  if (isNaN(+p))
    return r();
  const m = {};
  for (const $ of f) {
    if (!$.validate(p, u))
      return r();
    const C = $.set(p, m, u);
    Array.isArray(C) ? (p = C[0], Object.assign(m, C[1])) : p = C;
  }
  return p;
}
function KI(t) {
  return t.match(YI)[1].replace(HI, "'");
}
function Lw(t, e, n) {
  const [i, r] = yd(
    n == null ? void 0 : n.in,
    t,
    e
  );
  return +ca(i) == +ca(r);
}
function JI(t, e, n) {
  return mr(t, -e, n);
}
function jC(t, e, n) {
  const i = et(t, n == null ? void 0 : n.in), r = i.getFullYear(), o = i.getDate(), s = Mt((n == null ? void 0 : n.in) || t, 0);
  s.setFullYear(r, e, 15), s.setHours(0, 0, 0, 0);
  const a = tI(s);
  return i.setMonth(e, Math.min(o, a)), i;
}
function Qt(t, e, n) {
  let i = et(t, n == null ? void 0 : n.in);
  return isNaN(+i) ? Mt((n == null ? void 0 : n.in) || t, NaN) : (e.year != null && i.setFullYear(e.year), e.month != null && (i = jC(i, e.month)), e.date != null && i.setDate(e.date), e.hours != null && i.setHours(e.hours), e.minutes != null && i.setMinutes(e.minutes), e.seconds != null && i.setSeconds(e.seconds), e.milliseconds != null && i.setMilliseconds(e.milliseconds), i);
}
function eL(t, e, n) {
  const i = et(t, n == null ? void 0 : n.in);
  return i.setHours(e), i;
}
function YC(t, e, n) {
  const i = et(t, n == null ? void 0 : n.in);
  return i.setMilliseconds(e), i;
}
function tL(t, e, n) {
  const i = et(t, n == null ? void 0 : n.in);
  return i.setMinutes(e), i;
}
function HC(t, e, n) {
  const i = et(t, n == null ? void 0 : n.in);
  return i.setSeconds(e), i;
}
function Hr(t, e, n) {
  const i = et(t, n == null ? void 0 : n.in);
  return isNaN(+i) ? Mt((n == null ? void 0 : n.in) || t, NaN) : (i.setFullYear(e), i);
}
function Il(t, e, n) {
  return br(t, -e, n);
}
function nL(t, e, n) {
  const {
    years: i = 0,
    months: r = 0,
    weeks: o = 0,
    days: s = 0,
    hours: a = 0,
    minutes: l = 0,
    seconds: u = 0
  } = e, c = Il(t, r + i * 12, n), d = JI(c, s + o * 7, n), h = l + a * 60, p = (u + h * 60) * 1e3;
  return Mt((n == null ? void 0 : n.in) || t, +d - p);
}
function UC(t, e, n) {
  return Vy(t, -e, n);
}
function mu() {
  const t = zx();
  return _(), Z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img",
      ...t
    },
    [
      X("path", {
        d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
      }),
      X("path", {
        d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      X("path", {
        d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      X("path", {
        d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
      })
    ]
  );
}
mu.compatConfig = {
  MODE: 3
};
function GC() {
  return _(), Z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      X("path", {
        d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
      }),
      X("path", {
        d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
GC.compatConfig = {
  MODE: 3
};
function Xy() {
  return _(), Z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      X("path", {
        d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Xy.compatConfig = {
  MODE: 3
};
function zy() {
  return _(), Z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      X("path", {
        d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
      })
    ]
  );
}
zy.compatConfig = {
  MODE: 3
};
function jy() {
  return _(), Z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      X("path", {
        d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
      }),
      X("path", {
        d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      })
    ]
  );
}
jy.compatConfig = {
  MODE: 3
};
function Yy() {
  return _(), Z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      X("path", {
        d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Yy.compatConfig = {
  MODE: 3
};
function Hy() {
  return _(), Z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      X("path", {
        d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Hy.compatConfig = {
  MODE: 3
};
const xi = (t, e) => e ? new Date(t.toLocaleString("en-US", { timeZone: e })) : new Date(t), Uy = (t, e, n) => MO(t, e, n) || _e(), iL = (t, e, n) => {
  const i = e.dateInTz ? xi(new Date(t), e.dateInTz) : _e(t);
  return n ? ci(i, !0) : i;
}, MO = (t, e, n) => {
  if (!t)
    return null;
  const i = n ? ci(_e(t), !0) : _e(t);
  return e ? e.exactMatch ? iL(t, e, n) : xi(i, e.timezone) : i;
}, rL = (t, e) => {
  if (!t)
    return 0;
  const n = /* @__PURE__ */ new Date(), i = new Date(n.toLocaleString("en-US", { timeZone: "UTC" })), r = new Date(n.toLocaleString("en-US", { timeZone: t })), o = (e ?? r).getTimezoneOffset() / 60;
  return (+i - +r) / (1e3 * 60 * 60) - o;
};
var hr = /* @__PURE__ */ ((t) => (t.month = "month", t.year = "year", t))(hr || {}), fr = /* @__PURE__ */ ((t) => (t.top = "top", t.bottom = "bottom", t))(fr || {}), ga = /* @__PURE__ */ ((t) => (t.header = "header", t.calendar = "calendar", t.timePicker = "timePicker", t))(ga || {}), Xn = /* @__PURE__ */ ((t) => (t.month = "month", t.year = "year", t.calendar = "calendar", t.time = "time", t.minutes = "minutes", t.hours = "hours", t.seconds = "seconds", t))(Xn || {});
const oL = ["timestamp", "date", "iso"];
var ni = /* @__PURE__ */ ((t) => (t.up = "up", t.down = "down", t.left = "left", t.right = "right", t))(ni || {}), Wt = /* @__PURE__ */ ((t) => (t.arrowUp = "ArrowUp", t.arrowDown = "ArrowDown", t.arrowLeft = "ArrowLeft", t.arrowRight = "ArrowRight", t.enter = "Enter", t.space = " ", t.esc = "Escape", t.tab = "Tab", t.home = "Home", t.end = "End", t.pageUp = "PageUp", t.pageDown = "PageDown", t))(Wt || {});
function Vw(t) {
  return (e) => new Intl.DateTimeFormat(t, { weekday: "short", timeZone: "UTC" }).format(/* @__PURE__ */ new Date(`2017-01-0${e}T00:00:00+00:00`)).slice(0, 2);
}
function sL(t) {
  return (e) => no(xi(/* @__PURE__ */ new Date(`2017-01-0${e}T00:00:00+00:00`), "UTC"), "EEEEEE", { locale: t });
}
const aL = (t, e, n) => {
  const i = [1, 2, 3, 4, 5, 6, 7];
  let r;
  if (t !== null)
    try {
      r = i.map(sL(t));
    } catch {
      r = i.map(Vw(e));
    }
  else
    r = i.map(Vw(e));
  const o = r.slice(0, n), s = r.slice(n + 1, r.length);
  return [r[n]].concat(...s).concat(...o);
}, Gy = (t, e, n) => {
  const i = [];
  for (let r = +t[0]; r <= +t[1]; r++)
    i.push({ value: +r, text: tT(r, e) });
  return n ? i.reverse() : i;
}, KC = (t, e, n) => {
  const i = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((o) => {
    const s = o < 10 ? `0${o}` : o;
    return /* @__PURE__ */ new Date(`2017-${s}-01T00:00:00+00:00`);
  });
  if (t !== null)
    try {
      const o = n === "long" ? "LLLL" : "LLL";
      return i.map((s, a) => {
        const l = no(xi(s, "UTC"), o, { locale: t });
        return {
          text: l.charAt(0).toUpperCase() + l.substring(1),
          value: a
        };
      });
    } catch {
    }
  const r = new Intl.DateTimeFormat(e, { month: n, timeZone: "UTC" });
  return i.map((o, s) => {
    const a = r.format(o);
    return {
      text: a.charAt(0).toUpperCase() + a.substring(1),
      value: s
    };
  });
}, lL = (t) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][t], Tn = (t) => {
  const e = E(t);
  return e != null && e.$el ? e == null ? void 0 : e.$el : e;
}, uL = (t) => ({ type: "dot", ...t ?? {} }), JC = (t) => Array.isArray(t) ? !!t[0] && !!t[1] : !1, Ky = {
  prop: (t) => `"${t}" prop must be enabled!`,
  dateArr: (t) => `You need to use array as "model-value" binding in order to support "${t}"`
}, $n = (t) => t, Bw = (t) => t === 0 ? t : !t || isNaN(+t) ? null : +t, Zw = (t) => t === null, eT = (t) => {
  if (t)
    return [...t.querySelectorAll("input, button, select, textarea, a[href]")][0];
}, cL = (t) => {
  const e = [], n = (i) => i.filter((r) => r);
  for (let i = 0; i < t.length; i += 3) {
    const r = [t[i], t[i + 1], t[i + 2]];
    e.push(n(r));
  }
  return e;
}, Qc = (t, e, n) => {
  const i = n != null, r = e != null;
  if (!i && !r)
    return !1;
  const o = +n, s = +e;
  return i && r ? +t > o || +t < s : i ? +t > o : r ? +t < s : !1;
}, Ll = (t, e) => cL(t).map((n) => n.map((i) => {
  const { active: r, disabled: o, isBetween: s, highlighted: a } = e(i);
  return {
    ...i,
    active: r,
    disabled: o,
    className: {
      dp__overlay_cell_active: r,
      dp__overlay_cell: !r,
      dp__overlay_cell_disabled: o,
      dp__overlay_cell_pad: !0,
      dp__overlay_cell_active_disabled: o && r,
      dp__cell_in_between: s,
      "dp--highlighted": a
    }
  };
})), Ss = (t, e, n = !1) => {
  t && e.allowStopPropagation && (n && t.stopImmediatePropagation(), t.stopPropagation());
}, dL = () => [
  "a[href]",
  "area[href]",
  "input:not([disabled]):not([type='hidden'])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "[tabindex]:not([tabindex='-1'])",
  "[data-datepicker-instance]"
].join(", ");
function hL(t, e) {
  let n = [...document.querySelectorAll(dL())];
  n = n.filter((r) => !t.contains(r) || r.hasAttribute("data-datepicker-instance"));
  const i = n.indexOf(t);
  if (i >= 0 && (e ? i - 1 >= 0 : i + 1 <= n.length))
    return n[i + (e ? -1 : 1)];
}
const EO = (t, e) => t == null ? void 0 : t.querySelector(`[data-dp-element="${e}"]`), tT = (t, e) => new Intl.NumberFormat(e, { useGrouping: !1, style: "decimal" }).format(t), Jy = (t) => no(t, "dd-MM-yyyy"), Fm = (t) => Array.isArray(t), uf = (t, e) => e.get(Jy(t)), fL = (t, e) => t ? e ? e instanceof Map ? !!uf(t, e) : e(_e(t)) : !1 : !0, oi = (t, e, n = !1, i) => {
  if (t.key === Wt.enter || t.key === Wt.space)
    return n && t.preventDefault(), e();
  if (i)
    return i(t);
}, Fw = () => ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].some(
  (t) => navigator.userAgent.includes(t)
) || navigator.userAgent.includes("Mac") && "ontouchend" in document, qw = (t, e, n, i, r, o) => {
  const s = PO(t, e.slice(0, t.length), /* @__PURE__ */ new Date(), { locale: o });
  return ac(s) && DC(s) ? i || r ? s : Qt(s, {
    hours: +n.hours,
    minutes: +(n == null ? void 0 : n.minutes),
    seconds: +(n == null ? void 0 : n.seconds),
    milliseconds: 0
  }) : null;
}, pL = (t, e, n, i, r, o) => {
  const s = Array.isArray(n) ? n[0] : n;
  if (typeof e == "string")
    return qw(t, e, s, i, r, o);
  if (Array.isArray(e)) {
    let a = null;
    for (const l of e)
      if (a = qw(t, l, s, i, r, o), a)
        break;
    return a;
  }
  return typeof e == "function" ? e(t) : null;
}, _e = (t) => t ? new Date(t) : /* @__PURE__ */ new Date(), mL = (t, e, n) => {
  if (e) {
    const r = (t.getMonth() + 1).toString().padStart(2, "0"), o = t.getDate().toString().padStart(2, "0"), s = t.getHours().toString().padStart(2, "0"), a = t.getMinutes().toString().padStart(2, "0"), l = n ? t.getSeconds().toString().padStart(2, "0") : "00";
    return `${t.getFullYear()}-${r}-${o}T${s}:${a}:${l}.000Z`;
  }
  const i = Date.UTC(
    t.getUTCFullYear(),
    t.getUTCMonth(),
    t.getUTCDate(),
    t.getUTCHours(),
    t.getUTCMinutes(),
    t.getUTCSeconds()
  );
  return new Date(i).toISOString();
}, ci = (t, e) => {
  const n = _e(JSON.parse(JSON.stringify(t))), i = Qt(n, { hours: 0, minutes: 0, seconds: 0, milliseconds: 0 });
  return e ? lN(i) : i;
}, _s = (t, e, n, i) => {
  let r = t ? _e(t) : _e();
  return (e || e === 0) && (r = eL(r, +e)), (n || n === 0) && (r = tL(r, +n)), (i || i === 0) && (r = HC(r, +i)), YC(r, 0);
}, sn = (t, e) => !t || !e ? !1 : Dc(ci(t), ci(e)), Ot = (t, e) => !t || !e ? !1 : ml(ci(t), ci(e)), mn = (t, e) => !t || !e ? !1 : Nl(ci(t), ci(e)), qp = (t, e, n) => t != null && t[0] && t != null && t[1] ? mn(n, t[0]) && sn(n, t[1]) : t != null && t[0] && e ? mn(n, t[0]) && sn(n, e) || sn(n, t[0]) && mn(n, e) : !1, gr = (t) => {
  const e = Qt(new Date(t), { date: 1 });
  return ci(e);
}, qm = (t, e, n) => e && (n || n === 0) ? Object.fromEntries(
  ["hours", "minutes", "seconds"].map((i) => i === e ? [i, n] : [i, isNaN(+t[i]) ? void 0 : +t[i]])
) : {
  hours: isNaN(+t.hours) ? void 0 : +t.hours,
  minutes: isNaN(+t.minutes) ? void 0 : +t.minutes,
  seconds: isNaN(+t.seconds) ? void 0 : +t.seconds
}, Oa = (t) => ({
  hours: Lo(t),
  minutes: Es(t),
  seconds: Ql(t)
}), nT = (t, e) => {
  if (e) {
    const n = rt(_e(e));
    if (n > t)
      return 12;
    if (n === t)
      return ft(_e(e));
  }
}, iT = (t, e) => {
  if (e) {
    const n = rt(_e(e));
    return n < t ? -1 : n === t ? ft(_e(e)) : void 0;
  }
}, Vl = (t) => {
  if (t)
    return rt(_e(t));
}, rT = (t, e) => {
  const n = mn(t, e) ? e : t, i = mn(e, t) ? e : t;
  return NC({ start: n, end: i });
}, gL = (t) => {
  const e = br(t, 1);
  return { month: ft(e), year: rt(e) };
}, To = (t, e) => {
  const n = kr(t, { weekStartsOn: +e }), i = LC(t, { weekStartsOn: +e });
  return [n, i];
}, oT = (t, e) => {
  const n = {
    hours: Lo(_e()),
    minutes: Es(_e()),
    seconds: e ? Ql(_e()) : 0
  };
  return Object.assign(n, t);
}, ps = (t, e, n) => [Qt(_e(t), { date: 1 }), Qt(_e(), { month: e, year: n, date: 1 })], Eo = (t, e, n) => {
  let i = t ? _e(t) : _e();
  return (e || e === 0) && (i = jC(i, e)), n && (i = Hr(i, n)), i;
}, sT = (t, e, n, i, r) => {
  if (!i || r && !e || !r && !n)
    return !1;
  const o = r ? br(t, 1) : Il(t, 1), s = [ft(o), rt(o)];
  return r ? !vL(...s, e) : !OL(...s, n);
}, OL = (t, e, n) => sn(...ps(n, t, e)) || Ot(...ps(n, t, e)), vL = (t, e, n) => mn(...ps(n, t, e)) || Ot(...ps(n, t, e)), aT = (t, e, n, i, r, o, s) => {
  if (typeof e == "function" && !s)
    return e(t);
  const a = n ? { locale: n } : void 0;
  return Array.isArray(t) ? `${no(t[0], o, a)}${r && !t[1] ? "" : i}${t[1] ? no(t[1], o, a) : ""}` : no(t, o, a);
}, Ja = (t) => {
  if (t)
    return null;
  throw new Error(Ky.prop("partial-range"));
}, qd = (t, e) => {
  if (e)
    return t();
  throw new Error(Ky.prop("range"));
}, AO = (t) => Array.isArray(t) ? ac(t[0]) && (t[1] ? ac(t[1]) : !0) : t ? ac(t) : !1, yL = (t, e) => Qt(e ?? _e(), {
  hours: +t.hours || 0,
  minutes: +t.minutes || 0,
  seconds: +t.seconds || 0
}), Wm = (t, e, n, i) => {
  if (!t)
    return !0;
  if (i) {
    const r = n === "max" ? Dc(t, e) : Nl(t, e), o = { seconds: 0, milliseconds: 0 };
    return r || ml(Qt(t, o), Qt(e, o));
  }
  return n === "max" ? t.getTime() <= e.getTime() : t.getTime() >= e.getTime();
}, Xm = (t, e, n) => t ? yL(t, e) : _e(n ?? e), Ww = (t, e, n, i, r) => {
  if (Array.isArray(i)) {
    const s = Xm(t, i[0], e), a = Xm(t, i[1], e);
    return Wm(i[0], s, n, !!e) && Wm(i[1], a, n, !!e) && r;
  }
  const o = Xm(t, i, e);
  return Wm(i, o, n, !!e) && r;
}, zm = (t) => Qt(_e(), Oa(t)), bL = (t, e) => t instanceof Map ? Array.from(t.values()).filter((n) => rt(_e(n)) === e).map((n) => ft(n)) : [], wL = (t, e, n) => {
  if (t instanceof Map) {
    const i = Array.from(t.values()).filter((r) => rt(_e(r)) === e).map((r) => ft(r));
    return i.length ? i.includes(n) : !0;
  }
  return !0;
}, lT = (t, e, n) => typeof t == "function" ? t({ month: e, year: n }) : !!t.months.find((i) => i.month === e && i.year === n), eb = (t, e) => typeof t == "function" ? t(e) : t.years.includes(e), uT = (t) => no(t, "yyyy-MM-dd"), Pu = Bs({
  menuFocused: !1,
  shiftKeyInMenu: !1
}), cT = () => {
  const t = (n) => {
    Pu.menuFocused = n;
  }, e = (n) => {
    Pu.shiftKeyInMenu !== n && (Pu.shiftKeyInMenu = n);
  };
  return {
    control: J(() => ({ shiftKeyInMenu: Pu.shiftKeyInMenu, menuFocused: Pu.menuFocused })),
    setMenuFocused: t,
    setShiftKey: e
  };
}, qt = Bs({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), jm = re(null), Wd = re(!1), Ym = re(!1), Hm = re(!1), Um = re(!1), qn = re(0), pn = re(0), qs = () => {
  const t = J(() => Wd.value ? [...qt.selectionGrid, qt.actionRow].filter((d) => d.length) : Ym.value ? [
    ...qt.timePicker[0],
    ...qt.timePicker[1],
    Um.value ? [] : [jm.value],
    qt.actionRow
  ].filter((d) => d.length) : Hm.value ? [...qt.monthPicker, qt.actionRow] : [qt.monthYear, ...qt.calendar, qt.time, qt.actionRow].filter((d) => d.length)), e = (d) => {
    qn.value = d ? qn.value + 1 : qn.value - 1;
    let h = null;
    t.value[pn.value] && (h = t.value[pn.value][qn.value]), !h && t.value[pn.value + (d ? 1 : -1)] ? (pn.value = pn.value + (d ? 1 : -1), qn.value = d ? 0 : t.value[pn.value].length - 1) : h || (qn.value = d ? qn.value - 1 : qn.value + 1);
  }, n = (d) => {
    pn.value === 0 && !d || pn.value === t.value.length && d || (pn.value = d ? pn.value + 1 : pn.value - 1, t.value[pn.value] ? t.value[pn.value] && !t.value[pn.value][qn.value] && qn.value !== 0 && (qn.value = t.value[pn.value].length - 1) : pn.value = d ? pn.value - 1 : pn.value + 1);
  }, i = (d) => {
    let h = null;
    t.value[pn.value] && (h = t.value[pn.value][qn.value]), h ? h.focus({ preventScroll: !Wd.value }) : qn.value = d ? qn.value - 1 : qn.value + 1;
  }, r = () => {
    e(!0), i(!0);
  }, o = () => {
    e(!1), i(!1);
  }, s = () => {
    n(!1), i(!0);
  }, a = () => {
    n(!0), i(!0);
  }, l = (d, h) => {
    qt[h] = d;
  }, u = (d, h) => {
    qt[h] = d;
  }, c = () => {
    qn.value = 0, pn.value = 0;
  };
  return {
    buildMatrix: l,
    buildMultiLevelMatrix: u,
    setTimePickerBackRef: (d) => {
      jm.value = d;
    },
    setSelectionGrid: (d) => {
      Wd.value = d, c(), d || (qt.selectionGrid = []);
    },
    setTimePicker: (d, h = !1) => {
      Ym.value = d, Um.value = h, c(), d || (qt.timePicker[0] = [], qt.timePicker[1] = []);
    },
    setTimePickerElements: (d, h = 0) => {
      qt.timePicker[h] = d;
    },
    arrowRight: r,
    arrowLeft: o,
    arrowUp: s,
    arrowDown: a,
    clearArrowNav: () => {
      qt.monthYear = [], qt.calendar = [], qt.time = [], qt.actionRow = [], qt.selectionGrid = [], qt.timePicker[0] = [], qt.timePicker[1] = [], Wd.value = !1, Ym.value = !1, Um.value = !1, Hm.value = !1, c(), jm.value = null;
    },
    setMonthPicker: (d) => {
      Hm.value = d, c();
    },
    refSets: qt
    // exposed for testing
  };
}, Xw = (t) => ({
  menuAppearTop: "dp-menu-appear-top",
  menuAppearBottom: "dp-menu-appear-bottom",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down",
  ...t ?? {}
}), kL = (t) => ({
  toggleOverlay: "Toggle overlay",
  menu: "Datepicker menu",
  input: "Datepicker input",
  openTimePicker: "Open time picker",
  closeTimePicker: "Close time Picker",
  incrementValue: (e) => `Increment ${e}`,
  decrementValue: (e) => `Decrement ${e}`,
  openTpOverlay: (e) => `Open ${e} overlay`,
  amPmButton: "Switch AM/PM mode",
  openYearsOverlay: "Open years overlay",
  openMonthsOverlay: "Open months overlay",
  nextMonth: "Next month",
  prevMonth: "Previous month",
  nextYear: "Next year",
  prevYear: "Previous year",
  day: void 0,
  weekDay: void 0,
  clearInput: "Clear value",
  calendarIcon: "Calendar icon",
  timePicker: "Time picker",
  monthPicker: (e) => `Month picker${e ? " overlay" : ""}`,
  yearPicker: (e) => `Year picker${e ? " overlay" : ""}`,
  timeOverlay: (e) => `${e} overlay`,
  ...t ?? {}
}), zw = (t) => t ? typeof t == "boolean" ? t ? 2 : 0 : +t >= 2 ? +t : 2 : 0, SL = (t) => {
  const e = typeof t == "object" && t, n = {
    static: !0,
    solo: !1
  };
  if (!t)
    return { ...n, count: zw(!1) };
  const i = e ? t : {}, r = e ? i.count ?? !0 : t, o = zw(r);
  return Object.assign(n, i, { count: o });
}, _L = (t, e, n) => t || (typeof n == "string" ? n : e), xL = (t) => typeof t == "boolean" ? t ? Xw({}) : !1 : Xw(t), CL = (t) => {
  const e = {
    enterSubmit: !0,
    tabSubmit: !0,
    openMenu: "open",
    selectOnFocus: !1,
    rangeSeparator: " - "
  };
  return typeof t == "object" ? { ...e, ...t ?? {}, enabled: !0 } : { ...e, enabled: t };
}, TL = (t) => ({
  months: [],
  years: [],
  times: { hours: [], minutes: [], seconds: [] },
  ...t ?? {}
}), $L = (t) => ({
  showSelect: !0,
  showCancel: !0,
  showNow: !1,
  showPreview: !0,
  ...t ?? {}
}), PL = (t) => {
  const e = { input: !1 };
  return typeof t == "object" ? { ...e, ...t ?? {}, enabled: !0 } : {
    enabled: t,
    ...e
  };
}, ML = (t) => ({ allowStopPropagation: !0, closeOnScroll: !1, modeHeight: 255, allowPreventDefault: !1, closeOnClearValue: !0, closeOnAutoApply: !0, noSwipe: !1, keepActionRow: !1, onClickOutside: void 0, tabOutClosesMenu: !0, arrowLeft: void 0, keepViewOnOffsetClick: !1, timeArrowHoldThreshold: 0, shadowDom: !1, mobileBreakpoint: 600, setDateOnMenuClose: !1, ...t ?? {} }), EL = (t) => {
  const e = {
    dates: Array.isArray(t) ? t.map((n) => _e(n)) : [],
    years: [],
    months: [],
    quarters: [],
    weeks: [],
    weekdays: [],
    options: { highlightDisabled: !1 }
  };
  return typeof t == "function" ? t : { ...e, ...t ?? {} };
}, AL = (t) => typeof t == "object" ? {
  type: (t == null ? void 0 : t.type) ?? "local",
  hideOnOffsetDates: (t == null ? void 0 : t.hideOnOffsetDates) ?? !1
} : {
  type: t,
  hideOnOffsetDates: !1
}, RL = (t) => {
  const e = {
    noDisabledRange: !1,
    showLastInRange: !0,
    minMaxRawRange: !1,
    partialRange: !0,
    disableTimeRangeValidation: !1,
    maxRange: void 0,
    minRange: void 0,
    autoRange: void 0,
    fixedStart: !1,
    fixedEnd: !1
  };
  return typeof t == "object" ? { enabled: !0, ...e, ...t } : {
    enabled: t,
    ...e
  };
}, DL = (t) => t ? typeof t == "string" ? {
  timezone: t,
  exactMatch: !1,
  dateInTz: void 0,
  emitTimezone: void 0,
  convertModel: !0
} : {
  timezone: t.timezone,
  exactMatch: t.exactMatch ?? !1,
  dateInTz: t.dateInTz ?? void 0,
  emitTimezone: t.emitTimezone ?? void 0,
  convertModel: t.convertModel ?? !0
} : { timezone: void 0, exactMatch: !1, emitTimezone: void 0 }, Gm = (t, e, n) => new Map(
  t.map((i) => {
    const r = Uy(i, e, n);
    return [Jy(r), r];
  })
), QL = (t, e) => t.length ? new Map(
  t.map((n) => {
    const i = Uy(n.date, e);
    return [Jy(i), n];
  })
) : null, NL = (t) => {
  var e;
  return {
    minDate: MO(t.minDate, t.timezone, t.isSpecific),
    maxDate: MO(t.maxDate, t.timezone, t.isSpecific),
    disabledDates: Fm(t.disabledDates) ? Gm(t.disabledDates, t.timezone, t.isSpecific) : t.disabledDates,
    allowedDates: Fm(t.allowedDates) ? Gm(t.allowedDates, t.timezone, t.isSpecific) : null,
    highlight: typeof t.highlight == "object" && Fm((e = t.highlight) == null ? void 0 : e.dates) ? Gm(t.highlight.dates, t.timezone) : t.highlight,
    markers: QL(t.markers, t.timezone)
  };
}, IL = (t) => typeof t == "boolean" ? { enabled: t, dragSelect: !0, limit: null } : {
  enabled: !!t,
  limit: t.limit ? +t.limit : null,
  dragSelect: t.dragSelect ?? !0
}, LL = (t) => ({
  ...Object.fromEntries(
    Object.keys(t).map((e) => {
      const n = e, i = t[n], r = typeof t[n] == "string" ? { [i]: !0 } : Object.fromEntries(i.map((o) => [o, !0]));
      return [e, r];
    })
  )
}), Gt = (t) => {
  const e = () => {
    const w = t.enableSeconds ? ":ss" : "", S = t.enableMinutes ? ":mm" : "";
    return t.is24 ? `HH${S}${w}` : `hh${S}${w} aa`;
  }, n = () => {
    var w;
    return t.format ? t.format : t.monthPicker ? "MM/yyyy" : t.timePicker ? e() : t.weekPicker ? `${((w = g.value) == null ? void 0 : w.type) === "iso" ? "RR" : "ww"}-yyyy` : t.yearPicker ? "yyyy" : t.quarterPicker ? "QQQ/yyyy" : t.enableTimePicker ? `MM/dd/yyyy, ${e()}` : "MM/dd/yyyy";
  }, i = (w) => oT(w, t.enableSeconds), r = () => v.value.enabled ? t.startTime && Array.isArray(t.startTime) ? [i(t.startTime[0]), i(t.startTime[1])] : null : t.startTime && !Array.isArray(t.startTime) ? i(t.startTime) : null, o = J(() => SL(t.multiCalendars)), s = J(() => r()), a = J(() => kL(t.ariaLabels)), l = J(() => TL(t.filters)), u = J(() => xL(t.transitions)), c = J(() => $L(t.actionRow)), d = J(
    () => _L(t.previewFormat, t.format, n())
  ), h = J(() => CL(t.textInput)), f = J(() => PL(t.inline)), p = J(() => ML(t.config)), m = J(() => EL(t.highlight)), g = J(() => AL(t.weekNumbers)), O = J(() => DL(t.timezone)), y = J(() => IL(t.multiDates)), b = J(
    () => NL({
      minDate: t.minDate,
      maxDate: t.maxDate,
      disabledDates: t.disabledDates,
      allowedDates: t.allowedDates,
      highlight: m.value,
      markers: t.markers,
      timezone: O.value,
      isSpecific: t.monthPicker || t.yearPicker || t.quarterPicker
    })
  ), v = J(() => RL(t.range)), k = J(() => LL(t.ui));
  return {
    defaultedTransitions: u,
    defaultedMultiCalendars: o,
    defaultedStartTime: s,
    defaultedAriaLabels: a,
    defaultedFilters: l,
    defaultedActionRow: c,
    defaultedPreviewFormat: d,
    defaultedTextInput: h,
    defaultedInline: f,
    defaultedConfig: p,
    defaultedHighlight: m,
    defaultedWeekNumbers: g,
    defaultedRange: v,
    propDates: b,
    defaultedTz: O,
    defaultedMultiDates: y,
    defaultedUI: k,
    getDefaultPattern: n,
    getDefaultStartTime: r
  };
}, VL = (t, e, n) => {
  const i = re(), { defaultedTextInput: r, defaultedRange: o, defaultedTz: s, defaultedMultiDates: a, getDefaultPattern: l } = Gt(e), u = re(""), c = Ca(e, "format"), d = Ca(e, "formatLocale");
  gt(
    i,
    () => {
      typeof e.onInternalModelChange == "function" && t("internal-model-change", i.value, ce(!0));
    },
    { deep: !0 }
  ), gt(o, (F, xe) => {
    F.enabled !== xe.enabled && (i.value = null);
  }), gt(c, () => {
    V();
  });
  const h = (F) => s.value.timezone && s.value.convertModel ? xi(F, s.value.timezone) : F, f = (F) => {
    if (s.value.timezone && s.value.convertModel) {
      const xe = rL(s.value.timezone, F);
      return tN(F, xe);
    }
    return F;
  }, p = (F, xe, Be = !1) => aT(
    F,
    e.format,
    e.formatLocale,
    r.value.rangeSeparator,
    e.modelAuto,
    xe ?? l(),
    Be
  ), m = (F) => F ? e.modelType ? B(F) : {
    hours: Lo(F),
    minutes: Es(F),
    seconds: e.enableSeconds ? Ql(F) : 0
  } : null, g = (F) => e.modelType ? B(F) : { month: ft(F), year: rt(F) }, O = (F) => Array.isArray(F) ? a.value.enabled ? F.map((xe) => y(xe, Hr(_e(), xe))) : qd(
    () => [
      Hr(_e(), F[0]),
      F[1] ? Hr(_e(), F[1]) : Ja(o.value.partialRange)
    ],
    o.value.enabled
  ) : Hr(_e(), +F), y = (F, xe) => (typeof F == "string" || typeof F == "number") && e.modelType ? q(F) : xe, b = (F) => Array.isArray(F) ? [
    y(
      F[0],
      _s(null, +F[0].hours, +F[0].minutes, F[0].seconds)
    ),
    y(
      F[1],
      _s(null, +F[1].hours, +F[1].minutes, F[1].seconds)
    )
  ] : y(F, _s(null, F.hours, F.minutes, F.seconds)), v = (F) => {
    const xe = Qt(_e(), { date: 1 });
    return Array.isArray(F) ? a.value.enabled ? F.map((Be) => y(Be, Eo(xe, +Be.month, +Be.year))) : qd(
      () => [
        y(F[0], Eo(xe, +F[0].month, +F[0].year)),
        y(
          F[1],
          F[1] ? Eo(xe, +F[1].month, +F[1].year) : Ja(o.value.partialRange)
        )
      ],
      o.value.enabled
    ) : y(F, Eo(xe, +F.month, +F.year));
  }, k = (F) => {
    if (Array.isArray(F))
      return F.map((xe) => q(xe));
    throw new Error(Ky.dateArr("multi-dates"));
  }, w = (F) => {
    if (Array.isArray(F) && o.value.enabled) {
      const xe = F[0], Be = F[1];
      return [
        _e(Array.isArray(xe) ? xe[0] : null),
        Array.isArray(Be) && Be.length ? _e(Be[0]) : null
      ];
    }
    return _e(F[0]);
  }, S = (F) => e.modelAuto ? Array.isArray(F) ? [q(F[0]), q(F[1])] : e.autoApply ? [q(F)] : [q(F), null] : Array.isArray(F) ? qd(
    () => F[1] ? [
      q(F[0]),
      F[1] ? q(F[1]) : Ja(o.value.partialRange)
    ] : [q(F[0])],
    o.value.enabled
  ) : q(F), $ = () => {
    Array.isArray(i.value) && o.value.enabled && i.value.length === 1 && i.value.push(Ja(o.value.partialRange));
  }, C = () => {
    const F = i.value;
    return [
      B(F[0]),
      F[1] ? B(F[1]) : Ja(o.value.partialRange)
    ];
  }, L = () => i.value[1] ? C() : B($n(i.value[0])), j = () => (i.value || []).map((F) => B(F)), P = (F = !1) => (F || $(), e.modelAuto ? L() : a.value.enabled ? j() : Array.isArray(i.value) ? qd(() => C(), o.value.enabled) : B($n(i.value))), A = (F) => !F || Array.isArray(F) && !F.length ? null : e.timePicker ? b($n(F)) : e.monthPicker ? v($n(F)) : e.yearPicker ? O($n(F)) : a.value.enabled ? k($n(F)) : e.weekPicker ? w($n(F)) : S($n(F)), T = (F) => {
    const xe = A(F);
    AO($n(xe)) ? (i.value = $n(xe), V()) : (i.value = null, u.value = "");
  }, N = () => {
    const F = (xe) => no(xe, r.value.format);
    return `${F(i.value[0])} ${r.value.rangeSeparator} ${i.value[1] ? F(i.value[1]) : ""}`;
  }, Q = () => n.value && i.value ? Array.isArray(i.value) ? N() : no(i.value, r.value.format) : p(i.value), Y = () => i.value ? a.value.enabled ? i.value.map((F) => p(F)).join("; ") : r.value.enabled && typeof r.value.format == "string" ? Q() : p(i.value) : "", V = () => {
    !e.format || typeof e.format == "string" || r.value.enabled && typeof r.value.format == "string" ? u.value = Y() : u.value = e.format(i.value);
  }, q = (F) => {
    if (e.utc) {
      const xe = new Date(F);
      return e.utc === "preserve" ? new Date(xe.getTime() + xe.getTimezoneOffset() * 6e4) : xe;
    }
    return e.modelType ? oL.includes(e.modelType) ? h(new Date(F)) : e.modelType === "format" && (typeof e.format == "string" || !e.format) ? h(
      PO(F, l(), /* @__PURE__ */ new Date(), { locale: d.value })
    ) : h(
      PO(F, e.modelType, /* @__PURE__ */ new Date(), { locale: d.value })
    ) : h(new Date(F));
  }, B = (F) => F ? e.utc ? mL(F, e.utc === "preserve", e.enableSeconds) : e.modelType ? e.modelType === "timestamp" ? +f(F) : e.modelType === "iso" ? f(F).toISOString() : e.modelType === "format" && (typeof e.format == "string" || !e.format) ? p(f(F)) : p(f(F), e.modelType, !0) : f(F) : "", pe = (F, xe = !1, Be = !1) => {
    if (Be)
      return F;
    if (t("update:model-value", F), s.value.emitTimezone && xe) {
      const lt = Array.isArray(F) ? F.map((de) => xi($n(de), s.value.emitTimezone)) : xi($n(F), s.value.emitTimezone);
      t("update:model-timezone-value", lt);
    }
  }, oe = (F) => Array.isArray(i.value) ? a.value.enabled ? i.value.map((xe) => F(xe)) : [
    F(i.value[0]),
    i.value[1] ? F(i.value[1]) : Ja(o.value.partialRange)
  ] : F($n(i.value)), te = () => {
    if (Array.isArray(i.value)) {
      const F = To(i.value[0], e.weekStart), xe = i.value[1] ? To(i.value[1], e.weekStart) : [];
      return [F.map((Be) => _e(Be)), xe.map((Be) => _e(Be))];
    }
    return To(i.value, e.weekStart).map((F) => _e(F));
  }, M = (F, xe) => pe($n(oe(F)), !1, xe), G = (F) => {
    const xe = te();
    return F ? xe : t("update:model-value", te());
  }, ce = (F = !1) => (F || V(), e.monthPicker ? M(g, F) : e.timePicker ? M(m, F) : e.yearPicker ? M(rt, F) : e.weekPicker ? G(F) : pe(P(F), !0, F));
  return {
    inputValue: u,
    internalModelValue: i,
    checkBeforeEmit: () => i.value ? o.value.enabled ? o.value.partialRange ? i.value.length >= 1 : i.value.length === 2 : !!i.value : !1,
    parseExternalModelValue: T,
    formatInputValue: V,
    emitModelValue: ce
  };
}, BL = (t, e) => {
  const { defaultedFilters: n, propDates: i } = Gt(t), { validateMonthYearInRange: r } = Ws(t), o = (c, d) => {
    let h = c;
    return n.value.months.includes(ft(h)) ? (h = d ? br(c, 1) : Il(c, 1), o(h, d)) : h;
  }, s = (c, d) => {
    let h = c;
    return n.value.years.includes(rt(h)) ? (h = d ? Vy(c, 1) : UC(c, 1), s(h, d)) : h;
  }, a = (c, d = !1) => {
    const h = Qt(_e(), { month: t.month, year: t.year });
    let f = c ? br(h, 1) : Il(h, 1);
    t.disableYearSelect && (f = Hr(f, t.year));
    let p = ft(f), m = rt(f);
    n.value.months.includes(p) && (f = o(f, c), p = ft(f), m = rt(f)), n.value.years.includes(m) && (f = s(f, c), m = rt(f)), r(p, m, c, t.preventMinMaxNavigation) && l(p, m, d);
  }, l = (c, d, h) => {
    e("update-month-year", { month: c, year: d, fromNav: h });
  }, u = J(() => (c) => sT(
    Qt(_e(), { month: t.month, year: t.year }),
    i.value.maxDate,
    i.value.minDate,
    t.preventMinMaxNavigation,
    c
  ));
  return { handleMonthYearChange: a, isDisabled: u, updateMonthYear: l };
}, Wp = {
  multiCalendars: { type: [Boolean, Number, String, Object], default: void 0 },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: !1 },
  format: {
    type: [String, Function],
    default: () => null
  },
  autoPosition: { type: [Boolean, String], default: !0 },
  altPosition: { type: Function, default: null },
  transitions: { type: [Boolean, Object], default: !0 },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: !1 },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 },
  hideNavigation: { type: Array, default: () => [] },
  timezone: { type: [String, Object], default: null },
  vertical: { type: Boolean, default: !1 },
  disableMonthYearSelect: { type: Boolean, default: !1 },
  disableYearSelect: { type: Boolean, default: !1 },
  dayClass: {
    type: Function,
    default: null
  },
  yearRange: { type: Array, default: () => [1900, 2100] },
  enableTimePicker: { type: Boolean, default: !0 },
  autoApply: { type: Boolean, default: !1 },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  hideOffsetDates: { type: Boolean, default: !1 },
  noToday: { type: Boolean, default: !1 },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: null },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  escClose: { type: Boolean, default: !0 },
  spaceConfirm: { type: Boolean, default: !0 },
  monthChangeOnArrows: { type: Boolean, default: !0 },
  presetDates: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  partialFlow: { type: Boolean, default: !1 },
  preventMinMaxNavigation: { type: Boolean, default: !1 },
  reverseYears: { type: Boolean, default: !1 },
  weekPicker: { type: Boolean, default: !1 },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: !1 },
  highlight: {
    type: [Function, Object],
    default: null
  },
  teleport: { type: [Boolean, String, Object], default: null },
  teleportCenter: { type: Boolean, default: !1 },
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: {
    type: [String, Function, Object],
    default: null
  },
  monthChangeOnScroll: { type: [Boolean, String], default: !0 },
  dayNames: {
    type: [Function, Array],
    default: null
  },
  monthPicker: { type: Boolean, default: !1 },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: !1 },
  modelAuto: { type: Boolean, default: !1 },
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: [Object, Boolean], default: !1 },
  ignoreTimeValidation: { type: Boolean, default: !1 },
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null },
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null },
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: !1 },
  clearable: { type: Boolean, default: !0 },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: !1 },
  autocomplete: { type: String, default: "off" },
  timePicker: { type: Boolean, default: !1 },
  enableSeconds: { type: Boolean, default: !1 },
  is24: { type: Boolean, default: !0 },
  noHoursOverlay: { type: Boolean, default: !1 },
  noMinutesOverlay: { type: Boolean, default: !1 },
  noSecondsOverlay: { type: Boolean, default: !1 },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 },
  range: { type: [Boolean, Object], default: !1 },
  uid: { type: String, default: null },
  disabled: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  inline: { type: [Boolean, Object], default: !1 },
  textInput: { type: [Boolean, Object], default: !1 },
  sixWeeks: { type: [Boolean, String], default: !1 },
  actionRow: { type: Object, default: () => ({}) },
  focusStartDate: { type: Boolean, default: !1 },
  disabledTimes: { type: [Function, Array], default: void 0 },
  timePickerInline: { type: Boolean, default: !1 },
  calendar: { type: Function, default: null },
  config: { type: Object, default: void 0 },
  quarterPicker: { type: Boolean, default: !1 },
  yearFirst: { type: Boolean, default: !1 },
  loading: { type: Boolean, default: !1 },
  onInternalModelChange: { type: [Function, Object], default: null },
  enableMinutes: { type: Boolean, default: !0 },
  ui: { type: Object, default: () => ({}) }
}, Pr = {
  ...Wp,
  shadow: { type: Boolean, default: !1 },
  flowStep: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null },
  noOverlayFocus: { type: Boolean, default: !1 },
  collapse: { type: Boolean, default: !1 },
  menuWrapRef: { type: Object, default: null },
  getInputRect: { type: Function, default: () => ({}) },
  isTextInputDate: { type: Boolean, default: !1 },
  isMobile: { type: Boolean, default: void 0 }
}, ZL = ["title"], FL = ["disabled"], qL = /* @__PURE__ */ Te({
  compatConfig: {
    MODE: 3
  },
  __name: "ActionRow",
  props: {
    menuMount: { type: Boolean, default: !1 },
    calendarWidth: { type: Number, default: 0 },
    ...Pr
  },
  emits: ["close-picker", "select-date", "select-now", "invalid-select"],
  setup(t, { emit: e }) {
    const n = e, i = t, {
      defaultedActionRow: r,
      defaultedPreviewFormat: o,
      defaultedMultiCalendars: s,
      defaultedTextInput: a,
      defaultedInline: l,
      defaultedRange: u,
      defaultedMultiDates: c
    } = Gt(i), { isTimeValid: d, isMonthValid: h } = Ws(i), { buildMatrix: f } = qs(), p = re(null), m = re(null), g = re(!1), O = re({}), y = re(null), b = re(null);
    Et(() => {
      i.arrowNavigation && f([Tn(p), Tn(m)], "actionRow"), v(), window.addEventListener("resize", v);
    }), to(() => {
      window.removeEventListener("resize", v);
    });
    const v = () => {
      g.value = !1, setTimeout(() => {
        var T, N;
        const Q = (T = y.value) == null ? void 0 : T.getBoundingClientRect(), Y = (N = b.value) == null ? void 0 : N.getBoundingClientRect();
        Q && Y && (O.value.maxWidth = `${Y.width - Q.width - 20}px`), g.value = !0;
      }, 0);
    }, k = J(() => u.value.enabled && !u.value.partialRange && i.internalModelValue ? i.internalModelValue.length === 2 : !0), w = J(
      () => !d.value(i.internalModelValue) || !h.value(i.internalModelValue) || !k.value
    ), S = () => {
      const T = o.value;
      return i.timePicker || i.monthPicker, T($n(i.internalModelValue));
    }, $ = () => {
      const T = i.internalModelValue;
      return s.value.count > 0 ? `${C(T[0])} - ${C(T[1])}` : [C(T[0]), C(T[1])];
    }, C = (T) => aT(
      T,
      o.value,
      i.formatLocale,
      a.value.rangeSeparator,
      i.modelAuto,
      o.value
    ), L = J(() => !i.internalModelValue || !i.menuMount ? "" : typeof o.value == "string" ? Array.isArray(i.internalModelValue) ? i.internalModelValue.length === 2 && i.internalModelValue[1] ? $() : c.value.enabled ? i.internalModelValue.map((T) => `${C(T)}`) : i.modelAuto ? `${C(i.internalModelValue[0])}` : `${C(i.internalModelValue[0])} -` : C(i.internalModelValue) : S()), j = () => c.value.enabled ? "; " : " - ", P = J(
      () => Array.isArray(L.value) ? L.value.join(j()) : L.value
    ), A = () => {
      d.value(i.internalModelValue) && h.value(i.internalModelValue) && k.value ? n("select-date") : n("invalid-select");
    };
    return (T, N) => (_(), Z("div", {
      ref_key: "actionRowRef",
      ref: b,
      class: "dp__action_row"
    }, [
      T.$slots["action-row"] ? ne(T.$slots, "action-row", Ct(wt({ key: 0 }, {
        internalModelValue: T.internalModelValue,
        disabled: w.value,
        selectDate: () => T.$emit("select-date"),
        closePicker: () => T.$emit("close-picker")
      }))) : (_(), Z(Qe, { key: 1 }, [
        E(r).showPreview ? (_(), Z("div", {
          key: 0,
          class: "dp__selection_preview",
          title: P.value,
          style: pt(O.value)
        }, [
          T.$slots["action-preview"] && g.value ? ne(T.$slots, "action-preview", {
            key: 0,
            value: T.internalModelValue
          }) : W("", !0),
          !T.$slots["action-preview"] && g.value ? (_(), Z(Qe, { key: 1 }, [
            He(Pe(P.value), 1)
          ], 64)) : W("", !0)
        ], 12, ZL)) : W("", !0),
        X("div", {
          ref_key: "actionBtnContainer",
          ref: y,
          class: "dp__action_buttons",
          "data-dp-element": "action-row"
        }, [
          T.$slots["action-buttons"] ? ne(T.$slots, "action-buttons", {
            key: 0,
            value: T.internalModelValue
          }) : W("", !0),
          T.$slots["action-buttons"] ? W("", !0) : (_(), Z(Qe, { key: 1 }, [
            !E(l).enabled && E(r).showCancel ? (_(), Z("button", {
              key: 0,
              ref_key: "cancelButtonRef",
              ref: p,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: N[0] || (N[0] = (Q) => T.$emit("close-picker")),
              onKeydown: N[1] || (N[1] = (Q) => E(oi)(Q, () => T.$emit("close-picker")))
            }, Pe(T.cancelText), 545)) : W("", !0),
            E(r).showNow ? (_(), Z("button", {
              key: 1,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: N[2] || (N[2] = (Q) => T.$emit("select-now")),
              onKeydown: N[3] || (N[3] = (Q) => E(oi)(Q, () => T.$emit("select-now")))
            }, Pe(T.nowButtonLabel), 33)) : W("", !0),
            E(r).showSelect ? (_(), Z("button", {
              key: 2,
              ref_key: "selectButtonRef",
              ref: m,
              type: "button",
              class: "dp__action_button dp__action_select",
              disabled: w.value,
              "data-test-id": "select-button",
              onKeydown: N[4] || (N[4] = (Q) => E(oi)(Q, () => A())),
              onClick: A
            }, Pe(T.selectText), 41, FL)) : W("", !0)
          ], 64))
        ], 512)
      ], 64))
    ], 512));
  }
}), WL = ["role", "aria-label", "tabindex"], XL = { class: "dp__selection_grid_header" }, zL = ["aria-selected", "aria-disabled", "data-test-id", "onClick", "onKeydown", "onMouseover"], jL = ["aria-label"], bd = /* @__PURE__ */ Te({
  __name: "SelectionOverlay",
  props: {
    items: {},
    type: {},
    isLast: { type: Boolean },
    arrowNavigation: { type: Boolean },
    skipButtonRef: { type: Boolean },
    headerRefs: {},
    hideNavigation: {},
    escClose: { type: Boolean },
    useRelative: { type: Boolean },
    height: {},
    textInput: { type: [Boolean, Object] },
    config: {},
    noOverlayFocus: { type: Boolean },
    focusValue: {},
    menuWrapRef: {},
    ariaLabels: {},
    overlayLabel: {}
  },
  emits: ["selected", "toggle", "reset-flow", "hover-value"],
  setup(t, { expose: e, emit: n }) {
    const { setSelectionGrid: i, buildMultiLevelMatrix: r, setMonthPicker: o } = qs(), s = n, a = t, { defaultedAriaLabels: l, defaultedTextInput: u, defaultedConfig: c } = Gt(
      a
    ), { hideNavigationButtons: d } = jp(), h = re(!1), f = re(null), p = re(null), m = re([]), g = re(), O = re(null), y = re(0), b = re(null);
    jx(() => {
      f.value = null;
    }), Et(() => {
      nn().then(() => j()), a.noOverlayFocus || k(), v(!0);
    }), to(() => v(!1));
    const v = (oe) => {
      var te;
      a.arrowNavigation && ((te = a.headerRefs) != null && te.length ? o(oe) : i(oe));
    }, k = () => {
      var oe;
      const te = Tn(p);
      te && (u.value.enabled || (f.value ? (oe = f.value) == null || oe.focus({ preventScroll: !0 }) : te.focus({ preventScroll: !0 })), h.value = te.clientHeight < te.scrollHeight);
    }, w = J(
      () => ({
        dp__overlay: !0,
        "dp--overlay-absolute": !a.useRelative,
        "dp--overlay-relative": a.useRelative
      })
    ), S = J(
      () => a.useRelative ? { height: `${a.height}px`, width: "var(--dp-menu-min-width)" } : void 0
    ), $ = J(() => ({
      dp__overlay_col: !0
    })), C = J(
      () => ({
        dp__btn: !0,
        dp__button: !0,
        dp__overlay_action: !0,
        dp__over_action_scroll: h.value,
        dp__button_bottom: a.isLast
      })
    ), L = J(() => {
      var oe, te;
      return {
        dp__overlay_container: !0,
        dp__container_flex: ((oe = a.items) == null ? void 0 : oe.length) <= 6,
        dp__container_block: ((te = a.items) == null ? void 0 : te.length) > 6
      };
    });
    gt(
      () => a.items,
      () => j(!1),
      { deep: !0 }
    );
    const j = (oe = !0) => {
      nn().then(() => {
        const te = Tn(f), M = Tn(p), G = Tn(O), ce = Tn(b), F = G ? G.getBoundingClientRect().height : 0;
        M && (M.getBoundingClientRect().height ? y.value = M.getBoundingClientRect().height - F : y.value = c.value.modeHeight - F), te && ce && oe && (ce.scrollTop = te.offsetTop - ce.offsetTop - (y.value / 2 - te.getBoundingClientRect().height) - F);
      });
    }, P = (oe) => {
      oe.disabled || s("selected", oe.value);
    }, A = () => {
      s("toggle"), s("reset-flow");
    }, T = () => {
      a.escClose && A();
    }, N = (oe, te, M, G) => {
      oe && ((te.active || te.value === a.focusValue) && (f.value = oe), a.arrowNavigation && (Array.isArray(m.value[M]) ? m.value[M][G] = oe : m.value[M] = [oe], Q()));
    }, Q = () => {
      var oe, te;
      const M = (oe = a.headerRefs) != null && oe.length ? [a.headerRefs].concat(m.value) : m.value.concat([a.skipButtonRef ? [] : [O.value]]);
      r($n(M), (te = a.headerRefs) != null && te.length ? "monthPicker" : "selectionGrid");
    }, Y = (oe) => {
      a.arrowNavigation || Ss(oe, c.value, !0);
    }, V = (oe) => {
      g.value = oe, s("hover-value", oe);
    }, q = () => {
      if (A(), !a.isLast) {
        const oe = EO(a.menuWrapRef ?? null, "action-row");
        if (oe) {
          const te = eT(oe);
          te == null || te.focus();
        }
      }
    }, B = (oe) => {
      switch (oe.key) {
        case Wt.esc:
          return T();
        case Wt.arrowLeft:
          return Y(oe);
        case Wt.arrowRight:
          return Y(oe);
        case Wt.arrowUp:
          return Y(oe);
        case Wt.arrowDown:
          return Y(oe);
        default:
          return;
      }
    }, pe = (oe) => {
      if (oe.key === Wt.enter)
        return A();
      if (oe.key === Wt.tab)
        return q();
    };
    return e({ focusGrid: k }), (oe, te) => {
      var M;
      return _(), Z("div", {
        ref_key: "gridWrapRef",
        ref: p,
        class: Ae(w.value),
        style: pt(S.value),
        role: oe.useRelative ? void 0 : "dialog",
        "aria-label": oe.overlayLabel,
        tabindex: oe.useRelative ? void 0 : "0",
        onKeydown: B,
        onClick: te[0] || (te[0] = Tt(() => {
        }, ["prevent"]))
      }, [
        X("div", {
          ref_key: "containerRef",
          ref: b,
          class: Ae(L.value),
          style: pt({ "--dp-overlay-height": `${y.value}px` }),
          role: "grid"
        }, [
          X("div", XL, [
            ne(oe.$slots, "header")
          ]),
          oe.$slots.overlay ? ne(oe.$slots, "overlay", { key: 0 }) : (_(!0), Z(Qe, { key: 1 }, Ge(oe.items, (G, ce) => (_(), Z("div", {
            key: ce,
            class: Ae(["dp__overlay_row", { dp__flex_row: oe.items.length >= 3 }]),
            role: "row"
          }, [
            (_(!0), Z(Qe, null, Ge(G, (F, xe) => (_(), Z("div", {
              key: F.value,
              ref_for: !0,
              ref: (Be) => N(Be, F, ce, xe),
              role: "gridcell",
              class: Ae($.value),
              "aria-selected": F.active || void 0,
              "aria-disabled": F.disabled || void 0,
              tabindex: "0",
              "data-test-id": F.text,
              onClick: Tt((Be) => P(F), ["prevent"]),
              onKeydown: (Be) => E(oi)(Be, () => P(F), !0),
              onMouseover: (Be) => V(F.value)
            }, [
              X("div", {
                class: Ae(F.className)
              }, [
                oe.$slots.item ? ne(oe.$slots, "item", {
                  key: 0,
                  item: F
                }) : W("", !0),
                oe.$slots.item ? W("", !0) : (_(), Z(Qe, { key: 1 }, [
                  He(Pe(F.text), 1)
                ], 64))
              ], 2)
            ], 42, zL))), 128))
          ], 2))), 128))
        ], 6),
        oe.$slots["button-icon"] ? yt((_(), Z("button", {
          key: 0,
          ref_key: "toggleButton",
          ref: O,
          type: "button",
          "aria-label": (M = E(l)) == null ? void 0 : M.toggleOverlay,
          class: Ae(C.value),
          tabindex: "0",
          onClick: A,
          onKeydown: pe
        }, [
          ne(oe.$slots, "button-icon")
        ], 42, jL)), [
          [sc, !E(d)(oe.hideNavigation, oe.type)]
        ]) : W("", !0)
      ], 46, WL);
    };
  }
}), YL = ["data-dp-mobile"], Xp = /* @__PURE__ */ Te({
  __name: "InstanceWrap",
  props: {
    multiCalendars: {},
    stretch: { type: Boolean },
    collapse: { type: Boolean },
    isMobile: { type: Boolean }
  },
  setup(t) {
    const e = t, n = J(
      () => e.multiCalendars > 0 ? [...Array(e.multiCalendars).keys()] : [0]
    ), i = J(() => ({
      dp__instance_calendar: e.multiCalendars > 0
    }));
    return (r, o) => (_(), Z("div", {
      class: Ae({
        dp__menu_inner: !r.stretch,
        "dp--menu--inner-stretched": r.stretch,
        dp__flex_display: r.multiCalendars > 0,
        "dp--flex-display-collapsed": r.collapse
      }),
      "data-dp-mobile": r.isMobile
    }, [
      (_(!0), Z(Qe, null, Ge(n.value, (s, a) => (_(), Z("div", {
        key: s,
        class: Ae(i.value)
      }, [
        ne(r.$slots, "default", {
          instance: s,
          index: a
        })
      ], 2))), 128))
    ], 10, YL));
  }
}), HL = ["data-dp-element", "aria-label", "aria-disabled"], lc = /* @__PURE__ */ Te({
  compatConfig: {
    MODE: 3
  },
  __name: "ArrowBtn",
  props: {
    ariaLabel: {},
    elName: {},
    disabled: { type: Boolean }
  },
  emits: ["activate", "set-ref"],
  setup(t, { emit: e }) {
    const n = e, i = re(null);
    return Et(() => n("set-ref", i)), (r, o) => (_(), Z("button", {
      ref_key: "elRef",
      ref: i,
      type: "button",
      "data-dp-element": r.elName,
      class: "dp__btn dp--arrow-btn-nav",
      tabindex: "0",
      "aria-label": r.ariaLabel,
      "aria-disabled": r.disabled || void 0,
      onClick: o[0] || (o[0] = (s) => r.$emit("activate")),
      onKeydown: o[1] || (o[1] = (s) => E(oi)(s, () => r.$emit("activate"), !0))
    }, [
      X("span", {
        class: Ae(["dp__inner_nav", { dp__inner_nav_disabled: r.disabled }])
      }, [
        ne(r.$slots, "default")
      ], 2)
    ], 40, HL));
  }
}), UL = ["aria-label", "data-test-id"], dT = /* @__PURE__ */ Te({
  __name: "YearModePicker",
  props: {
    ...Pr,
    showYearPicker: { type: Boolean, default: !1 },
    items: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    isDisabled: { type: Function, default: () => !1 }
  },
  emits: ["toggle-year-picker", "year-select", "handle-year"],
  setup(t, { emit: e }) {
    const n = e, i = t, { showRightIcon: r, showLeftIcon: o } = jp(), { defaultedConfig: s, defaultedMultiCalendars: a, defaultedAriaLabels: l, defaultedTransitions: u, defaultedUI: c } = Gt(i), { showTransition: d, transitionName: h } = wd(u), f = re(!1), p = (O = !1, y) => {
      f.value = !f.value, n("toggle-year-picker", { flow: O, show: y });
    }, m = (O) => {
      f.value = !1, n("year-select", O);
    }, g = (O = !1) => {
      n("handle-year", O);
    };
    return (O, y) => {
      var b, v, k, w, S;
      return _(), Z(Qe, null, [
        X("div", {
          class: Ae(["dp--year-mode-picker", { "dp--hidden-el": f.value }])
        }, [
          E(o)(E(a), t.instance) ? (_(), ue(lc, {
            key: 0,
            ref: "mpPrevIconRef",
            "aria-label": (b = E(l)) == null ? void 0 : b.prevYear,
            disabled: t.isDisabled(!1),
            class: Ae((v = E(c)) == null ? void 0 : v.navBtnPrev),
            onActivate: y[0] || (y[0] = ($) => g(!1))
          }, {
            default: H(() => [
              O.$slots["arrow-left"] ? ne(O.$slots, "arrow-left", { key: 0 }) : W("", !0),
              O.$slots["arrow-left"] ? W("", !0) : (_(), ue(E(Xy), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled", "class"])) : W("", !0),
          X("button", {
            ref: "mpYearButtonRef",
            class: "dp__btn dp--year-select",
            type: "button",
            "aria-label": `${t.year}-${(k = E(l)) == null ? void 0 : k.openYearsOverlay}`,
            "data-test-id": `year-mode-btn-${t.instance}`,
            onClick: y[1] || (y[1] = () => p(!1)),
            onKeydown: y[2] || (y[2] = ai(() => p(!1), ["enter"]))
          }, [
            O.$slots.year ? ne(O.$slots, "year", {
              key: 0,
              year: t.year
            }) : W("", !0),
            O.$slots.year ? W("", !0) : (_(), Z(Qe, { key: 1 }, [
              He(Pe(t.year), 1)
            ], 64))
          ], 40, UL),
          E(r)(E(a), t.instance) ? (_(), ue(lc, {
            key: 1,
            ref: "mpNextIconRef",
            "aria-label": (w = E(l)) == null ? void 0 : w.nextYear,
            disabled: t.isDisabled(!0),
            class: Ae((S = E(c)) == null ? void 0 : S.navBtnNext),
            onActivate: y[3] || (y[3] = ($) => g(!0))
          }, {
            default: H(() => [
              O.$slots["arrow-right"] ? ne(O.$slots, "arrow-right", { key: 0 }) : W("", !0),
              O.$slots["arrow-right"] ? W("", !0) : (_(), ue(E(zy), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled", "class"])) : W("", !0)
        ], 2),
        fe(Fn, {
          name: E(h)(t.showYearPicker),
          css: E(d)
        }, {
          default: H(() => {
            var $, C;
            return [
              t.showYearPicker ? (_(), ue(bd, {
                key: 0,
                items: t.items,
                "text-input": O.textInput,
                "esc-close": O.escClose,
                config: O.config,
                "is-last": O.autoApply && !E(s).keepActionRow,
                "hide-navigation": O.hideNavigation,
                "aria-labels": O.ariaLabels,
                "overlay-label": (C = ($ = E(l)) == null ? void 0 : $.yearPicker) == null ? void 0 : C.call($, !0),
                type: "year",
                onToggle: p,
                onSelected: y[4] || (y[4] = (L) => m(L))
              }, un({
                "button-icon": H(() => [
                  O.$slots["calendar-icon"] ? ne(O.$slots, "calendar-icon", { key: 0 }) : W("", !0),
                  O.$slots["calendar-icon"] ? W("", !0) : (_(), ue(E(mu), { key: 1 }))
                ]),
                _: 2
              }, [
                O.$slots["year-overlay-value"] ? {
                  name: "item",
                  fn: H(({ item: L }) => [
                    ne(O.$slots, "year-overlay-value", {
                      text: L.text,
                      value: L.value
                    })
                  ]),
                  key: "0"
                } : void 0
              ]), 1032, ["items", "text-input", "esc-close", "config", "is-last", "hide-navigation", "aria-labels", "overlay-label"])) : W("", !0)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ], 64);
    };
  }
}), tb = (t, e, n) => {
  if (e.value && Array.isArray(e.value))
    if (e.value.some((i) => Ot(t, i))) {
      const i = e.value.filter((r) => !Ot(r, t));
      e.value = i.length ? i : null;
    } else
      (n && +n > e.value.length || !n) && e.value.push(t);
  else
    e.value = [t];
}, nb = (t, e, n) => {
  let i = t.value ? t.value.slice() : [];
  return i.length === 2 && i[1] !== null && (i = []), i.length ? (sn(e, i[0]) ? i.unshift(e) : i[1] = e, n("range-end", e)) : (i = [e], n("range-start", e)), i;
}, zp = (t, e, n, i) => {
  t && (t[0] && t[1] && n && e("auto-apply"), t[0] && !t[1] && i && n && e("auto-apply"));
}, hT = (t) => {
  Array.isArray(t.value) && t.value.length <= 2 && t.range ? t.modelValue.value = t.value.map((e) => xi(_e(e), t.timezone)) : Array.isArray(t.value) || (t.modelValue.value = xi(_e(t.value), t.timezone));
}, fT = (t, e, n, i) => Array.isArray(e.value) && (e.value.length === 2 || e.value.length === 1 && i.value.partialRange) ? i.value.fixedStart && (mn(t, e.value[0]) || Ot(t, e.value[0])) ? [e.value[0], t] : i.value.fixedEnd && (sn(t, e.value[1]) || Ot(t, e.value[1])) ? [t, e.value[1]] : (n("invalid-fixed-range", t), e.value) : [], pT = ({
  multiCalendars: t,
  range: e,
  highlight: n,
  propDates: i,
  calendars: r,
  modelValue: o,
  props: s,
  filters: a,
  year: l,
  month: u,
  emit: c
}) => {
  const d = J(() => Gy(s.yearRange, s.locale, s.reverseYears)), h = re([!1]), f = J(() => (L, j) => {
    const P = Qt(gr(/* @__PURE__ */ new Date()), {
      month: u.value(L),
      year: l.value(L)
    }), A = j ? IC(P) : Rc(P);
    return sT(
      A,
      i.value.maxDate,
      i.value.minDate,
      s.preventMinMaxNavigation,
      j
    );
  }), p = () => Array.isArray(o.value) && t.value.solo && o.value[1], m = () => {
    for (let L = 0; L < t.value.count; L++)
      if (L === 0)
        r.value[L] = r.value[0];
      else if (L === t.value.count - 1 && p())
        r.value[L] = {
          month: ft(o.value[1]),
          year: rt(o.value[1])
        };
      else {
        const j = Qt(_e(), r.value[L - 1]);
        r.value[L] = { month: ft(j), year: rt(Vy(j, 1)) };
      }
  }, g = (L) => {
    if (!L)
      return m();
    const j = Qt(_e(), r.value[L]);
    return r.value[0].year = rt(UC(j, t.value.count - 1)), m();
  }, O = (L, j) => {
    const P = sN(j, L);
    return e.value.showLastInRange && P > 1 ? j : L;
  }, y = (L) => s.focusStartDate || t.value.solo ? L[0] : L[1] ? O(L[0], L[1]) : L[0], b = () => {
    if (o.value) {
      const L = Array.isArray(o.value) ? y(o.value) : o.value;
      r.value[0] = { month: ft(L), year: rt(L) };
    }
  }, v = () => {
    b(), t.value.count && m();
  };
  gt(o, (L, j) => {
    s.isTextInputDate && JSON.stringify(L ?? {}) !== JSON.stringify(j ?? {}) && v();
  }), Et(() => {
    v();
  });
  const k = (L, j) => {
    r.value[j].year = L, c("update-month-year", { instance: j, year: L, month: r.value[j].month }), t.value.count && !t.value.solo && g(j);
  }, w = J(() => (L) => Ll(d.value, (j) => {
    var P;
    const A = l.value(L) === j.value, T = Qc(
      j.value,
      Vl(i.value.minDate),
      Vl(i.value.maxDate)
    ) || ((P = a.value.years) == null ? void 0 : P.includes(l.value(L))), N = eb(n.value, j.value);
    return { active: A, disabled: T, highlighted: N };
  })), S = (L, j) => {
    k(L, j), C(j);
  }, $ = (L, j = !1) => {
    if (!f.value(L, j)) {
      const P = j ? l.value(L) + 1 : l.value(L) - 1;
      k(P, L);
    }
  }, C = (L, j = !1, P) => {
    j || c("reset-flow"), P !== void 0 ? h.value[L] = P : h.value[L] = !h.value[L], h.value[L] ? c("overlay-toggle", { open: !0, overlay: Xn.year }) : (c("overlay-closed"), c("overlay-toggle", { open: !1, overlay: Xn.year }));
  };
  return {
    isDisabled: f,
    groupedYears: w,
    showYearPicker: h,
    selectYear: k,
    toggleYearPicker: C,
    handleYearSelect: S,
    handleYear: $
  };
}, GL = (t, e) => {
  const {
    defaultedMultiCalendars: n,
    defaultedAriaLabels: i,
    defaultedTransitions: r,
    defaultedConfig: o,
    defaultedRange: s,
    defaultedHighlight: a,
    propDates: l,
    defaultedTz: u,
    defaultedFilters: c,
    defaultedMultiDates: d
  } = Gt(t), h = () => {
    t.isTextInputDate && v(rt(_e(t.startDate)), 0);
  }, { modelValue: f, year: p, month: m, calendars: g } = kd(t, e, h), O = J(() => KC(t.formatLocale, t.locale, t.monthNameFormat)), y = re(null), { checkMinMaxRange: b } = Ws(t), {
    selectYear: v,
    groupedYears: k,
    showYearPicker: w,
    toggleYearPicker: S,
    handleYearSelect: $,
    handleYear: C,
    isDisabled: L
  } = pT({
    modelValue: f,
    multiCalendars: n,
    range: s,
    highlight: a,
    calendars: g,
    year: p,
    propDates: l,
    month: m,
    filters: c,
    props: t,
    emit: e
  });
  Et(() => {
    t.startDate && (f.value && t.focusStartDate || !f.value) && v(rt(_e(t.startDate)), 0);
  });
  const j = (M) => M ? { month: ft(M), year: rt(M) } : { month: null, year: null }, P = () => f.value ? Array.isArray(f.value) ? f.value.map((M) => j(M)) : j(f.value) : j(), A = (M, G) => {
    const ce = g.value[M], F = P();
    return Array.isArray(F) ? F.some((xe) => xe.year === (ce == null ? void 0 : ce.year) && xe.month === G) : (ce == null ? void 0 : ce.year) === F.year && G === F.month;
  }, T = (M, G, ce) => {
    var F, xe;
    const Be = P();
    return Array.isArray(Be) ? p.value(G) === ((F = Be[ce]) == null ? void 0 : F.year) && M === ((xe = Be[ce]) == null ? void 0 : xe.month) : !1;
  }, N = (M, G) => {
    if (s.value.enabled) {
      const ce = P();
      if (Array.isArray(f.value) && Array.isArray(ce)) {
        const F = T(M, G, 0) || T(M, G, 1), xe = Eo(gr(_e()), M, p.value(G));
        return qp(f.value, y.value, xe) && !F;
      }
      return !1;
    }
    return !1;
  }, Q = J(() => (M) => Ll(O.value, (G) => {
    var ce;
    const F = A(M, G.value), xe = Qc(
      G.value,
      nT(p.value(M), l.value.minDate),
      iT(p.value(M), l.value.maxDate)
    ) || bL(l.value.disabledDates, p.value(M)).includes(G.value) || ((ce = c.value.months) == null ? void 0 : ce.includes(G.value)) || !wL(l.value.allowedDates, p.value(M), G.value), Be = N(G.value, M), lt = lT(a.value, G.value, p.value(M));
    return { active: F, disabled: xe, isBetween: Be, highlighted: lt };
  })), Y = (M, G) => Eo(gr(_e()), M, p.value(G)), V = (M, G) => {
    const ce = f.value ? f.value : gr(/* @__PURE__ */ new Date());
    f.value = Eo(ce, M, p.value(G)), e("auto-apply"), e("update-flow-step");
  }, q = (M, G) => {
    const ce = Y(M, G);
    s.value.fixedEnd || s.value.fixedStart ? f.value = fT(ce, f, e, s) : f.value ? b(ce, f.value) && (f.value = nb(f, Y(M, G), e)) : f.value = [Y(M, G)], nn().then(() => {
      zp(f.value, e, t.autoApply, t.modelAuto);
    });
  }, B = (M, G) => {
    tb(Y(M, G), f, d.value.limit), e("auto-apply", !0);
  }, pe = (M, G) => (g.value[G].month = M, te(G, g.value[G].year, M), d.value.enabled ? B(M, G) : s.value.enabled ? q(M, G) : V(M, G)), oe = (M, G) => {
    v(M, G), te(G, M, null);
  }, te = (M, G, ce) => {
    let F = ce;
    if (!F && F !== 0) {
      const xe = P();
      F = Array.isArray(xe) ? xe[M].month : xe.month;
    }
    e("update-month-year", { instance: M, year: G, month: F });
  };
  return {
    groupedMonths: Q,
    groupedYears: k,
    year: p,
    isDisabled: L,
    defaultedMultiCalendars: n,
    defaultedAriaLabels: i,
    defaultedTransitions: r,
    defaultedConfig: o,
    showYearPicker: w,
    modelValue: f,
    presetDate: (M, G) => {
      hT({
        value: M,
        modelValue: f,
        range: s.value.enabled,
        timezone: G ? void 0 : u.value.timezone
      }), e("auto-apply");
    },
    setHoverDate: (M, G) => {
      y.value = Y(M, G);
    },
    selectMonth: pe,
    selectYear: oe,
    toggleYearPicker: S,
    handleYearSelect: $,
    handleYear: C,
    getModelMonthYear: P
  };
}, KL = /* @__PURE__ */ Te({
  compatConfig: {
    MODE: 3
  },
  __name: "MonthPicker",
  props: {
    ...Pr
  },
  emits: [
    "update:internal-model-value",
    "overlay-closed",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year",
    "update-flow-step",
    "mount",
    "invalid-fixed-range",
    "overlay-toggle"
  ],
  setup(t, { expose: e, emit: n }) {
    const i = n, r = zo(), o = Vi(r, "yearMode"), s = t;
    Et(() => {
      s.shadow || i("mount", null);
    });
    const {
      groupedMonths: a,
      groupedYears: l,
      year: u,
      isDisabled: c,
      defaultedMultiCalendars: d,
      defaultedConfig: h,
      showYearPicker: f,
      modelValue: p,
      presetDate: m,
      setHoverDate: g,
      selectMonth: O,
      selectYear: y,
      toggleYearPicker: b,
      handleYearSelect: v,
      handleYear: k,
      getModelMonthYear: w
    } = GL(s, i);
    return e({ getSidebarProps: () => ({
      modelValue: p,
      year: u,
      getModelMonthYear: w,
      selectMonth: O,
      selectYear: y,
      handleYear: k
    }), presetDate: m, toggleYearPicker: (S) => b(0, S) }), (S, $) => (_(), ue(Xp, {
      "multi-calendars": E(d).count,
      collapse: S.collapse,
      stretch: "",
      "is-mobile": S.isMobile
    }, {
      default: H(({ instance: C }) => [
        S.$slots["top-extra"] ? ne(S.$slots, "top-extra", {
          key: 0,
          value: S.internalModelValue
        }) : W("", !0),
        S.$slots["month-year"] ? ne(S.$slots, "month-year", Ct(wt({ key: 1 }, {
          year: E(u),
          months: E(a)(C),
          years: E(l)(C),
          selectMonth: E(O),
          selectYear: E(y),
          instance: C
        }))) : (_(), ue(bd, {
          key: 2,
          items: E(a)(C),
          "arrow-navigation": S.arrowNavigation,
          "is-last": S.autoApply && !E(h).keepActionRow,
          "esc-close": S.escClose,
          height: E(h).modeHeight,
          config: S.config,
          "no-overlay-focus": !!(S.noOverlayFocus || S.textInput),
          "use-relative": "",
          type: "month",
          onSelected: (L) => E(O)(L, C),
          onHoverValue: (L) => E(g)(L, C)
        }, un({
          header: H(() => [
            fe(dT, wt(S.$props, {
              items: E(l)(C),
              instance: C,
              "show-year-picker": E(f)[C],
              year: E(u)(C),
              "is-disabled": (L) => E(c)(C, L),
              onHandleYear: (L) => E(k)(C, L),
              onYearSelect: (L) => E(v)(L, C),
              onToggleYearPicker: (L) => E(b)(C, L == null ? void 0 : L.flow, L == null ? void 0 : L.show)
            }), un({ _: 2 }, [
              Ge(E(o), (L, j) => ({
                name: L,
                fn: H((P) => [
                  ne(S.$slots, L, Ct(Zt(P)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          _: 2
        }, [
          S.$slots["month-overlay-value"] ? {
            name: "item",
            fn: H(({ item: L }) => [
              ne(S.$slots, "month-overlay-value", {
                text: L.text,
                value: L.value
              })
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "config", "no-overlay-focus", "onSelected", "onHoverValue"]))
      ]),
      _: 3
    }, 8, ["multi-calendars", "collapse", "is-mobile"]));
  }
}), JL = (t, e) => {
  const n = () => {
    t.isTextInputDate && (c.value = rt(_e(t.startDate)));
  }, { modelValue: i } = kd(t, e, n), r = re(null), { defaultedHighlight: o, defaultedMultiDates: s, defaultedFilters: a, defaultedRange: l, propDates: u } = Gt(t), c = re();
  Et(() => {
    t.startDate && (i.value && t.focusStartDate || !i.value) && (c.value = rt(_e(t.startDate)));
  });
  const d = (m) => Array.isArray(i.value) ? i.value.some((g) => rt(g) === m) : i.value ? rt(i.value) === m : !1, h = (m) => l.value.enabled && Array.isArray(i.value) ? qp(i.value, r.value, p(m)) : !1, f = J(() => Ll(Gy(t.yearRange, t.locale, t.reverseYears), (m) => {
    const g = d(m.value), O = Qc(
      m.value,
      Vl(u.value.minDate),
      Vl(u.value.maxDate)
    ) || a.value.years.includes(m.value), y = h(m.value) && !g, b = eb(o.value, m.value);
    return { active: g, disabled: O, isBetween: y, highlighted: b };
  })), p = (m) => Hr(gr(Rc(/* @__PURE__ */ new Date())), m);
  return {
    groupedYears: f,
    modelValue: i,
    focusYear: c,
    setHoverValue: (m) => {
      r.value = Hr(gr(/* @__PURE__ */ new Date()), m);
    },
    selectYear: (m) => {
      var g;
      if (e("update-month-year", { instance: 0, year: m }), s.value.enabled)
        return i.value ? Array.isArray(i.value) && (((g = i.value) == null ? void 0 : g.map((O) => rt(O))).includes(m) ? i.value = i.value.filter((O) => rt(O) !== m) : i.value.push(Hr(ci(_e()), m))) : i.value = [Hr(ci(Rc(_e())), m)], e("auto-apply", !0);
      l.value.enabled ? (i.value = nb(i, p(m), e), nn().then(() => {
        zp(i.value, e, t.autoApply, t.modelAuto);
      })) : (i.value = p(m), e("auto-apply"));
    }
  };
}, eV = /* @__PURE__ */ Te({
  compatConfig: {
    MODE: 3
  },
  __name: "YearPicker",
  props: {
    ...Pr
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year"
  ],
  setup(t, { expose: e, emit: n }) {
    const i = n, r = t, { groupedYears: o, modelValue: s, focusYear: a, selectYear: l, setHoverValue: u } = JL(r, i), { defaultedConfig: c } = Gt(r);
    return e({ getSidebarProps: () => ({
      modelValue: s,
      selectYear: l
    }) }), (d, h) => (_(), Z("div", null, [
      d.$slots["top-extra"] ? ne(d.$slots, "top-extra", {
        key: 0,
        value: d.internalModelValue
      }) : W("", !0),
      d.$slots["month-year"] ? ne(d.$slots, "month-year", Ct(wt({ key: 1 }, {
        years: E(o),
        selectYear: E(l)
      }))) : (_(), ue(bd, {
        key: 2,
        items: E(o),
        "is-last": d.autoApply && !E(c).keepActionRow,
        height: E(c).modeHeight,
        config: d.config,
        "no-overlay-focus": !!(d.noOverlayFocus || d.textInput),
        "focus-value": E(a),
        type: "year",
        "use-relative": "",
        onSelected: E(l),
        onHoverValue: E(u)
      }, un({ _: 2 }, [
        d.$slots["year-overlay-value"] ? {
          name: "item",
          fn: H(({ item: f }) => [
            ne(d.$slots, "year-overlay-value", {
              text: f.text,
              value: f.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["items", "is-last", "height", "config", "no-overlay-focus", "focus-value", "onSelected", "onHoverValue"]))
    ]));
  }
}), tV = {
  key: 0,
  class: "dp__time_input"
}, nV = ["data-compact", "data-collapsed"], iV = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"], rV = ["aria-label", "disabled", "data-test-id", "onKeydown", "onClick"], oV = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"], sV = { key: 0 }, aV = ["aria-label", "data-compact"], lV = /* @__PURE__ */ Te({
  compatConfig: {
    MODE: 3
  },
  __name: "TimeInput",
  props: {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: { type: Function, default: () => !1 },
    ...Pr
  },
  emits: [
    "set-hours",
    "set-minutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed",
    "overlay-opened",
    "am-pm-change"
  ],
  setup(t, { expose: e, emit: n }) {
    const i = n, r = t, { setTimePickerElements: o, setTimePickerBackRef: s } = qs(), {
      defaultedAriaLabels: a,
      defaultedTransitions: l,
      defaultedFilters: u,
      defaultedConfig: c,
      defaultedRange: d,
      defaultedMultiCalendars: h
    } = Gt(r), { transitionName: f, showTransition: p } = wd(l), m = Bs({
      hours: !1,
      minutes: !1,
      seconds: !1
    }), g = re("AM"), O = re(null), y = re([]), b = re(), v = re(!1);
    Et(() => {
      i("mounted");
    });
    const k = (I) => Qt(/* @__PURE__ */ new Date(), {
      hours: I.hours,
      minutes: I.minutes,
      seconds: r.enableSeconds ? I.seconds : 0,
      milliseconds: 0
    }), w = J(
      () => (I) => q(I, r[I]) || $(I, r[I])
    ), S = J(() => ({ hours: r.hours, minutes: r.minutes, seconds: r.seconds })), $ = (I, ge) => d.value.enabled && !d.value.disableTimeRangeValidation ? !r.validateTime(I, ge) : !1, C = (I, ge) => {
      if (d.value.enabled && !d.value.disableTimeRangeValidation) {
        const ze = ge ? +r[`${I}Increment`] : -+r[`${I}Increment`], Se = r[I] + ze;
        return !r.validateTime(I, Se);
      }
      return !1;
    }, L = J(() => (I) => !M(+r[I] + +r[`${I}Increment`], I) || C(I, !0)), j = J(() => (I) => !M(+r[I] - +r[`${I}Increment`], I) || C(I, !1)), P = (I, ge) => EC(Qt(_e(), I), ge), A = (I, ge) => nL(Qt(_e(), I), ge), T = J(
      () => ({
        dp__time_col: !0,
        dp__time_col_block: !r.timePickerInline,
        dp__time_col_reg_block: !r.enableSeconds && r.is24 && !r.timePickerInline,
        dp__time_col_reg_inline: !r.enableSeconds && r.is24 && r.timePickerInline,
        dp__time_col_reg_with_button: !r.enableSeconds && !r.is24,
        dp__time_col_sec: r.enableSeconds && r.is24,
        dp__time_col_sec_with_button: r.enableSeconds && !r.is24
      })
    ), N = J(
      () => r.timePickerInline && d.value.enabled && !h.value.count
    ), Q = J(() => {
      const I = [{ type: "hours" }];
      return r.enableMinutes && I.push({ type: "", separator: !0 }, {
        type: "minutes"
      }), r.enableSeconds && I.push({ type: "", separator: !0 }, {
        type: "seconds"
      }), I;
    }), Y = J(() => Q.value.filter((I) => !I.separator)), V = J(() => (I) => {
      if (I === "hours") {
        const ge = lt(+r.hours);
        return { text: ge < 10 ? `0${ge}` : `${ge}`, value: ge };
      }
      return { text: r[I] < 10 ? `0${r[I]}` : `${r[I]}`, value: r[I] };
    }), q = (I, ge) => {
      var ze;
      if (!r.disabledTimesConfig)
        return !1;
      const Se = r.disabledTimesConfig(r.order, I === "hours" ? ge : void 0);
      return Se[I] ? !!((ze = Se[I]) != null && ze.includes(ge)) : !0;
    }, B = (I, ge) => ge !== "hours" || g.value === "AM" ? I : I + 12, pe = (I) => {
      const ge = r.is24 ? 24 : 12, ze = I === "hours" ? ge : 60, Se = +r[`${I}GridIncrement`], st = I === "hours" && !r.is24 ? Se : 0, D = [];
      for (let x = st; x < ze; x += Se)
        D.push({ value: r.is24 ? x : B(x, I), text: x < 10 ? `0${x}` : `${x}` });
      return I === "hours" && !r.is24 && D.unshift({ value: g.value === "PM" ? 12 : 0, text: "12" }), Ll(D, (x) => ({ active: !1, disabled: u.value.times[I].includes(x.value) || !M(x.value, I) || q(I, x.value) || $(I, x.value) }));
    }, oe = (I) => I >= 0 ? I : 59, te = (I) => I >= 0 ? I : 23, M = (I, ge) => {
      const ze = r.minTime ? k(qm(r.minTime)) : null, Se = r.maxTime ? k(qm(r.maxTime)) : null, st = k(
        qm(
          S.value,
          ge,
          ge === "minutes" || ge === "seconds" ? oe(I) : te(I)
        )
      );
      return ze && Se ? (Dc(st, Se) || ml(st, Se)) && (Nl(st, ze) || ml(st, ze)) : ze ? Nl(st, ze) || ml(st, ze) : Se ? Dc(st, Se) || ml(st, Se) : !0;
    }, G = (I) => r[`no${I[0].toUpperCase() + I.slice(1)}Overlay`], ce = (I) => {
      G(I) || (m[I] = !m[I], m[I] ? (v.value = !0, i("overlay-opened", I)) : (v.value = !1, i("overlay-closed", I)));
    }, F = (I) => I === "hours" ? Lo : I === "minutes" ? Es : Ql, xe = () => {
      b.value && clearTimeout(b.value);
    }, Be = (I, ge = !0, ze) => {
      const Se = ge ? P : A, st = ge ? +r[`${I}Increment`] : -+r[`${I}Increment`];
      M(+r[I] + st, I) && i(
        `update:${I}`,
        F(I)(Se({ [I]: +r[I] }, { [I]: +r[`${I}Increment`] }))
      ), !(ze != null && ze.keyboard) && c.value.timeArrowHoldThreshold && (b.value = setTimeout(() => {
        Be(I, ge);
      }, c.value.timeArrowHoldThreshold));
    }, lt = (I) => r.is24 ? I : (I >= 12 ? g.value = "PM" : g.value = "AM", lL(I)), de = () => {
      g.value === "PM" ? (g.value = "AM", i("update:hours", r.hours - 12)) : (g.value = "PM", i("update:hours", r.hours + 12)), i("am-pm-change", g.value);
    }, ye = (I) => {
      m[I] = !0;
    }, me = (I, ge, ze) => {
      if (I && r.arrowNavigation) {
        Array.isArray(y.value[ge]) ? y.value[ge][ze] = I : y.value[ge] = [I];
        const Se = y.value.reduce(
          (st, D) => D.map((x, U) => [...st[U] || [], D[U]]),
          []
        );
        s(r.closeTimePickerBtn), O.value && (Se[1] = Se[1].concat(O.value)), o(Se, r.order);
      }
    }, ie = (I, ge) => (ce(I), i(`update:${I}`, ge));
    return e({ openChildCmp: ye }), (I, ge) => {
      var ze;
      return I.disabled ? W("", !0) : (_(), Z("div", tV, [
        (_(!0), Z(Qe, null, Ge(Q.value, (Se, st) => {
          var D, x, U;
          return _(), Z("div", {
            key: st,
            class: Ae(T.value),
            "data-compact": N.value && !I.enableSeconds,
            "data-collapsed": N.value && I.enableSeconds
          }, [
            Se.separator ? (_(), Z(Qe, { key: 0 }, [
              v.value ? W("", !0) : (_(), Z(Qe, { key: 0 }, [
                He(":")
              ], 64))
            ], 64)) : (_(), Z(Qe, { key: 1 }, [
              X("button", {
                ref_for: !0,
                ref: (K) => me(K, st, 0),
                type: "button",
                class: Ae({
                  dp__btn: !0,
                  dp__inc_dec_button: !I.timePickerInline,
                  dp__inc_dec_button_inline: I.timePickerInline,
                  dp__tp_inline_btn_top: I.timePickerInline,
                  dp__inc_dec_button_disabled: L.value(Se.type),
                  "dp--hidden-el": v.value
                }),
                "data-test-id": `${Se.type}-time-inc-btn-${r.order}`,
                "aria-label": (D = E(a)) == null ? void 0 : D.incrementValue(Se.type),
                tabindex: "0",
                onKeydown: (K) => E(oi)(K, () => Be(Se.type, !0, { keyboard: !0 }), !0),
                onClick: (K) => E(c).timeArrowHoldThreshold ? void 0 : Be(Se.type, !0),
                onMousedown: (K) => E(c).timeArrowHoldThreshold ? Be(Se.type, !0) : void 0,
                onMouseup: xe
              }, [
                r.timePickerInline ? (_(), Z(Qe, { key: 1 }, [
                  I.$slots["tp-inline-arrow-up"] ? ne(I.$slots, "tp-inline-arrow-up", { key: 0 }) : (_(), Z(Qe, { key: 1 }, [
                    ge[2] || (ge[2] = X("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                    ge[3] || (ge[3] = X("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
                  ], 64))
                ], 64)) : (_(), Z(Qe, { key: 0 }, [
                  I.$slots["arrow-up"] ? ne(I.$slots, "arrow-up", { key: 0 }) : W("", !0),
                  I.$slots["arrow-up"] ? W("", !0) : (_(), ue(E(Yy), { key: 1 }))
                ], 64))
              ], 42, iV),
              X("button", {
                ref_for: !0,
                ref: (K) => me(K, st, 1),
                type: "button",
                "aria-label": `${V.value(Se.type).text}-${(x = E(a)) == null ? void 0 : x.openTpOverlay(Se.type)}`,
                class: Ae({
                  dp__time_display: !0,
                  dp__time_display_block: !I.timePickerInline,
                  dp__time_display_inline: I.timePickerInline,
                  "dp--time-invalid": w.value(Se.type),
                  "dp--time-overlay-btn": !w.value(Se.type),
                  "dp--hidden-el": v.value
                }),
                disabled: G(Se.type),
                tabindex: "0",
                "data-test-id": `${Se.type}-toggle-overlay-btn-${r.order}`,
                onKeydown: (K) => E(oi)(K, () => ce(Se.type), !0),
                onClick: (K) => ce(Se.type)
              }, [
                I.$slots[Se.type] ? ne(I.$slots, Se.type, {
                  key: 0,
                  text: V.value(Se.type).text,
                  value: V.value(Se.type).value
                }) : W("", !0),
                I.$slots[Se.type] ? W("", !0) : (_(), Z(Qe, { key: 1 }, [
                  He(Pe(V.value(Se.type).text), 1)
                ], 64))
              ], 42, rV),
              X("button", {
                ref_for: !0,
                ref: (K) => me(K, st, 2),
                type: "button",
                class: Ae({
                  dp__btn: !0,
                  dp__inc_dec_button: !I.timePickerInline,
                  dp__inc_dec_button_inline: I.timePickerInline,
                  dp__tp_inline_btn_bottom: I.timePickerInline,
                  dp__inc_dec_button_disabled: j.value(Se.type),
                  "dp--hidden-el": v.value
                }),
                "data-test-id": `${Se.type}-time-dec-btn-${r.order}`,
                "aria-label": (U = E(a)) == null ? void 0 : U.decrementValue(Se.type),
                tabindex: "0",
                onKeydown: (K) => E(oi)(K, () => Be(Se.type, !1, { keyboard: !0 }), !0),
                onClick: (K) => E(c).timeArrowHoldThreshold ? void 0 : Be(Se.type, !1),
                onMousedown: (K) => E(c).timeArrowHoldThreshold ? Be(Se.type, !1) : void 0,
                onMouseup: xe
              }, [
                r.timePickerInline ? (_(), Z(Qe, { key: 1 }, [
                  I.$slots["tp-inline-arrow-down"] ? ne(I.$slots, "tp-inline-arrow-down", { key: 0 }) : (_(), Z(Qe, { key: 1 }, [
                    ge[4] || (ge[4] = X("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                    ge[5] || (ge[5] = X("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
                  ], 64))
                ], 64)) : (_(), Z(Qe, { key: 0 }, [
                  I.$slots["arrow-down"] ? ne(I.$slots, "arrow-down", { key: 0 }) : W("", !0),
                  I.$slots["arrow-down"] ? W("", !0) : (_(), ue(E(Hy), { key: 1 }))
                ], 64))
              ], 42, oV)
            ], 64))
          ], 10, nV);
        }), 128)),
        I.is24 ? W("", !0) : (_(), Z("div", sV, [
          I.$slots["am-pm-button"] ? ne(I.$slots, "am-pm-button", {
            key: 0,
            toggle: de,
            value: g.value
          }) : W("", !0),
          I.$slots["am-pm-button"] ? W("", !0) : (_(), Z("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: O,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": (ze = E(a)) == null ? void 0 : ze.amPmButton,
            tabindex: "0",
            "data-compact": N.value,
            onClick: de,
            onKeydown: ge[0] || (ge[0] = (Se) => E(oi)(Se, () => de(), !0))
          }, Pe(g.value), 41, aV))
        ])),
        (_(!0), Z(Qe, null, Ge(Y.value, (Se, st) => (_(), ue(Fn, {
          key: st,
          name: E(f)(m[Se.type]),
          css: E(p)
        }, {
          default: H(() => {
            var D, x;
            return [
              m[Se.type] ? (_(), ue(bd, {
                key: 0,
                items: pe(Se.type),
                "is-last": I.autoApply && !E(c).keepActionRow,
                "esc-close": I.escClose,
                type: Se.type,
                "text-input": I.textInput,
                config: I.config,
                "arrow-navigation": I.arrowNavigation,
                "aria-labels": I.ariaLabels,
                "overlay-label": (x = (D = E(a)).timeOverlay) == null ? void 0 : x.call(D, Se.type),
                onSelected: (U) => ie(Se.type, U),
                onToggle: (U) => ce(Se.type),
                onResetFlow: ge[1] || (ge[1] = (U) => I.$emit("reset-flow"))
              }, un({
                "button-icon": H(() => [
                  I.$slots["clock-icon"] ? ne(I.$slots, "clock-icon", { key: 0 }) : W("", !0),
                  I.$slots["clock-icon"] ? W("", !0) : (_(), ue(ar(I.timePickerInline ? E(mu) : E(jy)), { key: 1 }))
                ]),
                _: 2
              }, [
                I.$slots[`${Se.type}-overlay-value`] ? {
                  name: "item",
                  fn: H(({ item: U }) => [
                    ne(I.$slots, `${Se.type}-overlay-value`, {
                      text: U.text,
                      value: U.value
                    })
                  ]),
                  key: "0"
                } : void 0,
                I.$slots[`${Se.type}-overlay-header`] ? {
                  name: "header",
                  fn: H(() => [
                    ne(I.$slots, `${Se.type}-overlay-header`, {
                      toggle: () => ce(Se.type)
                    })
                  ]),
                  key: "1"
                } : void 0
              ]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "config", "arrow-navigation", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : W("", !0)
            ];
          }),
          _: 2
        }, 1032, ["name", "css"]))), 128))
      ]));
    };
  }
}), uV = ["data-dp-mobile"], cV = ["aria-label", "tabindex"], dV = ["role", "aria-label", "tabindex"], hV = ["aria-label"], mT = /* @__PURE__ */ Te({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePicker",
  props: {
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: {
      type: Function,
      default: () => !1
    },
    ...Pr
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-opened",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(t, { expose: e, emit: n }) {
    const i = n, r = t, { buildMatrix: o, setTimePicker: s } = qs(), a = zo(), { defaultedTransitions: l, defaultedAriaLabels: u, defaultedTextInput: c, defaultedConfig: d, defaultedRange: h } = Gt(r), { transitionName: f, showTransition: p } = wd(l), { hideNavigationButtons: m } = jp(), g = re(null), O = re(null), y = re([]), b = re(null), v = re(!1);
    Et(() => {
      i("mount"), !r.timePicker && r.arrowNavigation ? o([Tn(g.value)], "time") : s(!0, r.timePicker);
    });
    const k = J(() => h.value.enabled && r.modelAuto ? JC(r.internalModelValue) : !0), w = re(!1), S = (q) => ({
      hours: Array.isArray(r.hours) ? r.hours[q] : r.hours,
      minutes: Array.isArray(r.minutes) ? r.minutes[q] : r.minutes,
      seconds: Array.isArray(r.seconds) ? r.seconds[q] : r.seconds
    }), $ = J(() => {
      const q = [];
      if (h.value.enabled)
        for (let B = 0; B < 2; B++)
          q.push(S(B));
      else
        q.push(S(0));
      return q;
    }), C = (q, B = !1, pe = "") => {
      B || i("reset-flow"), w.value = q, i(q ? "overlay-opened" : "overlay-closed", Xn.time), r.arrowNavigation && s(q), nn(() => {
        pe !== "" && y.value[0] && y.value[0].openChildCmp(pe);
      });
    }, L = J(() => ({
      dp__btn: !0,
      dp__button: !0,
      dp__button_bottom: r.autoApply && !d.value.keepActionRow
    })), j = Vi(a, "timePicker"), P = (q, B, pe) => h.value.enabled ? B === 0 ? [q, $.value[1][pe]] : [$.value[0][pe], q] : q, A = (q) => {
      i("update:hours", q);
    }, T = (q) => {
      i("update:minutes", q);
    }, N = (q) => {
      i("update:seconds", q);
    }, Q = () => {
      if (b.value && !c.value.enabled && !r.noOverlayFocus) {
        const q = eT(b.value);
        q && q.focus({ preventScroll: !0 });
      }
    }, Y = (q) => {
      v.value = !1, i("overlay-closed", q);
    }, V = (q) => {
      v.value = !0, i("overlay-opened", q);
    };
    return e({ toggleTimePicker: C }), (q, B) => {
      var pe;
      return _(), Z("div", {
        class: "dp--tp-wrap",
        "data-dp-mobile": q.isMobile
      }, [
        !q.timePicker && !q.timePickerInline ? yt((_(), Z("button", {
          key: 0,
          ref_key: "openTimePickerBtn",
          ref: g,
          type: "button",
          class: Ae({ ...L.value, "dp--hidden-el": w.value }),
          "aria-label": (pe = E(u)) == null ? void 0 : pe.openTimePicker,
          tabindex: q.noOverlayFocus ? void 0 : 0,
          "data-test-id": "open-time-picker-btn",
          onKeydown: B[0] || (B[0] = (oe) => E(oi)(oe, () => C(!0))),
          onClick: B[1] || (B[1] = (oe) => C(!0))
        }, [
          q.$slots["clock-icon"] ? ne(q.$slots, "clock-icon", { key: 0 }) : W("", !0),
          q.$slots["clock-icon"] ? W("", !0) : (_(), ue(E(jy), { key: 1 }))
        ], 42, cV)), [
          [sc, !E(m)(q.hideNavigation, "time")]
        ]) : W("", !0),
        fe(Fn, {
          name: E(f)(w.value),
          css: E(p) && !q.timePickerInline
        }, {
          default: H(() => {
            var oe, te;
            return [
              w.value || q.timePicker || q.timePickerInline ? (_(), Z("div", {
                key: 0,
                ref_key: "overlayRef",
                ref: b,
                role: q.timePickerInline ? void 0 : "dialog",
                class: Ae({
                  dp__overlay: !q.timePickerInline,
                  "dp--overlay-absolute": !r.timePicker && !q.timePickerInline,
                  "dp--overlay-relative": r.timePicker
                }),
                style: pt(q.timePicker ? { height: `${E(d).modeHeight}px` } : void 0),
                "aria-label": (oe = E(u)) == null ? void 0 : oe.timePicker,
                tabindex: q.timePickerInline ? void 0 : 0
              }, [
                X("div", {
                  class: Ae(
                    q.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"
                  ),
                  style: { display: "flex" }
                }, [
                  q.$slots["time-picker-overlay"] ? ne(q.$slots, "time-picker-overlay", {
                    key: 0,
                    hours: t.hours,
                    minutes: t.minutes,
                    seconds: t.seconds,
                    setHours: A,
                    setMinutes: T,
                    setSeconds: N
                  }) : W("", !0),
                  q.$slots["time-picker-overlay"] ? W("", !0) : (_(), Z("div", {
                    key: 1,
                    class: Ae(q.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
                  }, [
                    (_(!0), Z(Qe, null, Ge($.value, (M, G) => yt((_(), ue(lV, wt({
                      key: G,
                      ref_for: !0
                    }, {
                      ...q.$props,
                      order: G,
                      hours: M.hours,
                      minutes: M.minutes,
                      seconds: M.seconds,
                      closeTimePickerBtn: O.value,
                      disabledTimesConfig: t.disabledTimesConfig,
                      disabled: G === 0 ? E(h).fixedStart : E(h).fixedEnd
                    }, {
                      ref_for: !0,
                      ref_key: "timeInputRefs",
                      ref: y,
                      "validate-time": (ce, F) => t.validateTime(ce, P(F, G, ce)),
                      "onUpdate:hours": (ce) => A(P(ce, G, "hours")),
                      "onUpdate:minutes": (ce) => T(P(ce, G, "minutes")),
                      "onUpdate:seconds": (ce) => N(P(ce, G, "seconds")),
                      onMounted: Q,
                      onOverlayClosed: Y,
                      onOverlayOpened: V,
                      onAmPmChange: B[2] || (B[2] = (ce) => q.$emit("am-pm-change", ce))
                    }), un({ _: 2 }, [
                      Ge(E(j), (ce, F) => ({
                        name: ce,
                        fn: H((xe) => [
                          ne(q.$slots, ce, wt({ ref_for: !0 }, xe))
                        ])
                      }))
                    ]), 1040, ["validate-time", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [sc, G === 0 ? !0 : k.value]
                    ])), 128))
                  ], 2)),
                  !q.timePicker && !q.timePickerInline ? yt((_(), Z("button", {
                    key: 2,
                    ref_key: "closeTimePickerBtn",
                    ref: O,
                    type: "button",
                    class: Ae({ ...L.value, "dp--hidden-el": v.value }),
                    "aria-label": (te = E(u)) == null ? void 0 : te.closeTimePicker,
                    tabindex: "0",
                    onKeydown: B[3] || (B[3] = (M) => E(oi)(M, () => C(!1))),
                    onClick: B[4] || (B[4] = (M) => C(!1))
                  }, [
                    q.$slots["calendar-icon"] ? ne(q.$slots, "calendar-icon", { key: 0 }) : W("", !0),
                    q.$slots["calendar-icon"] ? W("", !0) : (_(), ue(E(mu), { key: 1 }))
                  ], 42, hV)), [
                    [sc, !E(m)(q.hideNavigation, "time")]
                  ]) : W("", !0)
                ], 2)
              ], 14, dV)) : W("", !0)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ], 8, uV);
    };
  }
}), gT = (t, e, n, i) => {
  const { defaultedRange: r } = Gt(t), o = (b, v) => Array.isArray(e[b]) ? e[b][v] : e[b], s = (b) => t.enableSeconds ? Array.isArray(e.seconds) ? e.seconds[b] : e.seconds : 0, a = (b, v) => b ? v !== void 0 ? _s(b, o("hours", v), o("minutes", v), s(v)) : _s(b, e.hours, e.minutes, s()) : HC(_e(), s(v)), l = (b, v) => {
    e[b] = v;
  }, u = J(() => t.modelAuto && r.value.enabled ? Array.isArray(n.value) ? n.value.length > 1 : !1 : r.value.enabled), c = (b, v) => {
    const k = Object.fromEntries(
      Object.keys(e).map((w) => w === b ? [w, v] : [w, e[w]].slice())
    );
    if (u.value && !r.value.disableTimeRangeValidation) {
      const w = ($) => n.value ? _s(
        n.value[$],
        k.hours[$],
        k.minutes[$],
        k.seconds[$]
      ) : null, S = ($) => YC(n.value[$], 0);
      return !(Ot(w(0), w(1)) && (Nl(w(0), S(1)) || Dc(w(1), S(0))));
    }
    return !0;
  }, d = (b, v) => {
    c(b, v) && (l(b, v), i && i());
  }, h = (b) => {
    d("hours", b);
  }, f = (b) => {
    d("minutes", b);
  }, p = (b) => {
    d("seconds", b);
  }, m = (b, v, k, w) => {
    v && h(b), !v && !k && f(b), k && p(b), n.value && w(n.value);
  }, g = (b) => {
    if (b) {
      const v = Array.isArray(b), k = v ? [+b[0].hours, +b[1].hours] : +b.hours, w = v ? [+b[0].minutes, +b[1].minutes] : +b.minutes, S = v ? [+b[0].seconds, +b[1].seconds] : +b.seconds;
      l("hours", k), l("minutes", w), t.enableSeconds && l("seconds", S);
    }
  }, O = (b, v) => {
    const k = {
      hours: Array.isArray(e.hours) ? e.hours[b] : e.hours,
      disabledArr: []
    };
    return (v || v === 0) && (k.hours = v), Array.isArray(t.disabledTimes) && (k.disabledArr = r.value.enabled && Array.isArray(t.disabledTimes[b]) ? t.disabledTimes[b] : t.disabledTimes), k;
  }, y = J(() => (b, v) => {
    var k;
    if (Array.isArray(t.disabledTimes)) {
      const { disabledArr: w, hours: S } = O(b, v), $ = w.filter((C) => +C.hours === S);
      return ((k = $[0]) == null ? void 0 : k.minutes) === "*" ? { hours: [S], minutes: void 0, seconds: void 0 } : {
        hours: [],
        minutes: ($ == null ? void 0 : $.map((C) => +C.minutes)) ?? [],
        seconds: ($ == null ? void 0 : $.map((C) => C.seconds ? +C.seconds : void 0)) ?? []
      };
    }
    return { hours: [], minutes: [], seconds: [] };
  });
  return {
    setTime: l,
    updateHours: h,
    updateMinutes: f,
    updateSeconds: p,
    getSetDateTime: a,
    updateTimeValues: m,
    getSecondsValue: s,
    assignStartTime: g,
    validateTime: c,
    disabledTimesConfig: y
  };
}, fV = (t, e) => {
  const n = () => {
    t.isTextInputDate && v();
  }, { modelValue: i, time: r } = kd(t, e, n), { defaultedStartTime: o, defaultedRange: s, defaultedTz: a } = Gt(t), { updateTimeValues: l, getSetDateTime: u, setTime: c, assignStartTime: d, disabledTimesConfig: h, validateTime: f } = gT(t, r, i, p);
  function p() {
    e("update-flow-step");
  }
  const m = (w) => {
    const { hours: S, minutes: $, seconds: C } = w;
    return { hours: +S, minutes: +$, seconds: C ? +C : 0 };
  }, g = () => {
    if (t.startTime) {
      if (Array.isArray(t.startTime)) {
        const S = m(t.startTime[0]), $ = m(t.startTime[1]);
        return [Qt(_e(), S), Qt(_e(), $)];
      }
      const w = m(t.startTime);
      return Qt(_e(), w);
    }
    return s.value.enabled ? [null, null] : null;
  }, O = () => {
    if (s.value.enabled) {
      const [w, S] = g();
      i.value = [
        xi(u(w, 0), a.value.timezone),
        xi(u(S, 1), a.value.timezone)
      ];
    } else
      i.value = xi(u(g()), a.value.timezone);
  }, y = (w) => Array.isArray(w) ? [Oa(_e(w[0])), Oa(_e(w[1]))] : [Oa(w ?? _e())], b = (w, S, $) => {
    c("hours", w), c("minutes", S), c("seconds", t.enableSeconds ? $ : 0);
  }, v = () => {
    const [w, S] = y(i.value);
    return s.value.enabled ? b(
      [w.hours, S.hours],
      [w.minutes, S.minutes],
      [w.seconds, S.seconds]
    ) : b(w.hours, w.minutes, w.seconds);
  };
  Et(() => {
    if (!t.shadow)
      return d(o.value), i.value ? v() : O();
  });
  const k = () => {
    Array.isArray(i.value) ? i.value = i.value.map((w, S) => w && u(w, S)) : i.value = u(i.value), e("time-update");
  };
  return {
    modelValue: i,
    time: r,
    disabledTimesConfig: h,
    updateTime: (w, S = !0, $ = !1) => {
      l(w, S, $, k);
    },
    validateTime: f
  };
}, pV = /* @__PURE__ */ Te({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePickerSolo",
  props: {
    ...Pr
  },
  emits: [
    "update:internal-model-value",
    "time-update",
    "am-pm-change",
    "mount",
    "reset-flow",
    "update-flow-step",
    "overlay-toggle"
  ],
  setup(t, { expose: e, emit: n }) {
    const i = n, r = t, o = zo(), s = Vi(o, "timePicker"), a = re(null), { time: l, modelValue: u, disabledTimesConfig: c, updateTime: d, validateTime: h } = fV(r, i);
    return Et(() => {
      r.shadow || i("mount", null);
    }), e({ getSidebarProps: () => ({
      modelValue: u,
      time: l,
      updateTime: d
    }), toggleTimePicker: (f, p = !1, m = "") => {
      var g;
      (g = a.value) == null || g.toggleTimePicker(f, p, m);
    } }), (f, p) => (_(), ue(Xp, {
      "multi-calendars": 0,
      stretch: "",
      "is-mobile": f.isMobile
    }, {
      default: H(() => [
        fe(mT, wt({
          ref_key: "tpRef",
          ref: a
        }, f.$props, {
          hours: E(l).hours,
          minutes: E(l).minutes,
          seconds: E(l).seconds,
          "internal-model-value": f.internalModelValue,
          "disabled-times-config": E(c),
          "validate-time": E(h),
          "onUpdate:hours": p[0] || (p[0] = (m) => E(d)(m)),
          "onUpdate:minutes": p[1] || (p[1] = (m) => E(d)(m, !1)),
          "onUpdate:seconds": p[2] || (p[2] = (m) => E(d)(m, !1, !0)),
          onAmPmChange: p[3] || (p[3] = (m) => f.$emit("am-pm-change", m)),
          onResetFlow: p[4] || (p[4] = (m) => f.$emit("reset-flow")),
          onOverlayClosed: p[5] || (p[5] = (m) => f.$emit("overlay-toggle", { open: !1, overlay: m })),
          onOverlayOpened: p[6] || (p[6] = (m) => f.$emit("overlay-toggle", { open: !0, overlay: m }))
        }), un({ _: 2 }, [
          Ge(E(s), (m, g) => ({
            name: m,
            fn: H((O) => [
              ne(f.$slots, m, Ct(Zt(O)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"])
      ]),
      _: 3
    }, 8, ["is-mobile"]));
  }
}), mV = { class: "dp--header-wrap" }, gV = {
  key: 0,
  class: "dp__month_year_wrap"
}, OV = { key: 0 }, vV = { class: "dp__month_year_wrap" }, yV = ["data-dp-element", "aria-label", "data-test-id", "onClick", "onKeydown"], bV = /* @__PURE__ */ Te({
  compatConfig: {
    MODE: 3
  },
  __name: "DpHeader",
  props: {
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    instance: { type: Number, default: 0 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    ...Pr
  },
  emits: ["update-month-year", "mount", "reset-flow", "overlay-closed", "overlay-opened"],
  setup(t, { expose: e, emit: n }) {
    const i = n, r = t, {
      defaultedTransitions: o,
      defaultedAriaLabels: s,
      defaultedMultiCalendars: a,
      defaultedFilters: l,
      defaultedConfig: u,
      defaultedHighlight: c,
      propDates: d,
      defaultedUI: h
    } = Gt(r), { transitionName: f, showTransition: p } = wd(o), { buildMatrix: m } = qs(), { handleMonthYearChange: g, isDisabled: O, updateMonthYear: y } = BL(r, i), { showLeftIcon: b, showRightIcon: v } = jp(), k = re(!1), w = re(!1), S = re(!1), $ = re([null, null, null, null]);
    Et(() => {
      i("mount");
    });
    const C = (te) => ({
      get: () => r[te],
      set: (M) => {
        const G = te === hr.month ? hr.year : hr.month;
        i("update-month-year", { [te]: M, [G]: r[G] }), te === hr.month ? Y(!0) : V(!0);
      }
    }), L = J(C(hr.month)), j = J(C(hr.year)), P = J(() => (te) => ({
      month: r.month,
      year: r.year,
      items: te === hr.month ? r.months : r.years,
      instance: r.instance,
      updateMonthYear: y,
      toggle: te === hr.month ? Y : V
    })), A = J(() => r.months.find((M) => M.value === r.month) || { text: "", value: 0 }), T = J(() => Ll(r.months, (te) => {
      const M = r.month === te.value, G = Qc(
        te.value,
        nT(r.year, d.value.minDate),
        iT(r.year, d.value.maxDate)
      ) || l.value.months.includes(te.value), ce = lT(c.value, te.value, r.year);
      return { active: M, disabled: G, highlighted: ce };
    })), N = J(() => Ll(r.years, (te) => {
      const M = r.year === te.value, G = Qc(
        te.value,
        Vl(d.value.minDate),
        Vl(d.value.maxDate)
      ) || l.value.years.includes(te.value), ce = eb(c.value, te.value);
      return { active: M, disabled: G, highlighted: ce };
    })), Q = (te, M, G) => {
      G !== void 0 ? te.value = G : te.value = !te.value, te.value ? (S.value = !0, i("overlay-opened", M)) : (S.value = !1, i("overlay-closed", M));
    }, Y = (te = !1, M) => {
      q(te), Q(k, Xn.month, M);
    }, V = (te = !1, M) => {
      q(te), Q(w, Xn.year, M);
    }, q = (te) => {
      te || i("reset-flow");
    }, B = (te, M) => {
      r.arrowNavigation && ($.value[M] = Tn(te), m($.value, "monthYear"));
    }, pe = J(() => {
      var te, M, G, ce, F, xe;
      return [
        {
          type: hr.month,
          index: 1,
          toggle: Y,
          modelValue: L.value,
          updateModelValue: (Be) => L.value = Be,
          text: A.value.text,
          showSelectionGrid: k.value,
          items: T.value,
          ariaLabel: (te = s.value) == null ? void 0 : te.openMonthsOverlay,
          overlayLabel: ((G = (M = s.value).monthPicker) == null ? void 0 : G.call(M, !0)) ?? void 0
        },
        {
          type: hr.year,
          index: 2,
          toggle: V,
          modelValue: j.value,
          updateModelValue: (Be) => j.value = Be,
          text: tT(r.year, r.locale),
          showSelectionGrid: w.value,
          items: N.value,
          ariaLabel: (ce = s.value) == null ? void 0 : ce.openYearsOverlay,
          overlayLabel: ((xe = (F = s.value).yearPicker) == null ? void 0 : xe.call(F, !0)) ?? void 0
        }
      ];
    }), oe = J(() => r.disableYearSelect ? [pe.value[0]] : r.yearFirst ? [...pe.value].reverse() : pe.value);
    return e({
      toggleMonthPicker: Y,
      toggleYearPicker: V,
      handleMonthYearChange: g
    }), (te, M) => {
      var G, ce, F, xe, Be, lt;
      return _(), Z("div", mV, [
        te.$slots["month-year"] ? (_(), Z("div", gV, [
          ne(te.$slots, "month-year", Ct(Zt({ month: t.month, year: t.year, months: t.months, years: t.years, updateMonthYear: E(y), handleMonthYearChange: E(g), instance: t.instance })))
        ])) : (_(), Z(Qe, { key: 1 }, [
          te.$slots["top-extra"] ? (_(), Z("div", OV, [
            ne(te.$slots, "top-extra", { value: te.internalModelValue })
          ])) : W("", !0),
          X("div", vV, [
            E(b)(E(a), t.instance) && !te.vertical ? (_(), ue(lc, {
              key: 0,
              "aria-label": (G = E(s)) == null ? void 0 : G.prevMonth,
              disabled: E(O)(!1),
              class: Ae((ce = E(h)) == null ? void 0 : ce.navBtnPrev),
              "el-name": "action-prev",
              onActivate: M[0] || (M[0] = (de) => E(g)(!1, !0)),
              onSetRef: M[1] || (M[1] = (de) => B(de, 0))
            }, {
              default: H(() => [
                te.$slots["arrow-left"] ? ne(te.$slots, "arrow-left", { key: 0 }) : W("", !0),
                te.$slots["arrow-left"] ? W("", !0) : (_(), ue(E(Xy), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled", "class"])) : W("", !0),
            X("div", {
              class: Ae(["dp__month_year_wrap", {
                dp__year_disable_select: te.disableYearSelect
              }])
            }, [
              (_(!0), Z(Qe, null, Ge(oe.value, (de, ye) => (_(), Z(Qe, {
                key: de.type
              }, [
                X("button", {
                  ref_for: !0,
                  ref: (me) => B(me, ye + 1),
                  type: "button",
                  "data-dp-element": `overlay-${de.type}`,
                  class: Ae(["dp__btn dp__month_year_select", { "dp--hidden-el": S.value }]),
                  "aria-label": `${de.text}-${de.ariaLabel}`,
                  "data-test-id": `${de.type}-toggle-overlay-${t.instance}`,
                  onClick: de.toggle,
                  onKeydown: (me) => E(oi)(me, () => de.toggle(), !0)
                }, [
                  te.$slots[de.type] ? ne(te.$slots, de.type, {
                    key: 0,
                    text: de.text,
                    value: r[de.type]
                  }) : W("", !0),
                  te.$slots[de.type] ? W("", !0) : (_(), Z(Qe, { key: 1 }, [
                    He(Pe(de.text), 1)
                  ], 64))
                ], 42, yV),
                fe(Fn, {
                  name: E(f)(de.showSelectionGrid),
                  css: E(p)
                }, {
                  default: H(() => [
                    de.showSelectionGrid ? (_(), ue(bd, {
                      key: 0,
                      items: de.items,
                      "arrow-navigation": te.arrowNavigation,
                      "hide-navigation": te.hideNavigation,
                      "is-last": te.autoApply && !E(u).keepActionRow,
                      "skip-button-ref": !1,
                      config: te.config,
                      type: de.type,
                      "header-refs": [],
                      "esc-close": te.escClose,
                      "menu-wrap-ref": te.menuWrapRef,
                      "text-input": te.textInput,
                      "aria-labels": te.ariaLabels,
                      "overlay-label": de.overlayLabel,
                      onSelected: de.updateModelValue,
                      onToggle: de.toggle
                    }, un({
                      "button-icon": H(() => [
                        te.$slots["calendar-icon"] ? ne(te.$slots, "calendar-icon", { key: 0 }) : W("", !0),
                        te.$slots["calendar-icon"] ? W("", !0) : (_(), ue(E(mu), { key: 1 }))
                      ]),
                      _: 2
                    }, [
                      te.$slots[`${de.type}-overlay-value`] ? {
                        name: "item",
                        fn: H(({ item: me }) => [
                          ne(te.$slots, `${de.type}-overlay-value`, {
                            text: me.text,
                            value: me.value
                          })
                        ]),
                        key: "0"
                      } : void 0,
                      te.$slots[`${de.type}-overlay`] ? {
                        name: "overlay",
                        fn: H(() => [
                          ne(te.$slots, `${de.type}-overlay`, wt({ ref_for: !0 }, P.value(de.type)))
                        ]),
                        key: "1"
                      } : void 0,
                      te.$slots[`${de.type}-overlay-header`] ? {
                        name: "header",
                        fn: H(() => [
                          ne(te.$slots, `${de.type}-overlay-header`, {
                            toggle: de.toggle
                          })
                        ]),
                        key: "2"
                      } : void 0
                    ]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "config", "type", "esc-close", "menu-wrap-ref", "text-input", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : W("", !0)
                  ]),
                  _: 2
                }, 1032, ["name", "css"])
              ], 64))), 128))
            ], 2),
            E(b)(E(a), t.instance) && te.vertical ? (_(), ue(lc, {
              key: 1,
              "aria-label": (F = E(s)) == null ? void 0 : F.prevMonth,
              "el-name": "action-prev",
              disabled: E(O)(!1),
              class: Ae((xe = E(h)) == null ? void 0 : xe.navBtnPrev),
              onActivate: M[2] || (M[2] = (de) => E(g)(!1, !0))
            }, {
              default: H(() => [
                te.$slots["arrow-up"] ? ne(te.$slots, "arrow-up", { key: 0 }) : W("", !0),
                te.$slots["arrow-up"] ? W("", !0) : (_(), ue(E(Yy), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled", "class"])) : W("", !0),
            E(v)(E(a), t.instance) ? (_(), ue(lc, {
              key: 2,
              ref: "rightIcon",
              "el-name": "action-next",
              disabled: E(O)(!0),
              "aria-label": (Be = E(s)) == null ? void 0 : Be.nextMonth,
              class: Ae((lt = E(h)) == null ? void 0 : lt.navBtnNext),
              onActivate: M[3] || (M[3] = (de) => E(g)(!0, !0)),
              onSetRef: M[4] || (M[4] = (de) => B(de, te.disableYearSelect ? 2 : 3))
            }, {
              default: H(() => [
                te.$slots[te.vertical ? "arrow-down" : "arrow-right"] ? ne(te.$slots, te.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : W("", !0),
                te.$slots[te.vertical ? "arrow-down" : "arrow-right"] ? W("", !0) : (_(), ue(ar(te.vertical ? E(Hy) : E(zy)), { key: 1 }))
              ]),
              _: 3
            }, 8, ["disabled", "aria-label", "class"])) : W("", !0)
          ])
        ], 64))
      ]);
    };
  }
}), wV = {
  class: "dp__calendar_header",
  role: "row"
}, kV = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, SV = ["aria-label"], _V = {
  key: 0,
  class: "dp__calendar_item dp__week_num",
  role: "gridcell"
}, xV = { class: "dp__cell_inner" }, CV = ["id", "aria-pressed", "aria-disabled", "aria-label", "tabindex", "data-test-id", "onClick", "onTouchend", "onKeydown", "onMouseenter", "onMouseleave", "onMousedown"], TV = /* @__PURE__ */ Te({
  compatConfig: {
    MODE: 3
  },
  __name: "DpCalendar",
  props: {
    mappedDates: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    ...Pr
  },
  emits: [
    "select-date",
    "set-hover-date",
    "handle-scroll",
    "mount",
    "handle-swipe",
    "handle-space",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(t, { expose: e, emit: n }) {
    const i = n, r = t, { buildMultiLevelMatrix: o } = qs(), {
      defaultedTransitions: s,
      defaultedConfig: a,
      defaultedAriaLabels: l,
      defaultedMultiCalendars: u,
      defaultedWeekNumbers: c,
      defaultedMultiDates: d,
      defaultedUI: h
    } = Gt(r), f = re(null), p = re({
      bottom: "",
      left: "",
      transform: ""
    }), m = re([]), g = re(null), O = re(!0), y = re(""), b = re({ startX: 0, endX: 0, startY: 0, endY: 0 }), v = re([]), k = re({ left: "50%" }), w = re(!1), S = J(() => r.calendar ? r.calendar(r.mappedDates) : r.mappedDates), $ = J(() => r.dayNames ? Array.isArray(r.dayNames) ? r.dayNames : r.dayNames(r.locale, +r.weekStart) : aL(r.formatLocale, r.locale, +r.weekStart));
    Et(() => {
      i("mount", { cmp: "calendar", refs: m }), a.value.noSwipe || g.value && (g.value.addEventListener("touchstart", B, { passive: !1 }), g.value.addEventListener("touchend", pe, { passive: !1 }), g.value.addEventListener("touchmove", oe, { passive: !1 })), r.monthChangeOnScroll && g.value && g.value.addEventListener("wheel", G, { passive: !1 });
    });
    const C = (de) => de ? r.vertical ? "vNext" : "next" : r.vertical ? "vPrevious" : "previous", L = (de, ye) => {
      if (r.transitions) {
        const me = ci(Eo(_e(), r.month, r.year));
        y.value = mn(ci(Eo(_e(), de, ye)), me) ? s.value[C(!0)] : s.value[C(!1)], O.value = !1, nn(() => {
          O.value = !0;
        });
      }
    }, j = J(
      () => ({
        ...h.value.calendar ?? {}
      })
    ), P = J(() => (de) => {
      const ye = uL(de);
      return {
        dp__marker_dot: ye.type === "dot",
        dp__marker_line: ye.type === "line"
      };
    }), A = J(() => (de) => Ot(de, f.value)), T = J(() => ({
      dp__calendar: !0,
      dp__calendar_next: u.value.count > 0 && r.instance !== 0
    })), N = J(() => (de) => r.hideOffsetDates ? de.current : !0), Q = async (de, ye) => {
      const { width: me, height: ie } = de.getBoundingClientRect();
      f.value = ye.value;
      let I = { left: `${me / 2}px` }, ge = -50;
      if (await nn(), v.value[0]) {
        const { left: ze, width: Se } = v.value[0].getBoundingClientRect();
        ze < 0 && (I = { left: "0" }, ge = 0, k.value.left = `${me / 2}px`), window.innerWidth < ze + Se && (I = { right: "0" }, ge = 0, k.value.left = `${Se - me / 2}px`);
      }
      p.value = {
        bottom: `${ie}px`,
        ...I,
        transform: `translateX(${ge}%)`
      };
    }, Y = async (de, ye, me) => {
      var ie, I, ge;
      const ze = Tn(m.value[ye][me]);
      ze && ((ie = de.marker) != null && ie.customPosition && (ge = (I = de.marker) == null ? void 0 : I.tooltip) != null && ge.length ? p.value = de.marker.customPosition(ze) : await Q(ze, de), i("tooltip-open", de.marker));
    }, V = async (de, ye, me) => {
      var ie, I;
      if (w.value && d.value.enabled && d.value.dragSelect)
        return i("select-date", de);
      if (i("set-hover-date", de), (I = (ie = de.marker) == null ? void 0 : ie.tooltip) != null && I.length) {
        if (r.hideOffsetDates && !de.current)
          return;
        await Y(de, ye, me);
      }
    }, q = (de) => {
      f.value && (f.value = null, p.value = JSON.parse(JSON.stringify({ bottom: "", left: "", transform: "" })), i("tooltip-close", de.marker));
    }, B = (de) => {
      b.value.startX = de.changedTouches[0].screenX, b.value.startY = de.changedTouches[0].screenY;
    }, pe = (de) => {
      b.value.endX = de.changedTouches[0].screenX, b.value.endY = de.changedTouches[0].screenY, te();
    }, oe = (de) => {
      r.vertical && !r.inline && de.preventDefault();
    }, te = () => {
      const de = r.vertical ? "Y" : "X";
      Math.abs(b.value[`start${de}`] - b.value[`end${de}`]) > 10 && i("handle-swipe", b.value[`start${de}`] > b.value[`end${de}`] ? "right" : "left");
    }, M = (de, ye, me) => {
      de && (Array.isArray(m.value[ye]) ? m.value[ye][me] = de : m.value[ye] = [de]), r.arrowNavigation && o(m.value, "calendar");
    }, G = (de) => {
      r.monthChangeOnScroll && (de.preventDefault(), i("handle-scroll", de));
    }, ce = (de) => c.value.type === "local" ? Fy(de.value, { weekStartsOn: +r.weekStart }) : c.value.type === "iso" ? By(de.value) : typeof c.value.type == "function" ? c.value.type(de.value) : "", F = (de) => {
      const ye = de[0];
      return c.value.hideOnOffsetDates ? de.some((me) => me.current) ? ce(ye) : "" : ce(ye);
    }, xe = (de, ye, me = !0) => {
      me && Fw() || !me && !Fw() || (!d.value.enabled || a.value.allowPreventDefault) && (Ss(de, a.value), i("select-date", ye));
    }, Be = (de) => {
      Ss(de, a.value);
    }, lt = (de) => {
      d.value.enabled && d.value.dragSelect ? (w.value = !0, i("select-date", de)) : d.value.enabled && i("select-date", de);
    };
    return e({ triggerTransition: L }), (de, ye) => (_(), Z("div", {
      class: Ae(T.value)
    }, [
      X("div", {
        ref_key: "calendarWrapRef",
        ref: g,
        class: Ae(j.value),
        role: "grid"
      }, [
        X("div", wV, [
          de.weekNumbers ? (_(), Z("div", kV, Pe(de.weekNumName), 1)) : W("", !0),
          (_(!0), Z(Qe, null, Ge($.value, (me, ie) => {
            var I, ge;
            return _(), Z("div", {
              key: ie,
              class: "dp__calendar_header_item",
              role: "gridcell",
              "data-test-id": "calendar-header",
              "aria-label": (ge = (I = E(l)) == null ? void 0 : I.weekDay) == null ? void 0 : ge.call(I, ie)
            }, [
              de.$slots["calendar-header"] ? ne(de.$slots, "calendar-header", {
                key: 0,
                day: me,
                index: ie
              }) : W("", !0),
              de.$slots["calendar-header"] ? W("", !0) : (_(), Z(Qe, { key: 1 }, [
                He(Pe(me), 1)
              ], 64))
            ], 8, SV);
          }), 128))
        ]),
        ye[2] || (ye[2] = X("div", { class: "dp__calendar_header_separator" }, null, -1)),
        fe(Fn, {
          name: y.value,
          css: !!de.transitions
        }, {
          default: H(() => [
            O.value ? (_(), Z("div", {
              key: 0,
              class: "dp__calendar",
              role: "rowgroup",
              onMouseleave: ye[1] || (ye[1] = (me) => w.value = !1)
            }, [
              (_(!0), Z(Qe, null, Ge(S.value, (me, ie) => (_(), Z("div", {
                key: ie,
                class: "dp__calendar_row",
                role: "row"
              }, [
                de.weekNumbers ? (_(), Z("div", _V, [
                  X("div", xV, Pe(F(me.days)), 1)
                ])) : W("", !0),
                (_(!0), Z(Qe, null, Ge(me.days, (I, ge) => {
                  var ze, Se, st;
                  return _(), Z("div", {
                    id: E(uT)(I.value),
                    ref_for: !0,
                    ref: (D) => M(D, ie, ge),
                    key: ge + ie,
                    role: "gridcell",
                    class: "dp__calendar_item",
                    "aria-pressed": (I.classData.dp__active_date || I.classData.dp__range_start || I.classData.dp__range_start) ?? void 0,
                    "aria-disabled": I.classData.dp__cell_disabled || void 0,
                    "aria-label": (Se = (ze = E(l)) == null ? void 0 : ze.day) == null ? void 0 : Se.call(ze, I),
                    tabindex: !I.current && de.hideOffsetDates ? void 0 : 0,
                    "data-test-id": I.value,
                    onClick: Tt((D) => xe(D, I), ["prevent"]),
                    onTouchend: (D) => xe(D, I, !1),
                    onKeydown: (D) => E(oi)(D, () => de.$emit("select-date", I)),
                    onMouseenter: (D) => V(I, ie, ge),
                    onMouseleave: (D) => q(I),
                    onMousedown: (D) => lt(I),
                    onMouseup: ye[0] || (ye[0] = (D) => w.value = !1)
                  }, [
                    X("div", {
                      class: Ae(["dp__cell_inner", I.classData])
                    }, [
                      de.$slots.day && N.value(I) ? ne(de.$slots, "day", {
                        key: 0,
                        day: +I.text,
                        date: I.value
                      }) : W("", !0),
                      de.$slots.day ? W("", !0) : (_(), Z(Qe, { key: 1 }, [
                        He(Pe(I.text), 1)
                      ], 64)),
                      I.marker && N.value(I) ? (_(), Z(Qe, { key: 2 }, [
                        de.$slots.marker ? ne(de.$slots, "marker", {
                          key: 0,
                          marker: I.marker,
                          day: +I.text,
                          date: I.value
                        }) : (_(), Z("div", {
                          key: 1,
                          class: Ae(P.value(I.marker)),
                          style: pt(I.marker.color ? { backgroundColor: I.marker.color } : {})
                        }, null, 6))
                      ], 64)) : W("", !0),
                      A.value(I.value) ? (_(), Z("div", {
                        key: 3,
                        ref_for: !0,
                        ref_key: "activeTooltip",
                        ref: v,
                        class: "dp__marker_tooltip",
                        style: pt(p.value)
                      }, [
                        (st = I.marker) != null && st.tooltip ? (_(), Z("div", {
                          key: 0,
                          class: "dp__tooltip_content",
                          onClick: Be
                        }, [
                          (_(!0), Z(Qe, null, Ge(I.marker.tooltip, (D, x) => (_(), Z("div", {
                            key: x,
                            class: "dp__tooltip_text"
                          }, [
                            de.$slots["marker-tooltip"] ? ne(de.$slots, "marker-tooltip", {
                              key: 0,
                              tooltip: D,
                              day: I.value
                            }) : W("", !0),
                            de.$slots["marker-tooltip"] ? W("", !0) : (_(), Z(Qe, { key: 1 }, [
                              X("div", {
                                class: "dp__tooltip_mark",
                                style: pt(D.color ? { backgroundColor: D.color } : {})
                              }, null, 4),
                              X("div", null, Pe(D.text), 1)
                            ], 64))
                          ]))), 128)),
                          X("div", {
                            class: "dp__arrow_bottom_tp",
                            style: pt(k.value)
                          }, null, 4)
                        ])) : W("", !0)
                      ], 4)) : W("", !0)
                    ], 2)
                  ], 40, CV);
                }), 128))
              ]))), 128))
            ], 32)) : W("", !0)
          ]),
          _: 3
        }, 8, ["name", "css"])
      ], 2)
    ], 2));
  }
}), jw = (t) => Array.isArray(t), $V = (t, e, n, i) => {
  const r = re([]), o = re(/* @__PURE__ */ new Date()), s = re(), a = () => B(t.isTextInputDate), { modelValue: l, calendars: u, time: c, today: d } = kd(t, e, a), {
    defaultedMultiCalendars: h,
    defaultedStartTime: f,
    defaultedRange: p,
    defaultedConfig: m,
    defaultedTz: g,
    propDates: O,
    defaultedMultiDates: y
  } = Gt(t), { validateMonthYearInRange: b, isDisabled: v, isDateRangeAllowed: k, checkMinMaxRange: w } = Ws(t), { updateTimeValues: S, getSetDateTime: $, setTime: C, assignStartTime: L, validateTime: j, disabledTimesConfig: P } = gT(t, c, l, i), A = J(
    () => (z) => u.value[z] ? u.value[z].month : 0
  ), T = J(
    () => (z) => u.value[z] ? u.value[z].year : 0
  ), N = (z) => !m.value.keepViewOnOffsetClick || z ? !0 : !s.value, Q = (z, ae, Me, he = !1) => {
    var Re, Fe;
    N(he) && (u.value[z] || (u.value[z] = { month: 0, year: 0 }), u.value[z].month = Zw(ae) ? (Re = u.value[z]) == null ? void 0 : Re.month : ae, u.value[z].year = Zw(Me) ? (Fe = u.value[z]) == null ? void 0 : Fe.year : Me);
  }, Y = () => {
    t.autoApply && e("select-date");
  };
  Et(() => {
    t.shadow || (l.value || (de(), f.value && L(f.value)), B(!0), t.focusStartDate && t.startDate && de());
  });
  const V = J(() => {
    var z;
    return (z = t.flow) != null && z.length && !t.partialFlow ? t.flowStep === t.flow.length : !0;
  }), q = () => {
    t.autoApply && V.value && e("auto-apply", t.partialFlow ? t.flowStep !== t.flow.length : !1);
  }, B = (z = !1) => {
    if (l.value)
      return Array.isArray(l.value) ? (r.value = l.value, F(z)) : te(l.value, z);
    if (h.value.count && z && !t.startDate)
      return oe(_e(), z);
  }, pe = () => Array.isArray(l.value) && p.value.enabled ? ft(l.value[0]) === ft(l.value[1] ?? l.value[0]) : !1, oe = (z = /* @__PURE__ */ new Date(), ae = !1) => {
    if ((!h.value.count || !h.value.static || ae) && Q(0, ft(z), rt(z)), h.value.count && (!l.value || pe() || !h.value.solo) && (!h.value.solo || ae))
      for (let Me = 1; Me < h.value.count; Me++) {
        const he = Qt(_e(), { month: A.value(Me - 1), year: T.value(Me - 1) }), Re = EC(he, { months: 1 });
        u.value[Me] = { month: ft(Re), year: rt(Re) };
      }
  }, te = (z, ae) => {
    oe(z), C("hours", Lo(z)), C("minutes", Es(z)), C("seconds", Ql(z)), h.value.count && ae && lt();
  }, M = (z) => {
    if (h.value.count) {
      if (h.value.solo)
        return 0;
      const ae = ft(z[0]), Me = ft(z[1]);
      return Math.abs(Me - ae) < h.value.count ? 0 : 1;
    }
    return 1;
  }, G = (z, ae) => {
    z[1] && p.value.showLastInRange ? oe(z[M(z)], ae) : oe(z[0], ae);
    const Me = (he, Re) => [
      he(z[0]),
      z[1] ? he(z[1]) : c[Re][1]
    ];
    C("hours", Me(Lo, "hours")), C("minutes", Me(Es, "minutes")), C("seconds", Me(Ql, "seconds"));
  }, ce = (z, ae) => {
    if ((p.value.enabled || t.weekPicker) && !y.value.enabled)
      return G(z, ae);
    if (y.value.enabled && ae) {
      const Me = z[z.length - 1];
      return te(Me, ae);
    }
  }, F = (z) => {
    const ae = l.value;
    ce(ae, z), h.value.count && h.value.solo && lt();
  }, xe = (z, ae) => {
    const Me = Qt(_e(), { month: A.value(ae), year: T.value(ae) }), he = z < 0 ? br(Me, 1) : Il(Me, 1);
    b(ft(he), rt(he), z < 0, t.preventMinMaxNavigation) && (Q(ae, ft(he), rt(he)), e("update-month-year", { instance: ae, month: ft(he), year: rt(he) }), h.value.count && !h.value.solo && Be(ae), n());
  }, Be = (z) => {
    for (let ae = z - 1; ae >= 0; ae--) {
      const Me = Il(Qt(_e(), { month: A.value(ae + 1), year: T.value(ae + 1) }), 1);
      Q(ae, ft(Me), rt(Me));
    }
    for (let ae = z + 1; ae <= h.value.count - 1; ae++) {
      const Me = br(Qt(_e(), { month: A.value(ae - 1), year: T.value(ae - 1) }), 1);
      Q(ae, ft(Me), rt(Me));
    }
  }, lt = () => {
    if (Array.isArray(l.value) && l.value.length === 2) {
      const z = _e(
        _e(l.value[1] ? l.value[1] : br(l.value[0], 1))
      ), [ae, Me] = [ft(l.value[0]), rt(l.value[0])], [he, Re] = [ft(l.value[1]), rt(l.value[1])];
      (ae !== he || ae === he && Me !== Re) && h.value.solo && Q(1, ft(z), rt(z));
    } else
      l.value && !Array.isArray(l.value) && (Q(0, ft(l.value), rt(l.value)), oe(_e()));
  }, de = () => {
    t.startDate && (Q(0, ft(_e(t.startDate)), rt(_e(t.startDate))), h.value.count && Be(0));
  }, ye = (z, ae) => {
    if (t.monthChangeOnScroll) {
      const Me = (/* @__PURE__ */ new Date()).getTime() - o.value.getTime(), he = Math.abs(z.deltaY);
      let Re = 500;
      he > 1 && (Re = 100), he > 100 && (Re = 0), Me > Re && (o.value = /* @__PURE__ */ new Date(), xe(t.monthChangeOnScroll !== "inverse" ? -z.deltaY : z.deltaY, ae));
    }
  }, me = (z, ae, Me = !1) => {
    t.monthChangeOnArrows && t.vertical === Me && ie(z, ae);
  }, ie = (z, ae) => {
    xe(z === "right" ? -1 : 1, ae);
  }, I = (z) => {
    if (O.value.markers)
      return uf(z.value, O.value.markers);
  }, ge = (z, ae) => {
    switch (t.sixWeeks === !0 ? "append" : t.sixWeeks) {
      case "prepend":
        return [!0, !1];
      case "center":
        return [z == 0, !0];
      case "fair":
        return [z == 0 || ae > z, !0];
      case "append":
        return [!1, !1];
      default:
        return [!1, !1];
    }
  }, ze = (z, ae, Me, he) => {
    if (t.sixWeeks && z.length < 6) {
      const Re = 6 - z.length, Fe = (ae.getDay() + 7 - he) % 7, fn = 6 - (Me.getDay() + 7 - he) % 7, [ti, cr] = ge(Fe, fn);
      for (let Wi = 1; Wi <= Re; Wi++)
        if (cr ? !!(Wi % 2) == ti : ti) {
          const Rr = z[0].days[0], Ks = Se(mr(Rr.value, -7), ft(ae));
          z.unshift({ days: Ks });
        } else {
          const Rr = z[z.length - 1], Ks = Rr.days[Rr.days.length - 1], Ua = Se(mr(Ks.value, 1), ft(ae));
          z.push({ days: Ua });
        }
    }
    return z;
  }, Se = (z, ae) => {
    const Me = _e(z), he = [];
    for (let Re = 0; Re < 7; Re++) {
      const Fe = mr(Me, Re), fn = ft(Fe) !== ae;
      he.push({
        text: t.hideOffsetDates && fn ? "" : Fe.getDate(),
        value: Fe,
        current: !fn,
        classData: {}
      });
    }
    return he;
  }, st = (z, ae) => {
    const Me = [], he = new Date(ae, z), Re = new Date(ae, z + 1, 0), Fe = t.weekStart, fn = kr(he, { weekStartsOn: Fe }), ti = (cr) => {
      const Wi = Se(cr, z);
      if (Me.push({ days: Wi }), !Me[Me.length - 1].days.some(
        (Rr) => Ot(ci(Rr.value), ci(Re))
      )) {
        const Rr = mr(cr, 7);
        ti(Rr);
      }
    };
    return ti(fn), ze(Me, he, Re, Fe);
  }, D = (z) => {
    const ae = _s(_e(z.value), c.hours, c.minutes, se());
    e("date-update", ae), y.value.enabled ? tb(ae, l, y.value.limit) : l.value = ae, i(), nn().then(() => {
      q();
    });
  }, x = (z) => p.value.noDisabledRange ? rT(r.value[0], z).some((ae) => v(ae)) : !1, U = () => {
    r.value = l.value ? l.value.slice() : [], r.value.length === 2 && !(p.value.fixedStart || p.value.fixedEnd) && (r.value = []);
  }, K = (z, ae) => {
    const Me = [
      _e(z.value),
      mr(_e(z.value), +p.value.autoRange)
    ];
    k(Me) ? (ae && ke(z.value), r.value = Me) : e("invalid-date", z.value);
  }, ke = (z) => {
    const ae = ft(_e(z)), Me = rt(_e(z));
    if (Q(0, ae, Me), h.value.count > 0)
      for (let he = 1; he < h.value.count; he++) {
        const Re = gL(
          Qt(_e(z), { year: T.value(he - 1), month: A.value(he - 1) })
        );
        Q(he, Re.month, Re.year);
      }
  }, Ve = (z) => {
    if (x(z.value) || !w(z.value, l.value, p.value.fixedStart ? 0 : 1))
      return e("invalid-date", z.value);
    r.value = fT(_e(z.value), l, e, p);
  }, be = (z, ae) => {
    if (U(), p.value.autoRange)
      return K(z, ae);
    if (p.value.fixedStart || p.value.fixedEnd)
      return Ve(z);
    r.value[0] ? w(_e(z.value), l.value) && !x(z.value) ? sn(_e(z.value), _e(r.value[0])) ? (r.value.unshift(_e(z.value)), e("range-end", r.value[0])) : (r.value[1] = _e(z.value), e("range-end", r.value[1])) : (t.autoApply && e("auto-apply-invalid", z.value), e("invalid-date", z.value)) : (r.value[0] = _e(z.value), e("range-start", r.value[0]));
  }, se = (z = !0) => t.enableSeconds ? Array.isArray(c.seconds) ? z ? c.seconds[0] : c.seconds[1] : c.seconds : 0, Oe = (z) => {
    r.value[z] = _s(
      r.value[z],
      c.hours[z],
      c.minutes[z],
      se(z !== 1)
    );
  }, at = () => {
    var z, ae;
    r.value[0] && r.value[1] && +((z = r.value) == null ? void 0 : z[0]) > +((ae = r.value) == null ? void 0 : ae[1]) && (r.value.reverse(), e("range-start", r.value[0]), e("range-end", r.value[1]));
  }, $t = () => {
    r.value.length && (r.value[0] && !r.value[1] ? Oe(0) : (Oe(0), Oe(1), i()), at(), l.value = r.value.slice(), zp(r.value, e, t.autoApply, t.modelAuto));
  }, Qn = (z, ae = !1) => {
    if (v(z.value) || !z.current && t.hideOffsetDates)
      return e("invalid-date", z.value);
    if (s.value = JSON.parse(JSON.stringify(z)), !p.value.enabled)
      return D(z);
    jw(c.hours) && jw(c.minutes) && !y.value.enabled && (be(z, ae), $t());
  }, qi = (z, ae) => {
    var Me;
    Q(z, ae.month, ae.year, !0), h.value.count && !h.value.solo && Be(z), e("update-month-year", { instance: z, month: ae.month, year: ae.year }), n(h.value.solo ? z : void 0);
    const he = (Me = t.flow) != null && Me.length ? t.flow[t.flowStep] : void 0;
    !ae.fromNav && (he === Xn.month || he === Xn.year) && i();
  }, Mi = (z, ae) => {
    hT({
      value: z,
      modelValue: l,
      range: p.value.enabled,
      timezone: ae ? void 0 : g.value.timezone
    }), Y(), t.multiCalendars && nn().then(() => B(!0));
  }, R = () => {
    const z = Uy(_e(), g.value);
    !p.value.enabled && !y.value.enabled ? l.value = z : l.value && Array.isArray(l.value) && l.value[0] ? y.value.enabled ? l.value = [...l.value, z] : l.value = sn(z, l.value[0]) ? [z, l.value[0]] : [l.value[0], z] : l.value = [z], Y();
  }, le = () => {
    if (Array.isArray(l.value))
      if (y.value.enabled) {
        const z = $e();
        l.value[l.value.length - 1] = $(z);
      } else
        l.value = l.value.map((z, ae) => z && $(z, ae));
    else
      l.value = $(l.value);
    e("time-update");
  }, $e = () => Array.isArray(l.value) && l.value.length ? l.value[l.value.length - 1] : null;
  return {
    calendars: u,
    modelValue: l,
    month: A,
    year: T,
    time: c,
    disabledTimesConfig: P,
    today: d,
    validateTime: j,
    getCalendarDays: st,
    getMarker: I,
    handleScroll: ye,
    handleSwipe: ie,
    handleArrow: me,
    selectDate: Qn,
    updateMonthYear: qi,
    presetDate: Mi,
    selectCurrentDate: R,
    updateTime: (z, ae = !0, Me = !1) => {
      S(z, ae, Me, le);
    },
    assignMonthAndYear: oe
  };
}, PV = { key: 0 }, MV = /* @__PURE__ */ Te({
  __name: "DatePicker",
  props: {
    ...Pr
  },
  emits: [
    "tooltip-open",
    "tooltip-close",
    "mount",
    "update:internal-model-value",
    "update-flow-step",
    "reset-flow",
    "auto-apply",
    "focus-menu",
    "select-date",
    "range-start",
    "range-end",
    "invalid-fixed-range",
    "time-update",
    "am-pm-change",
    "time-picker-open",
    "time-picker-close",
    "recalculate-position",
    "update-month-year",
    "auto-apply-invalid",
    "date-update",
    "invalid-date",
    "overlay-toggle"
  ],
  setup(t, { expose: e, emit: n }) {
    const i = n, r = t, {
      calendars: o,
      month: s,
      year: a,
      modelValue: l,
      time: u,
      disabledTimesConfig: c,
      today: d,
      validateTime: h,
      getCalendarDays: f,
      getMarker: p,
      handleArrow: m,
      handleScroll: g,
      handleSwipe: O,
      selectDate: y,
      updateMonthYear: b,
      presetDate: v,
      selectCurrentDate: k,
      updateTime: w,
      assignMonthAndYear: S
    } = $V(r, i, pe, oe), $ = zo(), { setHoverDate: C, getDayClassData: L, clearHoverDate: j } = jV(l, r), { defaultedMultiCalendars: P } = Gt(r), A = re([]), T = re([]), N = re(null), Q = Vi($, "calendar"), Y = Vi($, "monthYear"), V = Vi($, "timePicker"), q = (ye) => {
      r.shadow || i("mount", ye);
    };
    gt(
      o,
      () => {
        r.shadow || setTimeout(() => {
          i("recalculate-position");
        }, 0);
      },
      { deep: !0 }
    ), gt(
      P,
      (ye, me) => {
        ye.count - me.count > 0 && S();
      },
      { deep: !0 }
    );
    const B = J(() => (ye) => f(s.value(ye), a.value(ye)).map((me) => ({
      ...me,
      days: me.days.map((ie) => (ie.marker = p(ie), ie.classData = L(ie), ie))
    })));
    function pe(ye) {
      var me;
      ye || ye === 0 ? (me = T.value[ye]) == null || me.triggerTransition(s.value(ye), a.value(ye)) : T.value.forEach((ie, I) => ie.triggerTransition(s.value(I), a.value(I)));
    }
    function oe() {
      i("update-flow-step");
    }
    const te = (ye, me = !1) => {
      y(ye, me), r.spaceConfirm && i("select-date");
    }, M = (ye, me, ie = 0) => {
      var I;
      (I = A.value[ie]) == null || I.toggleMonthPicker(ye, me);
    }, G = (ye, me, ie = 0) => {
      var I;
      (I = A.value[ie]) == null || I.toggleYearPicker(ye, me);
    }, ce = (ye, me, ie) => {
      var I;
      (I = N.value) == null || I.toggleTimePicker(ye, me, ie);
    }, F = (ye, me) => {
      var ie;
      if (!r.range) {
        const I = l.value ? l.value : d, ge = me ? new Date(me) : I, ze = ye ? kr(ge, { weekStartsOn: 1 }) : LC(ge, { weekStartsOn: 1 });
        y({
          value: ze,
          current: ft(ge) === s.value(0),
          text: "",
          classData: {}
        }), (ie = document.getElementById(uT(ze))) == null || ie.focus();
      }
    }, xe = (ye) => {
      var me;
      (me = A.value[0]) == null || me.handleMonthYearChange(ye, !0);
    }, Be = (ye) => {
      b(0, { month: s.value(0), year: a.value(0) + (ye ? 1 : -1), fromNav: !0 });
    }, lt = (ye, me) => {
      ye === Xn.time && i(`time-picker-${me ? "open" : "close"}`), i("overlay-toggle", { open: me, overlay: ye });
    }, de = (ye) => {
      i("overlay-toggle", { open: !1, overlay: ye }), i("focus-menu");
    };
    return e({
      clearHoverDate: j,
      presetDate: v,
      selectCurrentDate: k,
      toggleMonthPicker: M,
      toggleYearPicker: G,
      toggleTimePicker: ce,
      handleArrow: m,
      updateMonthYear: b,
      getSidebarProps: () => ({
        modelValue: l,
        month: s,
        year: a,
        time: u,
        updateTime: w,
        updateMonthYear: b,
        selectDate: y,
        presetDate: v
      }),
      changeMonth: xe,
      changeYear: Be,
      selectWeekDate: F
    }), (ye, me) => (_(), Z(Qe, null, [
      fe(Xp, {
        "multi-calendars": E(P).count,
        collapse: ye.collapse,
        "is-mobile": ye.isMobile
      }, {
        default: H(({ instance: ie, index: I }) => [
          ye.disableMonthYearSelect ? W("", !0) : (_(), ue(bV, wt({
            key: 0,
            ref: (ge) => {
              ge && (A.value[I] = ge);
            },
            months: E(KC)(ye.formatLocale, ye.locale, ye.monthNameFormat),
            years: E(Gy)(ye.yearRange, ye.locale, ye.reverseYears),
            month: E(s)(ie),
            year: E(a)(ie),
            instance: ie
          }, ye.$props, {
            onMount: me[0] || (me[0] = (ge) => q(E(ga).header)),
            onResetFlow: me[1] || (me[1] = (ge) => ye.$emit("reset-flow")),
            onUpdateMonthYear: (ge) => E(b)(ie, ge),
            onOverlayClosed: de,
            onOverlayOpened: me[2] || (me[2] = (ge) => ye.$emit("overlay-toggle", { open: !0, overlay: ge }))
          }), un({ _: 2 }, [
            Ge(E(Y), (ge, ze) => ({
              name: ge,
              fn: H((Se) => [
                ne(ye.$slots, ge, Ct(Zt(Se)))
              ])
            }))
          ]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])),
          fe(TV, wt({
            ref: (ge) => {
              ge && (T.value[I] = ge);
            },
            "mapped-dates": B.value(ie),
            month: E(s)(ie),
            year: E(a)(ie),
            instance: ie
          }, ye.$props, {
            onSelectDate: (ge) => E(y)(ge, ie !== 1),
            onHandleSpace: (ge) => te(ge, ie !== 1),
            onSetHoverDate: me[3] || (me[3] = (ge) => E(C)(ge)),
            onHandleScroll: (ge) => E(g)(ge, ie),
            onHandleSwipe: (ge) => E(O)(ge, ie),
            onMount: me[4] || (me[4] = (ge) => q(E(ga).calendar)),
            onResetFlow: me[5] || (me[5] = (ge) => ye.$emit("reset-flow")),
            onTooltipOpen: me[6] || (me[6] = (ge) => ye.$emit("tooltip-open", ge)),
            onTooltipClose: me[7] || (me[7] = (ge) => ye.$emit("tooltip-close", ge))
          }), un({ _: 2 }, [
            Ge(E(Q), (ge, ze) => ({
              name: ge,
              fn: H((Se) => [
                ne(ye.$slots, ge, Ct(Zt({ ...Se })))
              ])
            }))
          ]), 1040, ["mapped-dates", "month", "year", "instance", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
        ]),
        _: 3
      }, 8, ["multi-calendars", "collapse", "is-mobile"]),
      ye.enableTimePicker ? (_(), Z("div", PV, [
        ye.$slots["time-picker"] ? ne(ye.$slots, "time-picker", Ct(wt({ key: 0 }, { time: E(u), updateTime: E(w) }))) : (_(), ue(mT, wt({
          key: 1,
          ref_key: "timePickerRef",
          ref: N
        }, ye.$props, {
          hours: E(u).hours,
          minutes: E(u).minutes,
          seconds: E(u).seconds,
          "internal-model-value": ye.internalModelValue,
          "disabled-times-config": E(c),
          "validate-time": E(h),
          onMount: me[8] || (me[8] = (ie) => q(E(ga).timePicker)),
          "onUpdate:hours": me[9] || (me[9] = (ie) => E(w)(ie)),
          "onUpdate:minutes": me[10] || (me[10] = (ie) => E(w)(ie, !1)),
          "onUpdate:seconds": me[11] || (me[11] = (ie) => E(w)(ie, !1, !0)),
          onResetFlow: me[12] || (me[12] = (ie) => ye.$emit("reset-flow")),
          onOverlayClosed: me[13] || (me[13] = (ie) => lt(ie, !1)),
          onOverlayOpened: me[14] || (me[14] = (ie) => lt(ie, !0)),
          onAmPmChange: me[15] || (me[15] = (ie) => ye.$emit("am-pm-change", ie))
        }), un({ _: 2 }, [
          Ge(E(V), (ie, I) => ({
            name: ie,
            fn: H((ge) => [
              ne(ye.$slots, ie, Ct(Zt(ge)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"]))
      ])) : W("", !0)
    ], 64));
  }
}), EV = (t, e) => {
  const n = re(), {
    defaultedMultiCalendars: i,
    defaultedConfig: r,
    defaultedHighlight: o,
    defaultedRange: s,
    propDates: a,
    defaultedFilters: l,
    defaultedMultiDates: u
  } = Gt(t), { modelValue: c, year: d, month: h, calendars: f } = kd(t, e), { isDisabled: p } = Ws(t), { selectYear: m, groupedYears: g, showYearPicker: O, isDisabled: y, toggleYearPicker: b, handleYearSelect: v, handleYear: k } = pT({
    modelValue: c,
    multiCalendars: i,
    range: s,
    highlight: o,
    calendars: f,
    propDates: a,
    month: h,
    year: d,
    filters: l,
    props: t,
    emit: e
  }), w = (N, Q) => [N, Q].map((Y) => no(Y, "MMMM", { locale: t.formatLocale })).join("-"), S = J(() => (N) => c.value ? Array.isArray(c.value) ? c.value.some((Q) => Lw(N, Q)) : Lw(c.value, N) : !1), $ = (N) => {
    if (s.value.enabled) {
      if (Array.isArray(c.value)) {
        const Q = Ot(N, c.value[0]) || Ot(N, c.value[1]);
        return qp(c.value, n.value, N) && !Q;
      }
      return !1;
    }
    return !1;
  }, C = (N, Q) => N.quarter === Aw(Q) && N.year === rt(Q), L = (N) => typeof o.value == "function" ? o.value({ quarter: Aw(N), year: rt(N) }) : !!o.value.quarters.find((Q) => C(Q, N)), j = J(() => (N) => {
    const Q = Qt(/* @__PURE__ */ new Date(), { year: d.value(N) });
    return aN({
      start: Rc(Q),
      end: IC(Q)
    }).map((Y) => {
      const V = ca(Y), q = Rw(Y), B = p(Y), pe = $(V), oe = L(V);
      return {
        text: w(V, q),
        value: V,
        active: S.value(V),
        highlighted: oe,
        disabled: B,
        isBetween: pe
      };
    });
  }), P = (N) => {
    tb(N, c, u.value.limit), e("auto-apply", !0);
  }, A = (N) => {
    c.value = nb(c, N, e), zp(c.value, e, t.autoApply, t.modelAuto);
  }, T = (N) => {
    c.value = N, e("auto-apply");
  };
  return {
    defaultedConfig: r,
    defaultedMultiCalendars: i,
    groupedYears: g,
    year: d,
    isDisabled: y,
    quarters: j,
    showYearPicker: O,
    modelValue: c,
    setHoverDate: (N) => {
      n.value = N;
    },
    selectYear: m,
    selectQuarter: (N, Q, Y) => {
      if (!Y)
        return f.value[Q].month = ft(Rw(N)), u.value.enabled ? P(N) : s.value.enabled ? A(N) : T(N);
    },
    toggleYearPicker: b,
    handleYearSelect: v,
    handleYear: k
  };
}, AV = { class: "dp--quarter-items" }, RV = ["data-test-id", "disabled", "onClick", "onMouseover"], DV = /* @__PURE__ */ Te({
  compatConfig: {
    MODE: 3
  },
  __name: "QuarterPicker",
  props: {
    ...Pr
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "overlay-closed",
    "auto-apply",
    "range-start",
    "range-end",
    "overlay-toggle",
    "update-month-year"
  ],
  setup(t, { expose: e, emit: n }) {
    const i = n, r = t, o = zo(), s = Vi(o, "yearMode"), {
      defaultedMultiCalendars: a,
      defaultedConfig: l,
      groupedYears: u,
      year: c,
      isDisabled: d,
      quarters: h,
      modelValue: f,
      showYearPicker: p,
      setHoverDate: m,
      selectQuarter: g,
      toggleYearPicker: O,
      handleYearSelect: y,
      handleYear: b
    } = EV(r, i);
    return e({ getSidebarProps: () => ({
      modelValue: f,
      year: c,
      selectQuarter: g,
      handleYearSelect: y,
      handleYear: b
    }) }), (v, k) => (_(), ue(Xp, {
      "multi-calendars": E(a).count,
      collapse: v.collapse,
      stretch: "",
      "is-mobile": v.isMobile
    }, {
      default: H(({ instance: w }) => [
        X("div", {
          class: "dp-quarter-picker-wrap",
          style: pt({ minHeight: `${E(l).modeHeight}px` })
        }, [
          v.$slots["top-extra"] ? ne(v.$slots, "top-extra", {
            key: 0,
            value: v.internalModelValue
          }) : W("", !0),
          X("div", null, [
            fe(dT, wt(v.$props, {
              items: E(u)(w),
              instance: w,
              "show-year-picker": E(p)[w],
              year: E(c)(w),
              "is-disabled": (S) => E(d)(w, S),
              onHandleYear: (S) => E(b)(w, S),
              onYearSelect: (S) => E(y)(S, w),
              onToggleYearPicker: (S) => E(O)(w, S == null ? void 0 : S.flow, S == null ? void 0 : S.show)
            }), un({ _: 2 }, [
              Ge(E(s), (S, $) => ({
                name: S,
                fn: H((C) => [
                  ne(v.$slots, S, Ct(Zt(C)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          X("div", AV, [
            (_(!0), Z(Qe, null, Ge(E(h)(w), (S, $) => (_(), Z("div", { key: $ }, [
              X("button", {
                type: "button",
                class: Ae(["dp--qr-btn", {
                  "dp--qr-btn-active": S.active,
                  "dp--qr-btn-between": S.isBetween,
                  "dp--qr-btn-disabled": S.disabled,
                  "dp--highlighted": S.highlighted
                }]),
                "data-test-id": S.value,
                disabled: S.disabled,
                onClick: (C) => E(g)(S.value, w, S.disabled),
                onMouseover: (C) => E(m)(S.value)
              }, [
                v.$slots.quarter ? ne(v.$slots, "quarter", {
                  key: 0,
                  value: S.value,
                  text: S.text
                }) : (_(), Z(Qe, { key: 1 }, [
                  He(Pe(S.text), 1)
                ], 64))
              ], 42, RV)
            ]))), 128))
          ])
        ], 4)
      ]),
      _: 3
    }, 8, ["multi-calendars", "collapse", "is-mobile"]));
  }
}), OT = (t, e) => {
  const n = re(0);
  Et(() => {
    i(), window.addEventListener("resize", i, { passive: !0 });
  }), to(() => {
    window.removeEventListener("resize", i);
  });
  const i = () => {
    n.value = window.document.documentElement.clientWidth;
  };
  return {
    isMobile: J(
      () => n.value <= t.value.mobileBreakpoint && !e ? !0 : void 0
    )
  };
}, QV = ["id", "tabindex", "role", "aria-label"], NV = {
  key: 0,
  class: "dp--menu-load-container"
}, IV = {
  key: 1,
  class: "dp--menu-header"
}, LV = ["data-dp-mobile"], VV = {
  key: 0,
  class: "dp__sidebar_left"
}, BV = ["data-dp-mobile"], ZV = ["data-test-id", "data-dp-mobile", "onClick", "onKeydown"], FV = {
  key: 2,
  class: "dp__sidebar_right"
}, qV = {
  key: 3,
  class: "dp__action_extra"
}, Yw = /* @__PURE__ */ Te({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerMenu",
  props: {
    ...Wp,
    shadow: { type: Boolean, default: !1 },
    openOnTop: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null },
    noOverlayFocus: { type: Boolean, default: !1 },
    collapse: { type: Boolean, default: !1 },
    getInputRect: { type: Function, default: () => ({}) },
    isTextInputDate: { type: Boolean, default: !1 }
  },
  emits: [
    "close-picker",
    "select-date",
    "auto-apply",
    "time-update",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "update:internal-model-value",
    "recalculate-position",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "auto-apply-invalid",
    "date-update",
    "invalid-date",
    "overlay-toggle",
    "menu-blur"
  ],
  setup(t, { expose: e, emit: n }) {
    const i = n, r = t, o = re(null), s = J(() => {
      const { openOnTop: x, ...U } = r;
      return {
        ...U,
        isMobile: m.value,
        flowStep: j.value,
        menuWrapRef: o.value
      };
    }), { setMenuFocused: a, setShiftKey: l, control: u } = cT(), c = zo(), { defaultedTextInput: d, defaultedInline: h, defaultedConfig: f, defaultedUI: p } = Gt(r), { isMobile: m } = OT(f, r.shadow), g = re(null), O = re(0), y = re(null), b = re(!1), v = re(null), k = re(!1);
    Et(() => {
      if (!r.shadow) {
        b.value = !0, w(), window.addEventListener("resize", w);
        const x = Tn(o);
        if (x && !d.value.enabled && !h.value.enabled && (a(!0), V()), x) {
          const U = (K) => {
            k.value = !0, f.value.allowPreventDefault && K.preventDefault(), Ss(K, f.value, !0);
          };
          x.addEventListener("pointerdown", U), x.addEventListener("mousedown", U);
        }
      }
      document.addEventListener("mousedown", D);
    }), to(() => {
      window.removeEventListener("resize", w), document.addEventListener("mousedown", D);
    });
    const w = () => {
      const x = Tn(y);
      x && (O.value = x.getBoundingClientRect().width);
    }, { arrowRight: S, arrowLeft: $, arrowDown: C, arrowUp: L } = qs(), { flowStep: j, updateFlowStep: P, childMount: A, resetFlow: T, handleFlow: N } = YV(r, i, v), Q = J(() => r.monthPicker ? KL : r.yearPicker ? eV : r.timePicker ? pV : r.quarterPicker ? DV : MV), Y = J(() => {
      var x;
      if (f.value.arrowLeft)
        return f.value.arrowLeft;
      const U = (x = o.value) == null ? void 0 : x.getBoundingClientRect(), K = r.getInputRect();
      return (K == null ? void 0 : K.width) < (O == null ? void 0 : O.value) && (K == null ? void 0 : K.left) <= ((U == null ? void 0 : U.left) ?? 0) ? `${(K == null ? void 0 : K.width) / 2}px` : (K == null ? void 0 : K.right) >= ((U == null ? void 0 : U.right) ?? 0) && (K == null ? void 0 : K.width) < (O == null ? void 0 : O.value) ? `${(O == null ? void 0 : O.value) - (K == null ? void 0 : K.width) / 2}px` : "50%";
    }), V = () => {
      const x = Tn(o);
      x && x.focus({ preventScroll: !0 });
    }, q = J(() => {
      var x;
      return ((x = v.value) == null ? void 0 : x.getSidebarProps()) || {};
    }), B = () => {
      r.openOnTop && i("recalculate-position");
    }, pe = Vi(c, "action"), oe = J(() => r.monthPicker || r.yearPicker ? Vi(c, "monthYear") : r.timePicker ? Vi(c, "timePicker") : Vi(c, "shared")), te = J(() => r.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), M = J(() => ({
      dp__menu_disabled: r.disabled,
      dp__menu_readonly: r.readonly,
      "dp-menu-loading": r.loading
    })), G = J(
      () => ({
        dp__menu: !0,
        dp__menu_index: !h.value.enabled,
        dp__relative: h.value.enabled,
        ...p.value.menu ?? {}
      })
    ), ce = (x) => {
      Ss(x, f.value, !0);
    }, F = () => {
      r.escClose && i("close-picker");
    }, xe = (x) => {
      if (r.arrowNavigation) {
        if (x === ni.up)
          return L();
        if (x === ni.down)
          return C();
        if (x === ni.left)
          return $();
        if (x === ni.right)
          return S();
      } else
        x === ni.left || x === ni.up ? me("handleArrow", ni.left, 0, x === ni.up) : me("handleArrow", ni.right, 0, x === ni.down);
    }, Be = (x) => {
      l(x.shiftKey), !r.disableMonthYearSelect && x.code === Wt.tab && x.target.classList.contains("dp__menu") && u.value.shiftKeyInMenu && (x.preventDefault(), Ss(x, f.value, !0), i("close-picker"));
    }, lt = () => {
      V(), i("time-picker-close");
    }, de = (x) => {
      var U, K, ke;
      (U = v.value) == null || U.toggleTimePicker(!1, !1), (K = v.value) == null || K.toggleMonthPicker(!1, !1, x), (ke = v.value) == null || ke.toggleYearPicker(!1, !1, x);
    }, ye = (x, U = 0) => {
      var K, ke, Ve;
      return x === "month" ? (K = v.value) == null ? void 0 : K.toggleMonthPicker(!1, !0, U) : x === "year" ? (ke = v.value) == null ? void 0 : ke.toggleYearPicker(!1, !0, U) : x === "time" ? (Ve = v.value) == null ? void 0 : Ve.toggleTimePicker(!0, !1) : de(U);
    }, me = (x, ...U) => {
      var K, ke;
      (K = v.value) != null && K[x] && ((ke = v.value) == null || ke[x](...U));
    }, ie = () => {
      me("selectCurrentDate");
    }, I = (x, U) => {
      me("presetDate", x, U);
    }, ge = () => {
      me("clearHoverDate");
    }, ze = (x, U) => {
      me("updateMonthYear", x, U);
    }, Se = (x, U) => {
      x.preventDefault(), xe(U);
    }, st = (x) => {
      var U, K, ke;
      if (Be(x), x.key === Wt.home || x.key === Wt.end)
        return me(
          "selectWeekDate",
          x.key === Wt.home,
          x.target.getAttribute("id")
        );
      switch ((x.key === Wt.pageUp || x.key === Wt.pageDown) && (x.shiftKey ? (me("changeYear", x.key === Wt.pageUp), (U = EO(o.value, "overlay-year")) == null || U.focus()) : (me("changeMonth", x.key === Wt.pageUp), (K = EO(o.value, x.key === Wt.pageUp ? "action-prev" : "action-next")) == null || K.focus()), x.target.getAttribute("id") && ((ke = o.value) == null || ke.focus({ preventScroll: !0 }))), x.key) {
        case Wt.esc:
          return F();
        case Wt.arrowLeft:
          return Se(x, ni.left);
        case Wt.arrowRight:
          return Se(x, ni.right);
        case Wt.arrowUp:
          return Se(x, ni.up);
        case Wt.arrowDown:
          return Se(x, ni.down);
        default:
          return;
      }
    }, D = (x) => {
      var U;
      h.value.enabled && !h.value.input && !((U = o.value) != null && U.contains(x.target)) && k.value && (k.value = !1, i("menu-blur"));
    };
    return e({
      updateMonthYear: ze,
      switchView: ye,
      handleFlow: N
    }), (x, U) => {
      var K, ke, Ve;
      return _(), Z("div", {
        id: x.uid ? `dp-menu-${x.uid}` : void 0,
        ref_key: "dpMenuRef",
        ref: o,
        tabindex: E(h).enabled ? void 0 : "0",
        role: E(h).enabled ? void 0 : "dialog",
        "aria-label": (K = x.ariaLabels) == null ? void 0 : K.menu,
        class: Ae(G.value),
        style: pt({ "--dp-arrow-left": Y.value }),
        onMouseleave: ge,
        onClick: ce,
        onKeydown: st
      }, [
        (x.disabled || x.readonly) && E(h).enabled || x.loading ? (_(), Z("div", {
          key: 0,
          class: Ae(M.value)
        }, [
          x.loading ? (_(), Z("div", NV, U[19] || (U[19] = [
            X("span", { class: "dp--menu-loader" }, null, -1)
          ]))) : W("", !0)
        ], 2)) : W("", !0),
        x.$slots["menu-header"] ? (_(), Z("div", IV, [
          ne(x.$slots, "menu-header")
        ])) : W("", !0),
        !E(h).enabled && !x.teleportCenter ? (_(), Z("div", {
          key: 2,
          class: Ae(te.value)
        }, null, 2)) : W("", !0),
        X("div", {
          ref_key: "innerMenuRef",
          ref: y,
          class: Ae({
            dp__menu_content_wrapper: ((ke = x.presetDates) == null ? void 0 : ke.length) || !!x.$slots["left-sidebar"] || !!x.$slots["right-sidebar"],
            "dp--menu-content-wrapper-collapsed": t.collapse && (((Ve = x.presetDates) == null ? void 0 : Ve.length) || !!x.$slots["left-sidebar"] || !!x.$slots["right-sidebar"])
          }),
          "data-dp-mobile": E(m),
          style: pt({ "--dp-menu-width": `${O.value}px` })
        }, [
          x.$slots["left-sidebar"] ? (_(), Z("div", VV, [
            ne(x.$slots, "left-sidebar", Ct(Zt(q.value)))
          ])) : W("", !0),
          x.presetDates.length ? (_(), Z("div", {
            key: 1,
            class: Ae({ "dp--preset-dates-collapsed": t.collapse, "dp--preset-dates": !0 }),
            "data-dp-mobile": E(m)
          }, [
            (_(!0), Z(Qe, null, Ge(x.presetDates, (be, se) => (_(), Z(Qe, { key: se }, [
              be.slot ? ne(x.$slots, be.slot, {
                key: 0,
                presetDate: I,
                label: be.label,
                value: be.value
              }) : (_(), Z("button", {
                key: 1,
                type: "button",
                style: pt(be.style || {}),
                class: Ae(["dp__btn dp--preset-range", { "dp--preset-range-collapsed": t.collapse }]),
                "data-test-id": be.testId ?? void 0,
                "data-dp-mobile": E(m),
                onClick: Tt((Oe) => I(be.value, be.noTz), ["prevent"]),
                onKeydown: (Oe) => E(oi)(Oe, () => I(be.value, be.noTz), !0)
              }, Pe(be.label), 47, ZV))
            ], 64))), 128))
          ], 10, BV)) : W("", !0),
          X("div", {
            ref_key: "calendarWrapperRef",
            ref: g,
            class: "dp__instance_calendar",
            role: "document"
          }, [
            (_(), ue(ar(Q.value), wt({
              ref_key: "dynCmpRef",
              ref: v
            }, s.value, {
              "flow-step": E(j),
              onMount: E(A),
              onUpdateFlowStep: E(P),
              onResetFlow: E(T),
              onFocusMenu: V,
              onSelectDate: U[0] || (U[0] = (be) => x.$emit("select-date")),
              onDateUpdate: U[1] || (U[1] = (be) => x.$emit("date-update", be)),
              onTooltipOpen: U[2] || (U[2] = (be) => x.$emit("tooltip-open", be)),
              onTooltipClose: U[3] || (U[3] = (be) => x.$emit("tooltip-close", be)),
              onAutoApply: U[4] || (U[4] = (be) => x.$emit("auto-apply", be)),
              onRangeStart: U[5] || (U[5] = (be) => x.$emit("range-start", be)),
              onRangeEnd: U[6] || (U[6] = (be) => x.$emit("range-end", be)),
              onInvalidFixedRange: U[7] || (U[7] = (be) => x.$emit("invalid-fixed-range", be)),
              onTimeUpdate: U[8] || (U[8] = (be) => x.$emit("time-update")),
              onAmPmChange: U[9] || (U[9] = (be) => x.$emit("am-pm-change", be)),
              onTimePickerOpen: U[10] || (U[10] = (be) => x.$emit("time-picker-open", be)),
              onTimePickerClose: lt,
              onRecalculatePosition: B,
              onUpdateMonthYear: U[11] || (U[11] = (be) => x.$emit("update-month-year", be)),
              onAutoApplyInvalid: U[12] || (U[12] = (be) => x.$emit("auto-apply-invalid", be)),
              onInvalidDate: U[13] || (U[13] = (be) => x.$emit("invalid-date", be)),
              onOverlayToggle: U[14] || (U[14] = (be) => x.$emit("overlay-toggle", be)),
              "onUpdate:internalModelValue": U[15] || (U[15] = (be) => x.$emit("update:internal-model-value", be))
            }), un({ _: 2 }, [
              Ge(oe.value, (be, se) => ({
                name: be,
                fn: H((Oe) => [
                  ne(x.$slots, be, Ct(Zt({ ...Oe })))
                ])
              }))
            ]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))
          ], 512),
          x.$slots["right-sidebar"] ? (_(), Z("div", FV, [
            ne(x.$slots, "right-sidebar", Ct(Zt(q.value)))
          ])) : W("", !0),
          x.$slots["action-extra"] ? (_(), Z("div", qV, [
            x.$slots["action-extra"] ? ne(x.$slots, "action-extra", {
              key: 0,
              selectCurrentDate: ie
            }) : W("", !0)
          ])) : W("", !0)
        ], 14, LV),
        !x.autoApply || E(f).keepActionRow ? (_(), ue(qL, wt({
          key: 3,
          "menu-mount": b.value
        }, s.value, {
          "calendar-width": O.value,
          onClosePicker: U[16] || (U[16] = (be) => x.$emit("close-picker")),
          onSelectDate: U[17] || (U[17] = (be) => x.$emit("select-date")),
          onInvalidSelect: U[18] || (U[18] = (be) => x.$emit("invalid-select")),
          onSelectNow: ie
        }), un({ _: 2 }, [
          Ge(E(pe), (be, se) => ({
            name: be,
            fn: H((Oe) => [
              ne(x.$slots, be, Ct(Zt({ ...Oe })))
            ])
          }))
        ]), 1040, ["menu-mount", "calendar-width"])) : W("", !0)
      ], 46, QV);
    };
  }
});
var sl = /* @__PURE__ */ ((t) => (t.center = "center", t.left = "left", t.right = "right", t))(sl || {});
const WV = ({
  menuRef: t,
  menuRefInner: e,
  inputRef: n,
  pickerWrapperRef: i,
  inline: r,
  emit: o,
  props: s,
  slots: a
}) => {
  const { defaultedConfig: l } = Gt(s), u = re({}), c = re(!1), d = re({
    top: "0",
    left: "0"
  }), h = re(!1), f = Ca(s, "teleportCenter");
  gt(f, () => {
    d.value = JSON.parse(JSON.stringify({})), k();
  });
  const p = (Q) => {
    if (s.teleport) {
      const Y = Q.getBoundingClientRect();
      return {
        left: Y.left + window.scrollX,
        top: Y.top + window.scrollY
      };
    }
    return { top: 0, left: 0 };
  }, m = (Q, Y) => {
    d.value.left = `${Q + Y - u.value.width}px`;
  }, g = (Q) => {
    d.value.left = `${Q}px`;
  }, O = (Q, Y) => {
    s.position === sl.left && g(Q), s.position === sl.right && m(Q, Y), s.position === sl.center && (d.value.left = `${Q + Y / 2 - u.value.width / 2}px`);
  }, y = (Q) => {
    const { width: Y, height: V } = Q.getBoundingClientRect(), { top: q, left: B } = p(Q);
    return { top: +q, left: +B, width: Y, height: V };
  }, b = () => {
    d.value.left = "50%", d.value.top = "50%", d.value.transform = "translate(-50%, -50%)", d.value.position = "fixed", delete d.value.opacity;
  }, v = () => {
    const Q = Tn(n);
    d.value = s.altPosition(Q);
  }, k = (Q = !0) => {
    var Y;
    if (!r.value.enabled) {
      if (f.value)
        return b();
      if (s.altPosition !== null)
        return v();
      if (Q) {
        const V = s.teleport ? (Y = e.value) == null ? void 0 : Y.$el : t.value;
        V && (u.value = V.getBoundingClientRect()), o("recalculate-position");
      }
      return P();
    }
  }, w = ({ inputEl: Q, left: Y, width: V }) => {
    window.screen.width > 768 && !c.value && O(Y, V), C(Q);
  }, S = (Q) => {
    const { top: Y, left: V, height: q, width: B } = y(Q);
    d.value.top = `${q + Y + +s.offset}px`, h.value = !1, c.value || (d.value.left = `${V + B / 2 - u.value.width / 2}px`), w({ inputEl: Q, left: V, width: B });
  }, $ = (Q) => {
    const { top: Y, left: V, width: q } = y(Q);
    d.value.top = `${Y - +s.offset - u.value.height}px`, h.value = !0, w({ inputEl: Q, left: V, width: q });
  }, C = (Q) => {
    if (s.autoPosition) {
      const { left: Y, width: V } = y(Q), { left: q, right: B } = u.value;
      if (!c.value) {
        if (Math.abs(q) !== Math.abs(B)) {
          if (q <= 0)
            return c.value = !0, g(Y);
          if (B >= document.documentElement.clientWidth)
            return c.value = !0, m(Y, V);
        }
        return O(Y, V);
      }
    }
  }, L = () => {
    const Q = Tn(n);
    if (Q) {
      if (s.autoPosition === fr.top)
        return fr.top;
      if (s.autoPosition === fr.bottom)
        return fr.bottom;
      const { height: Y } = u.value, { top: V, height: q } = Q.getBoundingClientRect(), B = window.innerHeight - V - q, pe = V;
      return Y <= B ? fr.bottom : Y > B && Y <= pe ? fr.top : B >= pe ? fr.bottom : fr.top;
    }
    return fr.bottom;
  }, j = (Q) => L() === fr.bottom ? S(Q) : $(Q), P = () => {
    const Q = Tn(n);
    if (Q)
      return s.autoPosition ? j(Q) : S(Q);
  }, A = function(Q) {
    if (Q) {
      const Y = Q.scrollHeight > Q.clientHeight, V = window.getComputedStyle(Q).overflowY.indexOf("hidden") !== -1;
      return Y && !V;
    }
    return !0;
  }, T = function(Q) {
    return !Q || Q === document.body || Q.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : A(Q) ? Q : T(
      Q.assignedSlot && l.value.shadowDom ? Q.assignedSlot.parentNode : Q.parentNode
    );
  }, N = (Q) => {
    if (Q)
      switch (s.position) {
        case sl.left:
          return { left: 0, transform: "translateX(0)" };
        case sl.right:
          return { left: `${Q.width}px`, transform: "translateX(-100%)" };
        default:
          return { left: `${Q.width / 2}px`, transform: "translateX(-50%)" };
      }
    return {};
  };
  return {
    openOnTop: h,
    menuStyle: d,
    xCorrect: c,
    setMenuPosition: k,
    getScrollableParent: T,
    shadowRender: (Q, Y) => {
      var V, q, B;
      const pe = document.createElement("div"), oe = (V = Tn(n)) == null ? void 0 : V.getBoundingClientRect();
      pe.setAttribute("id", "dp--temp-container");
      const te = (q = i.value) != null && q.clientWidth ? i.value : document.body;
      te.append(pe);
      const M = N(oe), G = l.value.shadowDom ? Object.keys(a).filter(
        (F) => ["right-sidebar", "left-sidebar", "top-extra", "action-extra"].includes(F)
      ) : Object.keys(a), ce = ir(
        Q,
        {
          ...Y,
          shadow: !0,
          style: { opacity: 0, position: "absolute", ...M }
        },
        Object.fromEntries(G.map((F) => [F, a[F]]))
      );
      K0(ce, pe), u.value = (B = ce.el) == null ? void 0 : B.getBoundingClientRect(), K0(null, pe), te.removeChild(pe);
    }
  };
}, Jo = [
  { name: "clock-icon", use: ["time", "calendar", "shared"] },
  { name: "arrow-left", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-right", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-up", use: ["time", "calendar", "month-year", "shared"] },
  { name: "arrow-down", use: ["time", "calendar", "month-year", "shared"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar", "shared", "year-mode"] },
  { name: "day", use: ["calendar", "shared"] },
  { name: "month-overlay-value", use: ["calendar", "month-year", "shared"] },
  { name: "year-overlay-value", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "year-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay-header", use: ["month-year", "shared"] },
  { name: "year-overlay-header", use: ["month-year", "shared"] },
  { name: "hours-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "hours-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "hours", use: ["calendar", "time", "shared"] },
  { name: "minutes", use: ["calendar", "time", "shared"] },
  { name: "month", use: ["calendar", "month-year", "shared"] },
  { name: "year", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "action-buttons", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar", "shared"] },
  { name: "marker-tooltip", use: ["calendar", "shared"] },
  { name: "action-extra", use: ["menu"] },
  { name: "time-picker-overlay", use: ["calendar", "time", "shared"] },
  { name: "am-pm-button", use: ["calendar", "time", "shared"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year", "shared"] },
  { name: "time-picker", use: ["menu", "shared"] },
  { name: "action-row", use: ["action"] },
  { name: "marker", use: ["calendar", "shared"] },
  { name: "quarter", use: ["shared"] },
  { name: "top-extra", use: ["shared", "month-year"] },
  { name: "tp-inline-arrow-up", use: ["shared", "time"] },
  { name: "tp-inline-arrow-down", use: ["shared", "time"] },
  { name: "menu-header", use: ["menu"] }
], XV = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], zV = {
  all: () => Jo,
  monthYear: () => Jo.filter((t) => t.use.includes("month-year")),
  input: () => XV,
  timePicker: () => Jo.filter((t) => t.use.includes("time")),
  action: () => Jo.filter((t) => t.use.includes("action")),
  calendar: () => Jo.filter((t) => t.use.includes("calendar")),
  menu: () => Jo.filter((t) => t.use.includes("menu")),
  shared: () => Jo.filter((t) => t.use.includes("shared")),
  yearMode: () => Jo.filter((t) => t.use.includes("year-mode"))
}, Vi = (t, e, n) => {
  const i = [];
  return zV[e]().forEach((r) => {
    t[r.name] && i.push(r.name);
  }), n != null && n.length && n.forEach((r) => {
    r.slot && i.push(r.slot);
  }), i;
}, wd = (t) => {
  const e = J(() => (i) => t.value ? i ? t.value.open : t.value.close : ""), n = J(() => (i) => t.value ? i ? t.value.menuAppearTop : t.value.menuAppearBottom : "");
  return { transitionName: e, showTransition: !!t.value, menuTransition: n };
}, kd = (t, e, n) => {
  const { defaultedRange: i, defaultedTz: r } = Gt(t), o = _e(xi(_e(), r.value.timezone)), s = re([{ month: ft(o), year: rt(o) }]), a = (h) => {
    const f = {
      hours: Lo(o),
      minutes: Es(o),
      seconds: 0
    };
    return i.value.enabled ? [f[h], f[h]] : f[h];
  }, l = Bs({
    hours: a("hours"),
    minutes: a("minutes"),
    seconds: a("seconds")
  });
  gt(
    i,
    (h, f) => {
      h.enabled !== f.enabled && (l.hours = a("hours"), l.minutes = a("minutes"), l.seconds = a("seconds"));
    },
    { deep: !0 }
  );
  const u = J({
    get: () => t.internalModelValue,
    set: (h) => {
      !t.readonly && !t.disabled && e("update:internal-model-value", h);
    }
  }), c = J(
    () => (h) => s.value[h] ? s.value[h].month : 0
  ), d = J(
    () => (h) => s.value[h] ? s.value[h].year : 0
  );
  return gt(
    u,
    (h, f) => {
      n && JSON.stringify(h ?? {}) !== JSON.stringify(f ?? {}) && n();
    },
    { deep: !0 }
  ), {
    calendars: s,
    time: l,
    modelValue: u,
    month: c,
    year: d,
    today: o
  };
}, jV = (t, e) => {
  const {
    defaultedMultiCalendars: n,
    defaultedMultiDates: i,
    defaultedUI: r,
    defaultedHighlight: o,
    defaultedTz: s,
    propDates: a,
    defaultedRange: l
  } = Gt(e), { isDisabled: u } = Ws(e), c = re(null), d = re(xi(/* @__PURE__ */ new Date(), s.value.timezone)), h = (M) => {
    !M.current && e.hideOffsetDates || (c.value = M.value);
  }, f = () => {
    c.value = null;
  }, p = (M) => Array.isArray(t.value) && l.value.enabled && t.value[0] && c.value ? M ? mn(c.value, t.value[0]) : sn(c.value, t.value[0]) : !0, m = (M, G) => {
    const ce = () => t.value ? G ? t.value[0] || null : t.value[1] : null, F = t.value && Array.isArray(t.value) ? ce() : null;
    return Ot(_e(M.value), F);
  }, g = (M) => {
    const G = Array.isArray(t.value) ? t.value[0] : null;
    return M ? !sn(c.value ?? null, G) : !0;
  }, O = (M, G = !0) => (l.value.enabled || e.weekPicker) && Array.isArray(t.value) && t.value.length === 2 ? e.hideOffsetDates && !M.current ? !1 : Ot(_e(M.value), t.value[G ? 0 : 1]) : l.value.enabled ? m(M, G) && g(G) || Ot(M.value, Array.isArray(t.value) ? t.value[0] : null) && p(G) : !1, y = (M, G) => {
    if (Array.isArray(t.value) && t.value[0] && t.value.length === 1) {
      const ce = Ot(M.value, c.value);
      return G ? mn(t.value[0], M.value) && ce : sn(t.value[0], M.value) && ce;
    }
    return !1;
  }, b = (M) => !t.value || e.hideOffsetDates && !M.current ? !1 : l.value.enabled ? e.modelAuto && Array.isArray(t.value) ? Ot(M.value, t.value[0] ? t.value[0] : d.value) : !1 : i.value.enabled && Array.isArray(t.value) ? t.value.some((G) => Ot(G, M.value)) : Ot(M.value, t.value ? t.value : d.value), v = (M) => {
    if (l.value.autoRange || e.weekPicker) {
      if (c.value) {
        if (e.hideOffsetDates && !M.current)
          return !1;
        const G = mr(c.value, +l.value.autoRange), ce = To(_e(c.value), e.weekStart);
        return e.weekPicker ? Ot(ce[1], _e(M.value)) : Ot(G, _e(M.value));
      }
      return !1;
    }
    return !1;
  }, k = (M) => {
    if (l.value.autoRange || e.weekPicker) {
      if (c.value) {
        const G = mr(c.value, +l.value.autoRange);
        if (e.hideOffsetDates && !M.current)
          return !1;
        const ce = To(_e(c.value), e.weekStart);
        return e.weekPicker ? mn(M.value, ce[0]) && sn(M.value, ce[1]) : mn(M.value, c.value) && sn(M.value, G);
      }
      return !1;
    }
    return !1;
  }, w = (M) => {
    if (l.value.autoRange || e.weekPicker) {
      if (c.value) {
        if (e.hideOffsetDates && !M.current)
          return !1;
        const G = To(_e(c.value), e.weekStart);
        return e.weekPicker ? Ot(G[0], M.value) : Ot(c.value, M.value);
      }
      return !1;
    }
    return !1;
  }, S = (M) => qp(t.value, c.value, M.value), $ = () => e.modelAuto && Array.isArray(e.internalModelValue) ? !!e.internalModelValue[0] : !1, C = () => e.modelAuto ? JC(e.internalModelValue) : !0, L = (M) => {
    if (e.weekPicker)
      return !1;
    const G = l.value.enabled ? !O(M) && !O(M, !1) : !0;
    return !u(M.value) && !b(M) && !(!M.current && e.hideOffsetDates) && G;
  }, j = (M) => l.value.enabled ? e.modelAuto ? $() && b(M) : !1 : b(M), P = (M) => o.value ? fL(M.value, a.value.highlight) : !1, A = (M) => {
    const G = u(M.value);
    return G && (typeof o.value == "function" ? !o.value(M.value, G) : !o.value.options.highlightDisabled);
  }, T = (M) => {
    var G;
    return typeof o.value == "function" ? o.value(M.value) : (G = o.value.weekdays) == null ? void 0 : G.includes(M.value.getDay());
  }, N = (M) => (l.value.enabled || e.weekPicker) && (!(n.value.count > 0) || M.current) && C() && !(!M.current && e.hideOffsetDates) && !b(M) ? S(M) : !1, Q = (M) => {
    const { isRangeStart: G, isRangeEnd: ce } = B(M), F = l.value.enabled ? G || ce : !1;
    return {
      dp__cell_offset: !M.current,
      dp__pointer: !e.disabled && !(!M.current && e.hideOffsetDates) && !u(M.value),
      dp__cell_disabled: u(M.value),
      dp__cell_highlight: !A(M) && (P(M) || T(M)) && !j(M) && !F && !w(M) && !(N(M) && e.weekPicker) && !ce,
      dp__cell_highlight_active: !A(M) && (P(M) || T(M)) && j(M),
      dp__today: !e.noToday && Ot(M.value, d.value) && M.current,
      "dp--past": sn(M.value, d.value),
      "dp--future": mn(M.value, d.value)
    };
  }, Y = (M) => ({
    dp__active_date: j(M),
    dp__date_hover: L(M)
  }), V = (M) => {
    if (t.value && !Array.isArray(t.value)) {
      const G = To(t.value, e.weekStart);
      return {
        ...oe(M),
        dp__range_start: Ot(G[0], M.value),
        dp__range_end: Ot(G[1], M.value),
        dp__range_between_week: mn(M.value, G[0]) && sn(M.value, G[1])
      };
    }
    return {
      ...oe(M)
    };
  }, q = (M) => {
    if (t.value && Array.isArray(t.value)) {
      const G = To(t.value[0], e.weekStart), ce = t.value[1] ? To(t.value[1], e.weekStart) : [];
      return {
        ...oe(M),
        dp__range_start: Ot(G[0], M.value) || Ot(ce[0], M.value),
        dp__range_end: Ot(G[1], M.value) || Ot(ce[1], M.value),
        dp__range_between_week: mn(M.value, G[0]) && sn(M.value, G[1]) || mn(M.value, ce[0]) && sn(M.value, ce[1]),
        dp__range_between: mn(M.value, G[1]) && sn(M.value, ce[0])
      };
    }
    return {
      ...oe(M)
    };
  }, B = (M) => {
    const G = n.value.count > 0 ? M.current && O(M) && C() : O(M) && C(), ce = n.value.count > 0 ? M.current && O(M, !1) && C() : O(M, !1) && C();
    return { isRangeStart: G, isRangeEnd: ce };
  }, pe = (M) => {
    const { isRangeStart: G, isRangeEnd: ce } = B(M);
    return {
      dp__range_start: G,
      dp__range_end: ce,
      dp__range_between: N(M),
      dp__date_hover: Ot(M.value, c.value) && !G && !ce && !e.weekPicker,
      dp__date_hover_start: y(M, !0),
      dp__date_hover_end: y(M, !1)
    };
  }, oe = (M) => ({
    ...pe(M),
    dp__cell_auto_range: k(M),
    dp__cell_auto_range_start: w(M),
    dp__cell_auto_range_end: v(M)
  }), te = (M) => l.value.enabled ? l.value.autoRange ? oe(M) : e.modelAuto ? { ...Y(M), ...pe(M) } : e.weekPicker ? q(M) : pe(M) : e.weekPicker ? V(M) : Y(M);
  return {
    setHoverDate: h,
    clearHoverDate: f,
    getDayClassData: (M) => e.hideOffsetDates && !M.current ? {} : {
      ...Q(M),
      ...te(M),
      [e.dayClass ? e.dayClass(M.value, e.internalModelValue) : ""]: !0,
      ...r.value.calendarCell ?? {}
    }
  };
}, Ws = (t) => {
  const { defaultedFilters: e, defaultedRange: n, propDates: i, defaultedMultiDates: r } = Gt(t), o = (T) => i.value.disabledDates ? typeof i.value.disabledDates == "function" ? i.value.disabledDates(_e(T)) : !!uf(T, i.value.disabledDates) : !1, s = (T) => i.value.maxDate ? t.yearPicker ? rt(T) > rt(i.value.maxDate) : mn(T, i.value.maxDate) : !1, a = (T) => i.value.minDate ? t.yearPicker ? rt(T) < rt(i.value.minDate) : sn(T, i.value.minDate) : !1, l = (T) => {
    const N = s(T), Q = a(T), Y = o(T), V = e.value.months.map((te) => +te).includes(ft(T)), q = t.disabledWeekDays.length ? t.disabledWeekDays.some((te) => +te === eI(T)) : !1, B = f(T), pe = rt(T), oe = pe < +t.yearRange[0] || pe > +t.yearRange[1];
    return !(N || Q || Y || V || oe || q || B);
  }, u = (T, N) => sn(...ps(i.value.minDate, T, N)) || Ot(...ps(i.value.minDate, T, N)), c = (T, N) => mn(...ps(i.value.maxDate, T, N)) || Ot(...ps(i.value.maxDate, T, N)), d = (T, N, Q) => {
    let Y = !1;
    return i.value.maxDate && Q && c(T, N) && (Y = !0), i.value.minDate && !Q && u(T, N) && (Y = !0), Y;
  }, h = (T, N, Q, Y) => {
    let V = !1;
    return Y && (i.value.minDate || i.value.maxDate) ? i.value.minDate && i.value.maxDate ? V = d(T, N, Q) : (i.value.minDate && u(T, N) || i.value.maxDate && c(T, N)) && (V = !0) : V = !0, V;
  }, f = (T) => Array.isArray(i.value.allowedDates) && !i.value.allowedDates.length ? !0 : i.value.allowedDates ? !uf(T, i.value.allowedDates) : !1, p = (T) => !l(T), m = (T) => n.value.noDisabledRange ? !NC({ start: T[0], end: T[1] }).some((N) => p(N)) : !0, g = (T) => {
    if (T) {
      const N = rt(T);
      return N >= +t.yearRange[0] && N <= t.yearRange[1];
    }
    return !0;
  }, O = (T, N) => !!(Array.isArray(T) && T[N] && (n.value.maxRange || n.value.minRange) && g(T[N])), y = (T, N, Q = 0) => {
    if (O(N, Q) && g(T)) {
      const Y = RC(T, N[Q]), V = rT(N[Q], T), q = V.length === 1 ? 0 : V.filter((pe) => p(pe)).length, B = Math.abs(Y) - (n.value.minMaxRawRange ? 0 : q);
      if (n.value.minRange && n.value.maxRange)
        return B >= +n.value.minRange && B <= +n.value.maxRange;
      if (n.value.minRange)
        return B >= +n.value.minRange;
      if (n.value.maxRange)
        return B <= +n.value.maxRange;
    }
    return !0;
  }, b = () => !t.enableTimePicker || t.monthPicker || t.yearPicker || t.ignoreTimeValidation, v = (T) => Array.isArray(T) ? [T[0] ? zm(T[0]) : null, T[1] ? zm(T[1]) : null] : zm(T), k = (T, N, Q) => T.find(
    (Y) => +Y.hours === Lo(N) && Y.minutes === "*" ? !0 : +Y.minutes === Es(N) && +Y.hours === Lo(N)
  ) && Q, w = (T, N, Q) => {
    const [Y, V] = T, [q, B] = N;
    return !k(Y, q, Q) && !k(V, B, Q) && Q;
  }, S = (T, N) => {
    const Q = Array.isArray(N) ? N : [N];
    return Array.isArray(t.disabledTimes) ? Array.isArray(t.disabledTimes[0]) ? w(t.disabledTimes, Q, T) : !Q.some((Y) => k(t.disabledTimes, Y, T)) : T;
  }, $ = (T, N) => {
    const Q = Array.isArray(N) ? [Oa(N[0]), N[1] ? Oa(N[1]) : void 0] : Oa(N), Y = !t.disabledTimes(Q);
    return T && Y;
  }, C = (T, N) => t.disabledTimes ? Array.isArray(t.disabledTimes) ? S(N, T) : $(N, T) : N, L = (T) => {
    let N = !0;
    if (!T || b())
      return !0;
    const Q = !i.value.minDate && !i.value.maxDate ? v(T) : T;
    return (t.maxTime || i.value.maxDate) && (N = Ww(
      t.maxTime,
      i.value.maxDate,
      "max",
      $n(Q),
      N
    )), (t.minTime || i.value.minDate) && (N = Ww(
      t.minTime,
      i.value.minDate,
      "min",
      $n(Q),
      N
    )), C(T, N);
  }, j = (T) => {
    if (!t.monthPicker)
      return !0;
    let N = !0;
    const Q = _e(gr(T));
    if (i.value.minDate && i.value.maxDate) {
      const Y = _e(gr(i.value.minDate)), V = _e(gr(i.value.maxDate));
      return mn(Q, Y) && sn(Q, V) || Ot(Q, Y) || Ot(Q, V);
    }
    if (i.value.minDate) {
      const Y = _e(gr(i.value.minDate));
      N = mn(Q, Y) || Ot(Q, Y);
    }
    if (i.value.maxDate) {
      const Y = _e(gr(i.value.maxDate));
      N = sn(Q, Y) || Ot(Q, Y);
    }
    return N;
  }, P = J(() => (T) => !t.enableTimePicker || t.ignoreTimeValidation ? !0 : L(T)), A = J(() => (T) => t.monthPicker ? Array.isArray(T) && (n.value.enabled || r.value.enabled) ? !T.filter((N) => !j(N)).length : j(T) : !0);
  return {
    isDisabled: p,
    validateDate: l,
    validateMonthYearInRange: h,
    isDateRangeAllowed: m,
    checkMinMaxRange: y,
    isValidTime: L,
    isTimeValid: P,
    isMonthValid: A
  };
}, jp = () => {
  const t = J(() => (i, r) => i == null ? void 0 : i.includes(r)), e = J(() => (i, r) => i.count ? i.solo ? !0 : r === 0 : !0), n = J(() => (i, r) => i.count ? i.solo ? !0 : r === i.count - 1 : !0);
  return { hideNavigationButtons: t, showLeftIcon: e, showRightIcon: n };
}, YV = (t, e, n) => {
  const i = re(0), r = Bs({
    [ga.timePicker]: !t.enableTimePicker || t.timePicker || t.monthPicker,
    [ga.calendar]: !1,
    [ga.header]: !1
  }), o = J(() => t.monthPicker || t.timePicker), s = (d) => {
    var h;
    if ((h = t.flow) != null && h.length) {
      if (!d && o.value)
        return c();
      r[d] = !0, Object.keys(r).filter((f) => !r[f]).length || c();
    }
  }, a = () => {
    var d, h;
    (d = t.flow) != null && d.length && i.value !== -1 && (i.value += 1, e("flow-step", i.value), c()), ((h = t.flow) == null ? void 0 : h.length) === i.value && nn().then(() => l());
  }, l = () => {
    i.value = -1;
  }, u = (d, h, ...f) => {
    var p, m;
    t.flow[i.value] === d && n.value && ((m = (p = n.value)[h]) == null || m.call(p, ...f));
  }, c = (d = 0) => {
    d && (i.value += d), u(Xn.month, "toggleMonthPicker", !0), u(Xn.year, "toggleYearPicker", !0), u(Xn.calendar, "toggleTimePicker", !1, !0), u(Xn.time, "toggleTimePicker", !0, !0);
    const h = t.flow[i.value];
    (h === Xn.hours || h === Xn.minutes || h === Xn.seconds) && u(h, "toggleTimePicker", !0, !0, h);
  };
  return { childMount: s, updateFlowStep: a, resetFlow: l, handleFlow: c, flowStep: i };
}, HV = {
  key: 1,
  class: "dp__input_wrap"
}, UV = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid"], GV = {
  key: 2,
  class: "dp--clear-btn"
}, KV = ["aria-label"], JV = /* @__PURE__ */ Te({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: !1 },
    inputValue: { type: String, default: "" },
    ...Wp
  },
  emits: [
    "clear",
    "open",
    "update:input-value",
    "set-input-date",
    "close",
    "select-date",
    "set-empty-date",
    "toggle",
    "focus-prev",
    "focus",
    "blur",
    "real-blur",
    "text-input"
  ],
  setup(t, { expose: e, emit: n }) {
    const i = n, r = t, {
      defaultedTextInput: o,
      defaultedAriaLabels: s,
      defaultedInline: a,
      defaultedConfig: l,
      defaultedRange: u,
      defaultedMultiDates: c,
      defaultedUI: d,
      getDefaultPattern: h,
      getDefaultStartTime: f
    } = Gt(r), { checkMinMaxRange: p } = Ws(r), m = re(), g = re(null), O = re(!1), y = re(!1), b = J(
      () => ({
        dp__pointer: !r.disabled && !r.readonly && !o.value.enabled,
        dp__disabled: r.disabled,
        dp__input_readonly: !o.value.enabled,
        dp__input: !0,
        dp__input_icon_pad: !r.hideInputIcon,
        dp__input_valid: typeof r.state == "boolean" ? r.state : !1,
        dp__input_invalid: typeof r.state == "boolean" ? !r.state : !1,
        dp__input_focus: O.value || r.isMenuOpen,
        dp__input_reg: !o.value.enabled,
        ...d.value.input ?? {}
      })
    ), v = () => {
      i("set-input-date", null), r.clearable && r.autoApply && (i("set-empty-date"), m.value = null);
    }, k = (B) => {
      const pe = f();
      return pL(
        B,
        o.value.format ?? h(),
        pe ?? oT({}, r.enableSeconds),
        r.inputValue,
        y.value,
        r.formatLocale
      );
    }, w = (B) => {
      const { rangeSeparator: pe } = o.value, [oe, te] = B.split(`${pe}`);
      if (oe) {
        const M = k(oe.trim()), G = te ? k(te.trim()) : null;
        if (Nl(M, G))
          return;
        const ce = M && G ? [M, G] : [M];
        p(G, ce, 0) && (m.value = M ? ce : null);
      }
    }, S = () => {
      y.value = !0;
    }, $ = (B) => {
      if (u.value.enabled)
        w(B);
      else if (c.value.enabled) {
        const pe = B.split(";");
        m.value = pe.map((oe) => k(oe.trim())).filter((oe) => oe);
      } else
        m.value = k(B);
    }, C = (B) => {
      var pe;
      const oe = typeof B == "string" ? B : (pe = B.target) == null ? void 0 : pe.value;
      oe !== "" ? (o.value.openMenu && !r.isMenuOpen && i("open"), $(oe), i("set-input-date", m.value)) : v(), y.value = !1, i("update:input-value", oe), i("text-input", B, m.value);
    }, L = (B) => {
      o.value.enabled ? ($(B.target.value), o.value.enterSubmit && AO(m.value) && r.inputValue !== "" ? (i("set-input-date", m.value, !0), m.value = null) : o.value.enterSubmit && r.inputValue === "" && (m.value = null, i("clear"))) : A(B);
    }, j = (B, pe) => {
      o.value.enabled && o.value.tabSubmit && !pe && $(B.target.value), o.value.tabSubmit && AO(m.value) && r.inputValue !== "" ? (i("set-input-date", m.value, !0, !0), m.value = null) : o.value.tabSubmit && r.inputValue === "" && (m.value = null, i("clear", !0));
    }, P = () => {
      O.value = !0, i("focus"), nn().then(() => {
        var B;
        o.value.enabled && o.value.selectOnFocus && ((B = g.value) == null || B.select());
      });
    }, A = (B) => {
      if (Ss(B, l.value, !0), o.value.enabled && o.value.openMenu && !a.value.input) {
        if (o.value.openMenu === "open" && !r.isMenuOpen)
          return i("open");
        if (o.value.openMenu === "toggle")
          return i("toggle");
      } else
        o.value.enabled || i("toggle");
    }, T = () => {
      i("real-blur"), O.value = !1, (!r.isMenuOpen || a.value.enabled && a.value.input) && i("blur"), r.autoApply && o.value.enabled && m.value && !r.isMenuOpen && (i("set-input-date", m.value), i("select-date"), m.value = null);
    }, N = (B) => {
      Ss(B, l.value, !0), i("clear");
    }, Q = (B) => {
      if (B.key === "Tab" && j(B), B.key === "Enter" && L(B), !o.value.enabled) {
        if (B.code === "Tab")
          return;
        B.preventDefault();
      }
    }, Y = () => {
      var B;
      (B = g.value) == null || B.focus({ preventScroll: !0 });
    }, V = (B) => {
      m.value = B;
    }, q = (B) => {
      B.key === Wt.tab && j(B, !0);
    };
    return e({
      focusInput: Y,
      setParsedDate: V
    }), (B, pe) => {
      var oe, te, M;
      return _(), Z("div", { onClick: A }, [
        B.$slots.trigger && !B.$slots["dp-input"] && !E(a).enabled ? ne(B.$slots, "trigger", { key: 0 }) : W("", !0),
        !B.$slots.trigger && (!E(a).enabled || E(a).input) ? (_(), Z("div", HV, [
          B.$slots["dp-input"] && !B.$slots.trigger && (!E(a).enabled || E(a).enabled && E(a).input) ? ne(B.$slots, "dp-input", {
            key: 0,
            value: t.inputValue,
            isMenuOpen: t.isMenuOpen,
            onInput: C,
            onEnter: L,
            onTab: j,
            onClear: N,
            onBlur: T,
            onKeypress: Q,
            onPaste: S,
            onFocus: P,
            openMenu: () => B.$emit("open"),
            closeMenu: () => B.$emit("close"),
            toggleMenu: () => B.$emit("toggle")
          }) : W("", !0),
          B.$slots["dp-input"] ? W("", !0) : (_(), Z("input", {
            key: 1,
            id: B.uid ? `dp-input-${B.uid}` : void 0,
            ref_key: "inputRef",
            ref: g,
            "data-test-id": "dp-input",
            name: B.name,
            class: Ae(b.value),
            inputmode: E(o).enabled ? "text" : "none",
            placeholder: B.placeholder,
            disabled: B.disabled,
            readonly: B.readonly,
            required: B.required,
            value: t.inputValue,
            autocomplete: B.autocomplete,
            "aria-label": (oe = E(s)) == null ? void 0 : oe.input,
            "aria-disabled": B.disabled || void 0,
            "aria-invalid": B.state === !1 ? !0 : void 0,
            onInput: C,
            onBlur: T,
            onFocus: P,
            onKeypress: Q,
            onKeydown: pe[0] || (pe[0] = (G) => Q(G)),
            onPaste: S
          }, null, 42, UV)),
          X("div", {
            onClick: pe[3] || (pe[3] = (G) => i("toggle"))
          }, [
            B.$slots["input-icon"] && !B.hideInputIcon ? (_(), Z("span", {
              key: 0,
              class: "dp__input_icon",
              onClick: pe[1] || (pe[1] = (G) => i("toggle"))
            }, [
              ne(B.$slots, "input-icon")
            ])) : W("", !0),
            !B.$slots["input-icon"] && !B.hideInputIcon && !B.$slots["dp-input"] ? (_(), ue(E(mu), {
              key: 1,
              "aria-label": (te = E(s)) == null ? void 0 : te.calendarIcon,
              class: "dp__input_icon dp__input_icons",
              onClick: pe[2] || (pe[2] = (G) => i("toggle"))
            }, null, 8, ["aria-label"])) : W("", !0)
          ]),
          B.$slots["clear-icon"] && t.inputValue && B.clearable && !B.disabled && !B.readonly ? (_(), Z("span", GV, [
            ne(B.$slots, "clear-icon", { clear: N })
          ])) : W("", !0),
          B.clearable && !B.$slots["clear-icon"] && t.inputValue && !B.disabled && !B.readonly ? (_(), Z("button", {
            key: 3,
            "aria-label": (M = E(s)) == null ? void 0 : M.clearInput,
            class: "dp--clear-btn",
            type: "button",
            onKeydown: pe[4] || (pe[4] = (G) => E(oi)(G, () => N(G), !0, q)),
            onClick: pe[5] || (pe[5] = Tt((G) => N(G), ["prevent"]))
          }, [
            fe(E(GC), {
              class: "dp__input_icons",
              "data-test-id": "clear-icon"
            })
          ], 40, KV)) : W("", !0)
        ])) : W("", !0)
      ]);
    };
  }
}), eB = typeof window < "u" ? window : void 0, Km = () => {
}, tB = (t) => Ey() ? (Ay(t), !0) : !1, nB = (t, e, n, i) => {
  if (!t)
    return Km;
  let r = Km;
  const o = gt(
    () => E(t),
    (a) => {
      r(), a && (a.addEventListener(e, n, i), r = () => {
        a.removeEventListener(e, n, i), r = Km;
      });
    },
    { immediate: !0, flush: "post" }
  ), s = () => {
    o(), r();
  };
  return tB(s), s;
}, iB = (t, e, n, i = {}) => {
  const { window: r = eB, event: o = "pointerdown" } = i;
  return r ? nB(r, o, (s) => {
    const a = Tn(t), l = Tn(e);
    !a || !l || a === s.target || s.composedPath().includes(a) || s.composedPath().includes(l) || n(s);
  }, { passive: !0 }) : void 0;
}, rB = ["data-dp-mobile"], oB = /* @__PURE__ */ Te({
  compatConfig: {
    MODE: 3
  },
  __name: "VueDatePicker",
  props: {
    ...Wp
  },
  emits: [
    "update:model-value",
    "update:model-timezone-value",
    "text-submit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internal-model-change",
    "recalculate-position",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "date-update",
    "invalid-date",
    "overlay-toggle",
    "text-input"
  ],
  setup(t, { expose: e, emit: n }) {
    const i = n, r = t, o = zo(), s = re(!1), a = Ca(r, "modelValue"), l = Ca(r, "timezone"), u = re(null), c = re(null), d = re(null), h = re(!1), f = re(null), p = re(!1), m = re(!1), g = re(!1), O = re(!1), { setMenuFocused: y, setShiftKey: b } = cT(), { clearArrowNav: v } = qs(), { validateDate: k, isValidTime: w } = Ws(r), {
      defaultedTransitions: S,
      defaultedTextInput: $,
      defaultedInline: C,
      defaultedConfig: L,
      defaultedRange: j,
      defaultedMultiDates: P
    } = Gt(r), { menuTransition: A, showTransition: T } = wd(S), { isMobile: N } = OT(L);
    Et(() => {
      ce(r.modelValue), nn().then(() => {
        if (!C.value.enabled) {
          const he = oe(f.value);
          he == null || he.addEventListener("scroll", ge), window == null || window.addEventListener("resize", ze);
        }
      }), C.value.enabled && (s.value = !0), window == null || window.addEventListener("keyup", Se), window == null || window.addEventListener("keydown", st);
    }), to(() => {
      if (!C.value.enabled) {
        const he = oe(f.value);
        he == null || he.removeEventListener("scroll", ge), window == null || window.removeEventListener("resize", ze);
      }
      window == null || window.removeEventListener("keyup", Se), window == null || window.removeEventListener("keydown", st);
    });
    const Q = Vi(o, "all", r.presetDates), Y = Vi(o, "input");
    gt(
      [a, l],
      () => {
        ce(a.value);
      },
      { deep: !0 }
    );
    const { openOnTop: V, menuStyle: q, xCorrect: B, setMenuPosition: pe, getScrollableParent: oe, shadowRender: te } = WV({
      menuRef: u,
      menuRefInner: c,
      inputRef: d,
      pickerWrapperRef: f,
      inline: C,
      emit: i,
      props: r,
      slots: o
    }), {
      inputValue: M,
      internalModelValue: G,
      parseExternalModelValue: ce,
      emitModelValue: F,
      formatInputValue: xe,
      checkBeforeEmit: Be
    } = VL(i, r, h), lt = J(
      () => ({
        dp__main: !0,
        dp__theme_dark: r.dark,
        dp__theme_light: !r.dark,
        dp__flex_display: C.value.enabled,
        "dp--flex-display-collapsed": g.value,
        dp__flex_display_with_input: C.value.input
      })
    ), de = J(() => r.dark ? "dp__theme_dark" : "dp__theme_light"), ye = J(() => r.teleport ? {
      to: typeof r.teleport == "boolean" ? "body" : r.teleport,
      disabled: !r.teleport || C.value.enabled
    } : {}), me = J(() => ({ class: "dp__outer_menu_wrap" })), ie = J(() => C.value.enabled && (r.timePicker || r.monthPicker || r.yearPicker || r.quarterPicker)), I = () => {
      var he, Re;
      return ((Re = (he = d.value) == null ? void 0 : he.$el) == null ? void 0 : Re.getBoundingClientRect()) ?? { width: 0, left: 0, right: 0 };
    }, ge = () => {
      s.value && (L.value.closeOnScroll ? Oe() : pe());
    }, ze = () => {
      var he;
      s.value && pe();
      const Re = ((he = c.value) == null ? void 0 : he.$el.getBoundingClientRect().width) ?? 0;
      g.value = document.body.offsetWidth <= Re;
    }, Se = (he) => {
      he.key === "Tab" && !C.value.enabled && !r.teleport && L.value.tabOutClosesMenu && (f.value.contains(document.activeElement) || Oe()), m.value = he.shiftKey;
    }, st = (he) => {
      m.value = he.shiftKey;
    }, D = () => {
      !r.disabled && !r.readonly && (te(Yw, r), pe(!1), s.value = !0, s.value && i("open"), s.value || se(), ce(r.modelValue));
    }, x = () => {
      var he;
      M.value = "", se(), (he = d.value) == null || he.setParsedDate(null), i("update:model-value", null), i("update:model-timezone-value", null), i("cleared"), L.value.closeOnClearValue && Oe();
    }, U = () => {
      const he = G.value;
      return !he || !Array.isArray(he) && k(he) ? !0 : Array.isArray(he) ? P.value.enabled || he.length === 2 && k(he[0]) && k(he[1]) ? !0 : j.value.partialRange && !r.timePicker ? k(he[0]) : !1 : !1;
    }, K = () => {
      Be() && U() ? (F(), Oe()) : i("invalid-select", G.value);
    }, ke = (he) => {
      Ve(), F(), L.value.closeOnAutoApply && !he && Oe();
    }, Ve = () => {
      d.value && $.value.enabled && d.value.setParsedDate(G.value);
    }, be = (he = !1) => {
      r.autoApply && w(G.value) && U() && (j.value.enabled && Array.isArray(G.value) ? (j.value.partialRange || G.value.length === 2) && ke(he) : ke(he));
    }, se = () => {
      $.value.enabled || (G.value = null);
    }, Oe = (he = !1) => {
      he && G.value && L.value.setDateOnMenuClose && K(), C.value.enabled || (s.value && (s.value = !1, B.value = !1, y(!1), b(!1), v(), i("closed"), M.value && ce(a.value)), se(), i("blur"));
    }, at = (he, Re, Fe = !1) => {
      if (!he) {
        G.value = null;
        return;
      }
      const fn = Array.isArray(he) ? !he.some((cr) => !k(cr)) : k(he), ti = w(he);
      fn && ti ? (O.value = !0, G.value = he, Re && (p.value = Fe, K(), i("text-submit")), nn().then(() => {
        O.value = !1;
      })) : i("invalid-date", he);
    }, $t = () => {
      r.autoApply && w(G.value) && F(), Ve();
    }, Qn = () => s.value ? Oe() : D(), qi = (he) => {
      G.value = he;
    }, Mi = () => {
      $.value.enabled && (h.value = !0, xe()), i("focus");
    }, R = () => {
      if ($.value.enabled && (h.value = !1, ce(r.modelValue), p.value)) {
        const he = hL(f.value, m.value);
        he == null || he.focus();
      }
      i("blur");
    }, le = (he) => {
      c.value && c.value.updateMonthYear(0, {
        month: Bw(he.month),
        year: Bw(he.year)
      });
    }, $e = (he) => {
      ce(he ?? r.modelValue);
    }, z = (he, Re) => {
      var Fe;
      (Fe = c.value) == null || Fe.switchView(he, Re);
    }, ae = (he) => L.value.onClickOutside ? L.value.onClickOutside(he) : Oe(!0), Me = (he = 0) => {
      var Re;
      (Re = c.value) == null || Re.handleFlow(he);
    };
    return iB(u, d, () => ae(U)), e({
      closeMenu: Oe,
      selectDate: K,
      clearValue: x,
      openMenu: D,
      onScroll: ge,
      formatInputValue: xe,
      // exposed for testing purposes
      updateInternalModelValue: qi,
      // modify internal modelValue
      setMonthYear: le,
      parseModel: $e,
      switchView: z,
      toggleMenu: Qn,
      handleFlow: Me,
      dpWrapMenuRef: u
    }), (he, Re) => (_(), Z("div", {
      ref_key: "pickerWrapperRef",
      ref: f,
      class: Ae(lt.value),
      "data-datepicker-instance": "",
      "data-dp-mobile": E(N)
    }, [
      fe(JV, wt({
        ref_key: "inputRef",
        ref: d,
        "input-value": E(M),
        "onUpdate:inputValue": Re[0] || (Re[0] = (Fe) => G0(M) ? M.value = Fe : null),
        "is-menu-open": s.value
      }, he.$props, {
        onClear: x,
        onOpen: D,
        onSetInputDate: at,
        onSetEmptyDate: E(F),
        onSelectDate: K,
        onToggle: Qn,
        onClose: Oe,
        onFocus: Mi,
        onBlur: R,
        onRealBlur: Re[1] || (Re[1] = (Fe) => h.value = !1),
        onTextInput: Re[2] || (Re[2] = (Fe) => he.$emit("text-input", Fe))
      }), un({ _: 2 }, [
        Ge(E(Y), (Fe, fn) => ({
          name: Fe,
          fn: H((ti) => [
            ne(he.$slots, Fe, Ct(Zt(ti)))
          ])
        }))
      ]), 1040, ["input-value", "is-menu-open", "onSetEmptyDate"]),
      (_(), ue(ar(he.teleport ? My : "div"), Ct(Zt(ye.value)), {
        default: H(() => [
          fe(Fn, {
            name: E(A)(E(V)),
            css: E(T) && !E(C).enabled
          }, {
            default: H(() => [
              s.value ? (_(), Z("div", wt({
                key: 0,
                ref_key: "dpWrapMenuRef",
                ref: u
              }, me.value, {
                class: { "dp--menu-wrapper": !E(C).enabled },
                style: E(C).enabled ? void 0 : E(q)
              }), [
                fe(Yw, wt({
                  ref_key: "dpMenuRef",
                  ref: c
                }, he.$props, {
                  "internal-model-value": E(G),
                  "onUpdate:internalModelValue": Re[3] || (Re[3] = (Fe) => G0(G) ? G.value = Fe : null),
                  class: { [de.value]: !0, "dp--menu-wrapper": he.teleport },
                  "open-on-top": E(V),
                  "no-overlay-focus": ie.value,
                  collapse: g.value,
                  "get-input-rect": I,
                  "is-text-input-date": O.value,
                  onClosePicker: Oe,
                  onSelectDate: K,
                  onAutoApply: be,
                  onTimeUpdate: $t,
                  onFlowStep: Re[4] || (Re[4] = (Fe) => he.$emit("flow-step", Fe)),
                  onUpdateMonthYear: Re[5] || (Re[5] = (Fe) => he.$emit("update-month-year", Fe)),
                  onInvalidSelect: Re[6] || (Re[6] = (Fe) => he.$emit("invalid-select", E(G))),
                  onAutoApplyInvalid: Re[7] || (Re[7] = (Fe) => he.$emit("invalid-select", Fe)),
                  onInvalidFixedRange: Re[8] || (Re[8] = (Fe) => he.$emit("invalid-fixed-range", Fe)),
                  onRecalculatePosition: E(pe),
                  onTooltipOpen: Re[9] || (Re[9] = (Fe) => he.$emit("tooltip-open", Fe)),
                  onTooltipClose: Re[10] || (Re[10] = (Fe) => he.$emit("tooltip-close", Fe)),
                  onTimePickerOpen: Re[11] || (Re[11] = (Fe) => he.$emit("time-picker-open", Fe)),
                  onTimePickerClose: Re[12] || (Re[12] = (Fe) => he.$emit("time-picker-close", Fe)),
                  onAmPmChange: Re[13] || (Re[13] = (Fe) => he.$emit("am-pm-change", Fe)),
                  onRangeStart: Re[14] || (Re[14] = (Fe) => he.$emit("range-start", Fe)),
                  onRangeEnd: Re[15] || (Re[15] = (Fe) => he.$emit("range-end", Fe)),
                  onDateUpdate: Re[16] || (Re[16] = (Fe) => he.$emit("date-update", Fe)),
                  onInvalidDate: Re[17] || (Re[17] = (Fe) => he.$emit("invalid-date", Fe)),
                  onOverlayToggle: Re[18] || (Re[18] = (Fe) => he.$emit("overlay-toggle", Fe)),
                  onMenuBlur: Re[19] || (Re[19] = (Fe) => he.$emit("blur"))
                }), un({ _: 2 }, [
                  Ge(E(Q), (Fe, fn) => ({
                    name: Fe,
                    fn: H((ti) => [
                      ne(he.$slots, Fe, Ct(Zt({ ...ti })))
                    ])
                  }))
                ]), 1040, ["internal-model-value", "class", "open-on-top", "no-overlay-focus", "collapse", "is-text-input-date", "onRecalculatePosition"])
              ], 16)) : W("", !0)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ]),
        _: 3
      }, 16))
    ], 10, rB));
  }
}), ib = /* @__PURE__ */ (() => {
  const t = oB;
  return t.install = (e) => {
    e.component("Vue3DatePicker", t);
  }, t;
})(), sB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ib
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(sB).forEach(([t, e]) => {
  t !== "default" && (ib[t] = e);
});
const aB = Te({
  name: "MtDatepicker",
  components: {
    "mt-icon": mt,
    "vue-datepicker": ib,
    "mt-field-label": $C
  },
  props: {
    /**
     * A label for your date picker field. It helps the user understand what this field is for.
     */
    label: {
      type: String,
      required: !1,
      default: null
    },
    /**
     * Defines the type of the date picker.
     * Options: "date" (for selecting a date), or "datetime" (for selecting both).
     */
    dateType: {
      type: String,
      required: !1,
      default: "datetime"
    },
    /**
     * Sets the locale for the date picker.
     * This affects things like the language used for month names and weekdays.
     */
    locale: {
      type: String,
      required: !1,
      default: "de"
    },
    /**
     * Defines the time zone for the date picker.
     * Useful for adjusting date and time according to a specific timezone.
     */
    timeZone: {
      type: String,
      required: !1,
      default: "UTC"
    },
    /**
     * The value of the date picker. Can be a single string or an array of strings.
     * This represents the currently selected date(s).
     */
    modelValue: {
      type: [String, Array],
      default: null
    },
    /**
     * Placeholder text to show in the date picker input field when no date is selected.
     */
    placeholder: {
      type: String,
      required: !1,
      default: "Y-m-d ..."
    },
    /**
     * Determines if the timepicker is in 24 or 12 hour format
     */
    is24: {
      type: Boolean,
      required: !1,
      default: !0
    },
    /**
     * Determines if the date picker field is required.
     * If true, the user must select a value before submitting the form.
     */
    required: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines if the date picker field is disabled.
     * If true, the user will not be able to interact with the field.
     */
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Enables the date range selection feature.
     * If true, the user can select a start and end date.
     */
    range: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  data() {
    return {
      isDatepickerOpen: !1,
      isTimeHintVisible: !0
    };
  },
  computed: {
    computedValue: {
      get() {
        return this.modelValue;
      },
      set(t) {
        if (!t)
          return;
        if (this.dateType === "date") {
          const n = this.convertDateToIso(t);
          this.$emit("update:modelValue", n);
          return;
        }
        const e = this.convertDateToIso(t);
        this.$emit("update:modelValue", e);
      }
    }
  },
  watch: {
    dateType(t) {
      this.isTimeHintVisible = t !== "date";
    }
  },
  methods: {
    formatDate(t) {
      const e = (n) => {
        const i = n.getFullYear(), r = String(n.getMonth() + 1).padStart(2, "0"), o = String(n.getDate()).padStart(2, "0"), s = String(n.getHours()).padStart(2, "0"), a = String(n.getMinutes()).padStart(2, "0");
        return this.dateType === "date" ? `${i}/${r}/${o}` : `${i}/${r}/${o}, ${s}:${a}`;
      };
      return Array.isArray(t) ? t.map(e).join(" - ") : e(t);
    },
    convertDateToIso(t) {
      return Array.isArray(t) ? t.map((e) => e.toISOString()) : t.toISOString();
    }
  },
  mounted() {
    this.isTimeHintVisible = this.dateType !== "date";
  }
});
const lB = { class: "wrapper" }, uB = {
  key: 0,
  class: "field-hint",
  "data-test": "time-zone-hint",
  style: { gridArea: "hint" }
};
function cB(t, e, n, i, r, o) {
  const s = Ce("mt-field-label"), a = Ce("mt-icon"), l = Ce("vue-datepicker");
  return _(), Z("div", lB, [
    fe(s, {
      style: { gridArea: "label" },
      id: "field-id"
    }, {
      default: H(() => [
        He(Pe(t.label), 1)
      ]),
      _: 1
    }),
    fe(l, {
      ref: "datepicker",
      modelValue: t.computedValue,
      "onUpdate:modelValue": e[0] || (e[0] = (u) => t.computedValue = u),
      style: { gridArea: "datepicker" },
      class: "date-picker",
      position: "left",
      onOpen: e[1] || (e[1] = (u) => t.isDatepickerOpen = !0),
      onClose: e[2] || (e[2] = (u) => t.isDatepickerOpen = !1),
      placeholder: t.placeholder,
      disabled: t.disabled,
      required: t.required,
      locale: t.locale,
      timezone: t.timeZone,
      open: t.isDatepickerOpen,
      teleport: !0,
      "show-cancel": !0,
      clearable: !1,
      "auto-apply": !0,
      range: t.range,
      format: t.formatDate,
      "is-24": t.is24,
      type: t.dateType,
      "enable-time-picker": t.dateType !== "date",
      exactMatch: t.dateType === "date",
      "time-picker-inline": ""
    }, {
      "input-icon": H(() => [
        fe(a, {
          name: "regular-calendar",
          class: "regular-calendar"
        })
      ]),
      "calendar-icon": H(() => [
        fe(a, {
          name: "regular-calendar",
          class: "regular-calendar"
        })
      ]),
      "tp-inline-arrow-up": H(() => [
        fe(a, {
          name: "regular-chevron-up-s",
          class: "time-arrow-up-down"
        })
      ]),
      "tp-inline-arrow-down": H(() => [
        fe(a, {
          name: "regular-chevron-down-s",
          class: "time-arrow-up-down"
        })
      ]),
      "arrow-left": H(() => [
        fe(a, {
          name: "regular-chevron-left-xs",
          class: "month-control-arrow"
        })
      ]),
      "arrow-right": H(() => [
        fe(a, {
          name: "regular-chevron-right-xs",
          class: "month-control-arrow"
        })
      ]),
      _: 1
    }, 8, ["modelValue", "placeholder", "disabled", "required", "locale", "timezone", "open", "range", "format", "is-24", "type", "enable-time-picker", "exactMatch"]),
    t.isTimeHintVisible ? (_(), Z("div", uB, [
      fe(a, {
        name: "solid-clock",
        class: "field-hint-icon"
      }),
      X("p", null, Pe(t.timeZone || "UTC"), 1)
    ])) : W("", !0)
  ]);
}
const Rae = /* @__PURE__ */ je(aB, [["render", cB]]), dB = /* @__PURE__ */ Te({
  __name: "mt-text",
  props: {
    size: {
      type: String,
      required: !1,
      default: "s"
    },
    weight: {
      type: String,
      required: !1,
      default: "regular"
    },
    color: {
      type: String,
      required: !1,
      default: "color-text-primary-default"
    },
    as: {
      type: String,
      required: !1
    }
  },
  setup(t) {
    return (e, n) => (_(), ue(ar(t.as ?? "p"), {
      class: Ae([`mt-text--size-${t.size}`, `mt-text--weight-${t.weight}`]),
      style: pt({ color: `var(--${t.color})` })
    }, {
      default: H(() => [
        ne(e.$slots, "default", {}, void 0, !0)
      ]),
      _: 3
    }, 8, ["class", "style"]));
  }
});
const Pi = /* @__PURE__ */ je(dB, [["__scopeId", "data-v-01ce30d7"]]), vT = {
  removeCardWidth: !1,
  removeDefaultMargin: !1
}, yT = Symbol("mt-future-flags");
function hB(t) {
  ua(yT, t ?? vT);
}
function Sd() {
  return fs(yT, vT);
}
const fB = { class: "mt-banner__message" }, pB = ["aria-label"], mB = /* @__PURE__ */ Te({
  __name: "mt-banner",
  props: {
    variant: { default: "neutral" },
    title: {},
    hideIcon: { type: Boolean, default: !1 },
    closable: { type: Boolean, default: !1 },
    bannerIndex: {},
    icon: {}
  },
  setup(t) {
    const { t: e } = Lt({
      messages: {
        de: {
          close: "Schließen"
        },
        en: {
          close: "Close"
        }
      }
    }), n = t, i = J(() => n.icon ? n.icon : {
      neutral: "solid-info-circle",
      info: "solid-info-circle",
      attention: "solid-exclamation-triangle",
      critical: "solid-exclamation-circle",
      positive: "solid-check-circle",
      inherited: "solid-link"
    }[n.variant] || "solid-info-circle"), r = Sd(), o = J(() => [
      "mt-banner",
      `mt-banner--${n.variant}`,
      {
        "mt-banner--future-remove-default-margin": r.removeDefaultMargin,
        "mt-banner--icon": !n.hideIcon,
        "mt-banner--closable": n.closable
      }
    ]), s = J(() => ({
      "mt-banner__body--icon": !n.hideIcon,
      "mt-banner__body--closable": n.closable
    }));
    return (a, l) => (_(), Z("div", {
      class: Ae(o.value),
      role: "banner"
    }, [
      ne(a.$slots, "customIcon", {}, () => [
        a.hideIcon ? W("", !0) : (_(), ue(mt, {
          key: 0,
          size: "1.25rem",
          class: "mt-banner__icon",
          name: i.value,
          decorative: ""
        }, null, 8, ["name"]))
      ], !0),
      X("div", {
        class: Ae(["mt-banner__body", s.value])
      }, [
        a.title ? (_(), ue(Pi, {
          key: 0,
          as: "h3",
          weight: "bold",
          size: "xs",
          class: "mt-banner__title"
        }, {
          default: H(() => [
            He(Pe(a.title), 1)
          ]),
          _: 1
        })) : W("", !0),
        X("div", fB, [
          ne(a.$slots, "default", {}, void 0, !0)
        ])
      ], 2),
      a.closable ? (_(), Z("button", {
        key: 0,
        class: "mt-banner__close",
        "aria-label": E(e)("close"),
        onClick: l[0] || (l[0] = Tt((u) => a.$emit("close", a.bannerIndex), ["prevent"]))
      }, [
        fe(mt, { name: "solid-times-s" })
      ], 8, pB)) : W("", !0)
    ], 2));
  }
});
const Dae = /* @__PURE__ */ je(mB, [["__scopeId", "data-v-0cd8eb75"]]), gB = { class: "mt-loader" }, OB = { class: "mt-loader-element" }, vB = /* @__PURE__ */ Te({
  __name: "mt-loader",
  props: {
    size: { default: "50px" }
  },
  setup(t) {
    const e = t, n = J(() => {
      const i = Number(e.size.replace("px", ""));
      return `${Number(i / 12).toPrecision(2)}px`;
    });
    return (i, r) => (_(), Z("div", gB, [
      X("div", {
        class: "mt-loader__container",
        style: pt({ width: i.size, height: i.size })
      }, [
        X("div", OB, [
          X("div", {
            style: pt({ borderWidth: n.value })
          }, null, 4),
          X("div", {
            style: pt({ borderWidth: n.value })
          }, null, 4),
          X("div", {
            style: pt({ borderWidth: n.value })
          }, null, 4),
          X("div", {
            style: pt({ borderWidth: n.value })
          }, null, 4)
        ])
      ], 4)
    ]));
  }
});
const rb = /* @__PURE__ */ je(vB, [["__scopeId", "data-v-66748148"]]), yB = /* @__PURE__ */ Te({
  __name: "mt-field-error",
  props: {
    error: {}
  },
  setup(t) {
    const e = t, n = J(() => {
      if (!e.error)
        return "";
      if (!e.error.code)
        return i(e.error.detail);
      const r = i(e.error.code, e.error.parameters || {});
      return r === e.error.code.toString() ? e.error.detail : r;
    }), { t: i } = Lt({
      messages: {
        en: {
          "mt-field-error": {
            FRAMEWORK__MISSING_PRIVILEGE_ERROR: "Missing permissions",
            FRAMEWORK__DELETE_RESTRICTED: "Deletion failed",
            INVALID_MEDIA_URL: "Please enter a valid URL to upload a file.",
            CONTENT__MISSING_RULE_TYPE_EXCEPTION: "You must choose a type for this rule.",
            CONTENT__INVALID_CATEGORY_TYPE_AS_ENTRY_POINT: "The type can not be assigned while category is an entry point.",
            SHOPWARE_INVALID_IP: "Please enter a valid IP address.",
            INVALID_URL: "Please enter a valid url.",
            INVALID_MAIL: "Please enter a valid email address.",
            FRAMEWORK__RATE_LIMIT_EXCEEDED: "Too many requests. Please wait {seconds} seconds before trying again.",
            DUPLICATED_URL: "This URL is already in use. Please choose another URL.",
            "c1051bb4-d103-4f74-8988-acbcafc7fdc3": "This field must not be empty."
          }
        },
        de: {
          "mt-field-error": {
            FRAMEWORK__MISSING_PRIVILEGE_ERROR: "Fehlende Berechtigungen",
            FRAMEWORK__DELETE_RESTRICTED: "Löschen fehlgeschlagen",
            INVALID_MEDIA_URL: "Bitte gib eine gültige URL ein, um eine Datei hochzuladen.",
            CONTENT__MISSING_RULE_TYPE_EXCEPTION: "Du musst einen Typ für diese Regel auswählen.",
            CONTENT__INVALID_CATEGORY_TYPE_AS_ENTRY_POINT: "Dieser Typ kann nicht gewählt werden, während die Kategorie als Einstiegspunkt festgelegt ist.",
            SHOPWARE_INVALID_IP: "Bitte gib eine gültige IP-Adresse ein.",
            INVALID_URL: "Bitte gib eine gültige URL ein.",
            INVALID_MAIL: "Bitte gib eine gültige E-Mail-Adresse ein.",
            FRAMEWORK__RATE_LIMIT_EXCEEDED: "Zu viele Anfragen. Bitte warten Sie {seconds} Sekunden, bevor Sie es erneut versuchen.",
            DUPLICATED_URL: "Diese URL wird bereits genutzt. Bitte wähle eine andere Domain.",
            "c1051bb4-d103-4f74-8988-acbcafc7fdc3": "Dieses Feld darf nicht leer sein"
          }
        }
      }
    });
    return (r, o) => r.error ? (_(), ue(Pi, {
      key: 0,
      as: "span",
      size: "2xs",
      color: "color-text-critical-default",
      class: "mt-field__error"
    }, {
      default: H(() => [
        fe(mt, {
          name: "solid-exclamation-circle",
          size: "0.75rem",
          "aria-hidden": "true"
        }),
        X("span", null, Pe(n.value), 1)
      ]),
      _: 1
    })) : W("", !0);
  }
});
const Xs = /* @__PURE__ */ je(yB, [["__scopeId", "data-v-cc988284"]]), bB = ["aria-valuenow", "aria-valuemax"], wB = { class: "mt-progress-bar__track" }, kB = /* @__PURE__ */ Te({
  __name: "mt-progress-bar",
  props: /* @__PURE__ */ FD({
    label: {},
    maxValue: {},
    error: {},
    progressLabelType: { default: "percent" }
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t) {
    const e = qD(t, "modelValue"), n = t, i = J(() => n.progressLabelType === "percent" ? r.value : `${e.value} ${n.progressLabelType} / ${n.maxValue} ${n.progressLabelType}`), r = J(() => {
      if (!e.value)
        return "0%";
      const o = Math.floor(e.value / n.maxValue * 100);
      return o > 100 ? "100%" : o < 0 ? "0%" : `${o}%`;
    });
    return (o, s) => (_(), Z("div", {
      class: "mt-progress-bar",
      role: "progressbar",
      "aria-valuenow": e.value,
      "aria-valuemax": o.maxValue,
      "aria-label": "Current progress"
    }, [
      fe($C, {
        id: "some-id",
        style: { gridArea: "label" }
      }, {
        default: H(() => [
          He(Pe(o.label), 1)
        ]),
        _: 1
      }),
      fe(Pi, {
        class: "mt-progress-bar__progress-label",
        as: "span",
        size: "xs"
      }, {
        default: H(() => [
          He(Pe(i.value), 1)
        ]),
        _: 1
      }),
      X("div", wB, [
        X("div", {
          class: Ae(["mt-progress-bar__fill", { "mt-progress-bar__fill--with-error": !!o.error }]),
          style: pt({ width: r.value })
        }, null, 6)
      ]),
      o.error ? (_(), ue(Xs, {
        key: 0,
        error: o.error,
        style: { marginTop: 0, gridArea: "error" }
      }, null, 8, ["error"])) : W("", !0)
    ], 8, bB));
  }
});
const Qae = /* @__PURE__ */ je(kB, [["__scopeId", "data-v-13132802"]]), bT = Symbol("TooltipContext");
function SB() {
  return fs(bT, !1);
}
const _B = ["href"], xB = { class: "mt-button__content" }, CB = ["disabled", "aria-disabled"], TB = /* @__PURE__ */ Te({
  __name: "mt-button",
  props: {
    disabled: { type: Boolean },
    variant: { default: "" },
    ghost: { type: Boolean },
    size: { default: "small" },
    square: { type: Boolean },
    block: { type: Boolean },
    link: {},
    isLoading: { type: Boolean }
  },
  setup(t) {
    const e = t, n = J(() => e.ghost && e.variant !== "secondary"), i = J(() => ({
      [`mt-button--${e.variant}${n.value ? "-ghost" : ""}`]: !!e.variant,
      [`mt-button--${e.size}`]: !!e.size,
      "mt-button--block": e.block,
      "mt-button--disabled": e.disabled,
      "mt-button--square": e.square
    })), r = J(() => e.size === "x-small" ? 8 : e.size === "large" ? 12 : 10), o = SB();
    return (s, a) => s.link ? (_(), Z("a", wt({
      key: 0,
      href: s.disabled ? "" : s.link,
      target: "_blank",
      rel: "noopener",
      class: ["mt-button", i.value]
    }, s.$attrs), [
      X("span", xB, [
        ne(s.$slots, "default", {}, void 0, !0)
      ])
    ], 16, _B)) : (_(), Z("button", wt({
      key: 1,
      class: ["mt-button", i.value],
      disabled: s.disabled && !E(o) || s.isLoading,
      "aria-disabled": s.disabled && E(o),
      onClick: a[0] || (a[0] = (l) => s.disabled && E(o) ? l.stopImmediatePropagation() : null)
    }, s.$attrs), [
      s.isLoading ? (_(), ue(rb, {
        key: 0,
        size: "16px",
        class: "mt-button__loader"
      })) : W("", !0),
      X("span", {
        class: Ae(["mt-button__content", {
          "mt-button__content--hidden": s.isLoading
        }])
      }, [
        s.$slots.iconFront ? ne(s.$slots, "iconFront", {
          key: 0,
          size: r.value
        }, void 0, !0) : W("", !0),
        ne(s.$slots, "default", {}, void 0, !0),
        s.$slots.iconBack ? ne(s.$slots, "iconBack", {
          key: 1,
          size: r.value
        }, void 0, !0) : W("", !0)
      ], 2)
    ], 16, CB));
  }
});
const Sr = /* @__PURE__ */ je(TB, [["__scopeId", "data-v-e982b12f"]]), $B = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let PB = (t = 21) => {
  let e = "", n = crypto.getRandomValues(new Uint8Array(t));
  for (; t--; )
    e += $B[n[t] & 63];
  return e;
};
function za() {
  return PB();
}
const Jm = ["top", "right", "bottom", "left"], cf = /* @__PURE__ */ new Map();
class ns {
  constructor({
    id: e = za(),
    placement: n = "top",
    message: i,
    width: r = 200,
    element: o,
    showDelay: s = 100,
    hideDelay: a = s,
    disabled: l = !1,
    appearance: u = "dark",
    showOnDisabledElements: c = !1,
    zIndex: d = null
  }) {
    De(this, "_id");
    De(this, "_placement");
    De(this, "_message");
    De(this, "_width");
    De(this, "_parentDOMElement");
    De(this, "_showDelay");
    De(this, "_hideDelay");
    De(this, "_disabled");
    De(this, "_appearance");
    De(this, "_showOnDisabledElements");
    De(this, "_zIndex");
    De(this, "_isShown");
    De(this, "_state");
    De(this, "_DOMElement");
    De(this, "_parentDOMElementWrapper");
    De(this, "_actualTooltipPlacement");
    De(this, "_timeout");
    this._id = e, this._placement = ns.validatePlacement(n), this._message = ns.validateMessage(i), this._width = ns.validateWidth(r), this._parentDOMElement = o, this._showDelay = s ?? 100, this._hideDelay = a ?? 100, this._disabled = l, this._appearance = u, this._showOnDisabledElements = c, this._zIndex = d, this._isShown = !1, this._state = !1, this._DOMElement = null, this._parentDOMElementWrapper = null, this._actualTooltipPlacement = null;
  }
  get id() {
    return this._id;
  }
  /**
   * Initializes the tooltip.
   * Needs to be called after the parent DOM Element is inserted to the DOM.
   */
  init() {
    this._DOMElement = this.createDOMElement(), this._showOnDisabledElements && (this._parentDOMElementWrapper = this.createParentDOMElementWrapper()), this.registerEvents();
  }
  /**
   * Updates the styles and/or text of the tooltip
   */
  update({
    message: e,
    placement: n,
    width: i,
    showDelay: r,
    hideDelay: o,
    disabled: s,
    appearance: a,
    showOnDisabledElements: l,
    zIndex: u
  }) {
    e && this._message !== e && (this._message = ns.validateMessage(e), this._DOMElement && (this._DOMElement.innerHTML = this._message), this.registerEvents()), i && this._width !== i && (this._width = ns.validateWidth(i), this._DOMElement.style.width = `${this._width}px`), n && this._placement !== n && (this._placement = ns.validatePlacement(n), this._placeTooltip()), r && this._showDelay !== r && (this._showDelay = r), o && this._hideDelay !== o && (this._hideDelay = o), s !== void 0 && this._disabled !== s && (this._disabled = s), a && this._appearance !== a && (this._DOMElement.classList.remove(`mt-tooltip--${this._appearance}`), this._appearance = a, this._DOMElement.classList.add(`mt-tooltip--${this._appearance}`)), l !== void 0 && this._showOnDisabledElements !== l && (this._showOnDisabledElements = l), u !== this._zIndex && u !== void 0 && (this._zIndex = u);
  }
  /**
   * Creates a wrapper around the original DOMElement.
   * This is needed because a disabled input field does not fire any mouse events and prevents the tooltip
   * therefore from working.
   * @returns {HTMLElement}
   */
  createParentDOMElementWrapper() {
    const e = document.createElement("div");
    return e.classList.add("mt-tooltip--wrapper"), this._parentDOMElement.parentNode.insertBefore(e, this._parentDOMElement), e.appendChild(this._parentDOMElement), e;
  }
  createDOMElement() {
    const e = document.createElement("div");
    return e.innerHTML = this._message, e.style.width = `${this._width}px`, e.setAttribute("aria-hidden", "false"), e.setAttribute("aria-role", "tooltip"), e.setAttribute("aria-label", "currently-opened-tooltip"), e.classList.add("mt-tooltip"), e.classList.add(`mt-tooltip--${this._appearance}`), this._zIndex !== null && (e.style.zIndex = this._zIndex.toFixed(0)), e;
  }
  registerEvents() {
    this._parentDOMElementWrapper ? (this._parentDOMElementWrapper.addEventListener("mouseenter", this.onMouseToggle.bind(this)), this._parentDOMElementWrapper.addEventListener("mouseleave", this.onMouseToggle.bind(this))) : (this._parentDOMElement.addEventListener("mouseenter", this.onMouseToggle.bind(this)), this._parentDOMElement.addEventListener("mouseleave", this.onMouseToggle.bind(this))), this._DOMElement.addEventListener("mouseenter", this.onMouseToggle.bind(this)), this._DOMElement.addEventListener("mouseleave", this.onMouseToggle.bind(this));
  }
  /**
   * Sets the state and triggers the toggle.
   */
  onMouseToggle(e) {
    this._state = e.type === "mouseenter", this._timeout && clearTimeout(this._timeout), this._timeout = setTimeout(
      this._toggle.bind(this),
      this._state ? this._showDelay : this._hideDelay
    );
  }
  _toggle() {
    if (this._state && !this._isShown && this._doesParentExist()) {
      this.showTooltip();
      return;
    }
    !this._state && this._isShown && this.hideTooltip();
  }
  /**
   * Gets the parent element by tag name and tooltip id and returns true or false whether the element exists.
   * @returns {boolean}
   * @private
   */
  _doesParentExist() {
    const e = this._parentDOMElement.getAttribute("tooltip-id") ?? "", n = this._parentDOMElement.tagName.toLowerCase();
    return !!document.querySelector(
      `${n}[tooltip-id="${e}"]`
    );
  }
  /**
   * Appends the tooltip to the DOM and sets a suitable position
   */
  showTooltip() {
    this._disabled || (document.body.appendChild(this._DOMElement), this._placeTooltip(), this._isShown = !0);
  }
  /**
   * Removes the tooltip from the DOM
   */
  hideTooltip() {
    this._disabled || (this._DOMElement.remove(), this._isShown = !1);
  }
  _placeTooltip() {
    let e = Jm, n = this._placement;
    for (e = e.filter((i) => i !== n), this._DOMElement.classList.remove(`mt-tooltip--${this._actualTooltipPlacement}`), this._setDOMElementPosition(this._calculateTooltipPosition(n ?? "top")), this._actualTooltipPlacement = n ?? null; !this._isElementInViewport(this._DOMElement); ) {
      if (e.length < 1) {
        this._actualTooltipPlacement = this._placement ?? null, this._setDOMElementPosition(this._calculateTooltipPosition(this._placement ?? "top"));
        break;
      }
      n = e.shift(), this._setDOMElementPosition(this._calculateTooltipPosition(n ?? "top")), this._actualTooltipPlacement = n ?? null;
    }
    this._DOMElement.classList.add(`mt-tooltip--${this._actualTooltipPlacement ?? ""}`);
  }
  _setDOMElementPosition({ top: e, left: n }) {
    this._DOMElement.style.position = "fixed", this._DOMElement.style.top = e, this._DOMElement.style.left = n;
  }
  _calculateTooltipPosition(e) {
    const n = this._parentDOMElement.getBoundingClientRect(), i = 10;
    let r, o;
    switch (e) {
      case "bottom":
        r = `${n.top + n.height + i}px`, o = `${n.left + n.width / 2 - this._DOMElement.offsetWidth / 2}px`;
        break;
      case "left":
        r = `${n.top + n.height / 2 - this._DOMElement.offsetHeight / 2}px`, o = `${n.left - i - this._DOMElement.offsetWidth}px`;
        break;
      case "right":
        r = `${n.top + n.height / 2 - this._DOMElement.offsetHeight / 2}px`, o = `${n.right + i}px`;
        break;
      case "top":
      default:
        r = `${n.top - this._DOMElement.offsetHeight - i}px`, o = `${n.left + n.width / 2 - this._DOMElement.offsetWidth / 2}px`;
    }
    return { top: r, left: o };
  }
  _isElementInViewport(e) {
    const n = e.getBoundingClientRect(), i = window.innerHeight || document.documentElement.clientHeight, r = window.innerWidth || document.documentElement.clientWidth, o = {
      top: n.top > 0,
      right: n.right < r,
      bottom: n.bottom < i,
      left: n.left > 0
    };
    return o.top && o.right && o.bottom && o.left;
  }
  static validatePlacement(e) {
    return Jm.includes(e) ? e : (console.warn(
      "Tooltip Directive",
      `The modifier has to be one of these "${Jm.join(",")}"`
    ), "top");
  }
  static validateMessage(e) {
    return typeof e != "string" && console.warn("Tooltip Directive", "The tooltip needs a message with type string"), e ?? "";
  }
  static validateWidth(e) {
    return e === "auto" ? e : typeof e != "number" || e < 1 ? (console.warn("Tooltip Directive", "The tooltip width has to be a number greater 0"), 200) : e;
  }
  static validateDelay(e) {
    return typeof e != "number" || e < 1 ? (console.warn("Tooltip Directive", "The tooltip delay has to be a number greater 0"), 100) : e;
  }
}
function Hw(t, {
  value: e,
  modifiers: n
}) {
  let i = typeof e == "string" ? e : e.message;
  i = i ? i.trim() : "";
  const r = e.position || Object.keys(n)[0], o = e.showDelay, s = e.hideDelay, a = e.disabled, l = e.appearance, u = e.width, c = e.showOnDisabledElements, d = e.zIndex, h = {
    element: t,
    message: i,
    placement: r,
    width: u,
    showDelay: o,
    hideDelay: s,
    disabled: a,
    appearance: l,
    showOnDisabledElements: c,
    zIndex: d
  };
  if (t.hasAttribute("tooltip-id")) {
    cf.get(t.getAttribute("tooltip-id")).update(h);
    return;
  }
  const f = new ns(h);
  cf.set(f.id ?? "", f), t.setAttribute("tooltip-id", f.id);
}
const ja = {
  beforeMount: (t, e) => {
    Hw(t, e);
  },
  unmounted: (t) => {
    t.hasAttribute("tooltip-id") && cf.get(t.getAttribute("tooltip-id")).hideTooltip();
  },
  updated: (t, e) => {
    Hw(t, e);
  },
  /**
   * Initialize the tooltip once it has been inserted to the DOM.
   */
  mounted: (t) => {
    t.hasAttribute("tooltip-id") && cf.get(t.getAttribute("tooltip-id")).init();
  }
}, MB = Te({
  name: "MtInheritanceSwitch",
  components: {
    "mt-icon": mt
  },
  directives: {
    tooltip: ja
  },
  props: {
    isInherited: {
      type: Boolean,
      required: !0,
      default: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(t, { emit: e }) {
    const { t: n } = Lt({
      messages: {
        en: {
          tooltipRemoveInheritance: "Remove inheritance",
          tooltipRestoreInheritance: "Restore inheritance"
        },
        de: {
          tooltipRemoveInheritance: "Vererbung entfernen",
          tooltipRestoreInheritance: "Vererbung wiederherstellen"
        }
      }
    });
    function i() {
      t.disabled || e("inheritance-restore");
    }
    function r() {
      t.disabled || e("inheritance-remove");
    }
    return { t: n, onClickRemoveInheritance: r, onClickRestoreInheritance: i };
  }
});
function EB(t, e, n, i, r, o) {
  const s = Ce("mt-icon"), a = vr("tooltip");
  return _(), Z("div", {
    class: Ae([
      "mt-inheritance-switch",
      {
        "mt-inheritance-switch--disabled": t.disabled,
        "mt-inheritance-switch--is-inherited": t.isInherited,
        "mt-inheritance-switch--is-not-inherited": !t.isInherited
      }
    ])
  }, [
    t.isInherited ? yt((_(), ue(s, {
      key: "inherit-icon",
      "data-testid": "mt-inheritance-switch-icon",
      multicolor: !0,
      name: "regular-link-horizontal",
      size: "14",
      onClick: t.onClickRemoveInheritance
    }, null, 8, ["onClick"])), [
      [a, {
        message: t.t("tooltipRemoveInheritance"),
        disabled: t.disabled
      }]
    ]) : yt((_(), ue(s, {
      key: "uninherit-icon",
      class: Ae({
        "is--clickable": !t.disabled
      }),
      multicolor: !0,
      name: "regular-link-horizontal-slash",
      size: "14",
      onClick: t.onClickRestoreInheritance
    }, null, 8, ["class", "onClick"])), [
      [a, {
        message: t.t("tooltipRestoreInheritance"),
        disabled: t.disabled
      }]
    ])
  ], 2);
}
const AB = /* @__PURE__ */ je(MB, [["render", EB], ["__scopeId", "data-v-c8e17518"]]), RB = Te({
  methods: {
    // eslint-disable-next-line no-unused-vars
    createNotification() {
    },
    createNotificationSuccess(t) {
      const e = {
        variant: "success",
        title: "global.default.success",
        ...t
      };
      this.createNotification(e);
    },
    createNotificationInfo(t) {
      const e = {
        variant: "info",
        title: "global.default.info",
        ...t
      };
      this.createNotification(e);
    },
    createNotificationWarning(t) {
      const e = {
        variant: "warning",
        title: this.$tc("global.default.warning"),
        ...t
      };
      this.createNotification(e);
    },
    createNotificationError(t) {
      const e = {
        variant: "error",
        title: "global.default.error",
        ...t
      };
      this.createNotification(e);
    },
    createSystemNotificationSuccess(t) {
      const e = {
        variant: "success",
        system: !0,
        ...t
      };
      this.createNotification(e);
    },
    createSystemNotificationInfo(t) {
      const e = {
        variant: "info",
        system: !0,
        ...t
      };
      this.createNotification(e);
    },
    createSystemNotificationWarning(t) {
      const e = {
        variant: "warning",
        system: !0,
        ...t
      };
      this.createNotification(e);
    },
    createSystemNotificationError(t) {
      const e = {
        variant: "error",
        system: !0,
        ...t
      };
      this.createNotification(e);
    },
    createSystemNotification(t) {
      const e = { system: !0, ...t };
      this.createNotification(e);
    }
  }
});
function DB(t) {
  const e = document.createElement("textarea");
  e.value = t, document.body.appendChild(e), e.select(), document.execCommand("copy"), document.body.removeChild(e);
}
const QB = Te({
  name: "MtFieldCopyable",
  directives: {
    tooltip: ja
  },
  components: {
    "mt-icon": mt
  },
  mixins: [RB],
  props: {
    copyableText: {
      type: String,
      required: !1,
      default: null
    },
    tooltip: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(t) {
    const e = re(!1), { t: n } = Lt({
      messages: {
        en: {
          tooltip: {
            wasCopied: "Copied to clipboard.",
            canCopy: "Copy to clipboard.",
            notificationCopySuccessMessage: "Text has been copied to clipboard.",
            notificationCopyFailureMessage: "Text could not be copied to clipboard.",
            errorTitle: "Error copying to clipboard"
          }
        },
        de: {
          tooltip: {
            wasCopied: "In Zwischenablage kopiert.",
            canCopy: "In Zwischenablage kopieren.",
            notificationCopySuccessMessage: "Der Text wurde in die Zwischenablage kopiert.",
            notificationCopyFailureMessage: "Der Text konnte nicht in die Zwischenablage kopiert werden.",
            errorTitle: "Fehler beim kopieren in die Zwischenablage"
          }
        }
      }
    }), i = J(
      () => e.value ? n("tooltip.wasCopied") : n("tooltip.canCopy")
    );
    function r() {
      t.copyableText && (DB(t.copyableText), t.tooltip && (e.value = !0));
    }
    return {
      copyToClipboard: r,
      tooltipText: i,
      wasCopied: e
    };
  }
});
function NB(t, e, n, i, r, o) {
  const s = Ce("mt-icon"), a = vr("tooltip");
  return yt((_(), ue(s, {
    class: "mt-field-copyable",
    name: "regular-copy",
    size: "18",
    onClick: t.copyToClipboard,
    onMouseleave: e[0] || (e[0] = (l) => t.wasCopied = !1)
  }, null, 8, ["onClick"])), [
    [a, {
      message: t.tooltipText,
      width: 220,
      position: "top",
      showDelay: 300,
      hideDelay: 0
    }]
  ]);
}
const IB = /* @__PURE__ */ je(QB, [["render", NB], ["__scopeId", "data-v-a4207187"]]), LB = Te({
  name: "MtHelpText",
  components: {
    "mt-icon": mt
  },
  directives: {
    tooltip: ja
  },
  props: {
    /**
     * The text which gets rendered in the tooltip
     */
    text: {
      type: String,
      required: !0,
      default: ""
    },
    /**
     * The width of the tooltip
     */
    width: {
      type: Number,
      required: !1,
      default: 200
    },
    /**
     * Choose the delay until the tooltip gets rendered when it gets hovered
     */
    showDelay: {
      type: Number,
      required: !1,
      default: 100
    },
    /**
     * Choose the delay until the tooltip gets removed the cursor leaves
     */
    hideDelay: {
      type: Number,
      required: !1,
      default: 100
    }
  }
});
const VB = {
  class: "mt-help-text",
  role: "tooltip",
  "aria-label": "help-text"
}, BB = { class: "mt-help-text__tooltip-text" };
function ZB(t, e, n, i, r, o) {
  const s = Ce("mt-icon"), a = vr("tooltip");
  return yt((_(), Z("button", VB, [
    fe(s, {
      "data-testid": "mt-help-text__icon",
      name: "solid-question-circle-s"
    }),
    X("span", BB, Pe(t.text), 1)
  ])), [
    [a, {
      message: t.text,
      width: t.width,
      showDelay: t.showDelay,
      hideDelay: t.hideDelay
    }]
  ]);
}
const FB = /* @__PURE__ */ je(LB, [["render", ZB], ["__scopeId", "data-v-52a768d7"]]);
function qB(t, e = {}) {
  return !wT(t, e);
}
function wT(t, e = {}) {
  return WB(t == null ? void 0 : t(e));
}
function WB(t) {
  return !t || XB(t).every(
    (e) => {
      var n, i;
      return e.type === WD || e.type === Xx && !((n = e.children) != null && n.length) || e.type === Qe && !((i = e.children) != null && i.length);
    }
  );
}
function XB(t) {
  return Array.isArray(t) ? t : t !== null ? [t] : [];
}
function zB() {
  return {
    hasSlotContent: qB,
    isSlotEmpty: wT
  };
}
var jB = typeof global == "object" && global && global.Object === Object && global;
const YB = jB;
var HB = typeof self == "object" && self && self.Object === Object && self, UB = YB || HB || Function("return this")();
const Yp = UB;
var GB = Yp.Symbol;
const Bl = GB;
var kT = Object.prototype, KB = kT.hasOwnProperty, JB = kT.toString, Mu = Bl ? Bl.toStringTag : void 0;
function e5(t) {
  var e = KB.call(t, Mu), n = t[Mu];
  try {
    t[Mu] = void 0;
    var i = !0;
  } catch {
  }
  var r = JB.call(t);
  return i && (e ? t[Mu] = n : delete t[Mu]), r;
}
var t5 = Object.prototype, n5 = t5.toString;
function i5(t) {
  return n5.call(t);
}
var r5 = "[object Null]", o5 = "[object Undefined]", Uw = Bl ? Bl.toStringTag : void 0;
function ST(t) {
  return t == null ? t === void 0 ? o5 : r5 : Uw && Uw in Object(t) ? e5(t) : i5(t);
}
function s5(t) {
  return t != null && typeof t == "object";
}
var a5 = "[object Symbol]";
function Hp(t) {
  return typeof t == "symbol" || s5(t) && ST(t) == a5;
}
function l5(t, e) {
  for (var n = -1, i = t == null ? 0 : t.length, r = Array(i); ++n < i; )
    r[n] = e(t[n], n, t);
  return r;
}
var u5 = Array.isArray;
const ob = u5;
var c5 = 1 / 0, Gw = Bl ? Bl.prototype : void 0, Kw = Gw ? Gw.toString : void 0;
function _T(t) {
  if (typeof t == "string")
    return t;
  if (ob(t))
    return l5(t, _T) + "";
  if (Hp(t))
    return Kw ? Kw.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -c5 ? "-0" : e;
}
var d5 = /\s/;
function h5(t) {
  for (var e = t.length; e-- && d5.test(t.charAt(e)); )
    ;
  return e;
}
var f5 = /^\s+/;
function p5(t) {
  return t && t.slice(0, h5(t) + 1).replace(f5, "");
}
function Vo(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Jw = 0 / 0, m5 = /^[-+]0x[0-9a-f]+$/i, g5 = /^0b[01]+$/i, O5 = /^0o[0-7]+$/i, v5 = parseInt;
function ek(t) {
  if (typeof t == "number")
    return t;
  if (Hp(t))
    return Jw;
  if (Vo(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Vo(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = p5(t);
  var n = g5.test(t);
  return n || O5.test(t) ? v5(t.slice(2), n ? 2 : 8) : m5.test(t) ? Jw : +t;
}
var y5 = "[object AsyncFunction]", b5 = "[object Function]", w5 = "[object GeneratorFunction]", k5 = "[object Proxy]";
function Bo(t) {
  if (!Vo(t))
    return !1;
  var e = ST(t);
  return e == b5 || e == w5 || e == y5 || e == k5;
}
var S5 = Yp["__core-js_shared__"];
const eg = S5;
var tk = function() {
  var t = /[^.]+$/.exec(eg && eg.keys && eg.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function _5(t) {
  return !!tk && tk in t;
}
var x5 = Function.prototype, C5 = x5.toString;
function T5(t) {
  if (t != null) {
    try {
      return C5.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var $5 = /[\\^$.*+?()[\]{}|]/g, P5 = /^\[object .+?Constructor\]$/, M5 = Function.prototype, E5 = Object.prototype, A5 = M5.toString, R5 = E5.hasOwnProperty, D5 = RegExp(
  "^" + A5.call(R5).replace($5, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Q5(t) {
  if (!Vo(t) || _5(t))
    return !1;
  var e = Bo(t) ? D5 : P5;
  return e.test(T5(t));
}
function N5(t, e) {
  return t == null ? void 0 : t[e];
}
function xT(t, e) {
  var n = N5(t, e);
  return Q5(n) ? n : void 0;
}
function I5(t, e) {
  return t === e || t !== t && e !== e;
}
var L5 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, V5 = /^\w*$/;
function B5(t, e) {
  if (ob(t))
    return !1;
  var n = typeof t;
  return n == "number" || n == "symbol" || n == "boolean" || t == null || Hp(t) ? !0 : V5.test(t) || !L5.test(t) || e != null && t in Object(e);
}
var Z5 = xT(Object, "create");
const Nc = Z5;
function F5() {
  this.__data__ = Nc ? Nc(null) : {}, this.size = 0;
}
function q5(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var W5 = "__lodash_hash_undefined__", X5 = Object.prototype, z5 = X5.hasOwnProperty;
function j5(t) {
  var e = this.__data__;
  if (Nc) {
    var n = e[t];
    return n === W5 ? void 0 : n;
  }
  return z5.call(e, t) ? e[t] : void 0;
}
var Y5 = Object.prototype, H5 = Y5.hasOwnProperty;
function U5(t) {
  var e = this.__data__;
  return Nc ? e[t] !== void 0 : H5.call(e, t);
}
var G5 = "__lodash_hash_undefined__";
function K5(t, e) {
  var n = this.__data__;
  return this.size += this.has(t) ? 0 : 1, n[t] = Nc && e === void 0 ? G5 : e, this;
}
function Ma(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var i = t[e];
    this.set(i[0], i[1]);
  }
}
Ma.prototype.clear = F5;
Ma.prototype.delete = q5;
Ma.prototype.get = j5;
Ma.prototype.has = U5;
Ma.prototype.set = K5;
function J5() {
  this.__data__ = [], this.size = 0;
}
function Up(t, e) {
  for (var n = t.length; n--; )
    if (I5(t[n][0], e))
      return n;
  return -1;
}
var e3 = Array.prototype, t3 = e3.splice;
function n3(t) {
  var e = this.__data__, n = Up(e, t);
  if (n < 0)
    return !1;
  var i = e.length - 1;
  return n == i ? e.pop() : t3.call(e, n, 1), --this.size, !0;
}
function i3(t) {
  var e = this.__data__, n = Up(e, t);
  return n < 0 ? void 0 : e[n][1];
}
function r3(t) {
  return Up(this.__data__, t) > -1;
}
function o3(t, e) {
  var n = this.__data__, i = Up(n, t);
  return i < 0 ? (++this.size, n.push([t, e])) : n[i][1] = e, this;
}
function gu(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var i = t[e];
    this.set(i[0], i[1]);
  }
}
gu.prototype.clear = J5;
gu.prototype.delete = n3;
gu.prototype.get = i3;
gu.prototype.has = r3;
gu.prototype.set = o3;
var s3 = xT(Yp, "Map");
const a3 = s3;
function l3() {
  this.size = 0, this.__data__ = {
    hash: new Ma(),
    map: new (a3 || gu)(),
    string: new Ma()
  };
}
function u3(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function Gp(t, e) {
  var n = t.__data__;
  return u3(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
function c3(t) {
  var e = Gp(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function d3(t) {
  return Gp(this, t).get(t);
}
function h3(t) {
  return Gp(this, t).has(t);
}
function f3(t, e) {
  var n = Gp(this, t), i = n.size;
  return n.set(t, e), this.size += n.size == i ? 0 : 1, this;
}
function Ya(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var i = t[e];
    this.set(i[0], i[1]);
  }
}
Ya.prototype.clear = l3;
Ya.prototype.delete = c3;
Ya.prototype.get = d3;
Ya.prototype.has = h3;
Ya.prototype.set = f3;
var p3 = "Expected a function";
function sb(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(p3);
  var n = function() {
    var i = arguments, r = e ? e.apply(this, i) : i[0], o = n.cache;
    if (o.has(r))
      return o.get(r);
    var s = t.apply(this, i);
    return n.cache = o.set(r, s) || o, s;
  };
  return n.cache = new (sb.Cache || Ya)(), n;
}
sb.Cache = Ya;
var m3 = 500;
function g3(t) {
  var e = sb(t, function(i) {
    return n.size === m3 && n.clear(), i;
  }), n = e.cache;
  return e;
}
var O3 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, v3 = /\\(\\)?/g, y3 = g3(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(O3, function(n, i, r, o) {
    e.push(r ? o.replace(v3, "$1") : i || n);
  }), e;
});
const b3 = y3;
function w3(t) {
  return t == null ? "" : _T(t);
}
function k3(t, e) {
  return ob(t) ? t : B5(t, e) ? [t] : b3(w3(t));
}
var S3 = 1 / 0;
function _3(t) {
  if (typeof t == "string" || Hp(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -S3 ? "-0" : e;
}
function x3(t, e) {
  e = k3(e, t);
  for (var n = 0, i = e.length; t != null && n < i; )
    t = t[_3(e[n++])];
  return n && n == i ? t : void 0;
}
function Zl(t, e, n) {
  var i = t == null ? void 0 : x3(t, e);
  return i === void 0 ? n : i;
}
var C3 = function() {
  return Yp.Date.now();
};
const tg = C3;
var T3 = "Expected a function", $3 = Math.max, P3 = Math.min;
function Kp(t, e, n) {
  var i, r, o, s, a, l, u = 0, c = !1, d = !1, h = !0;
  if (typeof t != "function")
    throw new TypeError(T3);
  e = ek(e) || 0, Vo(n) && (c = !!n.leading, d = "maxWait" in n, o = d ? $3(ek(n.maxWait) || 0, e) : o, h = "trailing" in n ? !!n.trailing : h);
  function f(w) {
    var S = i, $ = r;
    return i = r = void 0, u = w, s = t.apply($, S), s;
  }
  function p(w) {
    return u = w, a = setTimeout(O, e), c ? f(w) : s;
  }
  function m(w) {
    var S = w - l, $ = w - u, C = e - S;
    return d ? P3(C, o - $) : C;
  }
  function g(w) {
    var S = w - l, $ = w - u;
    return l === void 0 || S >= e || S < 0 || d && $ >= o;
  }
  function O() {
    var w = tg();
    if (g(w))
      return y(w);
    a = setTimeout(O, m(w));
  }
  function y(w) {
    return a = void 0, h && i ? f(w) : (i = r = void 0, s);
  }
  function b() {
    a !== void 0 && clearTimeout(a), u = 0, i = l = r = a = void 0;
  }
  function v() {
    return a === void 0 ? s : y(tg());
  }
  function k() {
    var w = tg(), S = g(w);
    if (i = arguments, r = this, l = w, S) {
      if (a === void 0)
        return p(l);
      if (d)
        return clearTimeout(a), a = setTimeout(O, e), f(l);
    }
    return a === void 0 && (a = setTimeout(O, e)), s;
  }
  return k.cancel = b, k.flush = v, k;
}
var M3 = "Expected a function";
function ab(t, e, n) {
  var i = !0, r = !0;
  if (typeof t != "function")
    throw new TypeError(M3);
  return Vo(n) && (i = "leading" in n ? !!n.leading : i, r = "trailing" in n ? !!n.trailing : r), Kp(t, e, {
    leading: i,
    maxWait: e,
    trailing: r
  });
}
function E3(t) {
  return typeof t == "string" && t.length <= 0 ? !1 : typeof t == "boolean" ? t === !0 : Vo(t) ? Object.keys(t).length > 0 : typeof t < "u" && t !== null;
}
function CT(t, e) {
  return e instanceof RegExp ? e.test(t) : new RegExp(e).test(t);
}
function A3(t) {
  return CT(
    t,
    // eslint-disable-next-line no-useless-escape
    /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
  );
}
const nk = {
  required: E3,
  regex: CT,
  email: A3
}, R3 = Te({
  props: {
    validation: {
      type: [String, Array, Object, Boolean],
      required: !1,
      default: null
    }
  },
  computed: {
    isValid() {
      const t = this.currentValue || this.value || this.selections;
      return this.validate(t);
    }
  },
  methods: {
    validate(t) {
      let { validation: e } = this, n = !0;
      if (typeof e == "boolean")
        return e;
      if (typeof e == "string") {
        const i = e.split(",");
        i.length > 1 ? e = i : n = this.validateRule(t, this.validation);
      }
      return Array.isArray(e) && (n = e.every((i) => typeof i == "boolean" ? i : this.validateRule(t, i.trim()))), n;
    },
    validateRule(t, e) {
      return typeof nk[e] > "u" ? !1 : nk[e](t);
    }
  }
}), Jp = Te({
  props: {
    mapInheritance: {
      type: Object,
      required: !1,
      default: null
    },
    name: {
      type: String,
      required: !1,
      default: null
    }
  },
  computed: {
    formFieldName() {
      if (this.$attrs.name)
        return this.$attrs.name;
      if (this.name)
        return this.name;
    }
  }
}), D3 = Te({
  name: "MtBaseField",
  components: {
    "mt-inheritance-switch": AB,
    "mt-help-text": FB,
    "mt-field-copyable": IB
  },
  mixins: [Jp, R3],
  props: {
    /**
     * Determines if the field is disabled.
     */
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines if the field is required.
     */
    required: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Toggles the inheritance visualization.
     */
    isInherited: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines if the field is inheritable.
     */
    isInheritanceField: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines the active state of the inheritance toggle.
     */
    disableInheritanceToggle: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Toggles the copy function of the text field.
     */
    copyable: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * If set to true the tooltip will change on successful copy.
     */
    copyableTooltip: {
      type: Boolean,
      required: !1,
      default: !1
    },
    hasFocus: {
      type: Boolean,
      required: !0
    },
    /**
     * A text that helps the user to understand what this field does.
     */
    helpText: {
      type: String,
      required: !1,
      default: ""
    },
    copyableText: {
      type: String,
      required: !1,
      default: ""
    },
    /**
     * The size of the text field.
     *
     * @values small, default
     */
    size: {
      type: String,
      required: !1,
      default: "default",
      validator(t) {
        return ["small", "default"].includes(t);
      }
    },
    /**
     * @ignore
     */
    name: {
      type: String,
      required: !1,
      default: null
    }
  },
  data() {
    return {
      id: void 0
    };
  },
  mounted() {
    this.id = za();
  },
  computed: {
    identification() {
      return this.name ? this.name : `mt-field--${this.id}`;
    },
    showLabel() {
      var t, e;
      return !!this.$slots.label || !!((e = (t = this.$slots).label) != null && e.call(t));
    },
    mtFieldLabelClasses() {
      return {
        "is--required": this.required
      };
    },
    mtBlockSize() {
      return `mt-field--${this.size}`;
    },
    hasError() {
      return this.hasSlotContent(this.$slots.error);
    }
  },
  setup() {
    const { hasSlotContent: t } = zB(), e = Sd();
    return {
      hasSlotContent: t,
      future: e
    };
  }
});
const Q3 = { class: "mt-field__label" }, N3 = ["for"], I3 = { class: "mt-block-field__block" }, L3 = { class: "mt-field__addition is--prefix" }, V3 = {
  key: 0,
  class: "mt-field__addition"
}, B3 = {
  key: 1,
  class: "mt-field__addition"
}, Z3 = { class: "mt-field__hint-wrapper" }, F3 = { class: "mt-field__hint" }, q3 = { class: "mt-field__hint-right" };
function W3(t, e, n, i, r, o) {
  const s = Ce("mt-inheritance-switch"), a = Ce("mt-help-text"), l = Ce("mt-field-copyable");
  return _(), Z("div", {
    class: Ae(["mt-field", [
      {
        "has--error": t.hasError,
        "is--disabled": t.disabled,
        "is--inherited": t.isInherited,
        "has--focus": t.hasFocus,
        "mt-field--future-remove-default-margin": t.future.removeDefaultMargin
      },
      t.mtBlockSize
    ]])
  }, [
    X("div", Q3, [
      t.isInheritanceField ? (_(), ue(s, wt({
        key: 0,
        disabled: t.disableInheritanceToggle,
        class: "mt-field__inheritance-icon",
        "is-inherited": t.isInherited
      }, { ...t.$attrs, class: "" }), null, 16, ["disabled", "is-inherited"])) : W("", !0),
      t.showLabel ? (_(), Z("label", {
        key: 1,
        for: t.identification,
        class: Ae(t.mtFieldLabelClasses)
      }, [
        ne(t.$slots, "label")
      ], 10, N3)) : W("", !0),
      t.helpText ? (_(), ue(a, {
        key: 2,
        class: "mt-field__help-text",
        text: t.helpText
      }, null, 8, ["text"])) : W("", !0)
    ]),
    X("div", I3, [
      X("div", L3, [
        ne(t.$slots, "field-prefix", Ct(Zt({ disabled: t.disabled, identification: t.identification })))
      ]),
      ne(t.$slots, "element", Ct(Zt({ disabled: t.disabled, identification: t.identification }))),
      t.copyable ? (_(), Z("div", V3, [
        fe(l, {
          "display-name": t.identification,
          "copyable-text": t.copyableText,
          tooltip: t.copyableTooltip
        }, null, 8, ["display-name", "copyable-text", "tooltip"])
      ])) : (_(), Z("div", B3, [
        ne(t.$slots, "field-suffix", Ct(Zt({ disabled: t.disabled, identification: t.identification })))
      ]))
    ]),
    ne(t.$slots, "error"),
    X("div", Z3, [
      X("div", F3, [
        ne(t.$slots, "field-hint")
      ]),
      X("div", q3, [
        ne(t.$slots, "field-hint-right")
      ])
    ])
  ], 2);
}
const As = /* @__PURE__ */ je(D3, [["render", W3]]), X3 = Te({
  name: "MtCheckbox",
  components: {
    "mt-icon": mt,
    "mt-base-field": As,
    "mt-field-error": Xs
  },
  mixins: [Jp],
  props: {
    /**
     * A label for the checkbox.
     */
    label: {
      type: String,
      required: !1,
      default: void 0
    },
    /**
     * Toggles the disabled state of the checkbox.
     */
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines the checked state of the checkbox.
     */
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    /**
     * Determines if the field is partially checked.
     */
    partial: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Inherited value from another SalesChannel.
     */
    inheritedValue: {
      type: Boolean,
      required: !1,
      default: null
    },
    /**
     * Error object for this field.
     */
    error: {
      type: Object,
      required: !1,
      default: null
    },
    /**
     * Determines if the field is surrounded by a border.
     */
    bordered: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Help text with additional information for the field.
     */
    helpText: {
      type: String,
      required: !1,
      default: null
    },
    /**
     * Marks the field as required with an asterix.
     */
    required: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  data() {
    return {
      currentValue: this.checked,
      id: void 0
    };
  },
  mounted() {
    this.id = za();
  },
  setup() {
    const t = Sd();
    return {
      checkboxClasses: J(() => ({
        "mt-switch--future-remove-default-margin": t.removeDefaultMargin
      }))
    };
  },
  computed: {
    MtCheckboxFieldClasses() {
      return {
        "has--error": !!this.hasError,
        "is--disabled": this.disabled,
        "is--inherited": !!this.isInherited,
        "is--bordered": this.bordered,
        "is--partly-checked": this.isPartlyChecked
      };
    },
    identification() {
      return `mt-field--${this.id}`;
    },
    hasError() {
      return this.error && this.error.code !== 0;
    },
    inputState() {
      return this.isInherited ? this.inheritedValue : this.currentValue || !1;
    },
    isInheritanceField() {
      return this.$attrs.isInheritanceField ? !0 : this.inheritedValue !== null;
    },
    isInherited() {
      return this.$attrs.isInherited ? !0 : this.isInheritanceField && this.currentValue === null;
    },
    isDisabled() {
      return this.disabled || this.isInherited;
    },
    isPartlyChecked() {
      return this.partial && !this.inputState;
    },
    iconName() {
      return this.isPartlyChecked ? "regular-minus-xxs" : "regular-checkmark-xxs";
    }
  },
  watch: {
    checked: {
      handler() {
        this.currentValue = this.checked;
      },
      immediate: !0
    }
  },
  methods: {
    onChange(t) {
      this.$emit("update:checked", t.target.checked), this.$emit("change", t.target.checked);
    }
  }
});
const z3 = { class: "mt-field--checkbox__container" }, j3 = { class: "mt-field--checkbox__content" }, Y3 = { class: "mt-field__checkbox" }, H3 = ["id", "name", "checked", "disabled", ".indeterminate"], U3 = { class: "mt-field__checkbox-state" };
function G3(t, e, n, i, r, o) {
  const s = Ce("mt-icon"), a = Ce("mt-base-field"), l = Ce("mt-field-error");
  return _(), Z("div", z3, [
    X("div", {
      class: Ae(["mt-field--checkbox", { ...t.MtCheckboxFieldClasses, ...t.checkboxClasses }])
    }, [
      X("div", j3, [
        X("div", Y3, [
          X("input", {
            id: t.identification,
            type: "checkbox",
            name: t.identification,
            checked: t.inputState,
            disabled: t.isDisabled,
            ".indeterminate": t.partial,
            onChange: e[0] || (e[0] = Tt((...u) => t.onChange && t.onChange(...u), ["stop"]))
          }, null, 40, H3),
          X("div", U3, [
            fe(s, { name: t.iconName }, null, 8, ["name"])
          ])
        ]),
        fe(a, {
          disabled: t.isDisabled,
          "is-inheritance-field": t.isInheritanceField,
          "is-inherited": t.isInherited,
          name: t.identification,
          "has-focus": !1,
          "help-text": t.helpText,
          required: t.required,
          onInheritanceRestore: e[1] || (e[1] = (u) => t.$emit("inheritance-restore", u)),
          onInheritanceRemove: e[2] || (e[2] = (u) => t.$emit("inheritance-remove", u))
        }, {
          label: H(() => [
            He(Pe(t.label), 1)
          ]),
          _: 1
        }, 8, ["disabled", "is-inheritance-field", "is-inherited", "name", "help-text", "required"])
      ])
    ], 2),
    fe(l, { error: t.error }, null, 8, ["error"])
  ]);
}
const em = /* @__PURE__ */ je(X3, [["render", G3]]), Fl = Math.min, va = Math.max, df = Math.round, Xd = Math.floor, Rs = (t) => ({
  x: t,
  y: t
}), K3 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, J3 = {
  start: "end",
  end: "start"
};
function RO(t, e, n) {
  return va(t, Fl(e, n));
}
function _d(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Ea(t) {
  return t.split("-")[0];
}
function xd(t) {
  return t.split("-")[1];
}
function TT(t) {
  return t === "x" ? "y" : "x";
}
function lb(t) {
  return t === "y" ? "height" : "width";
}
function tm(t) {
  return ["top", "bottom"].includes(Ea(t)) ? "y" : "x";
}
function ub(t) {
  return TT(tm(t));
}
function eZ(t, e, n) {
  n === void 0 && (n = !1);
  const i = xd(t), r = ub(t), o = lb(r);
  let s = r === "x" ? i === (n ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return e.reference[o] > e.floating[o] && (s = hf(s)), [s, hf(s)];
}
function tZ(t) {
  const e = hf(t);
  return [DO(t), e, DO(e)];
}
function DO(t) {
  return t.replace(/start|end/g, (e) => J3[e]);
}
function nZ(t, e, n) {
  const i = ["left", "right"], r = ["right", "left"], o = ["top", "bottom"], s = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? r : i : e ? i : r;
    case "left":
    case "right":
      return e ? o : s;
    default:
      return [];
  }
}
function iZ(t, e, n, i) {
  const r = xd(t);
  let o = nZ(Ea(t), n === "start", i);
  return r && (o = o.map((s) => s + "-" + r), e && (o = o.concat(o.map(DO)))), o;
}
function hf(t) {
  return t.replace(/left|right|bottom|top/g, (e) => K3[e]);
}
function rZ(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function $T(t) {
  return typeof t != "number" ? rZ(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function ff(t) {
  const {
    x: e,
    y: n,
    width: i,
    height: r
  } = t;
  return {
    width: i,
    height: r,
    top: n,
    left: e,
    right: e + i,
    bottom: n + r,
    x: e,
    y: n
  };
}
function ik(t, e, n) {
  let {
    reference: i,
    floating: r
  } = t;
  const o = tm(e), s = ub(e), a = lb(s), l = Ea(e), u = o === "y", c = i.x + i.width / 2 - r.width / 2, d = i.y + i.height / 2 - r.height / 2, h = i[a] / 2 - r[a] / 2;
  let f;
  switch (l) {
    case "top":
      f = {
        x: c,
        y: i.y - r.height
      };
      break;
    case "bottom":
      f = {
        x: c,
        y: i.y + i.height
      };
      break;
    case "right":
      f = {
        x: i.x + i.width,
        y: d
      };
      break;
    case "left":
      f = {
        x: i.x - r.width,
        y: d
      };
      break;
    default:
      f = {
        x: i.x,
        y: i.y
      };
  }
  switch (xd(e)) {
    case "start":
      f[s] -= h * (n && u ? -1 : 1);
      break;
    case "end":
      f[s] += h * (n && u ? -1 : 1);
      break;
  }
  return f;
}
const oZ = async (t, e, n) => {
  const {
    placement: i = "bottom",
    strategy: r = "absolute",
    middleware: o = [],
    platform: s
  } = n, a = o.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let u = await s.getElementRects({
    reference: t,
    floating: e,
    strategy: r
  }), {
    x: c,
    y: d
  } = ik(u, i, l), h = i, f = {}, p = 0;
  for (let m = 0; m < a.length; m++) {
    const {
      name: g,
      fn: O
    } = a[m], {
      x: y,
      y: b,
      data: v,
      reset: k
    } = await O({
      x: c,
      y: d,
      initialPlacement: i,
      placement: h,
      strategy: r,
      middlewareData: f,
      rects: u,
      platform: s,
      elements: {
        reference: t,
        floating: e
      }
    });
    c = y ?? c, d = b ?? d, f = {
      ...f,
      [g]: {
        ...f[g],
        ...v
      }
    }, k && p <= 50 && (p++, typeof k == "object" && (k.placement && (h = k.placement), k.rects && (u = k.rects === !0 ? await s.getElementRects({
      reference: t,
      floating: e,
      strategy: r
    }) : k.rects), {
      x: c,
      y: d
    } = ik(u, h, l)), m = -1);
  }
  return {
    x: c,
    y: d,
    placement: h,
    strategy: r,
    middlewareData: f
  };
};
async function PT(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: i,
    y: r,
    platform: o,
    rects: s,
    elements: a,
    strategy: l
  } = t, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: d = "floating",
    altBoundary: h = !1,
    padding: f = 0
  } = _d(e, t), p = $T(f), g = a[h ? d === "floating" ? "reference" : "floating" : d], O = ff(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(g))) == null || n ? g : g.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: l
  })), y = d === "floating" ? {
    x: i,
    y: r,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, b = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), v = await (o.isElement == null ? void 0 : o.isElement(b)) ? await (o.getScale == null ? void 0 : o.getScale(b)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, k = ff(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: y,
    offsetParent: b,
    strategy: l
  }) : y);
  return {
    top: (O.top - k.top + p.top) / v.y,
    bottom: (k.bottom - O.bottom + p.bottom) / v.y,
    left: (O.left - k.left + p.left) / v.x,
    right: (k.right - O.right + p.right) / v.x
  };
}
const sZ = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: i,
      placement: r,
      rects: o,
      platform: s,
      elements: a,
      middlewareData: l
    } = e, {
      element: u,
      padding: c = 0
    } = _d(t, e) || {};
    if (u == null)
      return {};
    const d = $T(c), h = {
      x: n,
      y: i
    }, f = ub(r), p = lb(f), m = await s.getDimensions(u), g = f === "y", O = g ? "top" : "left", y = g ? "bottom" : "right", b = g ? "clientHeight" : "clientWidth", v = o.reference[p] + o.reference[f] - h[f] - o.floating[p], k = h[f] - o.reference[f], w = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u));
    let S = w ? w[b] : 0;
    (!S || !await (s.isElement == null ? void 0 : s.isElement(w))) && (S = a.floating[b] || o.floating[p]);
    const $ = v / 2 - k / 2, C = S / 2 - m[p] / 2 - 1, L = Fl(d[O], C), j = Fl(d[y], C), P = L, A = S - m[p] - j, T = S / 2 - m[p] / 2 + $, N = RO(P, T, A), Q = !l.arrow && xd(r) != null && T !== N && o.reference[p] / 2 - (T < P ? L : j) - m[p] / 2 < 0, Y = Q ? T < P ? T - P : T - A : 0;
    return {
      [f]: h[f] + Y,
      data: {
        [f]: N,
        centerOffset: T - N - Y,
        ...Q && {
          alignmentOffset: Y
        }
      },
      reset: Q
    };
  }
}), aZ = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, i;
      const {
        placement: r,
        middlewareData: o,
        rects: s,
        initialPlacement: a,
        platform: l,
        elements: u
      } = e, {
        mainAxis: c = !0,
        crossAxis: d = !0,
        fallbackPlacements: h,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: m = !0,
        ...g
      } = _d(t, e);
      if ((n = o.arrow) != null && n.alignmentOffset)
        return {};
      const O = Ea(r), y = Ea(a) === a, b = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), v = h || (y || !m ? [hf(a)] : tZ(a));
      !h && p !== "none" && v.push(...iZ(a, m, p, b));
      const k = [a, ...v], w = await PT(e, g), S = [];
      let $ = ((i = o.flip) == null ? void 0 : i.overflows) || [];
      if (c && S.push(w[O]), d) {
        const P = eZ(r, s, b);
        S.push(w[P[0]], w[P[1]]);
      }
      if ($ = [...$, {
        placement: r,
        overflows: S
      }], !S.every((P) => P <= 0)) {
        var C, L;
        const P = (((C = o.flip) == null ? void 0 : C.index) || 0) + 1, A = k[P];
        if (A)
          return {
            data: {
              index: P,
              overflows: $
            },
            reset: {
              placement: A
            }
          };
        let T = (L = $.filter((N) => N.overflows[0] <= 0).sort((N, Q) => N.overflows[1] - Q.overflows[1])[0]) == null ? void 0 : L.placement;
        if (!T)
          switch (f) {
            case "bestFit": {
              var j;
              const N = (j = $.map((Q) => [Q.placement, Q.overflows.filter((Y) => Y > 0).reduce((Y, V) => Y + V, 0)]).sort((Q, Y) => Q[1] - Y[1])[0]) == null ? void 0 : j[0];
              N && (T = N);
              break;
            }
            case "initialPlacement":
              T = a;
              break;
          }
        if (r !== T)
          return {
            reset: {
              placement: T
            }
          };
      }
      return {};
    }
  };
};
async function lZ(t, e) {
  const {
    placement: n,
    platform: i,
    elements: r
  } = t, o = await (i.isRTL == null ? void 0 : i.isRTL(r.floating)), s = Ea(n), a = xd(n), l = tm(n) === "y", u = ["left", "top"].includes(s) ? -1 : 1, c = o && l ? -1 : 1, d = _d(e, t);
  let {
    mainAxis: h,
    crossAxis: f,
    alignmentAxis: p
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return a && typeof p == "number" && (f = a === "end" ? p * -1 : p), l ? {
    x: f * c,
    y: h * u
  } : {
    x: h * u,
    y: f * c
  };
}
const uZ = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, i;
      const {
        x: r,
        y: o,
        placement: s,
        middlewareData: a
      } = e, l = await lZ(e, t);
      return s === ((n = a.offset) == null ? void 0 : n.placement) && (i = a.arrow) != null && i.alignmentOffset ? {} : {
        x: r + l.x,
        y: o + l.y,
        data: {
          ...l,
          placement: s
        }
      };
    }
  };
}, cZ = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: i,
        placement: r
      } = e, {
        mainAxis: o = !0,
        crossAxis: s = !1,
        limiter: a = {
          fn: (g) => {
            let {
              x: O,
              y
            } = g;
            return {
              x: O,
              y
            };
          }
        },
        ...l
      } = _d(t, e), u = {
        x: n,
        y: i
      }, c = await PT(e, l), d = tm(Ea(r)), h = TT(d);
      let f = u[h], p = u[d];
      if (o) {
        const g = h === "y" ? "top" : "left", O = h === "y" ? "bottom" : "right", y = f + c[g], b = f - c[O];
        f = RO(y, f, b);
      }
      if (s) {
        const g = d === "y" ? "top" : "left", O = d === "y" ? "bottom" : "right", y = p + c[g], b = p - c[O];
        p = RO(y, p, b);
      }
      const m = a.fn({
        ...e,
        [h]: f,
        [d]: p
      });
      return {
        ...m,
        data: {
          x: m.x - n,
          y: m.y - i
        }
      };
    }
  };
};
function Ou(t) {
  return MT(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Bi(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function Ho(t) {
  var e;
  return (e = (MT(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function MT(t) {
  return t instanceof Node || t instanceof Bi(t).Node;
}
function so(t) {
  return t instanceof Element || t instanceof Bi(t).Element;
}
function ao(t) {
  return t instanceof HTMLElement || t instanceof Bi(t).HTMLElement;
}
function rk(t) {
  return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Bi(t).ShadowRoot;
}
function Cd(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: i,
    display: r
  } = _r(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + i + n) && !["inline", "contents"].includes(r);
}
function dZ(t) {
  return ["table", "td", "th"].includes(Ou(t));
}
function cb(t) {
  const e = db(), n = _r(t);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((i) => (n.willChange || "").includes(i)) || ["paint", "layout", "strict", "content"].some((i) => (n.contain || "").includes(i));
}
function hZ(t) {
  let e = Ds(t);
  for (; ao(e) && !ql(e); ) {
    if (cb(e))
      return e;
    e = Ds(e);
  }
  return null;
}
function db() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function ql(t) {
  return ["html", "body", "#document"].includes(Ou(t));
}
function _r(t) {
  return Bi(t).getComputedStyle(t);
}
function nm(t) {
  return so(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.pageXOffset,
    scrollTop: t.pageYOffset
  };
}
function Ds(t) {
  if (Ou(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    rk(t) && t.host || // Fallback.
    Ho(t)
  );
  return rk(e) ? e.host : e;
}
function ET(t) {
  const e = Ds(t);
  return ql(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : ao(e) && Cd(e) ? e : ET(e);
}
function Ic(t, e, n) {
  var i;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const r = ET(t), o = r === ((i = t.ownerDocument) == null ? void 0 : i.body), s = Bi(r);
  return o ? e.concat(s, s.visualViewport || [], Cd(r) ? r : [], s.frameElement && n ? Ic(s.frameElement) : []) : e.concat(r, Ic(r, [], n));
}
function AT(t) {
  const e = _r(t);
  let n = parseFloat(e.width) || 0, i = parseFloat(e.height) || 0;
  const r = ao(t), o = r ? t.offsetWidth : n, s = r ? t.offsetHeight : i, a = df(n) !== o || df(i) !== s;
  return a && (n = o, i = s), {
    width: n,
    height: i,
    $: a
  };
}
function hb(t) {
  return so(t) ? t : t.contextElement;
}
function bl(t) {
  const e = hb(t);
  if (!ao(e))
    return Rs(1);
  const n = e.getBoundingClientRect(), {
    width: i,
    height: r,
    $: o
  } = AT(e);
  let s = (o ? df(n.width) : n.width) / i, a = (o ? df(n.height) : n.height) / r;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const fZ = /* @__PURE__ */ Rs(0);
function RT(t) {
  const e = Bi(t);
  return !db() || !e.visualViewport ? fZ : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function pZ(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== Bi(t) ? !1 : e;
}
function Aa(t, e, n, i) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const r = t.getBoundingClientRect(), o = hb(t);
  let s = Rs(1);
  e && (i ? so(i) && (s = bl(i)) : s = bl(t));
  const a = pZ(o, n, i) ? RT(o) : Rs(0);
  let l = (r.left + a.x) / s.x, u = (r.top + a.y) / s.y, c = r.width / s.x, d = r.height / s.y;
  if (o) {
    const h = Bi(o), f = i && so(i) ? Bi(i) : i;
    let p = h, m = p.frameElement;
    for (; m && i && f !== p; ) {
      const g = bl(m), O = m.getBoundingClientRect(), y = _r(m), b = O.left + (m.clientLeft + parseFloat(y.paddingLeft)) * g.x, v = O.top + (m.clientTop + parseFloat(y.paddingTop)) * g.y;
      l *= g.x, u *= g.y, c *= g.x, d *= g.y, l += b, u += v, p = Bi(m), m = p.frameElement;
    }
  }
  return ff({
    width: c,
    height: d,
    x: l,
    y: u
  });
}
const mZ = [":popover-open", ":modal"];
function fb(t) {
  return mZ.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
function gZ(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: i,
    strategy: r
  } = t;
  const o = r === "fixed", s = Ho(i), a = e ? fb(e.floating) : !1;
  if (i === s || a && o)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = Rs(1);
  const c = Rs(0), d = ao(i);
  if ((d || !d && !o) && ((Ou(i) !== "body" || Cd(s)) && (l = nm(i)), ao(i))) {
    const h = Aa(i);
    u = bl(i), c.x = h.x + i.clientLeft, c.y = h.y + i.clientTop;
  }
  return {
    width: n.width * u.x,
    height: n.height * u.y,
    x: n.x * u.x - l.scrollLeft * u.x + c.x,
    y: n.y * u.y - l.scrollTop * u.y + c.y
  };
}
function OZ(t) {
  return Array.from(t.getClientRects());
}
function DT(t) {
  return Aa(Ho(t)).left + nm(t).scrollLeft;
}
function vZ(t) {
  const e = Ho(t), n = nm(t), i = t.ownerDocument.body, r = va(e.scrollWidth, e.clientWidth, i.scrollWidth, i.clientWidth), o = va(e.scrollHeight, e.clientHeight, i.scrollHeight, i.clientHeight);
  let s = -n.scrollLeft + DT(t);
  const a = -n.scrollTop;
  return _r(i).direction === "rtl" && (s += va(e.clientWidth, i.clientWidth) - r), {
    width: r,
    height: o,
    x: s,
    y: a
  };
}
function yZ(t, e) {
  const n = Bi(t), i = Ho(t), r = n.visualViewport;
  let o = i.clientWidth, s = i.clientHeight, a = 0, l = 0;
  if (r) {
    o = r.width, s = r.height;
    const u = db();
    (!u || u && e === "fixed") && (a = r.offsetLeft, l = r.offsetTop);
  }
  return {
    width: o,
    height: s,
    x: a,
    y: l
  };
}
function bZ(t, e) {
  const n = Aa(t, !0, e === "fixed"), i = n.top + t.clientTop, r = n.left + t.clientLeft, o = ao(t) ? bl(t) : Rs(1), s = t.clientWidth * o.x, a = t.clientHeight * o.y, l = r * o.x, u = i * o.y;
  return {
    width: s,
    height: a,
    x: l,
    y: u
  };
}
function ok(t, e, n) {
  let i;
  if (e === "viewport")
    i = yZ(t, n);
  else if (e === "document")
    i = vZ(Ho(t));
  else if (so(e))
    i = bZ(e, n);
  else {
    const r = RT(t);
    i = {
      ...e,
      x: e.x - r.x,
      y: e.y - r.y
    };
  }
  return ff(i);
}
function QT(t, e) {
  const n = Ds(t);
  return n === e || !so(n) || ql(n) ? !1 : _r(n).position === "fixed" || QT(n, e);
}
function wZ(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let i = Ic(t, [], !1).filter((a) => so(a) && Ou(a) !== "body"), r = null;
  const o = _r(t).position === "fixed";
  let s = o ? Ds(t) : t;
  for (; so(s) && !ql(s); ) {
    const a = _r(s), l = cb(s);
    !l && a.position === "fixed" && (r = null), (o ? !l && !r : !l && a.position === "static" && !!r && ["absolute", "fixed"].includes(r.position) || Cd(s) && !l && QT(t, s)) ? i = i.filter((c) => c !== s) : r = a, s = Ds(s);
  }
  return e.set(t, i), i;
}
function kZ(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: i,
    strategy: r
  } = t;
  const s = [...n === "clippingAncestors" ? fb(e) ? [] : wZ(e, this._c) : [].concat(n), i], a = s[0], l = s.reduce((u, c) => {
    const d = ok(e, c, r);
    return u.top = va(d.top, u.top), u.right = Fl(d.right, u.right), u.bottom = Fl(d.bottom, u.bottom), u.left = va(d.left, u.left), u;
  }, ok(e, a, r));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function SZ(t) {
  const {
    width: e,
    height: n
  } = AT(t);
  return {
    width: e,
    height: n
  };
}
function _Z(t, e, n) {
  const i = ao(e), r = Ho(e), o = n === "fixed", s = Aa(t, !0, o, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Rs(0);
  if (i || !i && !o)
    if ((Ou(e) !== "body" || Cd(r)) && (a = nm(e)), i) {
      const d = Aa(e, !0, o, e);
      l.x = d.x + e.clientLeft, l.y = d.y + e.clientTop;
    } else
      r && (l.x = DT(r));
  const u = s.left + a.scrollLeft - l.x, c = s.top + a.scrollTop - l.y;
  return {
    x: u,
    y: c,
    width: s.width,
    height: s.height
  };
}
function ng(t) {
  return _r(t).position === "static";
}
function sk(t, e) {
  return !ao(t) || _r(t).position === "fixed" ? null : e ? e(t) : t.offsetParent;
}
function NT(t, e) {
  const n = Bi(t);
  if (fb(t))
    return n;
  if (!ao(t)) {
    let r = Ds(t);
    for (; r && !ql(r); ) {
      if (so(r) && !ng(r))
        return r;
      r = Ds(r);
    }
    return n;
  }
  let i = sk(t, e);
  for (; i && dZ(i) && ng(i); )
    i = sk(i, e);
  return i && ql(i) && ng(i) && !cb(i) ? n : i || hZ(t) || n;
}
const xZ = async function(t) {
  const e = this.getOffsetParent || NT, n = this.getDimensions, i = await n(t.floating);
  return {
    reference: _Z(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
};
function CZ(t) {
  return _r(t).direction === "rtl";
}
const TZ = {
  convertOffsetParentRelativeRectToViewportRelativeRect: gZ,
  getDocumentElement: Ho,
  getClippingRect: kZ,
  getOffsetParent: NT,
  getElementRects: xZ,
  getClientRects: OZ,
  getDimensions: SZ,
  getScale: bl,
  isElement: so,
  isRTL: CZ
};
function $Z(t, e) {
  let n = null, i;
  const r = Ho(t);
  function o() {
    var a;
    clearTimeout(i), (a = n) == null || a.disconnect(), n = null;
  }
  function s(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), o();
    const {
      left: u,
      top: c,
      width: d,
      height: h
    } = t.getBoundingClientRect();
    if (a || e(), !d || !h)
      return;
    const f = Xd(c), p = Xd(r.clientWidth - (u + d)), m = Xd(r.clientHeight - (c + h)), g = Xd(u), y = {
      rootMargin: -f + "px " + -p + "px " + -m + "px " + -g + "px",
      threshold: va(0, Fl(1, l)) || 1
    };
    let b = !0;
    function v(k) {
      const w = k[0].intersectionRatio;
      if (w !== l) {
        if (!b)
          return s();
        w ? s(!1, w) : i = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      b = !1;
    }
    try {
      n = new IntersectionObserver(v, {
        ...y,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(v, y);
    }
    n.observe(t);
  }
  return s(!0), o;
}
function IT(t, e, n, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = i, u = hb(t), c = r || o ? [...u ? Ic(u) : [], ...Ic(e)] : [];
  c.forEach((O) => {
    r && O.addEventListener("scroll", n, {
      passive: !0
    }), o && O.addEventListener("resize", n);
  });
  const d = u && a ? $Z(u, n) : null;
  let h = -1, f = null;
  s && (f = new ResizeObserver((O) => {
    let [y] = O;
    y && y.target === u && f && (f.unobserve(e), cancelAnimationFrame(h), h = requestAnimationFrame(() => {
      var b;
      (b = f) == null || b.observe(e);
    })), n();
  }), u && !l && f.observe(u), f.observe(e));
  let p, m = l ? Aa(t) : null;
  l && g();
  function g() {
    const O = Aa(t);
    m && (O.x !== m.x || O.y !== m.y || O.width !== m.width || O.height !== m.height) && n(), m = O, p = requestAnimationFrame(g);
  }
  return n(), () => {
    var O;
    c.forEach((y) => {
      r && y.removeEventListener("scroll", n), o && y.removeEventListener("resize", n);
    }), d == null || d(), (O = f) == null || O.disconnect(), f = null, l && cancelAnimationFrame(p);
  };
}
const LT = uZ, PZ = cZ, VT = aZ, BT = sZ, ZT = (t, e, n) => {
  const i = /* @__PURE__ */ new Map(), r = {
    platform: TZ,
    ...n
  }, o = {
    ...r.platform,
    _c: i
  };
  return oZ(t, e, {
    ...r,
    platform: o
  });
};
function pb(t) {
  return Ey() ? (Ay(t), !0) : !1;
}
const mb = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const MZ = Object.prototype.toString, EZ = (t) => MZ.call(t) === "[object Object]", wl = () => {
}, QO = /* @__PURE__ */ AZ();
function AZ() {
  var t, e;
  return mb && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function ak(t) {
  return Array.isArray(t) ? t : [t];
}
function RZ(...t) {
  if (t.length !== 1)
    return Ca(...t);
  const e = t[0];
  return typeof e == "function" ? Yx(Hx(() => ({ get: e, set: wl }))) : re(e);
}
function DZ(t, e, n = {}) {
  const {
    immediate: i = !0
  } = n, r = re(!1);
  let o = null;
  function s() {
    o && (clearTimeout(o), o = null);
  }
  function a() {
    r.value = !1, s();
  }
  function l(...u) {
    s(), r.value = !0, o = setTimeout(() => {
      r.value = !1, o = null, t(...u);
    }, Ro(e));
  }
  return i && (r.value = !0, mb && l()), pb(a), {
    isPending: Yx(r),
    start: l,
    stop: a
  };
}
function lk(t = 1e3, e = {}) {
  const {
    controls: n = !1,
    callback: i
  } = e, r = DZ(
    i ?? wl,
    t,
    e
  ), o = J(() => !r.isPending.value);
  return n ? {
    ready: o,
    ...r
  } : o;
}
const FT = mb ? window : void 0;
function zu(t) {
  var e;
  const n = Ro(t);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
function Ah(...t) {
  let e, n, i, r;
  if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([n, i, r] = t, e = FT) : [e, n, i, r] = t, !e)
    return wl;
  n = ak(n), i = ak(i);
  const o = [], s = () => {
    o.forEach((c) => c()), o.length = 0;
  }, a = (c, d, h, f) => (c.addEventListener(d, h, f), () => c.removeEventListener(d, h, f)), l = gt(
    () => [zu(e), Ro(r)],
    ([c, d]) => {
      if (s(), !c)
        return;
      const h = EZ(d) ? { ...d } : d;
      o.push(
        ...n.flatMap((f) => i.map((p) => a(c, f, p, h)))
      );
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    l(), s();
  };
  return pb(u), u;
}
let uk = !1;
function ck(t, e, n = {}) {
  const { window: i = FT, ignore: r = [], capture: o = !0, detectIframe: s = !1 } = n;
  if (!i)
    return wl;
  QO && !uk && (uk = !0, Array.from(i.document.body.children).forEach((m) => m.addEventListener("click", wl)), i.document.documentElement.addEventListener("click", wl));
  let a = !0;
  const l = (m) => Ro(r).some((g) => {
    if (typeof g == "string")
      return Array.from(i.document.querySelectorAll(g)).some((O) => O === m.target || m.composedPath().includes(O));
    {
      const O = zu(g);
      return O && (m.target === O || m.composedPath().includes(O));
    }
  });
  function u(m) {
    const g = Ro(m);
    return g && g.$.subTree.shapeFlag === 16;
  }
  function c(m, g) {
    const O = Ro(m), y = O.$.subTree && O.$.subTree.children;
    return y == null || !Array.isArray(y) ? !1 : y.some((b) => b.el === g.target || g.composedPath().includes(b.el));
  }
  const d = (m) => {
    const g = zu(t);
    if (m.target != null && !(!(g instanceof Element) && u(t) && c(t, m)) && !(!g || g === m.target || m.composedPath().includes(g))) {
      if (m.detail === 0 && (a = !l(m)), !a) {
        a = !0;
        return;
      }
      e(m);
    }
  };
  let h = !1;
  const f = [
    Ah(i, "click", (m) => {
      h || (h = !0, setTimeout(() => {
        h = !1;
      }, 0), d(m));
    }, { passive: !0, capture: o }),
    Ah(i, "pointerdown", (m) => {
      const g = zu(t);
      a = !l(m) && !!(g && !m.composedPath().includes(g));
    }, { passive: !0 }),
    s && Ah(i, "blur", (m) => {
      setTimeout(() => {
        var g;
        const O = zu(t);
        ((g = i.document.activeElement) == null ? void 0 : g.tagName) === "IFRAME" && !(O != null && O.contains(i.document.activeElement)) && e(m);
      }, 0);
    }, { passive: !0 })
  ].filter(Boolean);
  return () => f.forEach((m) => m());
}
const QZ = {
  mounted(t, e) {
    const n = !e.modifiers.bubble;
    if (typeof e.value == "function")
      t.__onClickOutside_stop = ck(t, e.value, { capture: n });
    else {
      const [i, r] = e.value;
      t.__onClickOutside_stop = ck(t, i, Object.assign({ capture: n }, r));
    }
  },
  unmounted(t) {
    t.__onClickOutside_stop();
  }
};
function ig(t) {
  return typeof Window < "u" && t instanceof Window ? t.document.documentElement : typeof Document < "u" && t instanceof Document ? t.documentElement : t;
}
function qT(t) {
  const e = window.getComputedStyle(t);
  if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && t.clientWidth < t.scrollWidth || e.overflowY === "auto" && t.clientHeight < t.scrollHeight)
    return !0;
  {
    const n = t.parentNode;
    return !n || n.tagName === "BODY" ? !1 : qT(n);
  }
}
function NZ(t) {
  const e = t || window.event, n = e.target;
  return qT(n) ? !1 : e.touches.length > 1 ? !0 : (e.preventDefault && e.preventDefault(), !1);
}
const rg = /* @__PURE__ */ new WeakMap();
function IZ(t, e = !1) {
  const n = re(e);
  let i = null, r = "";
  gt(RZ(t), (a) => {
    const l = ig(Ro(a));
    if (l) {
      const u = l;
      if (rg.get(u) || rg.set(u, u.style.overflow), u.style.overflow !== "hidden" && (r = u.style.overflow), u.style.overflow === "hidden")
        return n.value = !0;
      if (n.value)
        return u.style.overflow = "hidden";
    }
  }, {
    immediate: !0
  });
  const o = () => {
    const a = ig(Ro(t));
    !a || n.value || (QO && (i = Ah(
      a,
      "touchmove",
      (l) => {
        NZ(l);
      },
      { passive: !1 }
    )), a.style.overflow = "hidden", n.value = !0);
  }, s = () => {
    const a = ig(Ro(t));
    !a || !n.value || (QO && (i == null || i()), a.style.overflow = r, rg.delete(a), n.value = !1);
  };
  return pb(s), J({
    get() {
      return n.value;
    },
    set(a) {
      a ? o() : s();
    }
  });
}
function LZ() {
  let t = !1;
  const e = re(!1);
  return (n, i) => {
    if (e.value = i.value, t)
      return;
    t = !0;
    const r = IZ(n, i.value);
    gt(e, (o) => r.value = o);
  };
}
LZ();
const VZ = ["data-show"], gb = /* @__PURE__ */ Te({
  __name: "mt-floating-ui",
  props: {
    isOpened: { type: Boolean },
    floatingUiOptions: {},
    showArrow: { type: Boolean },
    offset: {},
    autoUpdateOptions: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    var p;
    const n = t, i = e;
    let r = re(null);
    const o = re(null), s = re(null), a = re(null);
    let l;
    const u = window.document.querySelector("body"), c = (p = r.value) == null ? void 0 : p.parentElement, d = () => {
      var g;
      if (!o.value || !r.value)
        return;
      u.appendChild(r.value);
      const m = [...((g = a.value) == null ? void 0 : g.classList.values()) ?? []].filter(
        (O) => O !== "mt-floating-ui"
      );
      r.value.classList.add(...m), l = IT(
        o.value,
        r.value,
        () => {
          var O;
          !o.value || !r.value || ZT(o.value, r.value, {
            placement: "bottom-start",
            strategy: "fixed",
            middleware: [
              LT(n.offset ?? 6),
              ...(() => n.showArrow && s.value ? [BT({ element: s.value })] : [])(),
              VT(),
              ...((O = n.floatingUiOptions) == null ? void 0 : O.middleware) ?? []
            ],
            ...n.floatingUiOptions
          }).then(({ x: y, y: b, middlewareData: v, placement: k }) => {
            if (!r.value)
              return;
            const w = {
              top: "bottom",
              right: "left",
              bottom: "top",
              left: "right"
            }[k.split("-")[0]];
            n.showArrow && s.value && v.arrow && Object.assign(s.value.style, {
              left: v.arrow.x != null ? `${v.arrow.x}px` : "",
              top: v.arrow.y != null ? `${v.arrow.y}px` : "",
              right: "",
              bottom: "",
              [w]: "-2px"
            }), Object.assign(r.value.style, {
              left: `${y}px`,
              top: `${b}px`
            }), ["top", "right", "bottom", "left"].forEach((S) => {
              var $;
              ($ = r.value) == null || $.classList.remove(`mt-floating-ui--${S}`);
            }), r.value.classList.add(`mt-floating-ui--${w}`);
          });
        },
        {
          // fixes endless compute loop in rare situations (e.g. data-table)
          layoutShift: !1,
          ...n.autoUpdateOptions
        }
      );
    }, h = () => {
      l && l(), r.value && // floatingUiContent.value have to be direct child of bodyContainer
      r.value.parentElement === u && (c == null || c.appendChild(r.value));
    };
    gt(
      () => n.isOpened,
      (m) => {
        m ? nn(() => {
          d();
        }) : h();
      },
      { immediate: !0 }
    );
    const f = (m) => {
      var g;
      (g = a.value) != null && g.contains(m.target) || i("close");
    };
    return Zs(() => {
      var m;
      h(), r != null && r.value && c ? c == null || c.removeChild(r == null ? void 0 : r.value) : (m = r == null ? void 0 : r.value) == null || m.remove();
    }), (m, g) => (_(), Z("div", {
      ref_key: "floatingUi",
      ref: a,
      class: "mt-floating-ui"
    }, [
      X("div", {
        ref_key: "floatingUiTrigger",
        ref: o,
        class: "mt-floating-ui__trigger"
      }, [
        ne(m.$slots, "trigger")
      ], 512),
      m.isOpened ? yt((_(), Z("div", {
        key: 0,
        ref_key: "floatingUiContent",
        ref: r,
        class: "mt-floating-ui__content",
        "data-show": m.isOpened,
        tabindex: "0"
      }, [
        m.showArrow ? (_(), Z("div", {
          key: 0,
          ref_key: "floatingUiArrow",
          ref: s,
          class: "mt-floating-ui__arrow",
          "data-popper-arrow": ""
        }, null, 512)) : W("", !0),
        fe(Fn, { name: "popoverTransition" }, {
          default: H(() => [
            m.isOpened ? ne(m.$slots, "default", { key: 0 }) : W("", !0)
          ]),
          _: 3
        })
      ], 8, VZ)), [
        [E(QZ), f]
      ]) : W("", !0)
    ], 512));
  }
});
const BZ = Te({
  name: "MtColorpicker",
  setup() {
    const { t } = Lt({
      messages: {
        en: {
          "mt-colorpicker": {
            apply: "Apply"
          }
        },
        de: {
          "mt-colorpicker": {
            apply: "Anwenden"
          }
        }
      }
    });
    return {
      t
    };
  },
  components: {
    "mt-base-field": As,
    "mt-text": Pi,
    "mt-floating-ui": gb,
    "mt-button": Sr,
    "mt-field-error": Xs
  },
  props: {
    /**
     * The value of the colorpicker field.
     */
    modelValue: {
      type: String,
      required: !1,
      default: ""
    },
    /**
     * A label for your text field. Usually used to guide the user what value this field controls.
     */
    label: {
      type: String,
      required: !1,
      default: null
    },
    /**
     * A text that helps the user to understand what this field does.
     */
    helpText: {
      type: String,
      required: !1,
      default: null
    },
    /**
     * Change the output value which gets emitted and shown in the field.
     * @values auto, hex, hsl, rgb
     */
    colorOutput: {
      type: String,
      required: !1,
      default: "auto"
    },
    /**
     * If activated then the color value can contain alpha values
     */
    alpha: {
      type: Boolean,
      required: !1,
      default: !0
    },
    /**
     * Determines if the field is disabled.
     */
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines if the field is required.
     */
    required: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Toggles the inheritance visualization.
     */
    isInherited: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines if the field is inheritable.
     */
    isInheritanceField: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines the active state of the inheritance toggle.
     */
    disableInheritanceToggle: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines if the field can be edited
     */
    readonly: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Toggle the labels above each field inside the colorpicker
     */
    colorLabels: {
      type: Boolean,
      required: !1,
      default: !0
    },
    zIndex: {
      type: [Number, null],
      required: !1,
      default: null
    },
    /**
     * An error in your business logic related to this field.
     *
     * @example {"code": 500, "detail": "Error while saving"}
     */
    error: {
      type: Object,
      required: !1,
      default: null
    },
    /**
     * @ignore
     */
    name: {
      type: String,
      required: !1,
      default: null
    },
    /**
     * Show the colorpicker in a compact mode
     */
    compact: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Use apply-mode to apply the color value on button click
     */
    applyMode: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  data() {
    return {
      localValue: this.modelValue,
      visible: !1,
      isDragging: !1,
      userInput: null,
      luminanceValue: 50,
      saturationValue: 50,
      hueValue: 0,
      alphaValue: 1,
      hasFocus: !1
    };
  },
  computed: {
    colorValue: {
      get() {
        return this.localValue;
      },
      set(t) {
        this.localValue = t, this.debounceEmitColorValue();
      }
    },
    integerAlpha: {
      get() {
        return Math.floor(this.alphaValue * 100);
      },
      set(t) {
        this.alphaValue = t / 100;
      }
    },
    sliderBackground() {
      return `linear-gradient(90deg, hsla(${this.hueValue}, ${this.saturationValue}%, ${this.luminanceValue}%, 0), hsl(${this.hueValue}, ${this.saturationValue}%, ${this.luminanceValue}%)), url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' width='100%25' height='100%25'%3E%3Crect width='10' height='10' x='00' y='00' fill='%23cdd5db' /%3E%3Crect width='10' height='10' x='10' y='10' fill='%23cdd5db' /%3E%3C/svg%3E")`;
    },
    isColorValid() {
      return typeof this.colorValue == "string" ? this.colorValue.startsWith("rgb") || this.colorValue.startsWith("hsl") || this.colorValue.startsWith("#") : this.colorValue.string.startsWith("rgb") || this.colorValue.string.startsWith("hsl") || this.colorValue.string.startsWith("#");
    },
    previewColorValue() {
      return this.isColorValid ? typeof this.colorValue == "string" ? this.colorValue : this.colorValue.string : "transparent";
    },
    selectorBackground() {
      return `hsl(${this.hueValue}, 100%, 50%)`;
    },
    redValue: {
      get() {
        const t = this.convertHSLtoRGB(
          this.hueValue,
          this.saturationValue,
          this.luminanceValue,
          this.alphaValue
        );
        return Number(typeof t != "string" ? t.red : t);
      },
      set(t) {
        this.setSingleRGBValue(t, "red");
      }
    },
    greenValue: {
      get() {
        const t = this.convertHSLtoRGB(
          this.hueValue,
          this.saturationValue,
          this.luminanceValue,
          this.alphaValue
        );
        return Number(typeof t != "string" ? t.green : t);
      },
      set(t) {
        this.setSingleRGBValue(t, "green");
      }
    },
    blueValue: {
      get() {
        const t = this.convertHSLtoRGB(
          this.hueValue,
          this.saturationValue,
          this.luminanceValue,
          this.alphaValue
        );
        return Number(typeof t != "string" ? t.blue : t);
      },
      set(t) {
        this.setSingleRGBValue(t, "blue");
      }
    },
    rgbValue() {
      const t = this.convertHSLtoRGB(
        Math.abs(this.hueValue),
        Math.abs(this.saturationValue),
        Math.abs(this.luminanceValue),
        Math.abs(this.alphaValue)
      );
      return typeof t != "string" ? t.string : t;
    },
    hslValue() {
      const t = Math.abs(Math.floor(this.hueValue)), e = Math.abs(Math.floor(this.saturationValue)), n = Math.abs(Math.floor(this.luminanceValue));
      if (this.alphaValue !== 1) {
        const i = Math.abs(Number(this.alphaValue.toFixed(2)));
        return `hsla(${t}, ${e}%, ${n}%, ${i})`;
      }
      return `hsl(${t}, ${e}%, ${n}%)`;
    },
    hexValue: {
      get() {
        return this.alphaValue < 1 ? this.convertHSLtoHEX(
          this.hueValue,
          this.saturationValue,
          this.luminanceValue,
          this.alphaValue
        ) : this.convertHSLtoHEX(this.hueValue, this.saturationValue, this.luminanceValue);
      },
      set(t) {
        const e = t;
        if (!/^#[0-9a-f]{3,8}/i.test(e))
          return;
        const i = this.convertHEXtoHSL(t);
        i !== !1 && this.setHslaValues(
          i.hue,
          i.saturation,
          i.luminance,
          i.alpha ?? this.alphaValue
        );
      }
    },
    convertedValue() {
      switch (this.colorOutput) {
        case "auto":
          return this.alphaValue < 1 ? this.rgbValue : this.hexValue;
        case "rgb":
          return this.rgbValue;
        case "hsl":
          return this.hslValue;
        case "hex":
        default:
          return this.hexValue;
      }
    },
    selectorPositionX() {
      return `calc(${this.saturationValue}% - 9px)`;
    },
    selectorPositionY() {
      return `calc(${Math.abs(this.luminanceValue - 100)}% - 9px)`;
    },
    selectorStyles() {
      return {
        backgroundColor: this.hslValue,
        top: this.selectorPositionY,
        left: this.selectorPositionX
      };
    },
    componentClasses() {
      return {
        "mt-colorpicker": !0,
        "mt-colorpicker--compact": this.compact
      };
    }
  },
  watch: {
    modelValue() {
      this.colorValue = this.modelValue;
    },
    hslValue() {
      this.colorValue = this.convertedValue;
    },
    visible(t, e) {
      if (this.applyMode && !t && e && (this.colorValue = this.modelValue), !t)
        return;
      const n = this.colorValue;
      if ((typeof n == "string" ? n : n.string).startsWith("#")) {
        const i = this.convertHEXtoHSL(
          typeof this.colorValue == "string" ? this.colorValue : this.colorValue.string
        );
        if (!i)
          return;
        this.setHslaValues(
          i.hue,
          i.saturation,
          i.luminance,
          i.alpha
        );
      } else if ((typeof n == "string" ? n : n.string).startsWith("rgb")) {
        const i = this.splitRGBValues(
          typeof this.colorValue == "string" ? this.colorValue : this.colorValue.string
        ), r = this.convertRGBtoHSL(
          i.red,
          i.green,
          i.blue
        );
        this.setHslaValues(
          r.hue,
          r.saturation,
          r.luminance,
          i.alpha
        );
      } else if ((typeof n == "string" ? n : n.string).startsWith("hsl")) {
        const i = this.splitHSLValues(
          typeof this.colorValue == "string" ? this.colorValue : this.colorValue.string
        );
        this.setHslaValues(
          i.hue,
          i.saturation,
          i.luminance,
          i.alpha
        );
      }
    }
  },
  beforeUnmount() {
    window.removeEventListener("mousedown", this.outsideClick);
  },
  methods: {
    debounceEmitColorValue: Kp(function() {
      this.applyMode || this.$emit("update:modelValue", this.colorValue);
    }, 50),
    outsideClick(t) {
      /^mt-colorpicker__previewColor.active/.test(t.target._prevClass) || t.target.closest(".mt-colorpicker__colorpicker") !== null || (this.visible = !1, this.removeOutsideClickEvent());
    },
    setOutsideClickEvent() {
      window.addEventListener("mousedown", this.outsideClick);
    },
    removeOutsideClickEvent() {
      window.removeEventListener("mousedown", this.outsideClick);
    },
    toggleColorPicker() {
      if (!this.disabled) {
        if (this.visible = !this.visible, this.visible) {
          this.setOutsideClickEvent();
          return;
        }
        this.removeOutsideClickEvent();
      }
    },
    applyColor() {
      this.$emit("update:modelValue", this.colorValue), this.visible = !1;
    },
    moveSelector(t) {
      if (!this.isDragging)
        return;
      const e = this.$refs.colorPicker.getBoundingClientRect(), n = t.clientX - e.left, i = t.clientY - e.top, r = n / e.width * 100;
      let o;
      r > 100 ? o = 100 : r < 0 ? o = 0 : o = r;
      const s = (i / e.height - 1) * -100;
      let a;
      s > 100 ? a = 100 : s < 0 ? a = 0 : a = s, this.saturationValue = Math.floor(o), this.luminanceValue = Math.floor(a);
    },
    setDragging(t) {
      document.body.style.userSelect = "none", this.isDragging = !0, this.moveSelector(t), window.addEventListener("mousemove", this.moveSelector, !1), window.addEventListener("mouseup", this.removeDragging, !1);
    },
    removeDragging() {
      document.body.style.userSelect = null, this.isDragging = !1, window.removeEventListener("mousemove", this.moveSelector), window.removeEventListener("mouseup", this.removeDragging);
    },
    setSingleRGBValue(t, e) {
      if (!["red", "green", "blue"].includes(e))
        return;
      let i = null;
      t > 255 ? i = 255 : t < 0 ? i = 0 : i = t;
      const r = this.convertRGBtoHSL(
        e === "red" ? i : this.redValue,
        e === "green" ? i : this.greenValue,
        e === "blue" ? i : this.blueValue
      );
      this.setHslaValues(r.hue, r.saturation, r.luminance, this.alphaValue);
    },
    setHslaValues(t, e, n, i) {
      this.hueValue = t, this.luminanceValue = n, this.saturationValue = e, this.alphaValue = i || 1;
    },
    splitRGBValues(t) {
      const e = t.slice(t.indexOf("(") + 1, t.length - 1).split(", "), n = Number(e[0]), i = Number(e[1]), r = Number(e[2]), o = {
        red: n,
        green: i,
        blue: r
      };
      return t.includes("a") && (o.alpha = Number(e[3])), o;
    },
    splitHSLValues(t) {
      const e = t.slice(t.indexOf("(") + 1, t.length - 1).split(", "), n = Number(e[0]), i = Number(e[1].slice(0, e[1].length - 1)), r = Number(e[2].slice(0, e[2].length - 1)), o = e[3] || Number(e[3]) === 0 ? Number(e[3]) : void 0, s = {
        hue: n,
        saturation: i,
        luminance: r
      };
      return o !== void 0 && (s.alpha = o), s;
    },
    convertHSLtoRGB(t, e, n, i) {
      const r = {
        hue: t,
        saturation: e,
        luminance: n,
        alpha: i
      };
      return this.convertHSL("rgb", r);
    },
    convertHSLtoHEX(t, e, n, i) {
      const r = {
        hue: t,
        saturation: e,
        luminance: n,
        alpha: i
      };
      return this.convertHSL("hex", r);
    },
    convertHSL(t, e) {
      if (!["hex", "rgb"].includes(t))
        return {
          string: "",
          red: "",
          green: "",
          blue: ""
        };
      let { hue: i, saturation: r, luminance: o, alpha: s } = e;
      r /= 100, o /= 100;
      const a = (1 - Math.abs(2 * o - 1)) * r, l = a * (1 - Math.abs(i / 60 % 2 - 1)), u = o - a / 2;
      let c = 0, d = 0, h = 0;
      if (i >= 0 && i < 60 ? (c = a, d = l, h = 0) : i >= 60 && i < 120 ? (c = l, d = a, h = 0) : i >= 120 && i < 180 ? (c = 0, d = a, h = l) : i >= 180 && i < 240 ? (c = 0, d = l, h = a) : i >= 240 && i < 300 ? (c = l, d = 0, h = a) : i >= 300 && i < 361 && (c = a, d = 0, h = l), c = Math.round((c + u) * 255), d = Math.round((d + u) * 255), h = Math.round((h + u) * 255), t === "hex")
        return c = c.toString(16), d = d.toString(16), h = h.toString(16), c.length === 1 && (c = `0${c}`), d.length === 1 && (d = `0${d}`), h.length === 1 && (h = `0${h}`), s === void 0 ? `#${c}${d}${h}` : (s = Math.round(s * 255).toString(16), s.length === 1 && (s = `0${s}`), `#${c}${d}${h}${s}`);
      const f = {
        string: `rgb(${c}, ${d}, ${h})`,
        red: typeof c == "string" ? c : c.toString(),
        green: typeof d == "string" ? d : d.toString(),
        blue: typeof h == "string" ? h : h.toString(),
        alpha: void 0
      };
      return s !== 1 && (f.string = `rgba(${c}, ${d}, ${h}, ${s})`, typeof s == "string" ? f.alpha = s : s !== void 0 ? f.alpha = s.toString() : f.alpha = s), f;
    },
    convertRGBtoHSL(t, e, n) {
      let i = t, r = e, o = n;
      i.toString().startsWith("-") && (i = Math.abs(i)), o.toString().startsWith("-") && (o = Math.abs(o)), r.toString().startsWith("-") && (r = Math.abs(r)), i /= 255, r /= 255, o /= 255;
      const s = Math.min(i, r, o), a = Math.max(i, r, o), l = a - s;
      let u = 0, c = 0, d = 0;
      return l === 0 ? u = 0 : a === i ? u = (r - o) / l % 6 : a === r ? u = (o - i) / l + 2 : u = (i - r) / l + 4, u = Math.round(u * 60), u < 0 && (u += 360), d = (a + s) / 2, c = l === 0 ? 0 : l / (1 - Math.abs(2 * d - 1)), c = +(c * 100).toFixed(1), d = +(d * 100).toFixed(1), {
        string: `hsl(${u},${c}%,${d}%)`,
        hue: u,
        saturation: c,
        luminance: d
      };
    },
    convertHEXtoHSL(t) {
      const e = t;
      let n = 0, i = 0, r = 0, o;
      if (e.length !== 5 && e.length !== 9 && e.length !== 4 && e.length !== 7)
        return !1;
      e.length === 5 ? (n = `0x${e[1]}${e[1]}`, i = `0x${e[2]}${e[2]}`, r = `0x${e[3]}${e[3]}`, o = `0x${e[4]}${e[4]}`) : e.length === 9 ? (n = `0x${e[1]}${e[2]}`, i = `0x${e[3]}${e[4]}`, r = `0x${e[5]}${e[6]}`, o = `0x${e[7]}${e[8]}`) : e.length === 4 ? (n = `0x${e[1]}${e[1]}`, i = `0x${e[2]}${e[2]}`, r = `0x${e[3]}${e[3]}`) : e.length === 7 && (n = `0x${e[1]}${e[2]}`, i = `0x${e[3]}${e[4]}`, r = `0x${e[5]}${e[6]}`), n /= 255, i /= 255, r /= 255;
      const s = Math.min(Number(n), Number(i), Number(r)), a = Math.max(Number(n), Number(i), Number(r)), l = a - s;
      let u = 0, c = 0, d = 0;
      l === 0 ? u = 0 : a === n ? u = (Number(i) - Number(r)) / l % 6 : a === i ? u = (Number(r) - Number(n)) / l + 2 : u = (Number(n) - Number(i)) / l + 4, u = Math.round(u * 60), u < 0 && (u += 360), d = (a + s) / 2, c = l === 0 ? 0 : l / (1 - Math.abs(2 * d - 1)), c = +(c * 100).toFixed(1), d = +(d * 100).toFixed(1);
      const h = {
        string: `hsl(${u}, ${c}%, ${d}%)`,
        hue: u,
        saturation: c,
        luminance: d,
        alpha: void 0
      };
      return h.string = `hsla(${u}, ${c}%, ${d}, ${o}%)`, o = Number((Number(o) / 255).toFixed(2)), h.alpha = o, h;
    },
    onClickInput() {
      this.readonly && this.toggleColorPicker();
    },
    setFocusClass() {
      this.hasFocus = !0;
    },
    removeFocusClass() {
      this.hasFocus = !1;
    }
  }
});
const ZZ = ["aria-pressed"], FZ = ["disabled", "readonly"], qZ = { class: "mt-colorpicker__colorpicker" }, WZ = { class: "mt-colorpicker__row" }, XZ = { class: "mt-colorpicker__sliders" }, zZ = { class: "mt-colorpicker__row mt-colorpicker__input-row" }, jZ = { class: "mt-colorpicker__row-column" }, YZ = { class: "mt-colorpicker__row-column" }, HZ = { class: "mt-colorpicker__row-column" }, UZ = { class: "mt-colorpicker__row-column" }, GZ = {
  key: 0,
  class: "mt-colorpicker__row-column"
}, KZ = {
  key: 0,
  class: "mt-colorpicker__row mt-colorpicker__apply-row"
};
function JZ(t, e, n, i, r, o) {
  const s = Ce("mt-text"), a = Ce("mt-button"), l = Ce("mt-floating-ui"), u = Ce("mt-field-error"), c = Ce("mt-base-field");
  return _(), ue(c, {
    class: Ae(t.componentClasses),
    disabled: t.disabled,
    required: t.required,
    "is-inherited": t.isInherited,
    "is-inheritance-field": t.isInheritanceField,
    "disable-inheritance-toggle": t.disableInheritanceToggle,
    "has-focus": t.hasFocus,
    "help-text": t.helpText,
    name: t.name
  }, {
    label: H(() => [
      He(Pe(t.label), 1)
    ]),
    "field-prefix": H(() => [
      X("div", {
        class: "mt-colorpicker__previewWrapper",
        role: "button",
        "aria-pressed": t.visible,
        "aria-label": "colorpicker-toggle",
        onClick: e[0] || (e[0] = (...d) => t.toggleColorPicker && t.toggleColorPicker(...d))
      }, [
        X("div", {
          class: Ae(["mt-colorpicker__previewColor", { active: t.visible }]),
          style: pt({ background: t.previewColorValue })
        }, null, 6),
        X("div", {
          class: Ae(["mt-colorpicker__previewBackground", { "is--invalid": !t.isColorValid }])
        }, null, 2)
      ], 8, ZZ)
    ]),
    element: H(() => [
      yt(X("input", {
        "onUpdate:modelValue": e[1] || (e[1] = (d) => t.colorValue = d),
        "aria-label": "colorpicker-color-value",
        class: "mt-colorpicker__input",
        spellcheck: !1,
        disabled: t.disabled,
        readonly: t.readonly,
        onClick: e[2] || (e[2] = (...d) => t.onClickInput && t.onClickInput(...d))
      }, null, 8, FZ), [
        [Lr, t.colorValue]
      ]),
      fe(l, {
        isOpened: t.visible,
        class: "mt-colorpicker__colorpicker-position",
        "z-index": t.zIndex,
        offset: -12
      }, {
        default: H(() => [
          X("div", qZ, [
            X("div", {
              ref: "colorPicker",
              class: "mt-colorpicker__colorpicker-selection",
              style: pt({ backgroundColor: t.selectorBackground }),
              onMousedown: e[3] || (e[3] = (...d) => t.setDragging && t.setDragging(...d))
            }, [
              X("div", {
                class: "mt-colorpicker__colorpicker-selector",
                style: pt(t.selectorStyles)
              }, null, 4)
            ], 36),
            X("div", WZ, [
              X("div", XZ, [
                yt(X("input", {
                  "onUpdate:modelValue": e[4] || (e[4] = (d) => t.hueValue = d),
                  "aria-label": "colorpicker-color-range",
                  class: "mt-colorpicker__colorpicker-slider-range",
                  type: "range",
                  min: "0",
                  max: "360",
                  step: "1"
                }, null, 512), [
                  [
                    Lr,
                    t.hueValue,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                t.alpha ? yt((_(), Z("input", {
                  key: 0,
                  "onUpdate:modelValue": e[5] || (e[5] = (d) => t.alphaValue = d),
                  class: "mt-colorpicker__alpha-slider",
                  "aria-label": "colorpicker-alpha-range",
                  type: "range",
                  min: "0",
                  max: "1",
                  step: "0.01",
                  style: pt({ backgroundImage: t.sliderBackground })
                }, null, 4)), [
                  [
                    Lr,
                    t.alphaValue,
                    void 0,
                    { number: !0 }
                  ]
                ]) : W("", !0)
              ]),
              X("div", {
                class: Ae(["mt-colorpicker__colorpicker-wrapper", { "is--small": !t.alpha }])
              }, [
                X("div", {
                  class: "mt-colorpicker__colorpicker-previewColor",
                  style: pt({ background: t.previewColorValue })
                }, null, 4),
                X("div", {
                  class: Ae(["mt-colorpicker__colorpicker-previewBackground", { "is--invalid": !t.isColorValid }])
                }, null, 2)
              ], 2)
            ]),
            X("div", zZ, [
              X("div", jZ, [
                yt(X("input", {
                  "onUpdate:modelValue": e[6] || (e[6] = (d) => t.hexValue = d),
                  class: "mt-colorpicker__colorpicker-input is--hex",
                  "aria-label": "hex-value",
                  type: "text",
                  spellcheck: !1
                }, null, 512), [
                  [
                    Lr,
                    t.hexValue,
                    void 0,
                    { lazy: !0 }
                  ]
                ]),
                t.colorLabels ? (_(), ue(s, {
                  key: 0,
                  size: "2xs",
                  as: "label",
                  class: "mt-colorpicker__row-column-label"
                }, {
                  default: H(() => e[11] || (e[11] = [
                    He(" HEX ")
                  ])),
                  _: 1
                })) : W("", !0)
              ]),
              X("div", YZ, [
                yt(X("input", {
                  "onUpdate:modelValue": e[7] || (e[7] = (d) => t.redValue = d),
                  class: "mt-colorpicker__colorpicker-input",
                  "aria-label": "red-value",
                  type: "number",
                  min: "0",
                  max: "255",
                  step: "1",
                  placeholder: "0"
                }, null, 512), [
                  [
                    Lr,
                    t.redValue,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                t.colorLabels ? (_(), ue(s, {
                  key: 0,
                  size: "2xs",
                  as: "label",
                  class: "mt-colorpicker__row-column-label"
                }, {
                  default: H(() => e[12] || (e[12] = [
                    He(" R ")
                  ])),
                  _: 1
                })) : W("", !0)
              ]),
              X("div", HZ, [
                yt(X("input", {
                  "onUpdate:modelValue": e[8] || (e[8] = (d) => t.greenValue = d),
                  class: "mt-colorpicker__colorpicker-input",
                  "aria-label": "green-value",
                  type: "number",
                  min: "0",
                  max: "255",
                  step: "1",
                  placeholder: "0"
                }, null, 512), [
                  [
                    Lr,
                    t.greenValue,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                t.colorLabels ? (_(), ue(s, {
                  key: 0,
                  size: "2xs",
                  as: "label",
                  class: "mt-colorpicker__row-column-label"
                }, {
                  default: H(() => e[13] || (e[13] = [
                    He(" G ")
                  ])),
                  _: 1
                })) : W("", !0)
              ]),
              X("div", UZ, [
                yt(X("input", {
                  "onUpdate:modelValue": e[9] || (e[9] = (d) => t.blueValue = d),
                  class: "mt-colorpicker__colorpicker-input",
                  "aria-label": "blue-value",
                  type: "number",
                  min: "0",
                  max: "255",
                  step: "1",
                  placeholder: "0"
                }, null, 512), [
                  [
                    Lr,
                    t.blueValue,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                t.colorLabels ? (_(), ue(s, {
                  key: 0,
                  size: "2xs",
                  as: "label",
                  class: "mt-colorpicker__row-column-label"
                }, {
                  default: H(() => e[14] || (e[14] = [
                    He(" B ")
                  ])),
                  _: 1
                })) : W("", !0)
              ]),
              t.alpha ? (_(), Z("div", GZ, [
                yt(X("input", {
                  "onUpdate:modelValue": e[10] || (e[10] = (d) => t.integerAlpha = d),
                  class: "mt-colorpicker__colorpicker-input",
                  "aria-label": "alpha-value",
                  type: "number",
                  min: "0",
                  max: "100",
                  step: "1",
                  placeholder: "0"
                }, null, 512), [
                  [
                    Lr,
                    t.integerAlpha,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                t.colorLabels ? (_(), ue(s, {
                  key: 0,
                  as: "label",
                  size: "2xs",
                  class: "mt-colorpicker__row-column-label"
                }, {
                  default: H(() => e[15] || (e[15] = [
                    He(" Alpha ")
                  ])),
                  _: 1
                })) : W("", !0)
              ])) : W("", !0)
            ]),
            t.applyMode ? (_(), Z("div", KZ, [
              fe(a, {
                variant: "primary",
                block: "",
                "aria-label": "colorpicker-apply-color",
                onClick: t.applyColor
              }, {
                default: H(() => [
                  He(Pe(t.t("mt-colorpicker.apply")), 1)
                ]),
                _: 1
              }, 8, ["onClick"])
            ])) : W("", !0)
          ])
        ]),
        _: 1
      }, 8, ["isOpened", "z-index"])
    ]),
    error: H(() => [
      t.error ? (_(), ue(u, {
        key: 0,
        error: t.error
      }, null, 8, ["error"])) : W("", !0)
    ]),
    _: 1
  }, 8, ["class", "disabled", "required", "is-inherited", "is-inheritance-field", "disable-inheritance-toggle", "has-focus", "help-text", "name"]);
}
const eF = /* @__PURE__ */ je(BZ, [["render", JZ]]), tF = Te({
  name: "MtTextField",
  components: {
    "mt-field-error": Xs,
    "mt-base-field": As
  },
  props: {
    /**
     * The value of the text field.
     */
    modelValue: {
      type: String,
      required: !1,
      default: ""
    },
    /**
     * A placeholder text being displayed if no value is set.
     */
    placeholder: {
      type: String,
      required: !1,
      default: ""
    },
    /**
     * A label for your text field. Usually used to guide the user what value this field controls.
     */
    label: {
      type: String,
      required: !1,
      default: null
    },
    /**
     * A text that helps the user to understand what this field does.
     */
    helpText: {
      type: String,
      required: !1,
      default: null
    },
    /**
     * The size of the text field.
     *
     * @values small, default
     */
    size: {
      type: String,
      required: !1,
      default: "default",
      validator(t) {
        return ["small", "default"].includes(t);
      }
    },
    /**
     * Toggles the copy function of the text field.
     */
    copyable: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * If set to true the tooltip will change on successful copy.
     */
    copyableTooltip: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * An error in your business logic related to this field.
     *
     * @example {"code": 500, "detail": "Error while saving"}
     */
    error: {
      type: Object,
      required: !1,
      default: null
    },
    /**
     * Determines if the field is disabled.
     */
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines if the field is required.
     */
    required: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Toggles the inheritance visualization.
     */
    isInherited: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines if the field is inheritable.
     */
    isInheritanceField: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines the active state of the inheritance toggle.
     */
    disableInheritanceToggle: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * If set to a value a character counter will be displayed.
     */
    maxLength: {
      type: Number,
      required: !1,
      default: void 0
    },
    /**
     * @ignore
     */
    idSuffix: {
      type: String,
      required: !1,
      default: ""
    },
    /**
     * @ignore
     */
    name: {
      type: String,
      required: !1,
      default: null
    }
  },
  data() {
    return {
      currentValue: this.modelValue,
      hasFocus: !1
    };
  },
  computed: {
    hasError() {
      return !this.isValid || !!this.error;
    },
    hasDisabledInput() {
      return this.disabled || this.isInherited;
    }
  },
  watch: {
    modelValue(t) {
      this.currentValue = t;
    }
  },
  methods: {
    onChange(t) {
      this.$emit("change", t.target.value || "");
    },
    onInput(t) {
      this.$emit("update:modelValue", t.target.value);
    },
    handleFocus(t) {
      this.$emit("focus", t), this.setFocusClass();
    },
    restoreInheritance() {
      this.$emit("update:modelValue", null);
    },
    createInputId(t) {
      return !this.idSuffix || this.idSuffix.length <= 0 ? t : `${t}-${this.idSuffix}`;
    },
    setFocusClass() {
      this.hasFocus = !0;
    },
    removeFocusClass() {
      this.hasFocus = !1;
    }
  }
}), nF = ["id", "name", "disabled", "value", "placeholder", "maxlength", "aria-label"];
function iF(t, e, n, i, r, o) {
  const s = Ce("mt-field-error"), a = Ce("mt-base-field");
  return _(), ue(a, {
    class: "mt-text-field",
    disabled: t.disabled,
    required: t.required,
    "is-inherited": t.isInherited,
    "is-inheritance-field": t.isInheritanceField,
    "disable-inheritance-toggle": t.disableInheritanceToggle,
    copyable: t.copyable,
    "copyable-tooltip": t.copyableTooltip,
    "copyable-text": String(t.currentValue),
    "has-focus": t.hasFocus,
    "help-text": t.helpText,
    name: t.name,
    size: t.size,
    onInheritanceRestore: e[4] || (e[4] = (l) => t.$emit("inheritance-restore", l)),
    onInheritanceRemove: e[5] || (e[5] = (l) => t.$emit("inheritance-remove", l))
  }, un({
    label: H(() => [
      He(Pe(t.label), 1)
    ]),
    "field-prefix": H(() => [
      ne(t.$slots, "prefix")
    ]),
    element: H(({ identification: l }) => [
      X("input", {
        id: t.createInputId(l),
        type: "text",
        name: l,
        disabled: t.hasDisabledInput,
        value: t.currentValue,
        placeholder: t.placeholder,
        maxlength: t.maxLength,
        "aria-label": t.label,
        onInput: e[0] || (e[0] = (...u) => t.onInput && t.onInput(...u)),
        onChange: e[1] || (e[1] = Tt((...u) => t.onChange && t.onChange(...u), ["stop"])),
        onFocus: e[2] || (e[2] = (...u) => t.handleFocus && t.handleFocus(...u)),
        onBlur: e[3] || (e[3] = (...u) => t.removeFocusClass && t.removeFocusClass(...u))
      }, null, 40, nF)
    ]),
    "field-suffix": H(() => [
      ne(t.$slots, "suffix")
    ]),
    error: H(() => [
      t.error ? (_(), ue(s, {
        key: 0,
        error: t.error
      }, null, 8, ["error"])) : W("", !0)
    ]),
    "field-hint": H(() => [
      ne(t.$slots, "hint")
    ]),
    _: 2
  }, [
    t.maxLength ? {
      name: "field-hint-right",
      fn: H(() => {
        var l;
        return [
          He(Pe(((l = String(t.modelValue)) == null ? void 0 : l.length) ?? 0) + "/" + Pe(t.maxLength), 1)
        ];
      }),
      key: "0"
    } : void 0
  ]), 1032, ["disabled", "required", "is-inherited", "is-inheritance-field", "disable-inheritance-toggle", "copyable", "copyable-tooltip", "copyable-text", "has-focus", "help-text", "name", "size"]);
}
const im = /* @__PURE__ */ je(tF, [["render", iF]]), rF = Te({
  name: "MtEmailField",
  extends: im,
  data() {
    return {
      hasFocus: !1,
      validationError: null
    };
  },
  computed: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    computedError() {
      return this.validationError ? this.validationError : this.error;
    }
  },
  mounted() {
    this.modelValue && this.checkValidity();
  },
  methods: {
    setFocus() {
      this.hasFocus = !0;
    },
    removeFocus() {
      this.hasFocus = !1, this.checkValidity();
    },
    checkValidity() {
      if (this.$refs.input.checkValidity()) {
        this.validationError = null;
        return;
      }
      this.validationError = {
        // @ts-expect-error - ref is available
        detail: this.$refs.input.validationMessage
      };
    }
  }
}), oF = ["id", "name", "disabled", "value", "placeHolder"];
function sF(t, e, n, i, r, o) {
  const s = Ce("mt-field-error"), a = Ce("mt-base-field");
  return _(), ue(a, wt({ class: "mt-field--email" }, t.$attrs, {
    name: t.name,
    "has-focus": t.hasFocus,
    copyable: t.copyable,
    "copyable-tooltip": t.copyableTooltip,
    "copyable-text": t.currentValue,
    "help-text": t.helpText,
    size: t.size,
    required: t.required,
    disabled: t.disabled,
    "is-inherited": t.isInherited,
    "is-inheritance-field": t.isInheritanceField,
    onInheritanceRestore: e[4] || (e[4] = (l) => t.$emit("inheritance-restore", l)),
    onInheritanceRemove: e[5] || (e[5] = (l) => t.$emit("inheritance-remove", l))
  }), {
    label: H(() => [
      He(Pe(t.label), 1)
    ]),
    "field-prefix": H(() => [
      ne(t.$slots, "prefix")
    ]),
    element: H(({ identification: l, disabled: u }) => [
      X("input", {
        id: l,
        ref: "input",
        type: "email",
        name: l,
        disabled: u,
        value: t.currentValue,
        placeHolder: t.placeholder,
        onInput: e[0] || (e[0] = Tt((...c) => t.onInput && t.onInput(...c), ["stop"])),
        onChange: e[1] || (e[1] = Tt((...c) => t.onChange && t.onChange(...c), ["stop"])),
        onFocus: e[2] || (e[2] = (...c) => t.setFocus && t.setFocus(...c)),
        onBlur: e[3] || (e[3] = (...c) => t.removeFocus && t.removeFocus(...c))
      }, null, 40, oF)
    ]),
    "field-suffix": H(() => [
      ne(t.$slots, "suffix")
    ]),
    error: H(() => [
      t.computedError ? (_(), ue(s, {
        key: 0,
        error: t.computedError
      }, null, 8, ["error"])) : W("", !0)
    ]),
    "field-hint": H(() => [
      ne(t.$slots, "hint")
    ]),
    _: 3
  }, 16, ["name", "has-focus", "copyable", "copyable-tooltip", "copyable-text", "help-text", "size", "required", "disabled", "is-inherited", "is-inheritance-field"]);
}
const Nae = /* @__PURE__ */ je(rF, [["render", sF]]), aF = /* @__PURE__ */ Te({
  __name: "mt-link",
  props: {
    to: {},
    as: { default: "router-link" },
    variant: { default: "primary" },
    disabled: { type: Boolean, default: !1 },
    type: {}
  },
  emits: ["click"],
  setup(t) {
    return (e, n) => (_(), ue(ar(e.as), wt({
      class: [
        "mt-link",
        `mt-link--${e.variant}`,
        {
          "mt-link--disabled": e.disabled
        }
      ],
      "aria-disabled": e.disabled,
      role: "link",
      tabindex: e.disabled ? -1 : 0
    }, e.to ? { ...e.$attrs, to: e.to } : e.$attrs, {
      onClick: n[0] || (n[0] = (i) => e.disabled ? void 0 : e.$emit("click", i))
    }), {
      default: H(() => [
        ne(e.$slots, "default", {}, void 0, !0),
        e.type ? (_(), ue(mt, {
          key: 0,
          size: "0.75rem",
          name: e.type === "external" ? "regular-external-link-s" : "regular-long-arrow-right"
        }, null, 8, ["name"])) : W("", !0)
      ]),
      _: 3
    }, 16, ["class", "aria-disabled", "tabindex"]));
  }
});
const lF = /* @__PURE__ */ je(aF, [["__scopeId", "data-v-7ede804f"]]), uF = Te({
  name: "MtNumberField",
  components: {
    "mt-icon": mt
  },
  extends: im,
  props: {
    /**
     * Defines if the number should be a floating point number or integer.
     */
    numberType: {
      type: String,
      required: !1,
      default: "float",
      validator(t) {
        return ["float", "int"].includes(t);
      }
    },
    /**
     * Defines the amount of which the number is increased or decreased per step.
     */
    step: {
      type: Number,
      required: !1,
      default: null
    },
    /**
     * Defines the minimum value of the number.
     */
    min: {
      type: Number,
      required: !1,
      default: null
    },
    /**
     * Defines the maximum value of the number.
     */
    max: {
      type: Number,
      required: !1,
      default: null
    },
    /**
     * The value of the number field.
     */
    modelValue: {
      type: Number,
      required: !1,
      default: null
    },
    /**
     * Defines how many digits should be displayed after the decimal point.
     */
    digits: {
      type: Number,
      required: !1,
      default: 2,
      validator(t) {
        const e = t === Math.floor(t);
        return e || console.warn("mt-number-field", "Provided prop digits must be of type integer"), e;
      }
    },
    /**
     * Defines if digits should be filled with zeros if the value is smaller than the minimum value.
     */
    fillDigits: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Defines if the field can be empty.
     */
    allowEmpty: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Defines if the number should be aligned to the end of the input field.
     */
    numberAlignEnd: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  computed: {
    realStep() {
      return this.step === null ? this.numberType === "int" ? 1 : 0.01 : this.numberType === "int" ? Math.round(this.step) : this.step;
    },
    realMinimum() {
      return this.min === null ? null : this.numberType === "int" ? Math.ceil(this.min) : this.min;
    },
    realMaximum() {
      return this.max === null ? null : this.numberType === "int" ? Math.floor(this.max) : this.max;
    },
    stringRepresentation() {
      return this.currentValue === null ? "" : this.fillDigits && this.numberType !== "int" ? (
        // @ts-expect-error - wrong type because of component extends
        this.currentValue.toFixed(this.digits)
      ) : this.currentValue.toString();
    },
    controlClasses() {
      return {
        "mt-field__controls--disabled": this.disabled,
        "mt-field__controls--has-error": !!this.error
      };
    }
  },
  watch: {
    modelValue: {
      handler() {
        if (this.modelValue === null || this.modelValue === void 0) {
          this.currentValue = null;
          return;
        }
        this.computeValue(this.modelValue.toString());
      },
      immediate: !0
    }
  },
  methods: {
    onChange(t) {
      this.computeValue(t.target.value), this.$emit("change", this.currentValue), this.$emit("update:modelValue", this.currentValue);
    },
    onInput(t) {
      let e = Number.parseFloat(t.target.value);
      Number.isNaN(e) || (this.max && e > this.max && (e = this.max), this.min && e < this.min && (e = this.min), this.computeValue(e.toString()), this.$emit("input-change", e));
    },
    increaseNumberByStep() {
      this.computeValue((Number(this.currentValue) + this.realStep).toString()), this.$emit("change", this.currentValue), this.$emit("update:modelValue", this.currentValue);
    },
    decreaseNumberByStep() {
      this.computeValue((this.currentValue - this.realStep).toString()), this.$emit("change", this.currentValue), this.$emit("update:modelValue", this.currentValue);
    },
    computeValue(t) {
      const e = this.getNumberFromString(t);
      this.currentValue = this.parseValue(e);
    },
    // @ts-expect-error - defined in parent
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    parseValue(t) {
      return t === null || Number.isNaN(t) || !Number.isFinite(t) ? this.allowEmpty ? null : this.parseValue(0) : this.checkForInteger(this.checkBoundaries(t));
    },
    checkBoundaries(t) {
      return this.realMaximum !== null && t > this.realMaximum && (t = this.realMaximum), this.realMinimum !== null && t < this.realMinimum && (t = this.realMinimum), t;
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getNumberFromString(t) {
      let e = t.split("e").shift();
      if (e = e.replace(/,/g, ".").split("."), e.length === 1)
        return parseFloat(e[0]);
      if (this.numberType === "int")
        return parseInt(e.join(""), 10);
      const n = e[e.length - 1].length, i = parseFloat(e.join(".")).toFixed(n);
      return n > this.digits ? (
        // @ts-expect-error - can be calculated
        Math.round(i * 10 ** this.digits) / 10 ** this.digits
      ) : Number(i);
    },
    checkForInteger(t) {
      if (this.numberType !== "int")
        return t;
      const e = Math.floor(t);
      return e !== t && this.$nextTick(() => {
        this.$forceUpdate();
      }), e;
    }
  },
  setup() {
    const { t } = Lt({
      messages: {
        en: {
          increaseButton: "Increase",
          decreaseButton: "Decrease"
        },
        de: {
          increaseButton: "Erhöhen",
          decreaseButton: "Verringern"
        }
      }
    });
    return { t };
  }
});
const cF = ["id", "name", "disabled", "value", "placeholder"], dF = ["disabled", "aria-label"], hF = ["disabled", "aria-label"];
function fF(t, e, n, i, r, o) {
  const s = Ce("mt-icon"), a = Ce("mt-field-error"), l = Ce("mt-base-field");
  return _(), ue(l, {
    class: Ae(["mt-number-field", t.$attrs.class]),
    disabled: t.disabled,
    required: t.required,
    "is-inherited": t.isInherited,
    "is-inheritance-field": t.isInheritanceField,
    "disable-inheritance-toggle": t.disableInheritanceToggle,
    copyable: t.copyable,
    "copyable-tooltip": t.copyableTooltip,
    "copyable-text": t.stringRepresentation,
    "has-focus": t.hasFocus,
    "help-text": t.helpText,
    name: t.name,
    size: t.size,
    onInheritanceRestore: e[8] || (e[8] = (u) => t.$emit("inheritance-restore", u)),
    onInheritanceRemove: e[9] || (e[9] = (u) => t.$emit("inheritance-remove", u))
  }, {
    label: H(() => [
      He(Pe(t.label), 1)
    ]),
    "field-prefix": H(() => [
      ne(t.$slots, "prefix", {}, void 0, !0)
    ]),
    element: H(({ identification: u }) => [
      X("input", {
        id: t.createInputId(u),
        type: "text",
        name: u,
        disabled: t.disabled,
        value: t.stringRepresentation,
        placeholder: t.placeholder,
        class: Ae(t.numberAlignEnd ? "mt-number-field__align-end" : ""),
        onInput: e[0] || (e[0] = (...c) => t.onInput && t.onInput(...c)),
        onKeydown: [
          e[1] || (e[1] = ai((...c) => t.increaseNumberByStep && t.increaseNumberByStep(...c), ["up"])),
          e[2] || (e[2] = ai((...c) => t.decreaseNumberByStep && t.decreaseNumberByStep(...c), ["down"]))
        ],
        onChange: e[3] || (e[3] = (...c) => t.onChange && t.onChange(...c)),
        onFocus: e[4] || (e[4] = (...c) => t.setFocusClass && t.setFocusClass(...c)),
        onBlur: e[5] || (e[5] = (...c) => t.removeFocusClass && t.removeFocusClass(...c))
      }, null, 42, cF),
      X("div", {
        class: Ae(["mt-number-field__controls", t.controlClasses])
      }, [
        X("button", {
          onClick: e[6] || (e[6] = (...c) => t.increaseNumberByStep && t.increaseNumberByStep(...c)),
          disabled: t.disabled,
          "aria-label": t.t("increaseButton"),
          "data-testid": "mt-number-field-increase-button"
        }, [
          fe(s, {
            size: "10",
            name: "regular-chevron-up-s",
            "aria-hidden": "true"
          })
        ], 8, dF),
        X("button", {
          onClick: e[7] || (e[7] = (...c) => t.decreaseNumberByStep && t.decreaseNumberByStep(...c)),
          disabled: t.disabled,
          "aria-label": t.t("decreaseButton"),
          "data-testid": "mt-number-field-decrease-button"
        }, [
          fe(s, {
            style: { "margin-top": "-3px" },
            size: "10",
            name: "regular-chevron-down-s",
            "aria-hidden": "true"
          })
        ], 8, hF)
      ], 2)
    ]),
    "field-suffix": H(() => [
      ne(t.$slots, "suffix", {}, void 0, !0)
    ]),
    error: H(() => [
      t.error ? (_(), ue(a, {
        key: 0,
        error: t.error
      }, null, 8, ["error"])) : W("", !0)
    ]),
    "field-hint": H(() => [
      ne(t.$slots, "hint", {}, void 0, !0)
    ]),
    _: 3
  }, 8, ["class", "disabled", "required", "is-inherited", "is-inheritance-field", "disable-inheritance-toggle", "copyable", "copyable-tooltip", "copyable-text", "has-focus", "help-text", "name", "size"]);
}
const NO = /* @__PURE__ */ je(uF, [["render", fF], ["__scopeId", "data-v-dd85aa54"]]), pF = Te({
  name: "MtPasswordField",
  components: {
    "mt-icon": mt
  },
  extends: im,
  props: {
    passwordToggleAble: {
      type: Boolean,
      required: !1,
      default: !0
    },
    placeholderIsPassword: {
      type: Boolean,
      required: !1,
      default: !1
    },
    autocomplete: {
      type: String,
      required: !1,
      default: null
    }
  },
  setup(t) {
    const e = re(!1), n = J(
      () => e.value || !t.placeholderIsPassword ? t.placeholder : "*".repeat(t.placeholder.length ? t.placeholder.length : 6)
    ), { t: i } = Lt({
      messages: {
        en: {
          titleHidePassword: "Hide password",
          titleShowPassword: "Show password"
        },
        de: {
          titleHidePassword: "Passwort verbergen",
          titleShowPassword: "Passwort anzeigen"
        }
      }
    });
    return {
      t: i,
      showPassword: e,
      passwordPlaceholder: n
    };
  }
});
const mF = { class: "mt-field--password__container" }, gF = ["id", "type", "name", "placeholder", "disabled", "value", "autocomplete"], OF = ["disabled", "aria-label"];
function vF(t, e, n, i, r, o) {
  const s = Ce("mt-icon"), a = Ce("mt-field-error"), l = Ce("mt-base-field");
  return _(), ue(l, {
    class: "mt-field--password",
    disabled: t.disabled,
    required: t.required,
    "is-inherited": t.isInherited,
    "is-inheritance-field": t.isInheritanceField,
    "disable-inheritance-toggle": t.disableInheritanceToggle,
    copyable: t.copyable,
    "copyable-tooltip": t.copyableTooltip,
    "copyable-text": t.currentValue,
    "has-focus": t.hasFocus,
    "help-text": t.helpText,
    name: t.name,
    size: t.size,
    onInheritanceRestore: e[5] || (e[5] = (u) => t.$emit("inheritance-restore", u)),
    onInheritanceRemove: e[6] || (e[6] = (u) => t.$emit("inheritance-remove", u))
  }, {
    label: H(() => [
      He(Pe(t.label), 1)
    ]),
    "field-prefix": H(() => [
      ne(t.$slots, "prefix", {}, void 0, !0)
    ]),
    element: H(({ identification: u, disabled: c }) => [
      X("div", mF, [
        X("input", {
          id: u,
          type: t.showPassword ? "text" : "password",
          name: u,
          placeholder: t.passwordPlaceholder,
          disabled: c,
          value: t.currentValue,
          autocomplete: t.autocomplete,
          onInput: e[0] || (e[0] = Tt((...d) => t.onInput && t.onInput(...d), ["stop"])),
          onChange: e[1] || (e[1] = Tt((...d) => t.onChange && t.onChange(...d), ["stop"])),
          onFocus: e[2] || (e[2] = (...d) => t.setFocusClass && t.setFocusClass(...d)),
          onBlur: e[3] || (e[3] = (...d) => t.removeFocusClass && t.removeFocusClass(...d))
        }, null, 40, gF),
        t.passwordToggleAble ? (_(), Z("button", {
          key: 0,
          disabled: c,
          "aria-label": t.showPassword ? t.t("titleHidePassword") : t.t("titleShowPassword"),
          class: "mt-field__toggle-password-visibility",
          onClick: e[4] || (e[4] = () => t.showPassword = !t.showPassword)
        }, [
          t.showPassword ? (_(), ue(s, {
            key: 0,
            name: "solid-eye-slash",
            size: "18"
          })) : (_(), ue(s, {
            key: 1,
            "data-testid": "mt-password-field-show-button",
            name: "solid-eye",
            size: "18"
          }))
        ], 8, OF)) : W("", !0)
      ])
    ]),
    "field-suffix": H(() => [
      ne(t.$slots, "suffix", {}, void 0, !0)
    ]),
    error: H(() => [
      t.error ? (_(), ue(a, {
        key: 0,
        error: t.error
      }, null, 8, ["error"])) : W("", !0)
    ]),
    "field-hint": H(() => [
      ne(t.$slots, "hint", {}, void 0, !0)
    ]),
    _: 3
  }, 8, ["disabled", "required", "is-inherited", "is-inheritance-field", "disable-inheritance-toggle", "copyable", "copyable-tooltip", "copyable-text", "has-focus", "help-text", "name", "size"]);
}
const Iae = /* @__PURE__ */ je(pF, [["render", vF], ["__scopeId", "data-v-57aefe79"]]), yF = Te({
  name: "MtSelectBase",
  components: {
    "mt-base-field": As,
    "mt-icon": mt,
    "mt-loader": rb,
    "mt-field-error": Xs
  },
  props: {
    /**
     * The label for the select field itself.
     */
    label: {
      type: String,
      required: !0
    },
    /**
     * Toggles the loading state of the select field.
     */
    isLoading: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Disables or enables the select field.
     */
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Toggles a button to clear all selections.
     */
    showClearableButton: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * An error in your business logic related to this field.
     *
     * @example {"code": 500, "detail": "Error while saving"}
     */
    error: {
      type: Object,
      required: !1,
      default: null
    },
    /**
     * Toggles the inheritance visualization.
     */
    isInherited: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines if the field is inheritable.
     */
    isInheritanceField: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines the active state of the inheritance toggle.
     */
    disableInheritanceToggle: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  data() {
    return {
      expanded: !1
    };
  },
  computed: {
    mtFieldClasses() {
      return { "has--focus": this.expanded };
    }
  },
  methods: {
    toggleExpand() {
      this.expanded ? this.collapse() : this.expand();
    },
    expand() {
      this.expanded || this.disabled || (this.expanded = !0, document.addEventListener("click", this.listenToClickOutside), this.$emit("select-expanded"));
    },
    collapse(t) {
      var e;
      document.removeEventListener("click", this.listenToClickOutside), this.expanded = !1, ((e = t == null ? void 0 : t.target) == null ? void 0 : e.dataset.clearableButton) === void 0 && this.$emit("select-collapsed"), t != null && t.shiftKey && (t.preventDefault(), this.focusPreviousFormElement());
    },
    focusPreviousFormElement() {
      const t = 'a, button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])', e = this.$el.querySelector(t), n = [
        ...document.querySelectorAll(t)
        // @ts-expect-error - target is set and contains dataset
      ].filter((i) => !i.hasAttribute("disabled") && i.dataset.clearableButton === void 0);
      n.forEach((i, r) => {
        if (r > 0 && i === e) {
          const o = n[r - 1];
          o.click(), o.focus();
        }
      });
    },
    listenToClickOutside(t) {
      let { path: e } = t;
      typeof e > "u" && (e = this.computePath(t)), e.find((n) => n === this.$el) || this.collapse();
    },
    computePath(t) {
      const e = [];
      let { target: n } = t;
      for (; n; )
        e.push(n), n = n.parentElement;
      return e;
    },
    emitClear() {
      this.$emit("clear");
    },
    focusParentSelect(t) {
      t != null && t.shiftKey && (this.$refs.selectWrapper.click(), t.preventDefault());
    }
  }
});
const bF = { class: "mt-select__selection-indicators" };
function wF(t, e, n, i, r, o) {
  const s = Ce("mt-loader"), a = Ce("mt-icon"), l = Ce("mt-field-error"), u = Ce("mt-base-field");
  return _(), ue(u, wt({ class: t.mtFieldClasses }, t.$attrs, {
    disabled: t.disabled,
    "has-focus": t.expanded,
    "is-inherited": t.isInherited,
    "is-inheritance-field": t.isInheritanceField,
    "disable-inheritance-toggle": t.disableInheritanceToggle
  }), {
    label: H(() => [
      He(Pe(t.label), 1)
    ]),
    "field-prefix": H(() => [
      ne(t.$slots, "mt-select-prefix")
    ]),
    element: H(({ identification: c, error: d, size: h }) => [
      X("div", {
        ref: "selectWrapper",
        class: "mt-select__selection",
        tabindex: "0",
        onClick: e[0] || (e[0] = Tt((...f) => t.expand && t.expand(...f), ["stop"])),
        onFocus: e[1] || (e[1] = (...f) => t.expand && t.expand(...f)),
        onKeydown: [
          e[2] || (e[2] = ai((...f) => t.collapse && t.collapse(...f), ["tab"])),
          e[3] || (e[3] = ai((...f) => t.collapse && t.collapse(...f), ["esc"]))
        ]
      }, [
        ne(t.$slots, "mt-select-selection", Ct(Zt({ identification: c, error: d, disabled: t.disabled, size: h, expand: t.expand, collapse: t.collapse })))
      ], 544),
      X("div", bF, [
        t.isLoading ? (_(), ue(s, {
          key: 0,
          class: "mt-select__select-indicator",
          size: "16px"
        })) : W("", !0),
        !t.disabled && t.showClearableButton ? (_(), Z("button", {
          key: 1,
          class: "mt-select__select-indicator-hitbox",
          "data-clearable-button": "",
          "data-testid": "select-clear-button",
          onClick: e[4] || (e[4] = Tt((...f) => t.emitClear && t.emitClear(...f), ["prevent", "stop"])),
          onKeydown: e[5] || (e[5] = ai(Tt((...f) => t.focusParentSelect && t.focusParentSelect(...f), ["stop"]), ["tab"]))
        }, [
          fe(a, {
            class: "mt-select__select-indicator mt-select__select-indicator-clear",
            name: "regular-times-xxs"
          })
        ], 32)) : W("", !0),
        fe(a, {
          class: Ae(["mt-select__select-indicator", { "mt-select__select-indicator-rotated": t.expanded }]),
          "data-testid": "mt-select__select-indicator",
          name: "solid-chevron-down-xxs",
          onClick: Tt(t.toggleExpand, ["stop"])
        }, null, 8, ["class", "onClick"])
      ]),
      t.expanded ? (_(), ue(Fn, {
        key: 0,
        name: "mt-select-result-list-fade-down"
      }, {
        default: H(() => [
          ne(t.$slots, "results-list", Ct(Zt({ collapse: t.collapse })))
        ]),
        _: 3
      })) : W("", !0)
    ]),
    "field-suffix": H(() => [
      ne(t.$slots, "mt-select-suffix")
    ]),
    "field-hint": H(() => [
      ne(t.$slots, "mt-select-hint")
    ]),
    error: H(() => [
      t.error ? (_(), ue(l, {
        key: 0,
        error: t.error
      }, null, 8, ["error"])) : W("", !0)
    ]),
    _: 3
  }, 16, ["class", "disabled", "has-focus", "is-inherited", "is-inheritance-field", "disable-inheritance-toggle"]);
}
const kF = /* @__PURE__ */ je(yF, [["render", wF]]), Wl = /* @__PURE__ */ new Map(), Eu = {
  top: "--placement-top-outside",
  right: "--placement-right-outside",
  bottom: "--placement-bottom-outside",
  left: "--placement-left-outside"
}, SF = {
  active: !1,
  targetSelector: "",
  resizeWidth: !1,
  style: {}
}, _F = ["width", "position", "top", "left", "right", "bottom"];
function xF(t, e) {
  var l;
  const i = ((l = e.$parent) == null ? void 0 : l.$el).getBoundingClientRect(), r = window.innerHeight || document.documentElement.clientHeight, o = window.innerWidth || document.documentElement.clientWidth, s = {
    topSpace: i.top,
    rightSpace: o - i.right,
    bottomSpace: r - i.bottom,
    leftSpace: i.left
  };
  t.classList.remove(...Object.values(Eu));
  const a = [
    s.bottomSpace < s.topSpace ? Eu.bottom : Eu.top,
    s.rightSpace > s.leftSpace ? Eu.left : Eu.right
  ];
  t.classList.add(...a);
}
function WT(t, e, n) {
  const i = e || t, r = i.getBoundingClientRect();
  let o = i, s = {
    top: 0,
    left: 0
  };
  n.targetSelector && n.targetSelector.length > 0 && (o = i.closest(n.targetSelector), s = o.getBoundingClientRect()), Object.entries(n.style).forEach(([a, l]) => {
    _F.includes(a) || (t.style[a] = l);
  }), t.style.position = "absolute", t.style.top = `${r.top - s.top + i.clientHeight}px`, t.style.left = `${r.left - s.left}px`;
}
function CF() {
  window.addEventListener("scroll", zT, !0);
}
function XT() {
  window.removeEventListener("scroll", zT, !0);
}
function zT() {
  if (Wl.size <= 0) {
    XT();
    return;
  }
  Wl.forEach((t) => {
    WT(t.el, t.ref, t.config);
  });
}
function TF(t, e, n) {
  const i = e == null ? void 0 : e._uid;
  i && (Wl.size <= 0 && CF(), Wl.set(i, {
    el: t,
    // @ts-expect-error - $el exists on the context but is private
    ref: e.$el,
    config: n
  }));
}
function $F(t) {
  t && (Wl.delete(t), Wl.size <= 0 && XT());
}
const PF = {
  mounted(t, e) {
    var r, o;
    if (!e.value)
      return !1;
    const n = { ...SF, ...e.value };
    if (!n.active)
      return !1;
    let i = document.body;
    n.targetSelector && n.targetSelector.length > 0 && (i = t.closest(n.targetSelector)), i.appendChild(t), WT(t, (r = e.instance) == null ? void 0 : r.$el, n), n.resizeWidth && (t.style.width = `${(o = e.instance) == null ? void 0 : o.$el.clientWidth}px`), xF(t, e.instance), TF(t, e.instance, n);
  },
  unmounted(t, e, n) {
    var i;
    t.parentNode && t.parentNode.removeChild(t), $F((i = n.context) == null ? void 0 : i._uid);
  }
}, MF = Te({
  name: "MtPopover",
  directives: {
    popover: PF
  },
  props: {
    zIndex: {
      type: [Number, null],
      required: !1,
      default: null
    },
    resizeWidth: {
      type: Boolean,
      required: !1,
      default: !1
    },
    popoverClass: {
      type: [String, Array, Object],
      required: !1,
      default: ""
    }
  },
  computed: {
    componentStyle() {
      return {
        "z-Index": this.zIndex
      };
    },
    popoverConfig() {
      return {
        active: !0,
        resizeWidth: this.resizeWidth
      };
    }
  }
});
const EF = { class: "mt-popover-deprecated" };
function AF(t, e, n, i, r, o) {
  const s = vr("popover");
  return _(), Z("div", EF, [
    yt((_(), Z("div", {
      class: Ae(["mt-popover-deprecated__wrapper", t.popoverClass]),
      style: pt(t.componentStyle)
    }, [
      ne(t.$slots, "default")
    ], 6)), [
      [s, t.popoverConfig]
    ])
  ]);
}
const RF = /* @__PURE__ */ je(MF, [["render", AF]]), jT = Symbol(), YT = Symbol(), HT = Symbol(), UT = Symbol(), DF = Te({
  name: "MtSelectResultList",
  components: {
    "mt-popover-deprecated": RF,
    "mt-icon": mt
  },
  provide() {
    return {
      setActiveItemIndex: this.setActiveItemIndex
    };
  },
  setup() {
    const { t } = Lt({
      messages: {
        en: {
          messageNoResults: "No results found."
        },
        de: {
          messageNoResults: "Es wurden keine Ergebnisse gefunden."
        }
      }
    }), e = re(0), n = re([]), i = re([]), r = () => {
      n.value.forEach((c) => {
        c(e.value);
      });
    }, o = (c) => {
      e.value = c, r();
    }, s = (c) => {
      n.value.push(c);
    }, a = (c) => {
      n.value = n.value.filter(
        (d) => d !== c
      );
    }, l = (c) => {
      i.value.push(c);
    }, u = (c) => {
      i.value = i.value.filter(
        (d) => d !== c
      );
    };
    return ua(jT, s), ua(YT, a), ua(HT, l), ua(UT, u), {
      t,
      activeItemIndex: e,
      emitActiveItemIndex: r,
      setActiveItemIndex: o,
      addToActiveItemChangeListeners: s,
      removeActiveItemChangeListener: a,
      addToItemSelectByKeyboardListeners: l,
      removeItemSelectByKeyboardListener: u
    };
  },
  props: {
    options: {
      type: Array,
      required: !1,
      default() {
        return [];
      }
    },
    emptyMessage: {
      type: String,
      required: !1,
      default: null
    },
    focusEl: {
      type: [Object],
      required: !1,
      default() {
        return document;
      }
    },
    isLoading: {
      type: Boolean,
      required: !1,
      default: !1
    },
    popoverClasses: {
      type: Array,
      required: !1,
      default() {
        return [];
      }
    },
    popoverResizeWidth: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  data() {
    return {
      activeItemChangeListeners: [],
      itemSelectByKeyboardListeners: []
    };
  },
  computed: {
    popoverClass() {
      return [...this.popoverClasses, "mt-select-result-list-popover-wrapper"];
    }
  },
  created() {
    this.addEventListeners();
  },
  mounted() {
    this.emitActiveItemIndex();
  },
  beforeUnmount() {
    this.removeEventListeners();
  },
  methods: {
    addEventListeners() {
      this.focusEl.addEventListener("keydown", this.navigate), document.addEventListener("click", this.checkOutsideClick);
    },
    removeEventListeners() {
      this.focusEl.removeEventListener("keydown", this.navigate), document.removeEventListener("click", this.checkOutsideClick);
    },
    /**
     *
     * @param event {Event}
     */
    checkOutsideClick(t) {
      t.stopPropagation();
      const e = this.$refs.popoverContent.contains(t.target), n = this.$el.contains(t.target), i = this.$parent.$el.contains(t.target);
      e || n || i || this.$emit("outside-click");
    },
    navigate({ key: t }) {
      if (t = t.toUpperCase(), t === "ARROWDOWN") {
        this.navigateNext();
        return;
      }
      if (t === "ARROWUP") {
        this.navigatePrevious();
        return;
      }
      t === "ENTER" && this.emitClicked();
    },
    navigateNext() {
      if (this.activeItemIndex >= this.options.length - 1) {
        this.$emit("paginate");
        return;
      }
      this.activeItemIndex += 1, this.emitActiveItemIndex(), this.updateScrollPosition();
    },
    navigatePrevious() {
      this.activeItemIndex > 0 && (this.activeItemIndex -= 1), this.emitActiveItemIndex(), this.updateScrollPosition();
    },
    updateScrollPosition() {
      this.$nextTick(() => {
        const t = document.querySelector(".mt-select-result-list__content"), e = t.querySelector(".is--active"), n = e.offsetHeight, i = e.offsetTop, r = t.scrollTop;
        i !== 0 && (t.offsetHeight + r < i + n && (t.scrollTop += n), r !== 0 && i - r - n <= 0 && (t.scrollTop -= n));
      });
    },
    emitClicked() {
      this.$emit("item-select-by-keyboard", this.activeItemIndex), this.itemSelectByKeyboardListeners.forEach((t) => {
        t(this.activeItemIndex);
      });
    },
    onScroll(t) {
      this.getBottomDistance(t.target) === 0 && this.$emit("paginate");
    },
    getBottomDistance(t) {
      return t.scrollHeight - t.clientHeight - t.scrollTop;
    }
  }
});
const QF = { class: "mt-select-result-list" }, NF = { class: "mt-select-result-list__item-list" }, IF = {
  key: 0,
  class: "mt-select-result-list__empty"
};
function LF(t, e, n, i, r, o) {
  const s = Ce("mt-icon"), a = Ce("mt-popover-deprecated");
  return _(), Z("div", QF, [
    fe(a, {
      class: "mt-select-result-list-popover",
      "popover-class": t.popoverClass,
      "z-index": 1100,
      "resize-width": t.popoverResizeWidth
    }, {
      default: H(() => [
        X("div", {
          ref: "popoverContent",
          class: Ae([
            "mt-select-result-list__content",
            {
              "mt-select-result-list__content_empty": t.isLoading && (!t.options || t.options.length <= 0)
            }
          ]),
          onScroll: e[0] || (e[0] = (...l) => t.onScroll && t.onScroll(...l))
        }, [
          ne(t.$slots, "before-item-list"),
          X("ul", NF, [
            (_(!0), Z(Qe, null, Ge(t.options, (l, u) => ne(t.$slots, "result-item", wt({ ref_for: !0 }, { item: l, index: u }))), 256))
          ]),
          ne(t.$slots, "after-item-list"),
          !t.isLoading && t.options && t.options.length < 1 ? (_(), Z("div", IF, [
            fe(s, {
              name: "default-action-search",
              size: "20px"
            }),
            He(" " + Pe(t.emptyMessage || t.t("messageNoResults")), 1)
          ])) : W("", !0)
        ], 34)
      ]),
      _: 3
    }, 8, ["popover-class", "resize-width"])
  ]);
}
const VF = /* @__PURE__ */ je(DF, [["render", LF]]), BF = Te({
  components: {
    "mt-icon": mt
  },
  inject: ["setActiveItemIndex"],
  props: {
    index: {
      type: Number,
      required: !0
    },
    item: {
      type: Object,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    selected: {
      type: Boolean,
      required: !1,
      default: !1
    },
    descriptionPosition: {
      type: String,
      required: !1,
      default: "right",
      validator(t) {
        return ["bottom", "right"].includes(t);
      }
    }
  },
  data() {
    return {
      active: !1
    };
  },
  computed: {
    resultClasses() {
      return [
        {
          "is--active": this.active,
          "is--disabled": this.disabled,
          "has--description": this.hasDescriptionSlot,
          [`is--description-${this.descriptionPosition}`]: this.hasDescriptionSlot
        },
        `mt-select-option--${this.index}`
      ];
    },
    hasDescriptionSlot() {
      return !!this.$slots.description;
    }
  },
  setup() {
    const t = fs(jT), e = fs(YT), n = fs(HT), i = fs(
      UT
    );
    return {
      addActiveItemListener: t,
      removeActiveItemListener: e,
      addItemSelectByKeyboardListener: n,
      removeItemSelectByKeyboardListener: i
    };
  },
  created() {
    this.addActiveItemListener && this.addActiveItemListener(this.checkIfActive), this.addItemSelectByKeyboardListener && this.addItemSelectByKeyboardListener(this.checkIfSelected);
  },
  unmounted() {
    this.removeActiveItemListener && this.removeActiveItemListener(this.checkIfActive), this.removeItemSelectByKeyboardListener && this.removeItemSelectByKeyboardListener(this.checkIfSelected);
  },
  methods: {
    checkIfSelected(t) {
      t === this.index && this.onClickResult();
    },
    checkIfActive(t) {
      this.active = this.index === t;
    },
    onClickResult() {
      this.disabled || this.$parent.$parent.$emit("item-select", this.item);
    },
    onMouseEnter() {
      this.setActiveItemIndex(this.index);
    }
  }
});
const ZF = { class: "mt-select-result__result-item-preview" }, FF = { class: "mt-select-result__result-item-text" }, qF = {
  key: 0,
  class: "mt-select-result__result-item-description"
};
function WF(t, e, n, i, r, o) {
  const s = Ce("mt-icon");
  return _(), Z("li", {
    class: Ae(["mt-select-result", t.resultClasses]),
    onMouseenter: e[0] || (e[0] = (...a) => t.onMouseEnter && t.onMouseEnter(...a)),
    onClick: e[1] || (e[1] = Tt((...a) => t.onClickResult && t.onClickResult(...a), ["stop"]))
  }, [
    X("span", ZF, [
      ne(t.$slots, "preview")
    ]),
    X("span", FF, [
      ne(t.$slots, "default")
    ]),
    fe(Fn, { name: "mt-select-result-appear" }, {
      default: H(() => [
        t.selected ? (_(), ue(s, {
          key: 0,
          name: "regular-checkmark-xs",
          size: "16px"
        })) : W("", !0)
      ]),
      _: 1
    }),
    t.hasDescriptionSlot ? (_(), Z("span", qF, [
      ne(t.$slots, "description")
    ])) : W("", !0)
  ], 34);
}
const XF = /* @__PURE__ */ je(BF, [["render", WF]]), zF = Te({
  name: "MtColorBadge",
  props: {
    variant: {
      type: String,
      required: !1,
      default: "default",
      validator(t) {
        return ["default", "warning", "critical", "positive", "info"].includes(t);
      }
    },
    color: {
      type: String,
      required: !1,
      default: ""
    },
    rounded: {
      type: Boolean,
      required: !1,
      default: !1
    },
    hasText: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  computed: {
    colorStyle() {
      return this.color.length ? `background:${this.color}` : "";
    },
    variantClass() {
      return {
        [`is--${this.variant}`]: !0,
        "is--rounded": this.rounded,
        "has--text": this.hasText
      };
    }
  }
});
function jF(t, e, n, i, r, o) {
  return _(), Z("span", wt({
    class: ["mt-color-badge", t.variantClass]
  }, t.$attrs, { style: t.colorStyle }), [
    ne(t.$slots, "default")
  ], 16);
}
const Ob = /* @__PURE__ */ je(zF, [["render", jF]]), YF = { class: "mt-label__caption" }, HF = ["title"], UF = /* @__PURE__ */ Te({
  __name: "mt-label",
  props: {
    variant: { default: "" },
    size: { default: "default" },
    appearance: { default: "default" },
    ghost: { type: Boolean, default: !1 },
    caps: { type: Boolean, default: !1 },
    dismissable: { type: Boolean }
  },
  setup(t) {
    const e = t, { t: n } = Lt({
      messages: {
        en: {
          remove: "Remove"
        },
        de: {
          remove: "Entfernen"
        }
      }
    }), i = zx(), r = J(() => !!i.onDismiss && e.dismissable), o = J(() => [
      `mt-label--appearance-${e.appearance}`,
      `mt-label--size-${e.size}`,
      {
        [`mt-label--${e.variant}`]: !!e.variant,
        "mt-label--dismissable": r,
        "mt-label--ghost": e.ghost,
        "mt-label--caps": e.caps
      }
    ]);
    return (s, a) => (_(), Z("span", {
      class: Ae(["mt-label", o.value]),
      onClick: a[1] || (a[1] = Tt((l) => s.$emit("selected"), ["stop"])),
      tabindex: "0"
    }, [
      s.appearance === "badged" ? (_(), ue(Ob, {
        key: 0,
        variant: s.variant,
        rounded: !0
      }, null, 8, ["variant"])) : W("", !0),
      X("span", YF, [
        ne(s.$slots, "default")
      ]),
      r.value ? (_(), Z("button", {
        key: 1,
        class: "mt-label__dismiss",
        title: E(n)("remove"),
        onClick: a[0] || (a[0] = Tt((l) => s.$emit("dismiss"), ["prevent", "stop"]))
      }, [
        ne(s.$slots, "dismiss-icon", {}, () => [
          fe(mt, {
            "data-testid": "dismiss-label",
            name: "regular-times-xxs"
          })
        ])
      ], 8, HF)) : W("", !0)
    ], 2));
  }
});
const GF = Te({
  name: "MtSelectSelectionList",
  components: {
    "mt-label": UF,
    "mt-button": Sr
  },
  props: {
    selections: {
      type: Array,
      required: !1,
      default: () => []
    },
    labelProperty: {
      type: String,
      required: !1,
      default: "label"
    },
    valueProperty: {
      type: String,
      required: !1,
      default: "value"
    },
    enableSearch: {
      type: Boolean,
      required: !1,
      default: !0
    },
    invisibleCount: {
      type: Number,
      required: !1,
      default: 0
    },
    size: {
      type: String,
      required: !1,
      default: null
    },
    alwaysShowPlaceholder: {
      type: Boolean,
      required: !1,
      default: !1
    },
    placeholder: {
      type: String,
      required: !1,
      default: ""
    },
    isLoading: {
      type: Boolean,
      required: !1,
      default: !1
    },
    searchTerm: {
      type: String,
      required: !1,
      default: ""
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    selectionDisablingMethod: {
      type: Function,
      required: !1,
      default: () => !1
    },
    hideLabels: {
      type: Boolean,
      required: !1,
      default: !1
    },
    multiSelection: {
      type: Boolean,
      required: !0
    },
    disableInput: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  computed: {
    classBindings() {
      return {
        "mt-select-selection-list--single": !this.multiSelection
      };
    },
    showPlaceholder() {
      return this.alwaysShowPlaceholder || this.selections.length === 0 ? this.placeholder : "";
    }
  },
  methods: {
    isSelectionDisabled(t) {
      return !this.multiSelection || this.disabled ? !0 : typeof this.selectionDisablingMethod != "function" ? !1 : this.selectionDisablingMethod(t);
    },
    onClickInvisibleCount() {
      this.$emit("total-count-click");
    },
    onSearchTermChange(t) {
      this.$emit("search-term-change", t.target.value, t);
    },
    onKeyDownDelete() {
      this.searchTerm.length < 1 && this.$emit("last-item-delete");
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    onClickDismiss(t) {
      this.$emit("item-remove", t);
    },
    focus() {
      this.$refs.MtSelectInput && this.$refs.MtSelectInput.focus();
    },
    blur() {
      this.$refs.MtSelectInput && this.$refs.MtSelectInput.blur();
    },
    select() {
      this.$refs.MtSelectInput && this.$refs.MtSelectInput.select();
    },
    getFocusEl() {
      return this.$refs.MtSelectInput;
    }
  }
});
const KF = { class: "mt-select-selection-list" }, JF = ["data-id"], eq = ["title"], tq = {
  key: 0,
  class: "mt-select-selection-list__load-more"
}, nq = {
  key: 1,
  class: "mt-select-selection-list__input-wrapper"
}, iq = ["disabled", "readonly", "placeholder", "value"];
function rq(t, e, n, i, r, o) {
  const s = Ce("mt-label"), a = Ce("mt-button");
  return _(), Z("ul", KF, [
    (_(!0), Z(Qe, null, Ge(t.selections, (l, u) => (_(), Z(Qe, {
      key: l[t.valueProperty]
    }, [
      t.hideLabels ? W("", !0) : (_(), Z("li", {
        key: 0,
        class: Ae([
          "mt-select-selection-list__item-holder--" + u,
          "mt-select-selection-list__item-holder",
          t.classBindings
        ]),
        "data-id": l[t.valueProperty]
      }, [
        ne(t.$slots, "selected-option", wt({ ref_for: !0 }, { selection: l, defaultLabel: l[t.labelProperty], disabled: t.disabled }), () => [
          fe(s, {
            dismissable: !t.isSelectionDisabled(l),
            size: t.size,
            onDismiss: (c) => t.onClickDismiss(l)
          }, {
            default: H(() => [
              X("span", {
                class: "mt-select-selection-list__item",
                title: l[t.labelProperty]
              }, [
                ne(t.$slots, "label-property", wt({ ref_for: !0 }, { item: l, index: u, labelProperty: t.labelProperty, valueProperty: t.valueProperty }), () => [
                  He(Pe(l[t.labelProperty]), 1)
                ])
              ], 8, eq)
            ]),
            _: 2
          }, 1032, ["dismissable", "size", "onDismiss"])
        ])
      ], 10, JF))
    ], 64))), 128)),
    t.invisibleCount > 0 && !t.hideLabels ? (_(), Z("li", tq, [
      ne(t.$slots, "invisible-count", Ct(Zt({ invisibleCount: t.invisibleCount, onClickInvisibleCount: t.onClickInvisibleCount })), () => [
        fe(a, {
          variant: "secondary",
          class: "mt-select-selection-list__load-more-button",
          onClick: Tt(t.onClickInvisibleCount, ["stop"]),
          tabindex: "0"
        }, {
          default: H(() => [
            He(" +" + Pe(t.invisibleCount), 1)
          ]),
          _: 1
        }, 8, ["onClick"])
      ])
    ])) : W("", !0),
    t.disableInput ? W("", !0) : (_(), Z("li", nq, [
      ne(t.$slots, "input", Ct(Zt({ placeholder: t.placeholder, searchTerm: t.searchTerm, onSearchTermChange: t.onSearchTermChange, onKeyDownDelete: t.onKeyDownDelete })), () => [
        X("input", {
          ref: "MtSelectInput",
          class: "mt-select-selection-list__input",
          type: "text",
          disabled: t.disabled,
          readonly: !t.enableSearch,
          placeholder: t.showPlaceholder,
          value: t.searchTerm,
          onInput: e[0] || (e[0] = (...l) => t.onSearchTermChange && t.onSearchTermChange(...l)),
          onKeydown: e[1] || (e[1] = ai((...l) => t.onKeyDownDelete && t.onKeyDownDelete(...l), ["delete"]))
        }, null, 40, iq)
      ])
    ]))
  ]);
}
const oq = /* @__PURE__ */ je(GF, [["render", rq]]), sq = Te({
  name: "MtHighlightText",
  props: {
    searchTerm: {
      type: String,
      required: !1,
      default: null
    },
    text: {
      type: String,
      required: !1,
      default: null
    }
  },
  methods: {
    searchAndReplace() {
      if (!this.text)
        return "";
      if (!this.searchTerm)
        return this.text;
      const t = '<span class="mt-highlight-text__highlight">', e = "</span>", n = new RegExp(this.escapeRegExp(this.searchTerm), "ig");
      return this.text.replace(n, (i) => `${t}${i}${e}`);
    },
    // Remove regex special characters from search string
    escapeRegExp(t) {
      return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
  },
  render() {
    return ir("div", {
      class: "mt-highlight-text",
      innerHTML: this.searchAndReplace()
    });
  }
});
const aq = Te({
  name: "MtSelect",
  components: {
    "mt-select-base": kF,
    "mt-select-result-list": VF,
    "mt-select-selection-list": oq,
    "mt-highlight-text": sq,
    "mt-select-result": XF
  },
  inheritAttrs: !1,
  props: {
    /**
     * An array of objects with the labelProperty and valueProperty.
     *
     * @example [{label: 'Option A', value: 'a'}, {label: 'Option B', value: 'b'}]
     */
    options: {
      type: Array,
      required: !0
    },
    /**
     * Toggles if either one or more items can be selected.
     */
    enableMultiSelection: {
      type: Boolean,
      default: !1
    },
    /**
     * Dependent on multiSelection, either a single value or an array of values.
     */
    modelValue: {
      type: [String, Number, Boolean, Array, null, void 0],
      required: !1,
      default: null
    },
    /**
     * The object key of the label property.
     */
    labelProperty: {
      type: String,
      required: !1,
      default: "label"
    },
    /**
     * The object key to use for the value.
     */
    valueProperty: {
      type: String,
      required: !1,
      default: "value"
    },
    /**
     * The number of items that are expanded by default.
     */
    valueLimit: {
      type: Number,
      required: !1,
      default: 5
    },
    /**
     * The label for the select field itself.
     */
    label: {
      type: String,
      required: !1,
      default: ""
    },
    /**
     * The placeholder for the select field.
     */
    placeholder: {
      type: String,
      required: !1,
      default: ""
    },
    /**
     * Toggles the loading state of the select field.
     */
    isLoading: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Disables or enables the select field.
     */
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Toggles a button to clear all selections.
     */
    hideClearableButton: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines to highlight the searched term or not.
     */
    highlightSearchTerm: {
      type: Boolean,
      required: !1,
      default: !0
    },
    /**
     * Used to implement a custom search function.
     * Parameters passed: { options, labelProperty, valueProperty, searchTerm }
     */
    searchFunction: {
      type: Function,
      required: !1,
      default({
        options: t,
        labelProperty: e,
        searchTerm: n
      }) {
        return t.filter((i) => {
          const r = Zl(i, e);
          return r ? r.toLowerCase().includes(n.toLowerCase()) : !1;
        });
      }
    },
    /**
     * An error in your business logic related to this field.
     *
     * For example: {"code": 500, "detail": "Error while saving"}
     */
    error: {
      type: Object,
      required: !1,
      default: null
    },
    /**
     * Toggles the inheritance visualization.
     */
    isInherited: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines if the field is inheritable.
     */
    isInheritanceField: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Determines the active state of the inheritance toggle.
     */
    disableInheritanceToggle: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Render the select field in small without a search input
     */
    small: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  data() {
    return {
      searchTerm: "",
      limit: this.valueLimit
    };
  },
  computed: {
    visibleValues() {
      if (typeof this.currentValue == "string" || typeof this.currentValue == "number" || typeof this.currentValue == "boolean") {
        const t = this.currentValue;
        return this.options.filter((e) => t === this.getKey(e, this.valueProperty));
      }
      if (Array.isArray(this.currentValue)) {
        const t = this.currentValue;
        return this.currentValue.length <= 0 ? [] : this.options.filter((e) => t.includes(this.getKey(e, this.valueProperty))).slice(0, this.limit);
      }
      return this.options.filter((t) => this.isSelected(t)).slice(0, this.limit);
    },
    totalValuesCount() {
      return this.enableMultiSelection && Array.isArray(this.currentValue) && this.currentValue.length ? this.currentValue.length : (Array.isArray(this.currentValue) && this.currentValue.length, this.currentValue !== void 0 || this.currentValue !== null ? 1 : 0);
    },
    invisibleValueCount() {
      return this.currentValue ? Math.max(0, this.totalValuesCount - this.limit) : 0;
    },
    currentValue: {
      get() {
        return this.modelValue === null || this.modelValue === void 0 ? [] : this.modelValue;
      },
      set(t) {
        this.$emit("update:modelValue", t), this.$emit("change", t);
      }
    },
    visibleResults() {
      return this.searchTerm ? this.searchFunction({
        options: this.options,
        labelProperty: this.labelProperty,
        valueProperty: this.valueProperty,
        searchTerm: this.searchTerm
      }) : this.options;
    },
    componentClasses() {
      return {
        "mt-select--small": this.small
      };
    }
  },
  setup() {
    const { t } = Lt({
      messages: {
        en: {
          messageNoResults: 'No results found for "{term}".'
        },
        de: {
          messageNoResults: 'Es wurden keine Ergebnisse für "{term}" gefunden.'
        }
      }
    });
    return {
      t
    };
  },
  watch: {
    valueLimit(t) {
      this.limit = t;
    }
  },
  methods: {
    isSelected(t) {
      return this.enableMultiSelection && Array.isArray(this.currentValue) ? this.currentValue.includes(this.getKey(t, this.valueProperty)) : this.currentValue === this.getKey(t, this.valueProperty);
    },
    addItem(t) {
      const e = this.getKey(t, this.valueProperty);
      if (this.isSelected(t) && this.enableMultiSelection) {
        this.remove(t);
        return;
      }
      this.$emit("item-add", t), this.enableMultiSelection ? Array.isArray(this.currentValue) ? this.currentValue = [...this.currentValue, e] : this.currentValue !== void 0 || this.currentValue !== null ? this.currentValue = [e] : this.currentValue = [this.currentValue, e] : this.currentValue !== e && (this.currentValue = e, this.$refs.selectBase.collapse(), this.$refs.selectionList.blur()), this.$refs.selectionList.focus(), this.$refs.selectionList.select();
    },
    remove(t) {
      if (this.$emit("item-remove", t), !Array.isArray(this.currentValue)) {
        this.currentValue = null;
        return;
      }
      this.currentValue = this.currentValue.filter(
        (e) => e !== this.getKey(t, this.valueProperty)
      );
    },
    removeLastItem() {
      if (!this.visibleValues.length)
        return;
      if (this.invisibleValueCount > 0) {
        this.expandValueLimit();
        return;
      }
      const t = this.visibleValues[this.visibleValues.length - 1];
      this.remove(t);
    },
    expandValueLimit() {
      this.$emit("display-values-expand"), this.limit += this.limit;
    },
    onSearchTermChange: Kp(function(e) {
      this.searchTerm = e, this.$emit("search-term-change", this.searchTerm), this.resetActiveItem();
    }, 100),
    resetActiveItem() {
      this.$refs.MtSelectResultList && this.$refs.MtSelectResultList.setActiveItemIndex(0);
    },
    onSelectExpanded() {
      this.$refs.selectionList.focus();
    },
    onSelectCollapsed() {
      this.searchTerm = "", this.$refs.selectionList.blur();
    },
    getKey(t, e, n) {
      return Zl(t, e, n);
    },
    onClearSelection() {
      this.currentValue = [];
    },
    getFocusElement() {
      return this.$refs.selectionList.getFocusEl();
    }
  }
});
function lq(t, e, n, i, r, o) {
  const s = Ce("mt-select-selection-list"), a = Ce("mt-highlight-text"), l = Ce("mt-select-result"), u = Ce("mt-select-result-list"), c = Ce("mt-select-base");
  return _(), ue(c, wt({
    ref: "selectBase",
    class: ["mt-select", t.componentClasses],
    "is-loading": t.isLoading,
    label: t.label
  }, t.$attrs, {
    error: t.error,
    disabled: t.disabled,
    "show-clearable-button": !t.hideClearableButton,
    "is-inherited": t.isInherited,
    "is-inheritance-field": t.isInheritanceField,
    "disable-inheritance-toggle": t.disableInheritanceToggle,
    onSelectExpanded: t.onSelectExpanded,
    onSelectCollapsed: t.onSelectCollapsed,
    onClear: t.onClearSelection
  }), {
    "mt-select-prefix": H(() => [
      ne(t.$slots, "prefix")
    ]),
    "mt-select-selection": H(({ size: d }) => [
      fe(s, wt({
        ref: "selectionList",
        "disable-input": t.small,
        "multi-selection": t.enableMultiSelection,
        selections: t.visibleValues,
        "invisible-count": t.invisibleValueCount
      }, { size: d, valueProperty: t.valueProperty, labelProperty: t.labelProperty, placeholder: t.placeholder, searchTerm: t.searchTerm, disabled: t.disabled }, {
        onTotalCountClick: t.expandValueLimit,
        onItemRemove: t.remove,
        onLastItemDelete: t.removeLastItem,
        onSearchTermChange: t.onSearchTermChange
      }), {
        "label-property": H(({ item: h, index: f, itemLabelProperty: p, itemValueProperty: m }) => [
          ne(t.$slots, "selection-label-property", Ct(Zt({ item: h, index: f, itemLabelProperty: p, itemValueProperty: m })), () => [
            He(Pe(t.getKey(h, t.labelProperty)), 1)
          ])
        ]),
        _: 2
      }, 1040, ["disable-input", "multi-selection", "selections", "invisible-count", "onTotalCountClick", "onItemRemove", "onLastItemDelete", "onSearchTermChange"])
    ]),
    "results-list": H(() => [
      fe(u, {
        ref: "MtSelectResultList",
        options: t.visibleResults,
        "is-loading": t.isLoading,
        "empty-message": t.t("messageNoResults", { term: t.searchTerm }),
        "focus-el": t.getFocusElement(),
        onPaginate: e[0] || (e[0] = (d) => t.$emit("paginate")),
        onItemSelect: t.addItem
      }, {
        "before-item-list": H(() => [
          ne(t.$slots, "before-item-list")
        ]),
        "result-item": H(({ item: d, index: h }) => [
          ne(t.$slots, "result-item", Ct(Zt({
            item: d,
            index: h,
            labelProperty: t.labelProperty,
            valueProperty: t.valueProperty,
            searchTerm: t.searchTerm,
            highlightSearchTerm: t.highlightSearchTerm,
            isSelected: t.isSelected,
            addItem: t.addItem,
            getKey: t.getKey
          })), () => [
            fe(l, wt({
              selected: t.isSelected(d),
              class: "mt-select-option--" + d.value,
              "data-testid": "mt-select-option--" + d.value
            }, { item: d, index: h }, { onItemSelect: t.addItem }), {
              default: H(() => [
                ne(t.$slots, "result-label-property", Ct(Zt({ item: d, index: h, labelProperty: t.labelProperty, valueProperty: t.valueProperty, searchTerm: t.searchTerm, getKey: t.getKey })), () => [
                  t.highlightSearchTerm ? (_(), ue(a, {
                    key: 0,
                    text: t.getKey(d, t.labelProperty),
                    "search-term": t.searchTerm
                  }, null, 8, ["text", "search-term"])) : (_(), Z(Qe, { key: 1 }, [
                    He(Pe(t.getKey(d, t.labelProperty)), 1)
                  ], 64))
                ])
              ]),
              _: 2
            }, 1040, ["selected", "class", "data-testid", "onItemSelect"])
          ])
        ]),
        "after-item-list": H(() => [
          ne(t.$slots, "after-item-list")
        ]),
        _: 3
      }, 8, ["options", "is-loading", "empty-message", "focus-el", "onItemSelect"])
    ]),
    "mt-select-suffix": H(() => [
      ne(t.$slots, "suffix")
    ]),
    "mt-select-hint": H(() => [
      ne(t.$slots, "hint")
    ]),
    _: 3
  }, 16, ["class", "is-loading", "label", "error", "disabled", "show-clearable-button", "is-inherited", "is-inheritance-field", "disable-inheritance-toggle", "onSelectExpanded", "onSelectCollapsed", "onClear"]);
}
const uq = /* @__PURE__ */ je(aq, [["render", lq]]), cq = Te({
  name: "MtSlider",
  directives: {
    tooltip: ja
  },
  components: { MtNumberField: NO, MtBaseField: As },
  extends: As,
  props: {
    /**
     * Defines the label of the slider
     */
    label: {
      type: String,
      required: !0
    },
    /**
     * Defines the minimum value of the number.
     */
    min: {
      type: Number,
      required: !1,
      default: 0
    },
    /**
     * Defines the maximum value of the number.
     */
    max: {
      type: Number,
      required: !1,
      default: 100
    },
    /**
     * Defines the amount of which the number is increased or decreased per step.
     */
    step: {
      type: Number,
      required: !1,
      default: 1
    },
    /**
     * The value of the slider.
     * If isRange is true, this should be an array with two values.
     * If isRange is false, this should be a single number.
     */
    modelValue: {
      type: [Number, Array],
      required: !1,
      default: 0,
      validator(t) {
        return Array.isArray(t) ? t.length === 2 : !0;
      }
    },
    /**
     * Defines if it is a range slider.
     */
    isRange: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Defines the minimum distance between the two sliders.
     * Should be a multiple of the step.
     */
    minDistance: {
      type: Number,
      required: !1,
      default: 0
    },
    /**
     * Defines the amount of marks on the slider.
     */
    markCount: {
      type: Number,
      required: !1,
      default: 5
    }
  },
  data() {
    return {
      rangeRightValue: 0,
      rangeLeftValue: 0,
      activeSlider: null
    };
  },
  watch: {
    modelValue: {
      handler(t) {
        this.isArray(t) ? (this.rangeLeftValue = t[0], this.rangeRightValue = t[1]) : this.rangeRightValue = t;
      },
      immediate: !0
    },
    rangeRightValue: {
      handler(t) {
        if (typeof t == "string" && (t = parseFloat(t)), t >= this.max && (t = this.max), this.isRange) {
          t <= this.min && (t = this.min + this.minDistance);
          let e = this.rangeLeftValue;
          t <= this.rangeLeftValue && (e = t - this.minDistance), this.$emit("update:modelValue", [e, t]);
        } else
          t <= this.min && (t = this.min), this.$emit("update:modelValue", t);
      },
      immediate: !0
    },
    rangeLeftValue: {
      handler(t) {
        if (typeof t == "string" && (t = parseFloat(t)), !this.isRange)
          return;
        t >= this.max && (t = this.max - this.minDistance);
        let e = this.rangeRightValue;
        t >= this.rangeRightValue && (e = t + this.minDistance), this.$emit("update:modelValue", [t, e]);
      },
      immediate: !0
    },
    // ensure that the range values are within the min and max range
    min: {
      handler(t) {
        !this.isRange && this.rangeRightValue < t ? this.rangeRightValue = t : this.rangeLeftValue < t && (this.rangeLeftValue = t);
      },
      immediate: !0
    },
    max: {
      handler(t) {
        this.rangeRightValue > t && (this.rangeRightValue = t);
      },
      immediate: !0
    },
    step: {
      handler(t) {
        this.rangeLeftValue % t !== 0 && (this.rangeLeftValue = Math.floor(this.rangeLeftValue / t) * t), this.rangeRightValue % t !== 0 && (this.rangeRightValue = Math.floor(this.rangeRightValue / t) * t);
      },
      immediate: !0
    },
    isRange: {
      handler(t) {
        t && (this.rangeRightValue < this.min + this.minDistance && (this.rangeRightValue = this.min + this.minDistance), this.rangeLeftValue > this.rangeRightValue - this.minDistance && (this.rangeLeftValue = this.rangeRightValue - this.minDistance));
      },
      immediate: !0
    }
  },
  computed: {
    stringRepresentation() {
      return this.modelValue.toString();
    },
    styleStartPosition() {
      if (!this.isRange)
        return "0%";
      const t = 10, e = this.max - this.min, n = (this.rangeLeftValue - this.min) / e, i = n * 100, r = (1 - n * 2) * t;
      return `calc(${i}% + ${r}px)`;
    },
    styleEndPosition() {
      const e = this.max - this.min, n = (this.max - this.rangeRightValue) / e, i = n * 100, r = (1 - n * 2) * 10;
      return `calc(${i}% + ${r}px)`;
    },
    markStep() {
      return (this.max - this.min) / (this.markCount - 1);
    },
    toolTipText() {
      return this.activeSlider ? this.activeSlider === "left" ? this.rangeLeftValue.toString() : this.rangeRightValue.toString() : "";
    },
    toolTipStyle() {
      return this.activeSlider ? this.activeSlider === "left" ? {
        left: this.styleStartPosition,
        transform: "translateX(-50%)"
      } : {
        right: this.styleEndPosition,
        transform: "translateX(50%)"
      } : {
        display: "none"
      };
    }
  },
  methods: {
    isArray(t) {
      return Array.isArray(t) || typeof t != "number" && Array.isArray(t.target);
    }
  }
});
const dq = { class: "mt-slider__slider" }, hq = { class: "mt-slider__marks" }, fq = { class: "mt-slider__mark__label" }, pq = {
  class: "mt-slider__bar",
  ref: "sliderBar"
}, mq = ["min", "max", "step", "disabled"], gq = ["id", "min", "max", "step", "disabled"];
function Oq(t, e, n, i, r, o) {
  const s = Ce("mt-number-field"), a = Ce("mt-base-field");
  return _(), ue(a, {
    class: Ae(["mt-slider", t.$attrs.class]),
    disabled: t.disabled,
    required: t.required,
    "is-inherited": t.isInherited,
    "is-inheritance-field": t.isInheritanceField,
    "disable-inheritance-toggle": t.disableInheritanceToggle,
    copyable: t.copyable,
    "copyable-tooltip": t.copyableTooltip,
    "copyable-text": t.stringRepresentation,
    "has-focus": t.hasFocus,
    "help-text": t.helpText,
    name: t.name,
    size: t.size,
    onInheritanceRestore: e[8] || (e[8] = (l) => t.$emit("inheritance-restore", l)),
    onInheritanceRemove: e[9] || (e[9] = (l) => t.$emit("inheritance-remove", l))
  }, {
    label: H(() => [
      He(Pe(t.label), 1)
    ]),
    element: H(({ identification: l }) => [
      t.isRange ? (_(), ue(s, {
        key: 0,
        modelValue: t.rangeLeftValue,
        "onUpdate:modelValue": e[0] || (e[0] = (u) => t.rangeLeftValue = u),
        min: t.min,
        max: t.max - t.minDistance,
        step: t.step,
        disabled: t.disabled,
        size: "small",
        "number-type": t.step % 1 === 0 ? "int" : "float",
        "data-testid": "left-number-field"
      }, null, 8, ["modelValue", "min", "max", "step", "disabled", "number-type"])) : W("", !0),
      X("div", dq, [
        X("div", hq, [
          (_(!0), Z(Qe, null, Ge(t.markCount, (u) => (_(), Z("div", {
            key: u,
            class: "mt-slider__mark",
            "data-testid": "mark"
          }, [
            X("span", fq, Pe((u - 1) * t.markStep + t.min), 1)
          ]))), 128))
        ]),
        X("div", pq, [
          X("div", {
            class: "mt-slider__value",
            style: pt({ left: t.styleStartPosition, right: t.styleEndPosition })
          }, null, 4)
        ], 512),
        t.isRange ? yt((_(), Z("input", {
          key: 0,
          type: "range",
          class: "mt-slider__input-slider mt-slider__input-slider__double",
          "aria-label": "Left range slider",
          min: t.min,
          max: t.max,
          step: t.step,
          disabled: t.disabled,
          "onUpdate:modelValue": e[1] || (e[1] = (u) => t.rangeLeftValue = u),
          onMouseenter: e[2] || (e[2] = (u) => t.activeSlider = "left"),
          onMouseleave: e[3] || (e[3] = (u) => t.activeSlider = null),
          "data-testid": "left-slider"
        }, null, 40, mq)), [
          [
            Lr,
            t.rangeLeftValue,
            void 0,
            { number: !0 }
          ]
        ]) : W("", !0),
        yt(X("input", {
          id: l,
          type: "range",
          class: Ae(["mt-slider__input-slider", { "mt-slider__input-slider__double": t.isRange }]),
          "aria-label": "Right range slider",
          min: t.min,
          max: t.max,
          step: t.step,
          disabled: t.disabled,
          "onUpdate:modelValue": e[4] || (e[4] = (u) => t.rangeRightValue = u),
          onMouseenter: e[5] || (e[5] = (u) => t.activeSlider = "right"),
          onMouseleave: e[6] || (e[6] = (u) => t.activeSlider = null),
          "data-testid": "right-slider"
        }, null, 42, gq), [
          [
            Lr,
            t.rangeRightValue,
            void 0,
            { number: !0 }
          ]
        ]),
        X("span", {
          class: "mt-slider__input-slider__hint mt-tooltip mt-tooltip--dark mt-tooltip--top mt-tooltip--wrapper",
          style: pt(t.toolTipStyle)
        }, Pe(t.toolTipText), 5)
      ]),
      fe(s, {
        modelValue: t.rangeRightValue,
        "onUpdate:modelValue": e[7] || (e[7] = (u) => t.rangeRightValue = u),
        min: t.isRange ? t.min + t.minDistance : t.min,
        max: t.max,
        step: t.step,
        disabled: t.disabled,
        size: "small",
        "number-type": t.step % 1 === 0 ? "int" : "float",
        "data-testid": "right-number-field"
      }, null, 8, ["modelValue", "min", "max", "step", "disabled", "number-type"])
    ]),
    "field-hint": H(() => [
      ne(t.$slots, "hint")
    ]),
    _: 3
  }, 8, ["class", "disabled", "required", "is-inherited", "is-inheritance-field", "disable-inheritance-toggle", "copyable", "copyable-tooltip", "copyable-text", "has-focus", "help-text", "name", "size"]);
}
const Lae = /* @__PURE__ */ je(cq, [["render", Oq]]), vq = Te({
  name: "MtSwitch",
  components: {
    "mt-base-field": As,
    "mt-field-error": Xs
  },
  mixins: [Jp],
  props: {
    label: {
      type: String,
      required: !1,
      default: ""
    },
    required: {
      type: Boolean,
      default: !1
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * Determines the checked state of the checkbox.
     */
    checked: {
      type: Boolean,
      required: !1,
      default: null
    },
    /**
     * Determines if the field is surrounded by a border.
     */
    bordered: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Inherited value from another SalesChannel.
     */
    inheritedValue: {
      type: Boolean,
      required: !1,
      default: null
    },
    /**
     * Help text with additional information for the field.
     */
    helpText: {
      type: String,
      required: !1,
      default: null
    },
    /**
     * Error object for this field.
     */
    error: {
      type: Object,
      required: !1,
      default: null
    },
    removeTopMargin: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Name of the form field.
     */
    name: {
      type: String,
      required: !1,
      default: ""
    }
  },
  data() {
    return {
      currentValue: this.checked,
      id: void 0
    };
  },
  mounted() {
    this.id = za();
  },
  computed: {
    identification() {
      return `mt-field--${this.id}`;
    },
    inputState() {
      return this.isInherited ? this.inheritedValue : this.currentValue || !1;
    },
    isInheritanceField() {
      return this.$attrs.isInheritanceField ? !0 : this.inheritedValue !== null;
    },
    isInherited() {
      return this.$attrs.isInherited ? !0 : this.isInheritanceField && this.currentValue === null;
    },
    hasError() {
      return this.error && this.error.code !== 0;
    },
    MtSwitchFieldClasses() {
      return [
        {
          "has--error": this.hasError,
          "mt-field--switch-bordered": this.bordered,
          "mt-field--switch-no-margin-top": this.removeTopMargin,
          "mt-field--switch-no-margin-bottom": this.hasError
        }
      ];
    },
    errorClasses() {
      return [
        {
          "mt-field__error--move-up": !this.bordered
        }
      ];
    },
    isDisabled() {
      return this.disabled || this.isInherited;
    }
  },
  watch: {
    checked() {
      this.currentValue = this.checked;
    }
  },
  methods: {
    onChange(t) {
      this.$emit("change", t.target.checked);
    },
    onInheritanceRestore(t) {
      this.$emit("inheritance-restore", t);
    }
  }
});
const yq = { class: "mt-field--switch__container" }, bq = { class: "mt-field--switch__content" }, wq = { class: "mt-field--switch__input" }, kq = ["id", "name", "checked", "disabled"];
function Sq(t, e, n, i, r, o) {
  const s = Ce("mt-base-field"), a = Ce("mt-field-error");
  return _(), Z("div", yq, [
    X("div", {
      class: Ae(["mt-field--switch", t.MtSwitchFieldClasses])
    }, [
      X("div", bq, [
        X("div", wq, [
          X("input", {
            id: t.identification,
            type: "checkbox",
            name: t.formFieldName || t.identification,
            checked: t.inputState,
            disabled: t.isDisabled,
            onChange: e[0] || (e[0] = Tt((...l) => t.onChange && t.onChange(...l), ["stop"]))
          }, null, 40, kq),
          e[3] || (e[3] = X("div", { class: "mt-field__switch-state" }, [
            X("div", { class: "mt-field__switch-state-knob" })
          ], -1))
        ]),
        fe(s, wt(t.$attrs, {
          disabled: t.disabled,
          required: t.required,
          name: t.identification,
          "has-focus": !1,
          "help-text": t.helpText,
          "is-inheritance-field": t.isInheritanceField,
          "is-inherited": t.isInherited,
          onInheritanceRestore: e[1] || (e[1] = (l) => t.onInheritanceRestore(l)),
          onInheritanceRemove: e[2] || (e[2] = (l) => t.$emit("inheritance-remove", l))
        }), {
          label: H(() => [
            He(Pe(t.label), 1)
          ]),
          _: 1
        }, 16, ["disabled", "required", "name", "help-text", "is-inheritance-field", "is-inherited"])
      ])
    ], 2),
    fe(a, {
      error: t.error,
      class: Ae(t.errorClasses)
    }, null, 8, ["error", "class"])
  ]);
}
const rm = /* @__PURE__ */ je(vq, [["render", Sq]]), _q = Te({
  name: "MtTextarea",
  components: {
    "mt-base-field": As,
    "mt-field-error": Xs
  },
  mixins: [Jp],
  props: {
    modelValue: {
      type: String,
      required: !1,
      default: null
    },
    /**
     * Inherited value from another SalesChannel.
     */
    inheritedValue: {
      type: String,
      required: !1,
      default: null
    },
    label: {
      type: String,
      required: !1,
      default: null
    },
    placeholder: {
      type: String,
      required: !1,
      default: null
    },
    helpText: {
      type: String,
      required: !1,
      default: null
    },
    required: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    error: {
      type: Object,
      required: !1,
      default: null
    },
    /**
     * If set to a value a character counter will be displayed.
     */
    maxLength: {
      type: Number,
      required: !1,
      default: void 0
    }
  },
  data() {
    return {
      currentValue: this.modelValue,
      hasFocus: !1
    };
  },
  computed: {
    inputState() {
      return this.isInherited ? this.inheritedValue : this.currentValue || "";
    },
    isInheritanceField() {
      return this.$attrs.isInheritanceField ? !0 : this.inheritedValue !== null;
    },
    isInherited() {
      return this.$attrs.isInherited ? !0 : this.isInheritanceField && this.currentValue === null;
    }
  },
  watch: {
    modelValue() {
      this.currentValue = this.modelValue;
    }
  },
  methods: {
    onInput(t) {
      this.$emit("update:modelValue", t.target.value);
    },
    onChange(t) {
      this.$emit("change", t.target.value);
    },
    setFocus() {
      this.hasFocus = !0;
    },
    removeFocus() {
      this.hasFocus = !1;
    }
  }
});
const xq = ["id", "name", "placeholder", "disabled", "value", "maxlength"];
function Cq(t, e, n, i, r, o) {
  const s = Ce("mt-field-error"), a = Ce("mt-base-field");
  return _(), ue(a, wt({ class: "mt-field--textarea" }, t.$attrs, {
    name: t.formFieldName,
    "has-focus": t.hasFocus,
    required: t.required,
    disabled: t.disabled,
    "help-text": t.helpText,
    "is-inheritance-field": t.isInheritanceField,
    "is-inherited": t.isInherited,
    onInheritanceRestore: e[4] || (e[4] = (l) => t.$emit("inheritance-restore", l)),
    onInheritanceRemove: e[5] || (e[5] = (l) => t.$emit("inheritance-remove", l))
  }), un({
    element: H(({ identification: l, helpText: u, error: c, disabled: d }) => [
      X("textarea", {
        id: l,
        name: l,
        placeholder: t.placeholder,
        disabled: d,
        value: t.inputState,
        maxlength: t.maxLength,
        onChange: e[0] || (e[0] = Tt((...h) => t.onChange && t.onChange(...h), ["stop"])),
        onInput: e[1] || (e[1] = Tt((...h) => t.onInput && t.onInput(...h), ["stop"])),
        onFocus: e[2] || (e[2] = (...h) => t.setFocus && t.setFocus(...h)),
        onBlur: e[3] || (e[3] = (...h) => t.removeFocus && t.removeFocus(...h))
      }, null, 40, xq)
    ]),
    error: H(() => [
      t.error ? (_(), ue(s, {
        key: 0,
        error: t.error
      }, null, 8, ["error"])) : W("", !0)
    ]),
    "field-hint": H(() => [
      ne(t.$slots, "hint")
    ]),
    _: 2
  }, [
    t.label ? {
      name: "label",
      fn: H(() => [
        He(Pe(t.label), 1)
      ]),
      key: "0"
    } : void 0,
    t.maxLength ? {
      name: "field-hint-right",
      fn: H(() => {
        var l;
        return [
          He(Pe(((l = t.modelValue) == null ? void 0 : l.length) ?? 0) + "/" + Pe(t.maxLength), 1)
        ];
      }),
      key: "1"
    } : void 0
  ]), 1040, ["name", "has-focus", "required", "disabled", "help-text", "is-inheritance-field", "is-inherited"]);
}
const Vae = /* @__PURE__ */ je(_q, [["render", Cq]]), Tq = Te({
  name: "MtPopoverItem",
  components: {
    "mt-checkbox": em,
    "mt-switch": rm,
    "mt-icon": mt
  },
  props: {
    label: {
      type: String,
      required: !0
    },
    type: {
      type: String,
      required: !1,
      default: "default",
      validator: (t) => ["default", "critical", "active"].includes(t)
    },
    showCheckbox: {
      type: Boolean,
      required: !1,
      default: !1
    },
    checkboxChecked: {
      type: Boolean,
      required: !1,
      default: !1
    },
    checkboxPartial: {
      type: Boolean,
      required: !1,
      default: !1
    },
    icon: {
      type: String,
      required: !1,
      default: ""
    },
    onLabelClick: {
      type: Function,
      required: !1,
      default: void 0
    },
    metaCopy: {
      type: String,
      required: !1,
      default: ""
    },
    contextualDetail: {
      type: String,
      required: !1,
      default: ""
    },
    shortcut: {
      type: String,
      required: !1,
      default: ""
    },
    showSwitch: {
      type: Boolean,
      required: !1,
      default: !1
    },
    switchValue: {
      type: Boolean,
      required: !1,
      default: !1
    },
    showVisibility: {
      type: Boolean,
      required: !1,
      default: !1
    },
    visible: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    showOptions: {
      type: Boolean,
      required: !1,
      default: !1
    },
    optionsCount: {
      type: Number,
      required: !1,
      default: void 0
    },
    borderTop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    borderBottom: {
      type: Boolean,
      required: !1,
      default: !1
    },
    role: {
      type: String,
      required: !1,
      default: "menuitem"
    },
    isOptionItem: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["change-checkbox", "change-switch", "change-visibility", "click-options"],
  setup(t, { emit: e }) {
    const n = za(), i = (f) => {
      e("change-checkbox", f);
    }, r = (f) => {
      e("change-switch", f);
    }, o = (f) => {
      e("change-visibility", f);
    }, s = () => {
      e("click-options");
    }, a = J(() => (!!t.onLabelClick || t.showSwitch || t.showCheckbox || t.showOptions || t.isOptionItem) && !t.disabled), l = J(() => ({
      "mt-popover-item--default": t.type === "default",
      "mt-popover-item--critical": t.type === "critical",
      "mt-popover-item--active": t.type === "active",
      "mt-popover-item--disabled": t.disabled,
      "mt-popover-item--border-top": t.borderTop,
      "mt-popover-item--border-bottom": t.borderBottom,
      "mt-popover-item--clickable": !!a.value
    })), u = J(() => ({
      "mt-popover-item__label--clickable": (!!t.onLabelClick || t.showSwitch || t.showCheckbox || t.showOptions) && !t.disabled
    })), c = J(() => t.onLabelClick ? 0 : -1), d = () => {
      if (t.onLabelClick) {
        t.onLabelClick();
        return;
      }
      if (t.showOptions) {
        s();
        return;
      }
      if (t.showSwitch) {
        r(!t.switchValue);
        return;
      }
      if (t.showCheckbox) {
        i(!t.checkboxChecked);
        return;
      }
    }, h = J(() => ({
      "mt-popover-item__icon--clickable": !!t.onLabelClick
    }));
    return {
      emitChangeCheckbox: i,
      emitChangeSwitch: r,
      emitVisibilityChange: o,
      emitClickOptions: s,
      componentClasses: l,
      labelClasses: u,
      onLabelClickTabIndex: c,
      handleLableClick: d,
      isClickable: a,
      iconClasses: h,
      id: n
    };
  }
});
const $q = { class: "mt-popover-item__top-row" }, Pq = ["tabindex", "role", "for"], Mq = {
  key: 0,
  class: "mt-popover-item__meta-copy"
}, Eq = { class: "mt-popover-item__align-right" }, Aq = {
  key: 0,
  class: "mt-popover-item__contextual-detail"
}, Rq = {
  key: 1,
  class: "mt-popover-item__shortcut"
}, Dq = {
  key: 4,
  class: "mt-popover-item__options-count"
};
function Qq(t, e, n, i, r, o) {
  const s = Ce("mt-checkbox"), a = Ce("mt-icon"), l = Ce("mt-switch");
  return _(), Z("div", {
    class: Ae(["mt-popover-item", t.componentClasses]),
    onClick: e[3] || (e[3] = (...u) => t.handleLableClick && t.handleLableClick(...u))
  }, [
    X("div", $q, [
      t.showCheckbox ? (_(), ue(s, {
        key: 0,
        class: "mt-popover-item__checkbox",
        checked: t.checkboxChecked,
        partial: t.checkboxPartial,
        id: t.id,
        onChange: t.emitChangeCheckbox
      }, null, 8, ["checked", "partial", "id", "onChange"])) : W("", !0),
      ne(t.$slots, "extension-logo"),
      t.icon ? (_(), ue(a, {
        key: 1,
        class: Ae(["mt-popover-item__icon", t.iconClasses]),
        tabindex: t.onLabelClickTabIndex,
        name: t.icon,
        onClick: t.handleLableClick,
        onKeyup: ai(t.handleLableClick, ["enter"])
      }, null, 8, ["class", "tabindex", "name", "onClick", "onKeyup"])) : W("", !0),
      X("label", {
        class: Ae(["mt-popover-item__label", t.labelClasses]),
        tabindex: t.onLabelClickTabIndex,
        role: t.role,
        for: t.id,
        onClick: e[0] || (e[0] = Tt((...u) => t.handleLableClick && t.handleLableClick(...u), ["stop", "prevent"])),
        onKeyup: e[1] || (e[1] = ai((...u) => t.handleLableClick && t.handleLableClick(...u), ["enter"]))
      }, [
        He(Pe(t.label) + " ", 1),
        t.metaCopy ? (_(), Z("div", Mq, Pe(t.metaCopy), 1)) : W("", !0)
      ], 42, Pq),
      X("div", Eq, [
        t.contextualDetail ? (_(), Z("div", Aq, Pe(t.contextualDetail), 1)) : W("", !0),
        t.shortcut ? (_(), Z("div", Rq, Pe(t.shortcut), 1)) : W("", !0),
        t.showSwitch ? (_(), ue(l, {
          key: 2,
          checked: t.switchValue,
          class: "mt-popover-item__switch",
          onChange: t.emitChangeSwitch
        }, null, 8, ["checked", "onChange"])) : W("", !0),
        t.showVisibility ? (_(), ue(a, {
          key: 3,
          class: "mt-popover-item__visibility",
          name: t.visible ? "solid-eye" : "solid-eye-slash",
          onClick: e[2] || (e[2] = () => t.emitVisibilityChange(!t.visible))
        }, null, 8, ["name"])) : W("", !0),
        typeof t.optionsCount == "number" ? (_(), Z("div", Dq, Pe(t.optionsCount), 1)) : W("", !0),
        t.showOptions ? (_(), ue(a, {
          key: 5,
          class: "mt-popover-item__options",
          name: "solid-chevron-right-s",
          onClick: t.emitClickOptions
        }, null, 8, ["onClick"])) : W("", !0)
      ])
    ])
  ], 2);
}
const Zo = /* @__PURE__ */ je(Tq, [["render", Qq]]);
var Nq = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Iq(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var GT = { exports: {} };
(function(t, e) {
  (function(n, i) {
    t.exports = i();
  })(typeof self < "u" ? self : Nq, function() {
    return function(n) {
      var i = {};
      function r(o) {
        if (i[o])
          return i[o].exports;
        var s = i[o] = { i: o, l: !1, exports: {} };
        return n[o].call(s.exports, s, s.exports, r), s.l = !0, s.exports;
      }
      return r.m = n, r.c = i, r.d = function(o, s, a) {
        r.o(o, s) || Object.defineProperty(o, s, { enumerable: !0, get: a });
      }, r.r = function(o) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(o, "__esModule", { value: !0 });
      }, r.t = function(o, s) {
        if (1 & s && (o = r(o)), 8 & s || 4 & s && typeof o == "object" && o && o.__esModule)
          return o;
        var a = /* @__PURE__ */ Object.create(null);
        if (r.r(a), Object.defineProperty(a, "default", { enumerable: !0, value: o }), 2 & s && typeof o != "string")
          for (var l in o)
            r.d(a, l, (function(u) {
              return o[u];
            }).bind(null, l));
        return a;
      }, r.n = function(o) {
        var s = o && o.__esModule ? function() {
          return o.default;
        } : function() {
          return o;
        };
        return r.d(s, "a", s), s;
      }, r.o = function(o, s) {
        return Object.prototype.hasOwnProperty.call(o, s);
      }, r.p = "", r(r.s = 44);
    }([function(n, i, r) {
      var o = r(28)("wks"), s = r(14), a = r(1).Symbol, l = typeof a == "function";
      (n.exports = function(u) {
        return o[u] || (o[u] = l && a[u] || (l ? a : s)("Symbol." + u));
      }).store = o;
    }, function(n, i) {
      var r = n.exports = typeof window < "u" && window.Math == Math ? window : typeof self < "u" && self.Math == Math ? self : Function("return this")();
      typeof __g == "number" && (__g = r);
    }, function(n, i, r) {
      var o = r(1), s = r(7), a = r(3), l = r(19), u = r(24), c = function(d, h, f) {
        var p, m, g, O, y = d & c.F, b = d & c.G, v = d & c.S, k = d & c.P, w = d & c.B, S = b ? o : v ? o[h] || (o[h] = {}) : (o[h] || {}).prototype, $ = b ? s : s[h] || (s[h] = {}), C = $.prototype || ($.prototype = {});
        for (p in b && (f = h), f)
          g = ((m = !y && S && S[p] !== void 0) ? S : f)[p], O = w && m ? u(g, o) : k && typeof g == "function" ? u(Function.call, g) : g, S && l(S, p, g, d & c.U), $[p] != g && a($, p, O), k && C[p] != g && (C[p] = g);
      };
      o.core = s, c.F = 1, c.G = 2, c.S = 4, c.P = 8, c.B = 16, c.W = 32, c.U = 64, c.R = 128, n.exports = c;
    }, function(n, i, r) {
      var o = r(4), s = r(13);
      n.exports = r(8) ? function(a, l, u) {
        return o.f(a, l, s(1, u));
      } : function(a, l, u) {
        return a[l] = u, a;
      };
    }, function(n, i, r) {
      var o = r(12), s = r(34), a = r(23), l = Object.defineProperty;
      i.f = r(8) ? Object.defineProperty : function(u, c, d) {
        if (o(u), c = a(c, !0), o(d), s)
          try {
            return l(u, c, d);
          } catch {
          }
        if ("get" in d || "set" in d)
          throw TypeError("Accessors not supported!");
        return "value" in d && (u[c] = d.value), u;
      };
    }, function(n, i) {
      n.exports = function(r) {
        return typeof r == "object" ? r !== null : typeof r == "function";
      };
    }, function(n, i) {
      var r = {}.hasOwnProperty;
      n.exports = function(o, s) {
        return r.call(o, s);
      };
    }, function(n, i) {
      var r = n.exports = { version: "2.5.7" };
      typeof __e == "number" && (__e = r);
    }, function(n, i, r) {
      n.exports = !r(9)(function() {
        return Object.defineProperty({}, "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    }, function(n, i) {
      n.exports = function(r) {
        try {
          return !!r();
        } catch {
          return !0;
        }
      };
    }, function(n, i, r) {
      var o = r(37), s = r(29);
      n.exports = Object.keys || function(a) {
        return o(a, s);
      };
    }, function(n, i, r) {
      var o = r(25), s = r(17);
      n.exports = function(a) {
        return o(s(a));
      };
    }, function(n, i, r) {
      var o = r(5);
      n.exports = function(s) {
        if (!o(s))
          throw TypeError(s + " is not an object!");
        return s;
      };
    }, function(n, i) {
      n.exports = function(r, o) {
        return { enumerable: !(1 & r), configurable: !(2 & r), writable: !(4 & r), value: o };
      };
    }, function(n, i) {
      var r = 0, o = Math.random();
      n.exports = function(s) {
        return "Symbol(".concat(s === void 0 ? "" : s, ")_", (++r + o).toString(36));
      };
    }, function(n, i) {
      n.exports = {};
    }, function(n, i, r) {
      var o = r(17);
      n.exports = function(s) {
        return Object(o(s));
      };
    }, function(n, i) {
      n.exports = function(r) {
        if (r == null)
          throw TypeError("Can't call method on  " + r);
        return r;
      };
    }, function(n, i) {
      n.exports = !1;
    }, function(n, i, r) {
      var o = r(1), s = r(3), a = r(6), l = r(14)("src"), u = Function.toString, c = ("" + u).split("toString");
      r(7).inspectSource = function(d) {
        return u.call(d);
      }, (n.exports = function(d, h, f, p) {
        var m = typeof f == "function";
        m && (a(f, "name") || s(f, "name", h)), d[h] !== f && (m && (a(f, l) || s(f, l, d[h] ? "" + d[h] : c.join(String(h)))), d === o ? d[h] = f : p ? d[h] ? d[h] = f : s(d, h, f) : (delete d[h], s(d, h, f)));
      })(Function.prototype, "toString", function() {
        return typeof this == "function" && this[l] || u.call(this);
      });
    }, function(n, i) {
      var r = {}.toString;
      n.exports = function(o) {
        return r.call(o).slice(8, -1);
      };
    }, function(n, i) {
      i.f = {}.propertyIsEnumerable;
    }, function(n, i) {
      var r = Math.ceil, o = Math.floor;
      n.exports = function(s) {
        return isNaN(s = +s) ? 0 : (s > 0 ? o : r)(s);
      };
    }, function(n, i, r) {
      var o = r(5);
      n.exports = function(s, a) {
        if (!o(s))
          return s;
        var l, u;
        if (a && typeof (l = s.toString) == "function" && !o(u = l.call(s)) || typeof (l = s.valueOf) == "function" && !o(u = l.call(s)) || !a && typeof (l = s.toString) == "function" && !o(u = l.call(s)))
          return u;
        throw TypeError("Can't convert object to primitive value");
      };
    }, function(n, i, r) {
      var o = r(47);
      n.exports = function(s, a, l) {
        if (o(s), a === void 0)
          return s;
        switch (l) {
          case 1:
            return function(u) {
              return s.call(a, u);
            };
          case 2:
            return function(u, c) {
              return s.call(a, u, c);
            };
          case 3:
            return function(u, c, d) {
              return s.call(a, u, c, d);
            };
        }
        return function() {
          return s.apply(a, arguments);
        };
      };
    }, function(n, i, r) {
      var o = r(20);
      n.exports = Object("z").propertyIsEnumerable(0) ? Object : function(s) {
        return o(s) == "String" ? s.split("") : Object(s);
      };
    }, function(n, i, r) {
      var o = r(22), s = Math.min;
      n.exports = function(a) {
        return a > 0 ? s(o(a), 9007199254740991) : 0;
      };
    }, function(n, i, r) {
      var o = r(28)("keys"), s = r(14);
      n.exports = function(a) {
        return o[a] || (o[a] = s(a));
      };
    }, function(n, i, r) {
      var o = r(7), s = r(1), a = s["__core-js_shared__"] || (s["__core-js_shared__"] = {});
      (n.exports = function(l, u) {
        return a[l] || (a[l] = u !== void 0 ? u : {});
      })("versions", []).push({ version: o.version, mode: r(18) ? "pure" : "global", copyright: "© 2018 Denis Pushkarev (zloirock.ru)" });
    }, function(n, i) {
      n.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    }, function(n, i, r) {
      var o = r(4).f, s = r(6), a = r(0)("toStringTag");
      n.exports = function(l, u, c) {
        l && !s(l = c ? l : l.prototype, a) && o(l, a, { configurable: !0, value: u });
      };
    }, function(n, i, r) {
      var o = r(0)("unscopables"), s = Array.prototype;
      s[o] == null && r(3)(s, o, {}), n.exports = function(a) {
        s[o][a] = !0;
      };
    }, function(n, i) {
      i.f = Object.getOwnPropertySymbols;
    }, function(n, i, r) {
      var o = r(18), s = r(2), a = r(19), l = r(3), u = r(15), c = r(48), d = r(30), h = r(52), f = r(0)("iterator"), p = !([].keys && "next" in [].keys()), m = function() {
        return this;
      };
      n.exports = function(g, O, y, b, v, k, w) {
        c(y, O, b);
        var S, $, C, L = function(q) {
          if (!p && q in T)
            return T[q];
          switch (q) {
            case "keys":
            case "values":
              return function() {
                return new y(this, q);
              };
          }
          return function() {
            return new y(this, q);
          };
        }, j = O + " Iterator", P = v == "values", A = !1, T = g.prototype, N = T[f] || T["@@iterator"] || v && T[v], Q = N || L(v), Y = v ? P ? L("entries") : Q : void 0, V = O == "Array" && T.entries || N;
        if (V && (C = h(V.call(new g()))) !== Object.prototype && C.next && (d(C, j, !0), o || typeof C[f] == "function" || l(C, f, m)), P && N && N.name !== "values" && (A = !0, Q = function() {
          return N.call(this);
        }), o && !w || !p && !A && T[f] || l(T, f, Q), u[O] = Q, u[j] = m, v)
          if (S = { values: P ? Q : L("values"), keys: k ? Q : L("keys"), entries: Y }, w)
            for ($ in S)
              $ in T || a(T, $, S[$]);
          else
            s(s.P + s.F * (p || A), O, S);
        return S;
      };
    }, function(n, i, r) {
      n.exports = !r(8) && !r(9)(function() {
        return Object.defineProperty(r(35)("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    }, function(n, i, r) {
      var o = r(5), s = r(1).document, a = o(s) && o(s.createElement);
      n.exports = function(l) {
        return a ? s.createElement(l) : {};
      };
    }, function(n, i, r) {
      var o = r(12), s = r(49), a = r(29), l = r(27)("IE_PROTO"), u = function() {
      }, c = function() {
        var d, h = r(35)("iframe"), f = a.length;
        for (h.style.display = "none", r(51).appendChild(h), h.src = "javascript:", (d = h.contentWindow.document).open(), d.write("<script>document.F=Object<\/script>"), d.close(), c = d.F; f--; )
          delete c.prototype[a[f]];
        return c();
      };
      n.exports = Object.create || function(d, h) {
        var f;
        return d !== null ? (u.prototype = o(d), f = new u(), u.prototype = null, f[l] = d) : f = c(), h === void 0 ? f : s(f, h);
      };
    }, function(n, i, r) {
      var o = r(6), s = r(11), a = r(38)(!1), l = r(27)("IE_PROTO");
      n.exports = function(u, c) {
        var d, h = s(u), f = 0, p = [];
        for (d in h)
          d != l && o(h, d) && p.push(d);
        for (; c.length > f; )
          o(h, d = c[f++]) && (~a(p, d) || p.push(d));
        return p;
      };
    }, function(n, i, r) {
      var o = r(11), s = r(26), a = r(50);
      n.exports = function(l) {
        return function(u, c, d) {
          var h, f = o(u), p = s(f.length), m = a(d, p);
          if (l && c != c) {
            for (; p > m; )
              if ((h = f[m++]) != h)
                return !0;
          } else
            for (; p > m; m++)
              if ((l || m in f) && f[m] === c)
                return l || m || 0;
          return !l && -1;
        };
      };
    }, function(n, i, r) {
      var o = r(31), s = r(65), a = r(15), l = r(11);
      n.exports = r(33)(Array, "Array", function(u, c) {
        this._t = l(u), this._i = 0, this._k = c;
      }, function() {
        var u = this._t, c = this._k, d = this._i++;
        return !u || d >= u.length ? (this._t = void 0, s(1)) : s(0, c == "keys" ? d : c == "values" ? u[d] : [d, u[d]]);
      }, "values"), a.Arguments = a.Array, o("keys"), o("values"), o("entries");
    }, function(n, i, r) {
      var o = r(20);
      n.exports = Array.isArray || function(s) {
        return o(s) == "Array";
      };
    }, function(n, i, r) {
      var o = r(1), s = r(7), a = r(18), l = r(42), u = r(4).f;
      n.exports = function(c) {
        var d = s.Symbol || (s.Symbol = a ? {} : o.Symbol || {});
        c.charAt(0) == "_" || c in d || u(d, c, { value: l.f(c) });
      };
    }, function(n, i, r) {
      i.f = r(0);
    }, function(n, i, r) {
      var o = r(37), s = r(29).concat("length", "prototype");
      i.f = Object.getOwnPropertyNames || function(a) {
        return o(a, s);
      };
    }, function(n, i, r) {
      r.r(i), r(45), r(53), r(60), r(61), r(39), r(66), r(68), r(70), r(74), r(75), r(80);
      function o(f, p) {
        for (var m = 0; m < p.length; m++) {
          var g = p[m];
          g.enumerable = g.enumerable || !1, g.configurable = !0, "value" in g && (g.writable = !0), Object.defineProperty(f, g.key, g);
        }
      }
      var s = { methods: { $smoothReflow: function(f) {
        var p = (function() {
          var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this._smoothElements.push(new d(m));
        }).bind(this);
        Array.isArray(f) ? f.forEach(p) : p(f);
      }, $unsmoothReflow: function(f) {
        var p = (function() {
          var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : c(), g = this.$el, O = this._smoothElements.findIndex(function(y) {
            return l(g, y.options.el) === l(g, m.el);
          });
          if (O === -1)
            return void console.error("VSR_ERROR: $unsmoothReflow failed due to invalid el option");
          this._smoothElements[O].scheduleRemoval();
        }).bind(this);
        Array.isArray(f) ? f.forEach(p) : p(f);
      } }, beforeMount: function() {
        var f = this;
        this._smoothElements = [], this._endListener = function(p) {
          var m = !0, g = !1, O = void 0;
          try {
            for (var y, b = f._smoothElements[Symbol.iterator](); !(m = (y = b.next()).done); m = !0)
              y.value.endListener(p);
          } catch (v) {
            g = !0, O = v;
          } finally {
            try {
              m || b.return == null || b.return();
            } finally {
              if (g)
                throw O;
            }
          }
        };
      }, mounted: function() {
        this.$el.addEventListener("transitionend", this._endListener, { passive: !0 });
      }, destroyed: function() {
        this.$el.removeEventListener("transitionend", this._endListener, { passive: !0 });
      }, beforeUpdate: function() {
        this.$el.addEventListener("transitionend", this._endListener, { passive: !0 }), a(this);
        var f = !0, p = !1, m = void 0;
        try {
          for (var g, O = this._smoothElements[Symbol.iterator](); !(f = (g = O.next()).done); f = !0) {
            var y = g.value, b = l(this.$el, y.options.el);
            y.setSmoothElement(b), y.setBeforeValues();
          }
        } catch (v) {
          p = !0, m = v;
        } finally {
          try {
            f || O.return == null || O.return();
          } finally {
            if (p)
              throw m;
          }
        }
      }, updated: function() {
        var f = this;
        this.$nextTick(function() {
          var p = !0, m = !1, g = void 0;
          try {
            for (var O, y = f._smoothElements[Symbol.iterator](); !(p = (O = y.next()).done); p = !0) {
              var b = O.value, v = l(f.$el, b.options.el);
              b.setSmoothElement(v), b.doSmoothReflow();
            }
          } catch (k) {
            m = !0, g = k;
          } finally {
            try {
              p || y.return == null || y.return();
            } finally {
              if (m)
                throw g;
            }
          }
          a(f);
        });
      } };
      function a(f) {
        for (var p = f._smoothElements.length; p--; ) {
          var m = f._smoothElements[p];
          m.isRemoved && (m.stopTransition(), f._smoothElements.splice(p, 1));
        }
      }
      function l(f, p) {
        return !f || f instanceof Node && f.nodeType === Node.COMMENT_NODE ? null : p === null ? f : function(m, g) {
          return typeof g == "string" ? m.matches(g) ? m : m.querySelector(g) : g;
        }(f, p);
      }
      var u = { INACTIVE: "INACTIVE", ACTIVE: "ACTIVE" }, c = function() {
        return { el: null, property: "height", transitionEvent: null, hideOverflow: !0, debug: !1 };
      }, d = function() {
        function f(p) {
          (function(y, b) {
            if (!(y instanceof b))
              throw new TypeError("Cannot call a class as a function");
          })(this, f);
          var m = c();
          Object.assign(m, p);
          var g = this.parsePropertyOption(m.property);
          m.transition || (m.transition = g.map(function(y) {
            return "".concat(y, " .5s");
          }).join(","));
          var O = { $smoothEl: null, properties: g, beforeRect: {}, state: u.INACTIVE, isRemoved: !1 };
          Object.assign(this, { options: m }, O), this.endListener = this.endListener.bind(this), this.debug = this.debug.bind(this);
        }
        return function(p, m, g) {
          m && o(p.prototype, m), g && o(p, g);
        }(f, [{ key: "setSmoothElement", value: function(p) {
          this.$smoothEl = p;
        } }, { key: "transitionTo", value: function(p) {
          this.state = p;
        } }, { key: "parsePropertyOption", value: function(p) {
          return typeof p == "string" ? [p] : Array.isArray(p) ? p : [];
        } }, { key: "setBeforeValues", value: function() {
          var p = this.$smoothEl;
          if (this.beforeRect = {}, p) {
            var m = window.getComputedStyle(p) || {}, g = m.transition, O = m.overflowX, y = m.overflowY;
            this.computedTransition = g, this.overflowX = O, this.overflowY = y, this.beforeRect = h(p), this.state === u.ACTIVE && (this.stopTransition(), this.debug("Transition was interrupted."));
          }
        } }, { key: "didValuesChange", value: function(p, m) {
          var g = p, O = m;
          if (Object.keys(p).length === 0)
            return !1;
          var y = !0, b = !1, v = void 0;
          try {
            for (var k, w = this.properties[Symbol.iterator](); !(y = (k = w.next()).done); y = !0) {
              var S = k.value;
              if (S === "transform" && (g.top !== O.top || g.left !== O.left) || g[S] !== O[S])
                return !0;
            }
          } catch ($) {
            b = !0, v = $;
          } finally {
            try {
              y || w.return == null || w.return();
            } finally {
              if (b)
                throw v;
            }
          }
          return !1;
        } }, { key: "doSmoothReflow", value: function() {
          var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "data update", m = this.$smoothEl;
          if (!m)
            return this.debug("Could not find registered el to perform doSmoothReflow."), void this.transitionTo(u.INACTIVE);
          if (this.state !== u.ACTIVE) {
            var g = this.beforeRect, O = this.properties, y = this.options, b = this.overflowX, v = this.overflowY, k = this.debug;
            this.transitionTo(u.ACTIVE), k("doSmoothReflow triggered by:", typeof p == "string" ? p : p.target);
            var w = h(m);
            if (!this.didValuesChange(g, w))
              return k("Property values did not change."), void this.transitionTo(u.INACTIVE);
            k("beforeRect", g), k("afterRect", w), this.saveOverflowValues(m, b, v);
            var S = !0, $ = !1, C = void 0;
            try {
              for (var L, j = O[Symbol.iterator](); !(S = (L = j.next()).done); S = !0) {
                var P = L.value;
                if (P === "transform") {
                  var A = g.left - w.left, T = g.top - w.top;
                  m.style.transform = "translate(".concat(A, "px, ").concat(T, "px)");
                } else
                  m.style[P] = g[P] + "px";
              }
            } catch (pe) {
              $ = !0, C = pe;
            } finally {
              try {
                S || j.return == null || j.return();
              } finally {
                if ($)
                  throw C;
              }
            }
            m.offsetHeight, m.style.transition = [this.computedTransition, y.transition].filter(function(pe) {
              return pe;
            }).join(",");
            var N = !0, Q = !1, Y = void 0;
            try {
              for (var V, q = O[Symbol.iterator](); !(N = (V = q.next()).done); N = !0) {
                var B = V.value;
                B === "transform" ? m.style.transform = "" : m.style[B] = w[B] + "px";
              }
            } catch (pe) {
              Q = !0, Y = pe;
            } finally {
              try {
                N || q.return == null || q.return();
              } finally {
                if (Q)
                  throw Y;
              }
            }
          }
        } }, { key: "endListener", value: function(p) {
          var m = this.$smoothEl, g = this.properties;
          m === p.target ? g.includes(p.propertyName) && (this.stopTransition(), this.hasRegisteredEventEmitter() && this.setBeforeValues()) : this.isRegisteredEventEmitter(m, p) && this.doSmoothReflow(p);
        } }, { key: "hasRegisteredEventEmitter", value: function() {
          var p = this.options.transitionEvent;
          return p !== null && Object.keys(p).length > 0;
        } }, { key: "isRegisteredEventEmitter", value: function(p, m) {
          if (!this.hasRegisteredEventEmitter())
            return !1;
          var g = m.target, O = this.options.transitionEvent, y = O.selector, b = O.propertyName;
          if (b != null && b !== m.propertyName || y != null && !g.matches(y))
            return !1;
          if (this.properties.indexOf("transform") === -1) {
            var v = !1, k = m.composedPath ? m.composedPath() : [], w = !0, S = !1, $ = void 0;
            try {
              for (var C, L = k[Symbol.iterator](); !(w = (C = L.next()).done); w = !0)
                if (p === C.value) {
                  v = !0;
                  break;
                }
            } catch (j) {
              S = !0, $ = j;
            } finally {
              try {
                w || L.return == null || L.return();
              } finally {
                if (S)
                  throw $;
              }
            }
            if (!v)
              return !1;
          }
          return !0;
        } }, { key: "saveOverflowValues", value: function(p, m, g) {
          this.options.hideOverflow && (this.overflowX = m, this.overflowY = g, p.style.overflowX = "hidden", p.style.overflowY = "hidden");
        } }, { key: "restoreOverflowValues", value: function(p) {
          var m = this.options, g = this.overflowX, O = this.overflowY;
          m.hideOverflow && (p.style.overflowX = g, p.style.overflowY = O);
        } }, { key: "stopTransition", value: function() {
          var p = this.$smoothEl, m = this.properties, g = !0, O = !1, y = void 0;
          try {
            for (var b, v = m[Symbol.iterator](); !(g = (b = v.next()).done); g = !0) {
              var k = b.value;
              p.style[k] = null;
            }
          } catch (w) {
            O = !0, y = w;
          } finally {
            try {
              g || v.return == null || v.return();
            } finally {
              if (O)
                throw y;
            }
          }
          this.restoreOverflowValues(p), p.style.transition = null, this.transitionTo(u.INACTIVE);
        } }, { key: "scheduleRemoval", value: function() {
          this.isRemoved = !0;
        } }, { key: "debug", value: function() {
          if (this.options.debug) {
            var p = ["VSR_DEBUG:"].concat(Array.from(arguments));
            console.log.apply(null, p);
          }
        } }]), f;
      }(), h = function(f) {
        f.style.overflow = "hidden";
        var p = f.getBoundingClientRect(), m = p.top, g = p.right, O = p.bottom, y = p.left, b = p.width, v = p.height, k = p.x, w = p.y;
        return f.style.overflow = null, { top: m, right: g, bottom: O, left: y, width: b, height: v, x: k, y: w };
      };
      typeof Element < "u" && Element.prototype && !Element.prototype.matches && (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(f) {
        for (var p = (this.document || this.ownerDocument).querySelectorAll(f), m = p.length; --m >= 0 && p.item(m) !== this; )
          ;
        return m > -1;
      }), i.default = s;
    }, function(n, i, r) {
      var o = r(46)(!0);
      r(33)(String, "String", function(s) {
        this._t = String(s), this._i = 0;
      }, function() {
        var s, a = this._t, l = this._i;
        return l >= a.length ? { value: void 0, done: !0 } : (s = o(a, l), this._i += s.length, { value: s, done: !1 });
      });
    }, function(n, i, r) {
      var o = r(22), s = r(17);
      n.exports = function(a) {
        return function(l, u) {
          var c, d, h = String(s(l)), f = o(u), p = h.length;
          return f < 0 || f >= p ? a ? "" : void 0 : (c = h.charCodeAt(f)) < 55296 || c > 56319 || f + 1 === p || (d = h.charCodeAt(f + 1)) < 56320 || d > 57343 ? a ? h.charAt(f) : c : a ? h.slice(f, f + 2) : d - 56320 + (c - 55296 << 10) + 65536;
        };
      };
    }, function(n, i) {
      n.exports = function(r) {
        if (typeof r != "function")
          throw TypeError(r + " is not a function!");
        return r;
      };
    }, function(n, i, r) {
      var o = r(36), s = r(13), a = r(30), l = {};
      r(3)(l, r(0)("iterator"), function() {
        return this;
      }), n.exports = function(u, c, d) {
        u.prototype = o(l, { next: s(1, d) }), a(u, c + " Iterator");
      };
    }, function(n, i, r) {
      var o = r(4), s = r(12), a = r(10);
      n.exports = r(8) ? Object.defineProperties : function(l, u) {
        s(l);
        for (var c, d = a(u), h = d.length, f = 0; h > f; )
          o.f(l, c = d[f++], u[c]);
        return l;
      };
    }, function(n, i, r) {
      var o = r(22), s = Math.max, a = Math.min;
      n.exports = function(l, u) {
        return (l = o(l)) < 0 ? s(l + u, 0) : a(l, u);
      };
    }, function(n, i, r) {
      var o = r(1).document;
      n.exports = o && o.documentElement;
    }, function(n, i, r) {
      var o = r(6), s = r(16), a = r(27)("IE_PROTO"), l = Object.prototype;
      n.exports = Object.getPrototypeOf || function(u) {
        return u = s(u), o(u, a) ? u[a] : typeof u.constructor == "function" && u instanceof u.constructor ? u.constructor.prototype : u instanceof Object ? l : null;
      };
    }, function(n, i, r) {
      var o = r(24), s = r(2), a = r(16), l = r(54), u = r(55), c = r(26), d = r(56), h = r(57);
      s(s.S + s.F * !r(59)(function(f) {
        Array.from(f);
      }), "Array", { from: function(f) {
        var p, m, g, O, y = a(f), b = typeof this == "function" ? this : Array, v = arguments.length, k = v > 1 ? arguments[1] : void 0, w = k !== void 0, S = 0, $ = h(y);
        if (w && (k = o(k, v > 2 ? arguments[2] : void 0, 2)), $ == null || b == Array && u($))
          for (m = new b(p = c(y.length)); p > S; S++)
            d(m, S, w ? k(y[S], S) : y[S]);
        else
          for (O = $.call(y), m = new b(); !(g = O.next()).done; S++)
            d(m, S, w ? l(O, k, [g.value, S], !0) : g.value);
        return m.length = S, m;
      } });
    }, function(n, i, r) {
      var o = r(12);
      n.exports = function(s, a, l, u) {
        try {
          return u ? a(o(l)[0], l[1]) : a(l);
        } catch (d) {
          var c = s.return;
          throw c !== void 0 && o(c.call(s)), d;
        }
      };
    }, function(n, i, r) {
      var o = r(15), s = r(0)("iterator"), a = Array.prototype;
      n.exports = function(l) {
        return l !== void 0 && (o.Array === l || a[s] === l);
      };
    }, function(n, i, r) {
      var o = r(4), s = r(13);
      n.exports = function(a, l, u) {
        l in a ? o.f(a, l, s(0, u)) : a[l] = u;
      };
    }, function(n, i, r) {
      var o = r(58), s = r(0)("iterator"), a = r(15);
      n.exports = r(7).getIteratorMethod = function(l) {
        if (l != null)
          return l[s] || l["@@iterator"] || a[o(l)];
      };
    }, function(n, i, r) {
      var o = r(20), s = r(0)("toStringTag"), a = o(function() {
        return arguments;
      }()) == "Arguments";
      n.exports = function(l) {
        var u, c, d;
        return l === void 0 ? "Undefined" : l === null ? "Null" : typeof (c = function(h, f) {
          try {
            return h[f];
          } catch {
          }
        }(u = Object(l), s)) == "string" ? c : a ? o(u) : (d = o(u)) == "Object" && typeof u.callee == "function" ? "Arguments" : d;
      };
    }, function(n, i, r) {
      var o = r(0)("iterator"), s = !1;
      try {
        var a = [7][o]();
        a.return = function() {
          s = !0;
        }, Array.from(a, function() {
          throw 2;
        });
      } catch {
      }
      n.exports = function(l, u) {
        if (!u && !s)
          return !1;
        var c = !1;
        try {
          var d = [7], h = d[o]();
          h.next = function() {
            return { done: c = !0 };
          }, d[o] = function() {
            return h;
          }, l(d);
        } catch {
        }
        return c;
      };
    }, function(n, i, r) {
      var o = r(2), s = r(38)(!0);
      o(o.P, "Array", { includes: function(a) {
        return s(this, a, arguments.length > 1 ? arguments[1] : void 0);
      } }), r(31)("includes");
    }, function(n, i, r) {
      var o = r(2), s = r(62);
      o(o.P + o.F * r(64)("includes"), "String", { includes: function(a) {
        return !!~s(this, a, "includes").indexOf(a, arguments.length > 1 ? arguments[1] : void 0);
      } });
    }, function(n, i, r) {
      var o = r(63), s = r(17);
      n.exports = function(a, l, u) {
        if (o(l))
          throw TypeError("String#" + u + " doesn't accept regex!");
        return String(s(a));
      };
    }, function(n, i, r) {
      var o = r(5), s = r(20), a = r(0)("match");
      n.exports = function(l) {
        var u;
        return o(l) && ((u = l[a]) !== void 0 ? !!u : s(l) == "RegExp");
      };
    }, function(n, i, r) {
      var o = r(0)("match");
      n.exports = function(s) {
        var a = /./;
        try {
          "/./"[s](a);
        } catch {
          try {
            return a[o] = !1, !"/./"[s](a);
          } catch {
          }
        }
        return !0;
      };
    }, function(n, i) {
      n.exports = function(r, o) {
        return { value: o, done: !!r };
      };
    }, function(n, i, r) {
      var o = r(16), s = r(10);
      r(67)("keys", function() {
        return function(a) {
          return s(o(a));
        };
      });
    }, function(n, i, r) {
      var o = r(2), s = r(7), a = r(9);
      n.exports = function(l, u) {
        var c = (s.Object || {})[l] || Object[l], d = {};
        d[l] = u(c), o(o.S + o.F * a(function() {
          c(1);
        }), "Object", d);
      };
    }, function(n, i, r) {
      var o = r(2);
      o(o.S + o.F, "Object", { assign: r(69) });
    }, function(n, i, r) {
      var o = r(10), s = r(32), a = r(21), l = r(16), u = r(25), c = Object.assign;
      n.exports = !c || r(9)(function() {
        var d = {}, h = {}, f = Symbol(), p = "abcdefghijklmnopqrst";
        return d[f] = 7, p.split("").forEach(function(m) {
          h[m] = m;
        }), c({}, d)[f] != 7 || Object.keys(c({}, h)).join("") != p;
      }) ? function(d, h) {
        for (var f = l(d), p = arguments.length, m = 1, g = s.f, O = a.f; p > m; )
          for (var y, b = u(arguments[m++]), v = g ? o(b).concat(g(b)) : o(b), k = v.length, w = 0; k > w; )
            O.call(b, y = v[w++]) && (f[y] = b[y]);
        return f;
      } : c;
    }, function(n, i, r) {
      var o = r(2), s = r(71)(6), a = "findIndex", l = !0;
      a in [] && Array(1)[a](function() {
        l = !1;
      }), o(o.P + o.F * l, "Array", { findIndex: function(u) {
        return s(this, u, arguments.length > 1 ? arguments[1] : void 0);
      } }), r(31)(a);
    }, function(n, i, r) {
      var o = r(24), s = r(25), a = r(16), l = r(26), u = r(72);
      n.exports = function(c, d) {
        var h = c == 1, f = c == 2, p = c == 3, m = c == 4, g = c == 6, O = c == 5 || g, y = d || u;
        return function(b, v, k) {
          for (var w, S, $ = a(b), C = s($), L = o(v, k, 3), j = l(C.length), P = 0, A = h ? y(b, j) : f ? y(b, 0) : void 0; j > P; P++)
            if ((O || P in C) && (S = L(w = C[P], P, $), c)) {
              if (h)
                A[P] = S;
              else if (S)
                switch (c) {
                  case 3:
                    return !0;
                  case 5:
                    return w;
                  case 6:
                    return P;
                  case 2:
                    A.push(w);
                }
              else if (m)
                return !1;
            }
          return g ? -1 : p || m ? m : A;
        };
      };
    }, function(n, i, r) {
      var o = r(73);
      n.exports = function(s, a) {
        return new (o(s))(a);
      };
    }, function(n, i, r) {
      var o = r(5), s = r(40), a = r(0)("species");
      n.exports = function(l) {
        var u;
        return s(l) && (typeof (u = l.constructor) != "function" || u !== Array && !s(u.prototype) || (u = void 0), o(u) && (u = u[a]) === null && (u = void 0)), u === void 0 ? Array : u;
      };
    }, function(n, i, r) {
      r(41)("asyncIterator");
    }, function(n, i, r) {
      var o = r(1), s = r(6), a = r(8), l = r(2), u = r(19), c = r(76).KEY, d = r(9), h = r(28), f = r(30), p = r(14), m = r(0), g = r(42), O = r(41), y = r(77), b = r(40), v = r(12), k = r(5), w = r(11), S = r(23), $ = r(13), C = r(36), L = r(78), j = r(79), P = r(4), A = r(10), T = j.f, N = P.f, Q = L.f, Y = o.Symbol, V = o.JSON, q = V && V.stringify, B = m("_hidden"), pe = m("toPrimitive"), oe = {}.propertyIsEnumerable, te = h("symbol-registry"), M = h("symbols"), G = h("op-symbols"), ce = Object.prototype, F = typeof Y == "function", xe = o.QObject, Be = !xe || !xe.prototype || !xe.prototype.findChild, lt = a && d(function() {
        return C(N({}, "a", { get: function() {
          return N(this, "a", { value: 7 }).a;
        } })).a != 7;
      }) ? function(K, ke, Ve) {
        var be = T(ce, ke);
        be && delete ce[ke], N(K, ke, Ve), be && K !== ce && N(ce, ke, be);
      } : N, de = function(K) {
        var ke = M[K] = C(Y.prototype);
        return ke._k = K, ke;
      }, ye = F && typeof Y.iterator == "symbol" ? function(K) {
        return typeof K == "symbol";
      } : function(K) {
        return K instanceof Y;
      }, me = function(K, ke, Ve) {
        return K === ce && me(G, ke, Ve), v(K), ke = S(ke, !0), v(Ve), s(M, ke) ? (Ve.enumerable ? (s(K, B) && K[B][ke] && (K[B][ke] = !1), Ve = C(Ve, { enumerable: $(0, !1) })) : (s(K, B) || N(K, B, $(1, {})), K[B][ke] = !0), lt(K, ke, Ve)) : N(K, ke, Ve);
      }, ie = function(K, ke) {
        v(K);
        for (var Ve, be = y(ke = w(ke)), se = 0, Oe = be.length; Oe > se; )
          me(K, Ve = be[se++], ke[Ve]);
        return K;
      }, I = function(K) {
        var ke = oe.call(this, K = S(K, !0));
        return !(this === ce && s(M, K) && !s(G, K)) && (!(ke || !s(this, K) || !s(M, K) || s(this, B) && this[B][K]) || ke);
      }, ge = function(K, ke) {
        if (K = w(K), ke = S(ke, !0), K !== ce || !s(M, ke) || s(G, ke)) {
          var Ve = T(K, ke);
          return !Ve || !s(M, ke) || s(K, B) && K[B][ke] || (Ve.enumerable = !0), Ve;
        }
      }, ze = function(K) {
        for (var ke, Ve = Q(w(K)), be = [], se = 0; Ve.length > se; )
          s(M, ke = Ve[se++]) || ke == B || ke == c || be.push(ke);
        return be;
      }, Se = function(K) {
        for (var ke, Ve = K === ce, be = Q(Ve ? G : w(K)), se = [], Oe = 0; be.length > Oe; )
          !s(M, ke = be[Oe++]) || Ve && !s(ce, ke) || se.push(M[ke]);
        return se;
      };
      F || (u((Y = function() {
        if (this instanceof Y)
          throw TypeError("Symbol is not a constructor!");
        var K = p(arguments.length > 0 ? arguments[0] : void 0), ke = function(Ve) {
          this === ce && ke.call(G, Ve), s(this, B) && s(this[B], K) && (this[B][K] = !1), lt(this, K, $(1, Ve));
        };
        return a && Be && lt(ce, K, { configurable: !0, set: ke }), de(K);
      }).prototype, "toString", function() {
        return this._k;
      }), j.f = ge, P.f = me, r(43).f = L.f = ze, r(21).f = I, r(32).f = Se, a && !r(18) && u(ce, "propertyIsEnumerable", I, !0), g.f = function(K) {
        return de(m(K));
      }), l(l.G + l.W + l.F * !F, { Symbol: Y });
      for (var st = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), D = 0; st.length > D; )
        m(st[D++]);
      for (var x = A(m.store), U = 0; x.length > U; )
        O(x[U++]);
      l(l.S + l.F * !F, "Symbol", { for: function(K) {
        return s(te, K += "") ? te[K] : te[K] = Y(K);
      }, keyFor: function(K) {
        if (!ye(K))
          throw TypeError(K + " is not a symbol!");
        for (var ke in te)
          if (te[ke] === K)
            return ke;
      }, useSetter: function() {
        Be = !0;
      }, useSimple: function() {
        Be = !1;
      } }), l(l.S + l.F * !F, "Object", { create: function(K, ke) {
        return ke === void 0 ? C(K) : ie(C(K), ke);
      }, defineProperty: me, defineProperties: ie, getOwnPropertyDescriptor: ge, getOwnPropertyNames: ze, getOwnPropertySymbols: Se }), V && l(l.S + l.F * (!F || d(function() {
        var K = Y();
        return q([K]) != "[null]" || q({ a: K }) != "{}" || q(Object(K)) != "{}";
      })), "JSON", { stringify: function(K) {
        for (var ke, Ve, be = [K], se = 1; arguments.length > se; )
          be.push(arguments[se++]);
        if (Ve = ke = be[1], (k(ke) || K !== void 0) && !ye(K))
          return b(ke) || (ke = function(Oe, at) {
            if (typeof Ve == "function" && (at = Ve.call(this, Oe, at)), !ye(at))
              return at;
          }), be[1] = ke, q.apply(V, be);
      } }), Y.prototype[pe] || r(3)(Y.prototype, pe, Y.prototype.valueOf), f(Y, "Symbol"), f(Math, "Math", !0), f(o.JSON, "JSON", !0);
    }, function(n, i, r) {
      var o = r(14)("meta"), s = r(5), a = r(6), l = r(4).f, u = 0, c = Object.isExtensible || function() {
        return !0;
      }, d = !r(9)(function() {
        return c(Object.preventExtensions({}));
      }), h = function(p) {
        l(p, o, { value: { i: "O" + ++u, w: {} } });
      }, f = n.exports = { KEY: o, NEED: !1, fastKey: function(p, m) {
        if (!s(p))
          return typeof p == "symbol" ? p : (typeof p == "string" ? "S" : "P") + p;
        if (!a(p, o)) {
          if (!c(p))
            return "F";
          if (!m)
            return "E";
          h(p);
        }
        return p[o].i;
      }, getWeak: function(p, m) {
        if (!a(p, o)) {
          if (!c(p))
            return !0;
          if (!m)
            return !1;
          h(p);
        }
        return p[o].w;
      }, onFreeze: function(p) {
        return d && f.NEED && c(p) && !a(p, o) && h(p), p;
      } };
    }, function(n, i, r) {
      var o = r(10), s = r(32), a = r(21);
      n.exports = function(l) {
        var u = o(l), c = s.f;
        if (c)
          for (var d, h = c(l), f = a.f, p = 0; h.length > p; )
            f.call(l, d = h[p++]) && u.push(d);
        return u;
      };
    }, function(n, i, r) {
      var o = r(11), s = r(43).f, a = {}.toString, l = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      n.exports.f = function(u) {
        return l && a.call(u) == "[object Window]" ? function(c) {
          try {
            return s(c);
          } catch {
            return l.slice();
          }
        }(u) : s(o(u));
      };
    }, function(n, i, r) {
      var o = r(21), s = r(13), a = r(11), l = r(23), u = r(6), c = r(34), d = Object.getOwnPropertyDescriptor;
      i.f = r(8) ? d : function(h, f) {
        if (h = a(h), f = l(f, !0), c)
          try {
            return d(h, f);
          } catch {
          }
        if (u(h, f))
          return s(!o.f.call(h, f), h[f]);
      };
    }, function(n, i, r) {
      for (var o = r(39), s = r(10), a = r(19), l = r(1), u = r(3), c = r(15), d = r(0), h = d("iterator"), f = d("toStringTag"), p = c.Array, m = { CSSRuleList: !0, CSSStyleDeclaration: !1, CSSValueList: !1, ClientRectList: !1, DOMRectList: !1, DOMStringList: !1, DOMTokenList: !0, DataTransferItemList: !1, FileList: !1, HTMLAllCollection: !1, HTMLCollection: !1, HTMLFormElement: !1, HTMLSelectElement: !1, MediaList: !0, MimeTypeArray: !1, NamedNodeMap: !1, NodeList: !0, PaintRequestList: !1, Plugin: !1, PluginArray: !1, SVGLengthList: !1, SVGNumberList: !1, SVGPathSegList: !1, SVGPointList: !1, SVGStringList: !1, SVGTransformList: !1, SourceBufferList: !1, StyleSheetList: !0, TextTrackCueList: !1, TextTrackList: !1, TouchList: !1 }, g = s(m), O = 0; O < g.length; O++) {
        var y, b = g[O], v = m[b], k = l[b], w = k && k.prototype;
        if (w && (w[h] || u(w, h, p), w[f] || u(w, f, b), c[b] = p, v))
          for (y in o)
            w[y] || a(w, y, o[y], !0);
      }
    }]).default;
  });
})(GT);
var Lq = GT.exports;
const Vq = /* @__PURE__ */ Iq(Lq), Bq = Te({
  name: "SmoothReflow",
  mixins: [Vq],
  props: {
    tag: {
      type: String,
      required: !1,
      default: "div"
    },
    options: {
      type: Object,
      required: !1,
      default: () => ({
        property: ["height", "width", "transform"],
        transition: "height .2s, width .2s, transform .2s"
      })
    }
  },
  mounted() {
    this.$smoothReflow(this.options);
  }
});
function Zq(t, e, n, i, r, o) {
  return _(), ue(ar(t.tag), null, {
    default: H(() => [
      ne(t.$slots, "default")
    ]),
    _: 3
  });
}
const KT = /* @__PURE__ */ je(Bq, [["render", Zq]]), Fq = Te({
  components: {
    "mt-text": Pi,
    "mt-checkbox": em,
    "mt-switch": rm,
    "mt-icon": mt,
    "mt-popover-item": Zo,
    "mt-button": Sr,
    "mt-smooth-reflow": KT,
    "mt-floating-ui": gb
  },
  props: {
    title: {
      type: String,
      required: !1,
      default: ""
    },
    childViews: {
      type: Array,
      required: !1,
      default: () => []
    },
    disableFloat: {
      type: Boolean,
      required: !1,
      default: !1
    },
    width: {
      type: String,
      required: !1,
      default: "dynamic",
      validator: (t) => ["dynamic", "large", "medium", "small"].includes(t)
    }
  },
  emits: ["update:isOpened"],
  setup(t, { emit: e }) {
    const n = re(null), i = re("base"), r = re("slideIn"), o = re(!1);
    gt(o, (g) => {
      e("update:isOpened", g);
    });
    const s = J(() => t.disableFloat ? "div" : "mt-floating-ui"), a = () => {
      r.value = "slideOut";
      const g = c.value.find(
        (O) => {
          var y;
          return (y = O.childViews) == null ? void 0 : y.some((b) => b.name === i.value);
        }
      );
      g ? i.value = g.name : i.value = "base", n.value && (n.value.scrollTop = 0);
    }, l = (g) => {
      r.value = "slideIn", i.value = g, n.value && (n.value.scrollTop = 0);
    }, u = (g) => g ? g.reduce((O, y) => [...O, y, ...u(y.childViews)], []) : [], c = J(() => [
      {
        name: "base",
        title: t.title
      },
      ...u(t.childViews)
    ]), d = J(() => {
      const g = c.value.find((O) => O.name === i.value);
      return g ? {
        ...g,
        title: g.title ?? t.title
      } : { name: "base", title: t.title };
    }), h = () => {
      o.value = !1;
    }, f = () => {
      o.value = !o.value;
    }, p = J(() => !!d.value.title || d.value.name !== "base"), m = J(() => ({
      "mt-popover--float": !t.disableFloat,
      "is--open": o.value,
      "has--header": p.value,
      [`mt-popover--width-${t.width}`]: !0
    }));
    return {
      goViewBack: a,
      currentView: d,
      activeView: i,
      changeView: l,
      allViews: c,
      viewTransition: r,
      MtPopover: n,
      closeFloatingUi: h,
      toggleFloatingUi: f,
      isOpened: o,
      mainComponentTag: s,
      componentClasses: m,
      showHeader: p
    };
  }
});
const qq = {
  ref: "MtPopover",
  role: "dialog",
  class: "mt-popover__content"
}, Wq = {
  key: 0,
  class: "mt-popover__header"
}, Xq = {
  key: 1,
  class: "mt-popover__header-placeholder-right"
}, zq = { class: "mt-popover__items" };
function jq(t, e, n, i, r, o) {
  const s = Ce("mt-icon"), a = Ce("mt-button"), l = Ce("mt-text");
  return _(), ue(ar(t.mainComponentTag), {
    "is-opened": t.isOpened,
    class: Ae(["mt-popover", t.componentClasses]),
    onClose: t.closeFloatingUi
  }, {
    trigger: H(() => [
      ne(t.$slots, "trigger", {
        isOpened: t.isOpened,
        toggleFloatingUi: t.toggleFloatingUi
      })
    ]),
    default: H(() => [
      X("div", qq, [
        t.showHeader ? (_(), Z("div", Wq, [
          t.currentView.name !== "base" ? (_(), ue(a, {
            key: 0,
            class: "mt-popover__back-button",
            variant: "secondary",
            onClick: t.goViewBack
          }, {
            default: H(() => [
              fe(s, { name: "solid-long-arrow-left" })
            ]),
            _: 1
          }, 8, ["onClick"])) : W("", !0),
          fe(l, {
            as: "h3",
            class: "mt-popover__title",
            size: "s",
            weight: "semibold"
          }, {
            default: H(() => [
              He(Pe(t.currentView.title), 1)
            ]),
            _: 1
          }),
          t.currentView.name !== "base" ? (_(), Z("div", Xq)) : W("", !0)
        ])) : W("", !0),
        X("div", zq, [
          fe(Fn, { name: t.viewTransition }, {
            default: H(() => [
              (_(), Z("div", {
                key: t.currentView.name.toString()
              }, [
                ne(t.$slots, "popover-items__" + t.currentView.name, {
                  changeView: t.changeView,
                  toggleFloatingUi: t.toggleFloatingUi
                })
              ]))
            ]),
            _: 3
          }, 8, ["name"])
        ])
      ], 512)
    ]),
    _: 3
  }, 40, ["is-opened", "class", "onClose"]);
}
const Qs = /* @__PURE__ */ je(Fq, [["render", jq]]), Yq = Te({
  name: "MtContextButtonVue",
  components: {
    "mt-icon": mt,
    "mt-popover": Qs
  },
  props: {
    menuWidth: {
      type: Number,
      required: !1,
      default: 220
    },
    menuHorizontalAlign: {
      type: String,
      required: !1,
      default: "right",
      validator(t) {
        return t.length ? ["right", "left"].includes(t) : !0;
      }
    },
    menuVerticalAlign: {
      type: String,
      required: !1,
      default: "bottom",
      validator(t) {
        return t.length ? ["bottom", "top"].includes(t) : !0;
      }
    },
    icon: {
      type: String,
      required: !1,
      default: "solid-ellipsis-h-s"
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    hasError: {
      type: Boolean,
      required: !1,
      default: !1
    },
    autoClose: {
      type: Boolean,
      required: !1,
      default: !0
    },
    title: {
      type: String,
      required: !1,
      default: ""
    },
    childViews: {
      type: Array,
      required: !1,
      default: () => []
    }
  },
  data() {
    return {};
  },
  computed: {
    contextClass() {
      return {
        "is--disabled": this.disabled,
        "has--error": this.hasError
      };
    }
  },
  methods: {}
});
const Hq = ["onClick", "onKeyup"];
function Uq(t, e, n, i, r, o) {
  const s = Ce("mt-icon"), a = Ce("mt-popover");
  return _(), ue(a, {
    class: "mt-context-button",
    title: t.title,
    "child-views": t.childViews
  }, {
    trigger: H(({ toggleFloatingUi: l }) => [
      ne(t.$slots, "button", {}, () => [
        X("button", {
          role: "button",
          "aria-haspopup": "menu",
          "aria-label": "Context menu",
          class: "mt-context-button__button",
          onClick: l,
          onKeyup: ai(l, ["enter"])
        }, [
          fe(s, {
            name: t.icon,
            small: "",
            decorative: ""
          }, null, 8, ["name"]),
          ne(t.$slots, "button-text")
        ], 40, Hq)
      ])
    ]),
    "popover-items__base": H(({ toggleFloatingUi: l, changeView: u }) => [
      ne(t.$slots, "default", {
        changeView: u,
        toggleFloatingUi: l
      })
    ]),
    _: 3
  }, 8, ["title", "child-views"]);
}
const vb = /* @__PURE__ */ je(Yq, [["render", Uq]]), Gq = ["aria-label"], Kq = {
  key: 0,
  class: "mt-card__header"
}, Jq = { class: "mt-card__avatar" }, eW = ["aria-label"], tW = { class: "mt-card__titles-right-slot" }, nW = {
  key: 0,
  class: "mt-card__context-menu"
}, iW = { class: "mt-card__tabs" }, rW = { class: "mt-card__toolbar" }, oW = { class: "mt-card__content" }, sW = { class: "mt-card__footer" }, aW = /* @__PURE__ */ Te({
  __name: "mt-card",
  props: {
    title: {},
    subtitle: {},
    isLoading: { type: Boolean },
    large: { type: Boolean },
    inheritance: { type: Boolean, default: void 0 }
  },
  emits: ["update:inheritance"],
  setup(t) {
    const e = t, { t: n } = Lt({
      messages: {
        en: {
          disableInheritance: "Disable inheritance",
          enableInheritance: "Enable inheritance"
        },
        de: {
          disableInheritance: "Vererbung deaktivieren",
          enableInheritance: "Vererbung aktivieren"
        }
      }
    }), i = zo(), r = J(
      () => !!e.title || !!i.title || !!e.subtitle || !!i.subtitle || !!i.avatar
    ), o = Sd(), s = J(() => ({
      "mt-card--grid": !!i.grid,
      "mt-card--large": e.large,
      "mt-card--has-footer": !!i.footer,
      "mt-card--is-inherited": !!e.inheritance,
      "mt-card--future-ignore-max-width": o.removeCardWidth,
      "mt-card--future-remove-default-margin": o.removeDefaultMargin
    }));
    return (a, l) => (_(), Z(Qe, null, [
      ne(a.$slots, "before-card", {}, void 0, !0),
      X("article", wt({
        class: ["mt-card", s.value],
        "aria-label": a.title
      }, a.$attrs), [
        r.value ? (_(), Z("header", Kq, [
          X("div", Jq, [
            ne(a.$slots, "avatar", {}, void 0, !0)
          ]),
          X("div", {
            class: Ae([
              "mt-card__titles",
              {
                "mt-card__titles--has-inheritance-toggle": e.inheritance !== void 0
              }
            ])
          }, [
            ne(a.$slots, "title", {}, () => [
              a.title ? (_(), ue(Pi, {
                key: 0,
                as: "h3",
                weight: "semibold",
                size: "m",
                class: "mt-card__title"
              }, {
                default: H(() => [
                  He(Pe(a.title), 1)
                ]),
                _: 1
              })) : W("", !0)
            ], !0),
            ne(a.$slots, "subtitle", {}, () => [
              a.subtitle ? (_(), ue(Pi, {
                key: 0,
                color: "color-text-tertiary-default",
                size: "xs",
                class: "mt-card__subtitle"
              }, {
                default: H(() => [
                  He(Pe(a.subtitle), 1)
                ]),
                _: 1
              })) : W("", !0)
            ], !0),
            a.inheritance !== void 0 ? (_(), Z("button", {
              key: 0,
              class: "mt-card__inheritance-toggle",
              "aria-label": a.inheritance ? E(n)("disableInheritance") : E(n)("enableInheritance"),
              style: { "grid-area": "inheritance" },
              onClick: l[0] || (l[0] = (u) => a.$emit("update:inheritance", !a.inheritance))
            }, [
              fe(mt, {
                name: a.inheritance ? "regular-link-horizontal" : "regular-link-horizontal-slash",
                size: "1.25rem"
              }, null, 8, ["name"])
            ], 8, eW)) : W("", !0)
          ], 2),
          X("div", tW, [
            ne(a.$slots, "headerRight", {}, void 0, !0)
          ]),
          a.$slots["context-actions"] ? (_(), Z("div", nW, [
            fe(vb, null, {
              default: H(() => [
                ne(a.$slots, "context-actions", {}, void 0, !0)
              ]),
              _: 3
            })
          ])) : W("", !0)
        ])) : W("", !0),
        X("div", iW, [
          ne(a.$slots, "tabs", {}, void 0, !0)
        ]),
        X("div", rW, [
          ne(a.$slots, "toolbar", {}, void 0, !0)
        ]),
        X("div", oW, [
          ne(a.$slots, "default", {}, void 0, !0),
          ne(a.$slots, "grid", { title: a.title }, void 0, !0),
          a.isLoading ? (_(), ue(rb, { key: 0 })) : W("", !0)
        ]),
        X("footer", sW, [
          ne(a.$slots, "footer", {}, void 0, !0)
        ])
      ], 16, Gq),
      ne(a.$slots, "after-card", {}, void 0, !0)
    ], 64));
  }
});
const lW = /* @__PURE__ */ je(aW, [["__scopeId", "data-v-36576c2b"]]), uW = { class: "mt-empty-state" }, cW = { class: "mt-empty-state__icon" }, dW = /* @__PURE__ */ Te({
  __name: "mt-empty-state",
  props: {
    headline: {},
    description: {},
    icon: {},
    linkHref: {},
    linkText: {},
    buttonText: {}
  },
  emits: ["button-click"],
  setup(t) {
    return (e, n) => (_(), Z("div", uW, [
      X("div", cW, [
        fe(mt, {
          name: e.icon,
          color: "var(--color-icon-primary-default)",
          "aria-hidden": "true"
        }, null, 8, ["name"])
      ]),
      fe(Pi, {
        as: "h2",
        size: "l",
        weight: "bold",
        class: "mt-empty-state__headline"
      }, {
        default: H(() => [
          He(Pe(e.headline), 1)
        ]),
        _: 1
      }),
      fe(Pi, {
        size: "xs",
        color: "color-text-secondary-default",
        class: "mt-empty-state__description"
      }, {
        default: H(() => [
          He(Pe(e.description), 1)
        ]),
        _: 1
      }),
      e.linkHref && e.linkText ? (_(), ue(lF, {
        key: 0,
        href: e.linkHref,
        class: "mt-empty-state__link",
        type: "external",
        as: "a"
      }, {
        default: H(() => [
          He(Pe(e.linkText), 1)
        ]),
        _: 1
      }, 8, ["href"])) : W("", !0),
      e.buttonText ? (_(), ue(Sr, {
        key: 1,
        class: "mt-empty-state__button",
        variant: "primary",
        onClick: n[0] || (n[0] = (i) => e.$emit("button-click"))
      }, {
        default: H(() => [
          fe(mt, { name: "solid-plus-circle-s" }),
          He(" " + Pe(e.buttonText) + " ", 1),
          fe(mt, {
            name: "solid-long-arrow-right",
            size: "16px"
          })
        ]),
        _: 1
      })) : W("", !0)
    ]));
  }
});
const hW = /* @__PURE__ */ je(dW, [["__scopeId", "data-v-732f6717"]]), fW = Te({
  name: "MtContextMenuItem",
  components: {
    "mt-popover-item": Zo
  },
  props: {
    label: {
      type: String,
      required: !0
    },
    icon: {
      type: String,
      required: !1,
      default: null
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    type: {
      type: String,
      required: !1,
      default: "default"
    },
    role: {
      type: String,
      required: !1,
      default: "menuitem"
    }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    return {
      handleLableClick: () => {
        t.disabled || e("click");
      }
    };
  }
});
function pW(t, e, n, i, r, o) {
  const s = Ce("mt-popover-item");
  return _(), ue(s, {
    class: "mt-context-menu-item",
    label: t.label,
    icon: t.icon,
    disabled: t.disabled,
    "on-label-click": t.handleLableClick,
    type: t.type,
    role: t.role
  }, null, 8, ["label", "icon", "disabled", "on-label-click", "type", "role"]);
}
const JT = /* @__PURE__ */ je(fW, [["render", pW]]);
function dk(t) {
  if (!t)
    return 0;
  const e = window.getComputedStyle(t), n = parseFloat(e.marginLeft) + parseFloat(e.marginRight);
  return Math.ceil(t.offsetWidth + n);
}
const mW = Te({
  name: "PriorityPlusMenu",
  props: {
    /**
     * The list of navigation items to display.
     */
    list: {
      type: Array,
      required: !0,
      default() {
        return [];
      }
    },
    /**
     * The offset factor is used to multiply the width of the last visible item for the more button offset.
     */
    offsetFactor: {
      type: Number,
      default: 1.5
    },
    /**
     * The property used to identify the items in the list.
     */
    identifier: {
      type: String,
      required: !1,
      default: "name"
    }
  },
  data() {
    return {
      /**
       * The accumulated widths of the items in the list.
       * For example take this list for items with a widht of 100px each:
       * [100, 200, 300, 400, 500]
       *
       * This list is used to search the last item index which fits into the container width.
       */
      accumItemWidths: [],
      /**
       * This list contains the identifiers of the items which are hidden.
       * The values respect the prop `identifier`.
       */
      hiddenItemIdentifiers: []
    };
  },
  computed: {
    /**
     * The items which are currently displayed.
     */
    mainItems() {
      return this.list.filter((t) => !this.hiddenItemIdentifiers.includes(t.name));
    },
    /**
     * The items which are currently hidden.
     */
    moreItems() {
      return this.list.filter((t) => this.hiddenItemIdentifiers.includes(t.name));
    },
    hasHiddenItems() {
      return !!this.moreItems.length;
    },
    /**
     * The HTML elements of the visible items.
     */
    visibleElements() {
      const t = {};
      return this.list.forEach((e) => {
        if (this.hiddenItemIdentifiers.includes(e[this.identifier]))
          return;
        const n = this.$el.parentElement.querySelector(
          `[data-priority-plus="${e[this.identifier]}"]`
        );
        n && (t[e[this.identifier]] = n);
      }), t;
    },
    /**
     * The last visible HTML element.
     */
    lastVisibleElement() {
      const t = Object.keys(this.visibleElements), e = t[t.length - 1];
      return this.visibleElements[e];
    }
  },
  async mounted() {
    await this.$nextTick(), this.storeItemWidths(), this.handleResize(), this.handleResize(), window.addEventListener("resize", this.handleResize);
  },
  watch: {
    /**
     * Watch the list for changes and recalculate the item widths.
     * This is necessary if the list changes after the component is mounted.
     */
    list: {
      handler() {
        this.handleResize();
      },
      deep: !0
    }
  },
  beforeUnmount() {
    window.removeEventListener("resize", this.handleResize);
  },
  methods: {
    storeItemWidths() {
      let t = 0;
      this.list.forEach((e, n) => {
        t += dk(this.visibleElements[e[this.identifier]]), this.accumItemWidths[n] = t;
      });
    },
    getContainerWidth() {
      var e, n;
      let t = 0;
      if (this.hasHiddenItems) {
        const i = Object.values(this.visibleElements)[0];
        t = dk(i) * this.offsetFactor;
      }
      return ((n = (e = this.$el) == null ? void 0 : e.nextSibling) == null ? void 0 : n.offsetWidth) - t;
    },
    getLastVisibleItemIndex() {
      let t = 0;
      const e = this.getContainerWidth();
      for (; t < this.accumItemWidths.length; ) {
        if (this.accumItemWidths[t] > e) {
          t--;
          break;
        }
        t++;
      }
      return t;
    },
    async handleResize() {
      await this.$nextTick();
      const t = this.getLastVisibleItemIndex();
      this.hiddenItemIdentifiers = [], this.list.forEach((e, n) => {
        if (!(n > t)) {
          this.hiddenItemIdentifiers = this.hiddenItemIdentifiers.filter((r) => r !== e.name);
          return;
        }
        this.hiddenItemIdentifiers.push(e.name);
      });
    }
  }
});
function gW(t, e, n, i, r, o) {
  return ne(t.$slots, "default", {
    mainItems: t.mainItems,
    moreItems: t.moreItems
  });
}
const OW = /* @__PURE__ */ je(mW, [["render", gW]]), vW = Te({
  name: "MtTabs",
  components: {
    "mt-context-button": vb,
    "mt-context-menu-item": JT,
    "priority-plus": OW,
    "mt-color-badge": Ob,
    "mt-icon": mt
  },
  emits: ["new-item-active"],
  props: {
    items: {
      type: Array,
      required: !0
    },
    vertical: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * @deprecated v4.0.0 - Set max-width through parent container element
     */
    small: {
      type: Boolean,
      required: !1,
      default: !1
    },
    defaultItem: {
      type: String,
      required: !1,
      default: ""
    }
  },
  data() {
    return {
      // refreshKey is for recalculating specific computed properties
      refreshKey: !0,
      activeItemName: "",
      showMoreItems: !1,
      passedFirstRender: !1
    };
  },
  computed: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    activeDomItem() {
      this.refreshKey;
      const t = this.activeItemName;
      return (this.$refs.items ? this.$refs.items : []).find((i) => i.getAttribute("data-item-name") === t);
    },
    sliderPosition() {
      var e;
      if (this.refreshKey, !this.activeItem)
        return 0;
      if (!this.activeDomItem && this.$refs["more-items-button"])
        return (e = this.$refs["more-items-button"].$el) == null ? void 0 : e.offsetLeft;
      const t = parseFloat(
        getComputedStyle(this.activeDomItem).paddingLeft
      );
      return this.vertical ? this.activeDomItem.offsetTop : this.activeDomItem.offsetLeft + t;
    },
    sliderLength() {
      var n, i, r;
      if (this.refreshKey, !this.activeItem)
        return 0;
      if (!this.activeDomItem && this.$refs["more-items-button"])
        return (n = this.$refs["more-items-button"].$el) == null ? void 0 : n.offsetWidth;
      if ((i = this.activeItem) != null && i.hidden && this.$refs["more-items-button"])
        return (r = this.$refs["more-items-button"].$el) == null ? void 0 : r.offsetWidth;
      const t = getComputedStyle(this.activeDomItem), e = this.activeDomItem.clientWidth - parseFloat(t.paddingLeft) - parseFloat(t.paddingRight);
      return this.vertical ? this.activeDomItem.offsetHeight : e;
    },
    activeItem() {
      return this.refreshKey, this.items.find((t) => t.name === this.activeItemName);
    },
    sliderClasses() {
      var t;
      return this.refreshKey, {
        "mt-tabs__slider--error": ((t = this.activeItem) == null ? void 0 : t.hasError) ?? !1,
        "mt-tabs__slider--animated": this.passedFirstRender
      };
    },
    sliderStyle() {
      return this.refreshKey, this.vertical ? `
          transform: translate(0, ${this.sliderPosition}px) rotate(90deg);
          width: ${this.sliderLength}px;
      ` : `
        transform: translate(${this.sliderPosition}px, 0) rotate(0deg);
        width: ${this.sliderLength}px;
    `;
    }
  },
  setup(t) {
    const e = Sd();
    return {
      tabClasses: J(() => [
        "mt-tabs",
        {
          "mt-tabs--vertical": t.vertical,
          "mt-tabs--small": t.small,
          "mt-tabs--future-remove-default-margin": e.removeDefaultMargin
        }
      ])
    };
  },
  watch: {
    items: "handleResize",
    vertical: "handleResize",
    small: "handleResize"
  },
  mounted() {
    this.setActiveItem(this.defaultItem), this.$nextTick(() => {
      this.handleResize(), this.passedFirstRender = !0;
    }), this.$device.onResize({
      listener() {
        this.handleResize();
      },
      component: this,
      scope: this
    });
  },
  beforeUnmount() {
    this.$device.removeResizeListener(this);
  },
  methods: {
    handleClick(t) {
      this.setActiveItem(t), this.$emit("new-item-active", t);
      const e = this.items.find((n) => n.name === t);
      e != null && e.onClick && e.onClick(t);
    },
    getItemClasses(t) {
      return {
        "mt-tabs__item--error": t.hasError,
        "mt-tabs__item--active": t.name === this.activeItemName
      };
    },
    getContextMenuItemVariant(t) {
      return t.hasError ? "critical" : t.name === this.activeItemName ? "active" : t.badge === "critical" ? "critical" : "default";
    },
    setActiveItem(t) {
      this.activeItemName = `${t}`, this.refreshKey = !this.refreshKey;
    },
    handleResize() {
      this.$refs.priorityPlus && (this.refreshKey = !this.refreshKey, this.$refs.priorityPlus.handleResize().then(() => {
        this.refreshKey = !this.refreshKey;
      }));
    },
    toggleMoreTabItems() {
      this.showMoreItems = !this.showMoreItems;
    }
  }
});
const yW = ["data-priority-plus", "data-text", "data-item-name", "aria-selected", "disabled", "onClick", "onKeyup"], bW = ["data-item-name", "onClick"];
function wW(t, e, n, i, r, o) {
  const s = Ce("mt-icon"), a = Ce("mt-color-badge"), l = Ce("mt-context-menu-item"), u = Ce("mt-context-button"), c = Ce("priority-plus");
  return _(), ue(c, {
    ref: "priorityPlus",
    list: t.items
  }, {
    default: H(({ mainItems: d, moreItems: h }) => [
      X("div", {
        class: Ae(t.tabClasses),
        role: "tablist"
      }, [
        X("span", {
          class: Ae(["mt-tabs__slider", t.sliderClasses]),
          style: pt(t.sliderStyle)
        }, null, 6),
        t.vertical ? W("", !0) : (_(), Z(Qe, { key: 0 }, [
          (_(!0), Z(Qe, null, Ge(d, (f) => (_(), Z("button", {
            key: f.name,
            "data-priority-plus": f.name,
            ref_for: !0,
            ref: "items",
            class: Ae(["mt-tabs__item", t.getItemClasses(f)]),
            "data-text": f.label,
            "data-item-name": f.name,
            role: "tab",
            "aria-selected": f.name === t.activeItemName,
            disabled: f.disabled,
            onClick: (p) => t.handleClick(f.name),
            onKeyup: ai((p) => t.handleClick(f.name), ["enter"])
          }, [
            He(Pe(f.label) + " ", 1),
            f.hasError ? (_(), ue(s, {
              key: 0,
              class: "mt-tabs__error-badge",
              name: "solid-exclamation-circle"
            })) : W("", !0),
            f.badge ? (_(), ue(a, {
              key: 1,
              variant: f.badge,
              rounded: ""
            }, null, 8, ["variant"])) : W("", !0)
          ], 42, yW))), 128)),
          h.length ? (_(), ue(u, {
            key: 0,
            ref: "more-items-button",
            "has-error": h.some((f) => f.hasError)
          }, {
            "button-text": H(() => e[0] || (e[0] = [
              He(" More ")
            ])),
            default: H(({ toggleFloatingUi: f }) => [
              (_(!0), Z(Qe, null, Ge(h, (p) => (_(), ue(l, {
                key: p.name,
                type: t.getContextMenuItemVariant(p),
                role: "tab",
                "aria-selected": p.name === t.activeItemName,
                label: p.label,
                onClick: (m) => {
                  t.handleClick(p.name), f();
                },
                onKeyup: ai((m) => t.handleClick(p.name), ["enter"])
              }, null, 8, ["type", "aria-selected", "label", "onClick", "onKeyup"]))), 128))
            ]),
            _: 2
          }, 1032, ["has-error"])) : W("", !0)
        ], 64)),
        t.vertical ? (_(!0), Z(Qe, { key: 1 }, Ge([...d, ...h], (f) => (_(), Z("li", {
          key: f.name,
          ref_for: !0,
          ref: "items",
          class: Ae(["mt-tabs__item", t.getItemClasses(f)]),
          "data-item-name": f.name,
          onClick: (p) => t.handleClick(f.name)
        }, Pe(f.label), 11, bW))), 128)) : W("", !0)
      ], 2)
    ]),
    _: 1
  }, 8, ["list"]);
}
const Bae = /* @__PURE__ */ je(vW, [["render", wW], ["__scopeId", "data-v-b0e69830"]]);
function kW(t) {
  const e = (r) => {
    var a, l, u, c;
    const o = r != null && r.target ? r.target : r;
    if (!o)
      return;
    const s = 5;
    o.scrollHeight > o.clientHeight ? (o.scrollHeight - o.clientHeight - s > o.scrollTop ? o.dataset.scrollBottom = "" : delete o.dataset.scrollBottom, o.scrollTop - s > 0 ? o.dataset.scrollTop = "" : delete o.dataset.scrollTop, (a = o.parentElement) == null || a.style.setProperty(
      "--scrollbar-width",
      `${o.offsetWidth - o.clientWidth}px`
    )) : ((l = o.parentElement) == null || l.style.removeProperty("--scrollbar-width"), delete o.dataset.scrollTop, delete o.dataset.scrollBottom), o.scrollWidth > o.clientWidth ? (o.scrollWidth - o.clientWidth - s > o.scrollLeft ? o.dataset.scrollRight = "" : delete o.dataset.scrollRight, o.scrollLeft - s > 0 ? o.dataset.scrollLeft = "" : delete o.dataset.scrollLeft, (u = o.parentElement) == null || u.style.setProperty(
      "--scrollbar-height",
      `${o.offsetHeight - o.clientHeight}px`
    )) : (delete o.dataset.scrollRight, delete o.dataset.scrollLeft, (c = o.parentElement) == null || c.style.removeProperty("--scrollbar-height"));
  }, n = ab(function() {
    e(t.value);
  }, 15), i = new ResizeObserver(() => {
    nn().then(n);
  });
  return XD(() => {
    nn().then(n);
  }), Et(() => {
    window.addEventListener("resize", n), t.value && (t.value.addEventListener("scroll", n), i.observe(t.value), nn().then(() => {
      n();
    }));
  }), Zs(() => {
    window.removeEventListener("resize", n), t.value && (t.value.removeEventListener("scroll", n), i.unobserve(t.value));
  }), {};
}
const SW = { class: "mt-pagination" }, _W = {
  class: "mt-pagination__info-text",
  "data-testid": "mt-pagination-info-text"
}, xW = { class: "mt-pagination__controls" }, CW = ["disabled"], TW = { class: "visually-hidden" }, $W = ["disabled"], PW = { class: "visually-hidden" }, MW = ["value", "aria-label"], EW = ["disabled"], AW = { class: "visually-hidden" }, RW = ["disabled"], DW = { class: "visually-hidden" }, QW = /* @__PURE__ */ Te({
  __name: "mt-pagination",
  props: {
    currentPage: {},
    limit: {},
    totalItems: {}
  },
  emits: ["change-current-page"],
  setup(t, { emit: e }) {
    const n = t, { t: i } = Lt({
      messages: {
        en: {
          infoText: "{start}-{end} of {totalItems}",
          firstPage: "First page",
          previousPage: "Previous page",
          nextPage: "Next page",
          lastPage: "Last page"
        },
        de: {
          infoText: "{start}-{end} von {totalItems}",
          firstPage: "Erste Seite",
          previousPage: "Voherige Seite",
          nextPage: "Nächste Seite",
          lastPage: "Letzte Seite"
        }
      }
    }), r = e;
    gt(
      () => n.limit,
      () => {
        r("change-current-page", 1);
      }
    );
    const o = J(() => Math.max(1, Math.ceil(n.totalItems / n.limit))), s = J(() => n.currentPage === 1), a = J(() => n.currentPage === o.value), l = J(() => {
      const h = n.currentPage.toString().length;
      return h === 0 ? "calc(1ch + 1px)" : `calc(${h}ch + 1px)`;
    });
    function u(h) {
      const f = h.target;
      f.value !== "" && r("change-current-page", parseInt(f.value));
    }
    const c = J(() => (n.currentPage - 1) * n.limit + 1), d = J(() => {
      const h = n.limit * n.currentPage;
      return h > n.totalItems ? n.totalItems : h;
    });
    return (h, f) => (_(), Z("div", SW, [
      X("p", _W, Pe(E(i)("infoText", {
        start: c.value,
        end: d.value,
        totalItems: h.totalItems
      })), 1),
      X("div", xW, [
        X("button", {
          class: "mt-pagination__button",
          disabled: s.value,
          onClick: f[0] || (f[0] = (p) => h.$emit("change-current-page", 1)),
          "data-testid": "mt-pagination-first-page-button"
        }, [
          X("span", TW, Pe(E(i)("firstPage")), 1),
          fe(mt, {
            name: "regular-double-chevron-left-s",
            size: "0.5rem",
            "aria-hidden": "true"
          })
        ], 8, CW),
        X("button", {
          class: "mt-pagination__button",
          disabled: s.value,
          onClick: f[1] || (f[1] = (p) => h.$emit("change-current-page", h.currentPage - 1)),
          "data-testid": "mt-pagination-previous-page-button"
        }, [
          X("span", PW, Pe(E(i)("previousPage")), 1),
          fe(mt, {
            name: "regular-chevron-left-s",
            size: "0.5rem",
            "aria-hidden": "true"
          })
        ], 8, $W),
        X("input", {
          class: "mt-pagination__current-page-input",
          type: "number",
          min: "1",
          step: "1",
          style: pt({ width: l.value }),
          value: h.currentPage,
          onInput: u,
          "aria-label": `Page ${h.currentPage}`,
          "data-testid": "mt-pagination-current-page-input"
        }, null, 44, MW),
        X("button", {
          class: "mt-pagination__button",
          disabled: a.value,
          onClick: f[2] || (f[2] = (p) => h.$emit("change-current-page", h.currentPage + 1)),
          "data-testid": "mt-pagination-next-page-button"
        }, [
          X("span", AW, Pe(E(i)("nextPage")), 1),
          fe(mt, {
            name: "regular-chevron-right-s",
            size: "0.5rem",
            "aria-hidden": "true"
          })
        ], 8, EW),
        X("button", {
          class: "mt-pagination__button",
          disabled: a.value,
          onClick: f[3] || (f[3] = (p) => h.$emit("change-current-page", o.value)),
          "data-testid": "mt-pagination-last-page-button"
        }, [
          X("span", DW, Pe(E(i)("lastPage")), 1),
          fe(mt, {
            name: "regular-double-chevron-right-s",
            size: "0.5rem",
            "aria-hidden": "true"
          })
        ], 8, RW)
      ])
    ]));
  }
});
const NW = /* @__PURE__ */ je(QW, [["__scopeId", "data-v-3a603592"]]), IW = ["value", "disabled", "placeholder"], LW = /* @__PURE__ */ Te({
  __name: "mt-search",
  props: {
    modelValue: {},
    placeholder: {},
    size: { default: "default" },
    disabled: { type: Boolean }
  },
  emits: ["change", "update:modelValue"],
  setup(t) {
    const { t: e } = Lt({
      messages: {
        en: {
          placeholder: "Search"
        },
        de: {
          placeholder: "Suchen"
        }
      }
    });
    return (n, i) => (_(), Z("div", {
      class: Ae(["mt-search", `mt-search--size-${n.size}`, { "mt-search--disabled": n.disabled }])
    }, [
      X("input", {
        value: n.modelValue,
        onInput: i[0] || (i[0] = (r) => n.$emit("update:modelValue", r.target.value)),
        onChange: i[1] || (i[1] = (r) => n.$emit("change", r.target.value || "")),
        class: "mt-search__input",
        disabled: n.disabled,
        type: "text",
        placeholder: n.placeholder || E(e)("placeholder")
      }, null, 40, IW),
      fe(mt, {
        name: "regular-search-s",
        size: "1rem",
        color: "var(--color-icon-primary-default)"
      })
    ], 2));
  }
});
const e$ = /* @__PURE__ */ je(LW, [["__scopeId", "data-v-8735df65"]]);
let it = null, kt = null, Rt = null, pf = 0, mf = 0, uc = null;
const ju = [], og = {
  delay: 100,
  dragGroup: 1,
  draggableCls: "is--draggable",
  draggingStateCls: "is--dragging",
  dragElementCls: "is--drag-element",
  validDragCls: "is--valid-drag",
  invalidDragCls: "is--invalid-drag",
  preventEvent: !0,
  validateDrop: null,
  validateDrag: null,
  validateDragStart: null,
  onDragStart: null,
  onDragEnter: null,
  onDragLeave: null,
  onDrop: null,
  data: null,
  disabled: !1
}, hk = {
  dragGroup: 1,
  droppableCls: "is--droppable",
  validDropCls: "is--valid-drop",
  invalidDropCls: "is--invalid-drop",
  validateDrop: null,
  onDrop: null,
  data: null
};
function VW(t, e, n) {
  return n instanceof MouseEvent && n.buttons !== 1 ? !1 : (e.preventEvent && (n.preventDefault(), n.stopPropagation()), e.delay === null || e.delay <= 0 ? fk(t, e, n) : uc = window.setTimeout(fk.bind({}, t, e, n), e.delay), document.addEventListener("mouseup", Lc), document.addEventListener("touchend", Lc), !0);
}
function fk(t, e, n) {
  if (e.validateDragStart !== null && !e.validateDragStart(e.data, t, n) || (uc = null, it !== null))
    return;
  it = { el: t, dragConfig: e };
  const i = t.getBoundingClientRect(), r = n instanceof MouseEvent && n.pageX || n instanceof TouchEvent && n.touches[0].pageX, o = n instanceof MouseEvent && n.pageY || n instanceof TouchEvent && n.touches[0].pageY;
  pf = r - i.left, mf = o - i.top, Rt = t.cloneNode(!0), Rt.classList.add(e.dragElementCls), Rt.style.width = `${i.width}px`, Rt.style.translate = `${r - pf}px ${o - mf}px`, Rt.style.left = "0", Rt.style.top = "0", document.body.appendChild(Rt), t.classList.add(e.draggingStateCls), Bo(it.dragConfig.onDragStart) && it.dragConfig.onDragStart(it.dragConfig, t, Rt), document.addEventListener("mousemove", gf), document.addEventListener("touchmove", gf);
}
let pk = 0;
function BW(t, e) {
  return t && Math.abs(e - t) > 2 ? `${e - t > 0 ? 5 : -5}deg` : "";
}
function gf(t) {
  if (it === null) {
    Lc();
    return;
  }
  const e = t instanceof MouseEvent && t.pageX || t instanceof TouchEvent && t.touches[0].pageX, n = t instanceof MouseEvent && t.pageY || t instanceof TouchEvent && t.touches[0].pageY;
  if (Rt) {
    const i = Number(Rt.dataset.translateX), r = e - pf, o = n - mf;
    Rt.style.rotate = BW(i, r), clearTimeout(pk), pk = window.setTimeout(() => {
      Rt && (Rt.style.rotate = "0deg");
    }, 100), Rt.style.translate = `${r}px ${o}px`, Rt.dataset.translateX = r.toString();
  }
  t.type === "touchmove" && ju.forEach((i) => {
    ZW(t, i.el) ? (kt === null || i.el !== kt.el) && IO(i.el, i.dropConfig) : kt !== null && i.el === kt.el && LO(i.el, i.dropConfig);
  });
}
function ZW(t, e) {
  const n = t instanceof MouseEvent && t.pageX || t instanceof TouchEvent && t.touches[0].pageX, i = t instanceof MouseEvent && t.pageY || t instanceof TouchEvent && t.touches[0].pageY, r = e.getBoundingClientRect();
  return n >= r.x && n <= r.x + r.width && i >= r.y && i <= r.y + r.height;
}
function Lc() {
  var n;
  if (uc !== null) {
    window.clearTimeout(uc), uc = null;
    return;
  }
  const t = FW(), e = t$();
  t && it && Bo(it.dragConfig.onDrop) && it.dragConfig.onDrop(
    it.dragConfig.data,
    e ? (n = kt == null ? void 0 : kt.dropConfig) == null ? void 0 : n.data : null
  ), e && kt && Bo(kt.dropConfig.onDrop) && kt.dropConfig.onDrop(it == null ? void 0 : it.dragConfig.data, kt.dropConfig.data), document.removeEventListener("mousemove", gf), document.removeEventListener("touchmove", gf), document.removeEventListener("mouseup", Lc), document.removeEventListener("touchend", Lc), Rt !== null && (Rt.remove(), Rt = null), it !== null && (it.el.classList.remove(it.dragConfig.draggingStateCls), it.el.classList.remove(it.dragConfig.validDragCls), it.el.classList.remove(it.dragConfig.invalidDragCls), it = null), kt !== null && (kt.el.classList.remove(kt.dropConfig.validDropCls), kt.el.classList.remove(kt.dropConfig.invalidDropCls), kt = null), pf = 0, mf = 0;
}
function IO(t, e) {
  if (it === null)
    return;
  kt = { el: t, dropConfig: e };
  const n = t$();
  n ? (t.classList.add(e.validDropCls), t.classList.remove(e.invalidDropCls), Rt && (Rt.classList.add(it.dragConfig.validDragCls), Rt.classList.remove(it.dragConfig.invalidDragCls))) : (t.classList.add(e.invalidDropCls), t.classList.remove(e.validDropCls), Rt && (Rt.classList.add(it.dragConfig.invalidDragCls), Rt.classList.remove(it.dragConfig.validDragCls))), Bo(it.dragConfig.onDragEnter) && it.dragConfig.onDragEnter(
    it.dragConfig.data,
    kt.dropConfig.data,
    n
  );
}
function LO(t, e) {
  it !== null && kt !== null && (Bo(it.dragConfig.onDragLeave) && it.dragConfig.onDragLeave(it.dragConfig.data, kt.dropConfig.data), t.classList.remove(e.validDropCls), t.classList.remove(e.invalidDropCls), Rt && (Rt.classList.remove(it.dragConfig.validDragCls), Rt.classList.remove(it.dragConfig.invalidDragCls)), kt = null);
}
function t$() {
  let t = !0, e = !0, n = !0;
  return (it === null || kt === null || kt.dropConfig.dragGroup !== it.dragConfig.dragGroup) && (t = !1), it !== null && Bo(it.dragConfig.validateDrop) && (e = it.dragConfig.validateDrop(
    it.dragConfig.data,
    kt == null ? void 0 : kt.dropConfig.data
  )), kt !== null && Bo(kt.dropConfig.validateDrop) && (n = kt.dropConfig.validateDrop(
    it == null ? void 0 : it.dragConfig.data,
    kt.dropConfig.data
  )), t && e && n;
}
function FW() {
  let t = !0, e = !0;
  return it === null && (t = !1), it !== null && Bo(it.dragConfig.validateDrag) && (e = it.dragConfig.validateDrag(
    it.dragConfig.data,
    kt == null ? void 0 : kt.dropConfig.data
  )), t && e;
}
function cc(t, e) {
  const n = { ...t };
  return Vo(e.value) ? Object.assign(n, e.value) : Object.assign(n, { data: e.value }), n;
}
const n$ = {
  mounted(t, e) {
    const n = cc(og, e);
    t.dragConfig = n, t.boundDragListener = VW.bind(this, t, t.dragConfig), n.disabled || (t.classList.add(n.draggableCls), t.addEventListener("mousedown", t.boundDragListener), t.addEventListener("touchstart", t.boundDragListener));
  },
  updated(t, e) {
    const n = cc(og, e);
    t.dragConfig && t.dragConfig.disabled !== n.disabled && (n.disabled ? (t.classList.remove(t.dragConfig.draggableCls), t.boundDragListener && (t.removeEventListener("mousedown", t.boundDragListener), t.removeEventListener("touchstart", t.boundDragListener))) : (t.classList.remove(t.dragConfig.draggableCls), t.classList.add(n.draggableCls), t.boundDragListener && (t.addEventListener("mousedown", t.boundDragListener), t.addEventListener("touchstart", t.boundDragListener)))), Object.assign(t.dragConfig, n);
  },
  unmounted(t, e) {
    const n = cc(og, e);
    t.classList.remove(n.draggableCls), t.boundDragListener && (t.removeEventListener("mousedown", t.boundDragListener), t.removeEventListener("touchstart", t.boundDragListener));
  }
}, i$ = {
  mounted(t, e) {
    const n = cc(hk, e);
    ju.push({ el: t, dropConfig: n }), t.classList.add(n.droppableCls), t.addEventListener("mouseenter", IO.bind(this, t, n)), t.addEventListener("mouseleave", LO.bind(this, t, n));
  },
  unmounted(t, e) {
    const n = cc(hk, e);
    ju.splice(
      ju.findIndex((i) => i.el === t),
      1
    ), t.classList.remove(n.droppableCls), t.removeEventListener("mouseenter", IO.bind(this, t, n)), t.removeEventListener("mouseleave", LO.bind(this, t, n));
  },
  updated: (t, e) => {
    const n = ju.find((i) => i.el === t);
    Vo(e.value) ? Object.assign(n == null ? void 0 : n.dropConfig, e.value) : Object.assign(n == null ? void 0 : n.dropConfig, { data: e.value });
  }
}, qW = Te({
  name: "MtPopoverItemResult",
  directives: {
    draggable: n$,
    droppable: i$
  },
  components: {
    "mt-search": e$,
    "mt-popover-item": Zo,
    "mt-smooth-reflow": KT,
    "mt-text": Pi
  },
  props: {
    options: {
      type: Array,
      required: !0
    },
    groups: {
      type: Array,
      required: !1,
      default: () => []
    },
    hideSearch: {
      type: Boolean,
      default: !1
    },
    draggable: {
      type: Boolean,
      default: !1
    },
    selectable: {
      type: Boolean,
      default: !1
    },
    hidable: {
      type: Boolean,
      default: !1
    }
  },
  emits: [
    "change-checkbox",
    "change-visibility",
    "click-group-action",
    "click-option",
    "change-order",
    "search"
  ],
  setup(t, { emit: e }) {
    const n = {}, i = {
      disabled: !t.draggable,
      delay: 200,
      onDragStart: () => {
        document.body.classList.add("is-popover-item-result-dragging");
      },
      onDrop: (l, u) => {
        document.body.classList.remove("is-popover-item-result-dragging"), e("change-order", {
          itemId: l == null ? void 0 : l.id,
          dropZone: u == null ? void 0 : u.dropZone,
          dropId: u == null ? void 0 : u.id
        });
      }
    }, r = (l) => t.draggable && l.isSortable;
    return {
      getOptionsForGroup: (l) => t.options.filter((u) => u.parentGroup === l),
      getDragConfigForOption: (l) => ({
        ...i,
        disabled: !r(l)
      }),
      isOptionDraggable: r,
      getIconForOption: (l) => {
        if (r(l))
          return "solid-grip-vertical-s";
        if (t.draggable)
          return "solid-thumbtack";
      },
      dropConfig: n,
      dragConfig: i
    };
  }
});
const WW = { class: "mt-popover-item-result" }, XW = ["aria-label"], zW = ["onClick"], jW = ["aria-label"], YW = {
  key: 0,
  class: "mt-popover-item-result__option_drop_before"
}, HW = {
  key: 1,
  class: "mt-popover-item-result__option_drop_after"
};
function UW(t, e, n, i, r, o) {
  const s = Ce("mt-search"), a = Ce("mt-text"), l = Ce("mt-popover-item"), u = Ce("mt-smooth-reflow"), c = vr("droppable"), d = vr("draggable");
  return _(), Z("div", WW, [
    t.hideSearch ? W("", !0) : (_(), ue(s, {
      key: 0,
      size: "small",
      "onUpdate:modelValue": e[0] || (e[0] = (h) => t.$emit("search", h))
    })),
    (_(!0), Z(Qe, null, Ge([void 0, ...t.groups], (h) => (_(), Z(Qe, {
      key: "transition-group-" + (h && h.id)
    }, [
      fe(Fn, { name: "option-fade" }, {
        default: H(() => [
          h && t.getOptionsForGroup(h.id).length > 0 ? (_(), Z("div", {
            key: h.id,
            class: "mt-popover-item-result__group-header",
            "aria-label": h.label
          }, [
            fe(a, {
              as: "span",
              size: "xs",
              color: "color-text-secondary-default",
              class: "mt-popover-item-result__group-label"
            }, {
              default: H(() => [
                He(Pe(h.label), 1)
              ]),
              _: 2
            }, 1024),
            h.actionLabel ? (_(), Z("button", {
              key: 0,
              class: "mt-popover-item-result__group-action",
              onClick: () => t.$emit("click-group-action", h.id)
            }, Pe(h.actionLabel), 9, zW)) : W("", !0)
          ], 8, XW)) : W("", !0)
        ]),
        _: 2
      }, 1024),
      fe(u, null, {
        default: H(() => [
          fe(Ux, {
            name: "option-item",
            tag: "div"
          }, {
            default: H(() => [
              (_(!0), Z(Qe, null, Ge(t.getOptionsForGroup(h && h.id), (f) => (_(), Z("div", {
                key: f.id,
                class: "mt-popover-item-result__option",
                "aria-label": (h && h.label ? h.label : "No group") + ": " + f.label
              }, [
                t.isOptionDraggable(f) ? yt((_(), Z("div", YW, null, 512)), [
                  [c, { ...t.dropConfig, data: { ...f, dropZone: "before" } }]
                ]) : W("", !0),
                yt(fe(l, {
                  class: "mt-popover-item-result__option_item",
                  "is-option-item": t.isOptionDraggable(f),
                  label: f.label,
                  "show-checkbox": t.selectable,
                  "checkbox-checked": f.isSelected,
                  "contextual-detail": f.contextualDetail,
                  "meta-copy": f.metaCopy,
                  "show-visibility": t.hidable && f.isHidable,
                  visible: f.isVisible,
                  icon: t.getIconForOption(f),
                  "on-label-click": f.isClickable ? () => t.$emit("click-option", f.id) : void 0,
                  disabled: f.disabled,
                  onChangeCheckbox: (p) => t.$emit("change-checkbox", f.id, p),
                  onChangeVisibility: (p) => t.$emit("change-visibility", f.id, p)
                }, null, 8, ["is-option-item", "label", "show-checkbox", "checkbox-checked", "contextual-detail", "meta-copy", "show-visibility", "visible", "icon", "on-label-click", "disabled", "onChangeCheckbox", "onChangeVisibility"]), [
                  [d, { ...t.getDragConfigForOption(f), data: f }]
                ]),
                t.isOptionDraggable(f) ? yt((_(), Z("div", HW, null, 512)), [
                  [c, { ...t.dropConfig, data: { ...f, dropZone: "after" } }]
                ]) : W("", !0)
              ], 8, jW))), 128))
            ]),
            _: 2
          }, 1024)
        ]),
        _: 2
      }, 1024)
    ], 64))), 128))
  ]);
}
const r$ = /* @__PURE__ */ je(qW, [["render", UW]]), GW = Te({
  name: "MtDataTableSettings",
  components: {
    "mt-button": Sr,
    "mt-icon": mt,
    "mt-popover": Qs,
    "mt-popover-item": Zo,
    "mt-popover-item-result": r$
  },
  directives: {
    tooltip: ja
  },
  props: {
    columns: {
      type: Array,
      required: !0
    },
    showOutlines: {
      type: Boolean,
      required: !1,
      default: !1
    },
    showStripes: {
      type: Boolean,
      required: !1,
      default: !1
    },
    enableOutlineFraming: {
      type: Boolean,
      required: !1,
      default: !1
    },
    enableRowNumbering: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: [
    "reset-all-changes",
    "change-column-order",
    "change-column-visibility",
    "change-show-outlines",
    "change-show-stripes",
    "change-outline-framing",
    "change-enable-row-numbering"
  ],
  setup(t, { emit: e }) {
    const { t: n } = Lt({
      messages: {
        en: {
          title: "Settings",
          resetAllChanges: "Reset all changes",
          columnOrder: {
            title: "Columns",
            columnGroups: {
              labelShown: "Shown in table",
              actionLabelShown: "Hide all",
              labelHidden: "Hidden in table",
              actionLabelHidden: "Show all"
            }
          },
          showNumberedColumn: "Show numbered column",
          showStripedRows: "Show striped rows",
          showOutlines: "Show outlines",
          frameOutlines: "Frame outlines",
          frameOutlinesMetaCopy: "Highlight column and row outlines on mouse hover",
          tooltip: "View settings",
          "aria-toggle-table-settings": "Toggle view settings"
        },
        de: {
          title: "Einstellungen",
          resetAllChanges: "Alle Änderungen zurücksetzen",
          columnOrder: {
            title: "Spalten",
            columnGroups: {
              labelShown: "In Tabelle sichtbar",
              actionLabelShown: "Alle ausblenden",
              labelHidden: "In Tabelle ausgeblendet",
              actionLabelHidden: "Alle einblenden"
            }
          },
          showNumberedColumn: "Zeige nummerierte Spalte an",
          showStripedRows: "Zeige gestreifte Zeilen an",
          showOutlines: "Zeige Umrisse an",
          frameOutlines: "Hebe Umrisse vor",
          frameOutlinesMetaCopy: "Hervorhebung von Spalten- und Zeilenumrissen bei Mausüberlagerung",
          tooltip: "Tabelleneinstellungen",
          "aria-toggle-table-settings": "Tabelleneinstellungen umschalten"
        }
      }
    }), i = J(() => [
      {
        name: "columnOrder",
        title: n("columnOrder.title")
      }
    ]), r = J(() => [
      {
        id: "visible",
        label: n("columnOrder.columnGroups.labelShown"),
        actionLabel: n("columnOrder.columnGroups.actionLabelShown")
      },
      {
        id: "hidden",
        label: n("columnOrder.columnGroups.labelHidden"),
        actionLabel: n("columnOrder.columnGroups.actionLabelHidden")
      }
    ]), o = J(() => t.columns.map((d) => ({
      id: d.property,
      label: d.label,
      parentGroup: d.visible ?? !0 ? "visible" : "hidden",
      position: d.position,
      isVisible: d.visible ?? !0,
      isHidable: !c(d),
      isSortable: !c(d)
    }))), s = (d, h) => {
      e("change-column-visibility", d, h);
    }, a = (d) => {
      t.columns.forEach((h) => {
        c(h) || s(h.property, d !== "visible");
      });
    }, l = ({
      itemId: d,
      dropZone: h,
      dropId: f
    }) => {
      const p = t.columns.find((m) => m.property === f);
      d && (s(d, (p == null ? void 0 : p.visible) ?? !0), e("change-column-order", { itemId: d, dropZone: h, dropId: f }));
    }, u = () => {
      e("reset-all-changes");
    }, c = (d) => t.columns[0].property === d.property;
    return {
      tableSettingsChildViews: i,
      resetAllChanges: u,
      columnGroups: r,
      columnOrderOptions: o,
      onColumnChangeVisibility: s,
      onColumnClickGroupAction: a,
      onColumnChangeOrder: l,
      isPrimaryColumn: c,
      t: n
    };
  }
});
function KW(t, e, n, i, r, o) {
  const s = Ce("mt-icon"), a = Ce("mt-button"), l = Ce("mt-popover-item"), u = Ce("mt-popover-item-result"), c = Ce("mt-popover"), d = vr("tooltip");
  return _(), ue(c, {
    class: "mt-data-table-settings",
    title: t.t("title"),
    "child-views": t.tableSettingsChildViews,
    width: "large"
  }, {
    trigger: H(({ toggleFloatingUi: h }) => [
      yt((_(), ue(a, {
        variant: "secondary",
        square: "",
        "aria-label": t.t("aria-toggle-table-settings"),
        onClick: h
      }, {
        default: H(() => [
          fe(s, { name: "solid-cog-s" })
        ]),
        _: 2
      }, 1032, ["aria-label", "onClick"])), [
        [d, {
          message: t.t("tooltip"),
          width: "auto"
        }]
      ])
    ]),
    "popover-items__base": H(({ changeView: h }) => [
      fe(l, {
        label: t.t("columnOrder.title"),
        "border-bottom": "",
        "show-options": "",
        "on-label-click": () => h("columnOrder"),
        "options-count": t.columns.length,
        onClickOptions: () => h("columnOrder")
      }, null, 8, ["label", "on-label-click", "options-count", "onClickOptions"]),
      fe(l, {
        label: t.t("showNumberedColumn"),
        "show-switch": "",
        "switch-value": t.enableRowNumbering,
        icon: "solid-hashtag",
        onChangeSwitch: e[0] || (e[0] = (f) => t.$emit("change-enable-row-numbering", f))
      }, null, 8, ["label", "switch-value"]),
      fe(l, {
        label: t.t("showStripedRows"),
        "show-switch": "",
        "switch-value": t.showStripes,
        icon: "solid-bars",
        onChangeSwitch: e[1] || (e[1] = (f) => t.$emit("change-show-stripes", f))
      }, null, 8, ["label", "switch-value"]),
      fe(l, {
        label: t.t("showOutlines"),
        "show-switch": "",
        "switch-value": t.showOutlines,
        icon: "solid-table",
        onChangeSwitch: e[2] || (e[2] = (f) => t.$emit("change-show-outlines", f))
      }, null, 8, ["label", "switch-value"]),
      fe(l, {
        label: t.t("frameOutlines"),
        "meta-copy": t.t("frameOutlinesMetaCopy"),
        "show-switch": "",
        "switch-value": t.enableOutlineFraming,
        icon: "solid-highlight",
        onChangeSwitch: e[3] || (e[3] = (f) => t.$emit("change-outline-framing", f))
      }, null, 8, ["label", "meta-copy", "switch-value"]),
      fe(l, {
        label: t.t("resetAllChanges"),
        "border-top": "",
        icon: "solid-undo",
        "on-label-click": t.resetAllChanges
      }, null, 8, ["label", "on-label-click"])
    ]),
    "popover-items__columnOrder": H(() => [
      fe(u, {
        groups: t.columnGroups,
        options: t.columnOrderOptions,
        draggable: "",
        "hide-search": "",
        hidable: "",
        onChangeVisibility: t.onColumnChangeVisibility,
        onClickGroupAction: t.onColumnClickGroupAction,
        onChangeOrder: t.onColumnChangeOrder
      }, null, 8, ["groups", "options", "onChangeVisibility", "onClickGroupAction", "onChangeOrder"])
    ]),
    _: 1
  }, 8, ["title", "child-views"]);
}
const JW = /* @__PURE__ */ je(GW, [["render", KW]]);
const eX = {}, tX = { class: "mt-skeleton-bar" };
function nX(t, e) {
  return _(), Z("div", tX, e[0] || (e[0] = [
    X("div", { class: "mt-skeleton-bar__shimmer" }, null, -1)
  ]));
}
const iX = /* @__PURE__ */ je(eX, [["render", nX], ["__scopeId", "data-v-c76c4453"]]), rX = Te({
  name: "MtDataTableTextRenderer",
  props: {
    columnDefinition: {
      type: Object,
      required: !0
    },
    data: {
      type: void 0,
      required: !0
    }
  },
  setup(t) {
    const e = J(() => Zl(t.data, t.columnDefinition.previewImage || ""));
    return {
      renderString: J(() => Zl(t.data, t.columnDefinition.property)),
      renderPreviewImage: e
    };
  }
});
const oX = { class: "mt-data-table-text-renderer-cell" }, sX = {
  key: 0,
  class: "mt-data-table-preview-image-renderer"
}, aX = ["src", "alt"], lX = {
  key: 2,
  class: "mt-data-table-text-renderer"
};
function uX(t, e, n, i, r, o) {
  return _(), Z("div", oX, [
    t.columnDefinition.previewImage ? (_(), Z("div", sX, [
      t.columnDefinition.previewImage ? (_(), Z("img", {
        key: 0,
        class: "mt-data-table-preview-image-renderer-item",
        src: t.renderPreviewImage,
        alt: t.renderString
      }, null, 8, aX)) : W("", !0)
    ])) : W("", !0),
    t.columnDefinition.clickable ? (_(), Z("a", {
      key: 1,
      class: "mt-data-table-text-renderer",
      href: "#",
      onClick: e[0] || (e[0] = Tt((s) => t.$emit("click", t.data), ["prevent"]))
    }, Pe(t.renderString), 1)) : (_(), Z("p", lX, Pe(t.renderString), 1))
  ]);
}
const cX = /* @__PURE__ */ je(rX, [["render", uX], ["__scopeId", "data-v-e39d618c"]]), dX = Te({
  name: "MtDataTableNumberRenderer",
  props: {
    columnDefinition: {
      type: Object,
      required: !0
    },
    data: {
      type: void 0,
      required: !0
    }
  },
  setup(t) {
    return {
      renderString: J(() => String(Number(Zl(t.data, t.columnDefinition.property))))
    };
  }
});
const hX = {
  key: 1,
  class: "mt-data-table-number-renderer"
};
function fX(t, e, n, i, r, o) {
  return t.columnDefinition.clickable ? (_(), Z("a", {
    key: 0,
    class: "mt-data-table-number-renderer",
    href: "#",
    onClick: e[0] || (e[0] = Tt((s) => t.$emit("click", t.data), ["prevent"]))
  }, Pe(t.renderString), 1)) : (_(), Z("p", hX, Pe(t.renderString), 1));
}
const pX = /* @__PURE__ */ je(dX, [["render", fX]]), mX = Te({
  name: "MtDataTableBadgeRenderer",
  components: {
    "mt-color-badge": Ob
  },
  props: {
    columnDefinition: {
      type: Object,
      required: !0
    },
    data: {
      type: void 0,
      required: !0
    }
  },
  setup(t) {
    return {
      badgeProps: J(() => {
        var i, r, o;
        return ((i = t.columnDefinition) == null ? void 0 : i.renderer) !== "badge" ? {
          label: "Renderer is not badge",
          variant: "critical"
        } : (o = (r = t.columnDefinition) == null ? void 0 : r.rendererOptions) != null && o.renderItemBadge ? t.columnDefinition.rendererOptions.renderItemBadge(
          t.data,
          t.columnDefinition
        ) : {
          label: '"renderItemBadge" method is not defined',
          variant: "critical"
        };
      })
    };
  }
});
function gX(t, e, n, i, r, o) {
  const s = Ce("mt-color-badge");
  return _(), ue(s, {
    class: "mt-data-table-badge-renderer",
    "has-text": "",
    variant: t.badgeProps.variant
  }, {
    default: H(() => [
      He(Pe(t.badgeProps.label), 1)
    ]),
    _: 1
  }, 8, ["variant"]);
}
const OX = /* @__PURE__ */ je(mX, [["render", gX]]);
function vX(t, e, n, i = {}) {
  const o = {
    style: "currency",
    currency: e,
    ...n !== void 0 ? {
      minimumFractionDigits: n,
      maximumFractionDigits: n
    } : {
      minimumFractionDigits: 2,
      maximumFractionDigits: 20
    },
    ...i
  };
  return t.toLocaleString(i.language ?? "en-US", o);
}
const yX = Te({
  name: "MtDataTablePriceRenderer",
  props: {
    columnDefinition: {
      type: Object,
      required: !0
    },
    data: {
      type: void 0,
      required: !0
    }
  },
  setup(t) {
    return {
      renderString: J(() => {
        var a, l, u, c, d, h;
        if (t.columnDefinition.renderer !== "price")
          return "Wrong renderer for price renderer";
        const n = (l = (a = t.columnDefinition) == null ? void 0 : a.rendererOptions) == null ? void 0 : l.currencyId;
        if (!n)
          return "No currency id found";
        const i = Zl(t.data, t.columnDefinition.property);
        if (!i)
          return "No prices found";
        const r = i.find((f) => f.currencyId === n);
        if (!r)
          return "No price found";
        const o = (c = (u = t.columnDefinition) == null ? void 0 : u.rendererOptions) == null ? void 0 : c.currencyISOCode;
        if (!o)
          return "No iso code found";
        const s = (h = (d = t.columnDefinition) == null ? void 0 : d.rendererOptions) == null ? void 0 : h.source;
        return s ? vX(r[s], o) : "No source (gross/net) found";
      })
    };
  }
});
const bX = {
  key: 1,
  class: "mt-data-table-price-renderer"
};
function wX(t, e, n, i, r, o) {
  return t.columnDefinition.clickable ? (_(), Z("a", {
    key: 0,
    class: "mt-data-table-price-renderer",
    href: "#",
    onClick: e[0] || (e[0] = Tt((s) => t.$emit("click", t.data), ["prevent"]))
  }, Pe(t.renderString), 1)) : (_(), Z("p", bX, Pe(t.renderString), 1));
}
const kX = /* @__PURE__ */ je(yX, [["render", wX]]), SX = Te({
  components: {
    "mt-checkbox": em,
    "mt-icon": mt,
    "mt-popover": Qs
  },
  props: {
    actions: {
      type: Array,
      required: !0
    },
    /**
     * Activate to hide the padding around the controls.
     */
    disableContext: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: [],
  setup(t) {
    const e = (s) => {
      const a = [`mt-segmented-control__action-id-${s.id}`];
      return s.isPressed && !s.hasCheckbox && a.push("mt-segmented-control__action--pressed"), s.isCritical && a.push("mt-segmented-control__action--critical"), s.disabled && a.push("mt-segmented-control__action--disabled"), s.minSquare && a.push("mt-segmented-control__action--min-square"), a;
    }, n = (s, a) => {
      s.disabled || s.hasCheckbox || (s.popover && a(), s.onClick && s.onClick({}));
    }, i = (s, a) => {
      s.disabled || s.onClick && s.onClick({ checkboxValue: a });
    }, r = J(() => ({
      "mt-segmented-control--disabled-context": t.disableContext
    })), o = (s) => s ? s.reduce((a, l) => l.childViews ? [...a, l, ...o(l.childViews)] : [...a, l], []) : [];
    return {
      getActionClass: e,
      handleClick: n,
      handleCheckboxChange: i,
      segmentedControlClasses: r,
      flatChildViews: o
    };
  }
});
const _X = ["aria-pressed", "onClick", "disabled"];
function xX(t, e, n, i, r, o) {
  const s = Ce("mt-icon"), a = Ce("mt-checkbox"), l = Ce("mt-popover");
  return _(), Z("div", {
    class: Ae(["mt-segmented-control", t.segmentedControlClasses])
  }, [
    (_(!0), Z(Qe, null, Ge(t.actions, (u, c) => (_(), Z(Qe, null, [
      typeof u == "string" && !t.disableContext ? (_(), Z("div", {
        key: c,
        class: "mt-segmented-control__divider"
      })) : W("", !0),
      typeof u != "string" ? (_(), ue(l, {
        key: u.id,
        "child-views": u.popover && u.popover.childViews,
        title: u.popover && u.popover.title
      }, un({
        trigger: H(({ toggleFloatingUi: d }) => [
          X("button", {
            class: Ae(["mt-segmented-control__action", t.getActionClass(u)]),
            "aria-pressed": u.isPressed,
            onClick: () => t.handleClick(u, d),
            disabled: u.disabled
          }, [
            u.iconName ? (_(), ue(s, {
              key: 0,
              name: u.iconName,
              class: "mt-segmented-control__action-icon"
            }, null, 8, ["name"])) : W("", !0),
            u.hasCheckbox ? (_(), ue(a, {
              key: 1,
              checked: u.checked,
              label: u.label,
              onChange: (h) => t.handleCheckboxChange(u, h)
            }, null, 8, ["checked", "label", "onChange"])) : (_(), Z(Qe, { key: 2 }, [
              ne(t.$slots, "label__" + u.id),
              He(" " + Pe(u.label), 1)
            ], 64)),
            u.options ? (_(), ue(s, {
              key: 3,
              class: "mt-segmented-control__action-options-icon",
              name: "regular-chevron-down-xs"
            })) : W("", !0),
            ne(t.$slots, "options__" + u.id)
          ], 10, _X)
        ]),
        "popover-items__base": H(({ toggleFloatingUi: d, changeView: h }) => [
          ne(t.$slots, u.id + "--popover-items__base", {
            toggleFloatingUi: d,
            changeView: h
          })
        ]),
        _: 2
      }, [
        Ge(t.flatChildViews(u.popover && u.popover.childViews), (d) => ({
          name: `popover-items__${d.name}`,
          fn: H(({ toggleFloatingUi: h, changeView: f }) => [
            ne(t.$slots, u.id + "--popover-items__" + d.name, {
              toggleFloatingUi: h,
              changeView: f
            })
          ])
        }))
      ]), 1032, ["child-views", "title"])) : W("", !0)
    ], 64))), 256))
  ], 2);
}
const CX = /* @__PURE__ */ je(SX, [["render", xX]]), mk = function(t, e) {
  if (!t)
    return;
  let n = t.previousElementSibling;
  if (!e)
    return n;
  for (; n; ) {
    if (n.matches(e))
      return n;
    n = n.previousElementSibling;
  }
}, gk = (t) => {
  let e = 0, n = mk(t, "[data-sticky-column]");
  for (; n; )
    e += n.clientWidth, n = mk(n, "[data-sticky-column]");
  t.style.left = `${e - 0.5}px`, t.dataset.stickyColumnRight = `${e + t.getBoundingClientRect().width - 0.5}`;
};
let Au;
const TX = {
  beforeMount(t) {
    t.dataset.stickyColumn = "";
  },
  mounted(t) {
    gk(t), Au = new MutationObserver(
      ab(() => {
        gk(t);
      }, 60)
    ), Au.observe(t.parentElement, {
      childList: !0,
      subtree: !0
    });
  },
  unmounted() {
    Au == null || Au.disconnect();
  }
}, $X = { class: "mt-data-table-reset-filter-button" }, PX = /* @__PURE__ */ Te({
  __name: "mt-data-table-reset-filter-button",
  props: {
    numberOfAppliedFilters: {}
  },
  setup(t) {
    const { t: e } = Lt({
      messages: {
        en: {
          label: "Remove filter | Remove filters"
        },
        de: {
          label: "Filter entfernen | Filter entfernen"
        }
      }
    });
    return (n, i) => (_(), Z("button", $X, Pe(E(e)("label", { n: n.numberOfAppliedFilters })), 1));
  }
});
const MX = /* @__PURE__ */ je(PX, [["__scopeId", "data-v-42e67b6c"]]), EX = {
  class: "mt-data-table-filter",
  "data-testid": "mt-data-table-filter"
}, AX = ["onClick"], RX = ["aria-label"], DX = /* @__PURE__ */ Te({
  __name: "mt-data-table-filter",
  props: {
    filter: {},
    appliedOptions: {}
  },
  emits: ["removeOption", "addOption", "removeFilter"],
  setup(t) {
    const e = t;
    function n(r) {
      return !!e.appliedOptions.find((o) => o.id === r);
    }
    const { t: i } = Lt({
      messages: {
        en: {
          is: "is",
          removeButton: "Remove filter"
        },
        de: {
          is: "ist",
          removeButton: "Filter entfernen"
        }
      }
    });
    return (r, o) => (_(), Z("div", EX, [
      fe(Pi, {
        class: "mt-data-table-filter__property",
        size: "2xs"
      }, {
        default: H(() => [
          He(Pe(r.filter.label), 1)
        ]),
        _: 1
      }),
      fe(Pi, {
        size: "2xs",
        color: "color-text-secondary-default",
        class: "mt-data-table-filter__rule"
      }, {
        default: H(() => [
          He(Pe(E(i)("is")), 1)
        ]),
        _: 1
      }),
      fe(Qs, {
        class: "mt-data-table-filter__option",
        title: "Manufactuer"
      }, {
        trigger: H(({ toggleFloatingUi: s }) => [
          X("button", {
            onKeydown: o[0] || (o[0] = ai((a) => r.$emit("removeFilter"), ["delete"])),
            onClick: s
          }, Pe(r.appliedOptions.map((a) => a.label).join(", ")), 41, AX)
        ]),
        "popover-items__base": H(() => [
          (_(!0), Z(Qe, null, Ge(r.filter.type.options, (s) => (_(), ue(Zo, {
            key: s.id,
            label: s.label,
            "show-checkbox": "",
            "checkbox-checked": n(s.id),
            onChangeCheckbox: (a) => a ? r.$emit("addOption", r.filter.id, s.id) : r.$emit("removeOption", r.filter.id, s.id)
          }, null, 8, ["label", "checkbox-checked", "onChangeCheckbox"]))), 128))
        ]),
        _: 1
      }),
      X("button", {
        class: "mt-data-table-filter__remove-button",
        "aria-label": E(i)("removeButton"),
        onKeydown: o[1] || (o[1] = ai((s) => r.$emit("removeFilter"), ["delete"])),
        onClick: o[2] || (o[2] = (s) => r.$emit("removeFilter"))
      }, [
        fe(mt, {
          name: "solid-times-xxs",
          "aria-hidden": "true"
        })
      ], 40, RX)
    ]));
  }
});
const QX = /* @__PURE__ */ je(DX, [["__scopeId", "data-v-8b7c4be6"]]);
const NX = {}, IX = { class: "mt-inset" };
function LX(t, e) {
  return _(), Z("div", IX, [
    ne(t.$slots, "default", {}, void 0, !0)
  ]);
}
const VX = /* @__PURE__ */ je(NX, [["render", LX], ["__scopeId", "data-v-2baaeb42"]]), BX = Te({
  directives: {
    draggable: n$,
    droppable: i$,
    tooltip: ja,
    stickyColumn: TX
  },
  components: {
    "mt-card": lW,
    "mt-button": Sr,
    "mt-select": uq,
    "mt-icon": mt,
    "mt-pagination": NW,
    "mt-search": e$,
    "mt-checkbox": em,
    "mt-context-button": vb,
    "mt-data-table-settings": JW,
    "mt-popover": Qs,
    "mt-popover-item": Zo,
    "mt-popover-item-result": r$,
    "mt-skeleton-bar": iX,
    "mt-context-menu-item": JT,
    "mt-floating-ui": gb,
    "mt-segmented-control": CX,
    "mt-empty-state": hW,
    "mt-data-table-text-renderer": cX,
    "mt-data-table-number-renderer": pX,
    "mt-data-table-badge-renderer": OX,
    "mt-data-table-price-renderer": kX,
    "mt-data-table-reset-filter-button": MX,
    "mt-data-table-filter": QX,
    "mt-inset": VX
  },
  props: {
    /**
     * The data source which contains the data for the current
     * state of the table.
     */
    dataSource: {
      type: Array,
      required: !0
    },
    /**
     * The defintions for the columns which should be displayed in the table.
     */
    columns: {
      type: Array,
      required: !0,
      validator: (t) => t.map((n) => {
        const i = typeof n.label == "string" && n.label, r = typeof n.property == "string" && n.property, o = typeof n.renderer == "string" && ["text", "number", "price", "badge"].includes(n.renderer), s = typeof n.position == "number";
        return !(!i || !r || !o || !s);
      }).every((n) => n)
    },
    /**
     * Optional property. When you want to override the current column
     * information with the given changes, you can pass them here.
     * The changes will be applied to the current column information.
     * This is useful for saving and loading the current column configuration
     * when the user customizes the table.
     */
    columnChanges: {
      type: Object,
      required: !1,
      default: () => Bs({})
    },
    /**
     * Define the title of the table.
     */
    title: {
      type: String,
      required: !1,
      default: ""
    },
    /**
     * Define the subtitle of the table.
     */
    subtitle: {
      type: String,
      required: !1,
      default: ""
    },
    /**
     * The layout of the data table.
     * @values default, full
     */
    layout: {
      type: String,
      required: !1,
      default: "default"
    },
    /**
     * Activate the reload button at the top right corner of the table.
     */
    enableReload: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Define the current page of the table.
     */
    currentPage: {
      type: Number,
      required: !0
    },
    /**
     * Define the limit of items per page.
     */
    paginationLimit: {
      type: Number,
      required: !0
    },
    /**
     * Define the total amount of items.
     */
    paginationTotalItems: {
      type: Number,
      required: !0
    },
    /**
     * Define the available pagination limits.
     */
    paginationOptions: {
      type: Array,
      required: !1,
      default: () => [5, 10, 25, 50]
    },
    /**
     * Define the current sort by property.
     */
    sortBy: {
      type: String,
      required: !1,
      default: ""
    },
    /**
     * Define the current sort direction.
     */
    sortDirection: {
      type: String,
      required: !1,
      default: "ASC"
    },
    /**
     * If active then the search input will be disabled.
     */
    disableSearch: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Define the current search value.
     */
    searchValue: {
      type: String,
      required: !1,
      default: ""
    },
    /**
     * If active then the table will be in loading state.
     */
    isLoading: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * If active user can select rows and can perform actions on them.
     */
    allowRowSelection: {
      type: Boolean,
      required: !1,
      default: !1
    },
    selectedRows: {
      type: Array,
      required: !1,
      default: () => []
    },
    /**
     * If active user can do bulk edit by selecting items
     */
    allowBulkEdit: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * If active user can do bulk delete by selecting items
     */
    allowBulkDelete: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Add more custom bulk edit actions
     */
    bulkEditMoreActions: {
      type: Array,
      required: !1,
      default: () => []
    },
    /***
     * Enable numbered rows
     */
    enableRowNumbering: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Enable or disable the stripe design for the table.
     */
    showStripes: {
      type: Boolean,
      required: !1,
      default: !0
    },
    /**
     * Enable or disable outlines for the table.
     */
    showOutlines: {
      type: Boolean,
      required: !1,
      default: !0
    },
    /**
     * Enable or disable outline framing on hover
     */
    enableOutlineFraming: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Disable the possibility to delete items
     */
    disableDelete: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Disable the possibility to edit items
     */
    disableEdit: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Disable the possibility to settings table
     */
    disableSettingsTable: {
      type: Boolean,
      required: !1,
      default: !1
    },
    /**
     * Caption for accessibility
     */
    caption: {
      type: String,
      required: !1,
      default: "Data table"
    },
    /**
     * All available filters
     */
    filters: {
      type: Array,
      required: !1,
      default: () => []
    },
    /**
     * Filters in use by the user
     */
    appliedFilters: {
      type: Array,
      required: !1,
      default: () => []
    },
    /**
     * Displays how many results are found
     */
    numberOfResults: {
      type: Number,
      required: !1,
      default: void 0
    }
  },
  emits: [
    "reload",
    "pagination-limit-change",
    "pagination-current-page-change",
    "search-value-change",
    "sort-change",
    "open-details",
    "selection-change",
    "multiple-selection-change",
    "bulk-edit",
    "bulk-delete",
    "change-show-outlines",
    "change-show-stripes",
    "change-outline-framing",
    "change-enable-row-numbering",
    "item-delete",
    "update:appliedFilters"
  ],
  setup(t, { emit: e }) {
    const { t: n } = Lt({
      messages: {
        en: {
          itemsPerPage: "Items per page",
          filter: {
            numberOfResults: "No results found for | One result found for | {n} results found for",
            addFilter: "Add filter",
            fetchingFilteredResults: "Getting filtered results..."
          },
          columnSettings: {
            sortAscending: "Sort ascending",
            sortDescending: "Sort descending",
            hideColumn: "Hide column"
          },
          addColumnIndicator: {
            popoverTitle: "Add column content",
            tooltipMessage: "Add column"
          },
          contextButtons: {
            edit: "Edit",
            delete: "Delete"
          },
          emptyState: {
            headline: "Add your first item",
            description: "Currently no items are available yet."
          },
          bulkEdit: {
            itemsSelected: "1 item selected | {n} items selected",
            edit: "Edit",
            delete: "Delete",
            more: "..."
          },
          reload: {
            tooltip: "Reload"
          }
        },
        de: {
          itemsPerPage: "Einträge pro Seite",
          filter: {
            numberOfResults: "Keine Einträge gefunden | Ein Eintrag gefunden | {n} Einträge gefunden",
            addFilter: "Filter hinzufügen",
            fetchingFilteredResults: "Filterergebnisse werden geladen..."
          },
          columnSettings: {
            sortAscending: "Aufsteigend sortieren",
            sortDescending: "Absteigend sortieren",
            hideColumn: "Spalte ausblenden"
          },
          addColumnIndicator: {
            popoverTitle: "Spalteninhalt hinzufügen",
            tooltipMessage: "Spalte hinzufügen"
          },
          contextButtons: {
            edit: "Bearbeiten",
            delete: "Löschen"
          },
          emptyState: {
            headline: "Füge dein erstes Element hinzu",
            description: "Aktuell sind noch keine Elemente vorhanden."
          },
          bulkEdit: {
            itemsSelected: "1 Element ausgewählt | {n} Elemente ausgewählt",
            edit: "Bearbeiten",
            delete: "Löschen",
            more: "..."
          },
          reload: {
            tooltip: "Neu laden"
          }
        }
      }
    }), i = J(() => t.filters.map(({ id: R, label: le }) => ({ name: R, title: le }))), r = J(() => O.value.slice().sort((R, le) => R.position - le.position)), o = re(null), s = re(null), a = (R, le) => {
      o.value = R, s.value = le;
    }, l = J(() => r.value.filter((R) => R.visible !== !1)), u = (R) => l.value[0].property === R.property, c = (R) => t.columns[0].property === R.property, d = re(""), h = (R) => {
      d.value = R;
    }, f = J(() => r.value.map((R) => ({
      id: R.property,
      label: R.label,
      parentGroup: void 0,
      position: R.position,
      isVisible: R.visible ?? !0,
      isClickable: R.visible === !1,
      isSortable: !1,
      isHidable: !1,
      disabled: R.visible !== !1
    })).filter((R) => R.label.toLowerCase().includes(d.value.toLowerCase()))), p = (R, le) => {
      ce(R, le, "after"), de(R, !0);
    }, m = () => {
      Object.keys(t.columnChanges).forEach((R) => {
        t.columnChanges[R] = {};
      });
    }, g = (R, le) => {
      t.columnChanges[R] || (t.columnChanges[R] = {}), t.columnChanges[R] = {
        ...t.columnChanges[R],
        ...le
      };
    }, O = J(() => t.columns.map((R) => {
      const le = t.columnChanges[R.property];
      return le ? {
        ...R,
        ...le
      } : R;
    })), y = re(null), b = re({}), v = re({}), k = ({
      el: R,
      column: le,
      index: $e
    }) => {
      R && (Array.isArray(v.value[le.property]) || (v.value[le.property] = []), v.value[le.property][$e] = R);
    };
    jx(() => {
      b.value = {}, v.value = {};
    });
    const w = (R) => {
      if (!R)
        return;
      S();
      const le = b.value[R.property], $e = v.value[R.property];
      if (!le || typeof R.allowResize == "boolean" && !R.allowResize)
        return;
      const z = le.getBoundingClientRect(), ae = z.width;
      y.value && (y.value.classList.add("--no-transition"), y.value.classList.add("--resizing")), document.body.style.cursor = "col-resize";
      const Me = (Re) => {
        Re.stopPropagation(), Re.preventDefault();
        const Fe = Math.ceil(Re.pageX - z.left);
        if ($(le, Fe), C($e, Fe), y.value) {
          const fn = ae - Fe;
          y.value.style.paddingRight = fn > 0 ? `${fn}px` : "";
        }
      }, he = () => {
        document.body.style.cursor = "", g(R.property, {
          width: parseInt(le.style.width, 10)
        }), y.value && (y.value.classList.remove("--no-transition"), y.value.classList.remove("--resizing"), y.value.style.removeProperty("padding-right")), window.removeEventListener("mousemove", Me), window.removeEventListener("mouseup", he);
      };
      window.addEventListener("mousemove", Me), window.addEventListener("mouseup", he);
    }, S = () => {
      const R = {};
      Object.entries(b.value).forEach(([le, $e]) => {
        const z = t.columns.find(
          (Me) => Me.property === le
        );
        if (z && z.allowResize === !1 && typeof z.width == "number")
          return;
        const ae = $e.getBoundingClientRect();
        R[le] = ae.width, $($e, R[le]);
      }), Object.entries(v.value).forEach(([le, $e]) => {
        R[le] && C($e, R[le]);
      });
    }, $ = (R, le) => {
      R.style.width = `${le}px`, R.style.minWidth = `${le}px`;
    }, C = (R, le) => {
      R.forEach(($e) => {
        $e.style.width = `${le}px`, $e.style.minWidth = `${le}px`, $e.style.maxWidth = `${le}px`;
      });
    }, L = (R) => {
      var Fe;
      const le = (Fe = t.columnChanges[R.property]) == null ? void 0 : Fe.width, $e = "auto", z = "100px", ae = (() => le && R.allowResize !== !1 ? `${le}px` : typeof R.width == "number" ? `${R.width}px` : $e)(), Me = (() => le && R.allowResize !== !1 ? `${le}px` : typeof R.width == "number" ? `${R.width}px` : z)(), he = (() => le && R.allowResize !== !1 ? `${le}px` : R.cellWrap === "normal" ? "auto" : typeof R.width == "number" ? `${R.width}px` : z)(), Re = typeof R.cellWrap == "string" ? R.cellWrap : "nowrap";
      return {
        width: ae,
        "min-width": Me,
        "max-width": he,
        "white-space": Re
      };
    }, j = (R) => ({
      ...L(R),
      "max-width": "fit-content"
    }), P = (R) => ({
      ...L(R)
    }), A = (R) => {
      const le = [];
      return q.value === R.property && le.push("--highlighted"), o.value === R.property && le.push("--hovered"), le;
    }, T = (R) => {
      const le = [];
      return q.value === R.property && le.push("--highlighted"), o.value === R.property && le.push("--hovered"), le;
    }, N = (R) => {
      const le = [];
      return s.value === R && le.push("--hovered"), le;
    }, Q = (R) => R.visible ?? !0, Y = re(!1), V = re(!1), q = re(null), B = (R) => {
      var le;
      if (!((le = y.value) != null && le.classList.contains("--resizing"))) {
        if (!R) {
          if (V.value)
            return;
          Y.value = !1, window.setTimeout(() => {
            Y.value || (q.value = null);
          }, 100);
          return;
        }
        V.value || (Y.value = !0, q.value = R.property);
      }
    }, pe = () => e("reload"), oe = (R) => {
      e("pagination-limit-change", R);
    }, te = (R) => {
      e("pagination-current-page-change", R);
    }, M = (R) => {
      e("search-value-change", R);
    }, G = J(() => t.paginationOptions.map((R) => ({
      id: R,
      label: R.toString(),
      value: R
    }))), ce = (R, le, $e = "before") => {
      const z = O.value.find((Me) => Me.property === R), ae = O.value.find(
        (Me) => Me.property === le
      );
      !z || !ae || [...O.value].sort((Me, he) => Me.position - he.position).sort((Me, he) => he.property === z.property ? $e === "after" ? Me.position <= ae.position ? -1 : 1 : Me.position < ae.position ? -1 : 1 : Me.property === z.property ? $e === "after" ? he.position > ae.position ? -1 : 1 : he.position >= ae.position ? -1 : 1 : 0).forEach((Me, he) => {
        g(Me.property, { position: he * 100 });
      });
    }, F = re(!1), xe = "drag-group-column", Be = {
      dragGroup: xe,
      preventEvent: !1,
      validateDragStart: (R, le, $e) => [...document.querySelectorAll(".mt-data-table__table-head-dragzone")].some((Me) => Me.contains($e.target)),
      onDragStart: () => {
        y.value && y.value.classList.add("is--dragging-inside"), document.body.style.cursor = "grabbing", F.value = !0;
      },
      onDrop: (R, le) => {
        y.value && y.value.classList.remove("is--dragging-inside"), document.body.style.cursor = "", F.value = !1, R && le && ce(
          R.property,
          le.property,
          le.dropZone
        );
      }
    }, lt = {
      dragGroup: xe
    }, de = (R, le) => {
      O.value.find((z) => z.property === R) && g(R, {
        visible: le
      });
    }, ye = (R, le) => {
      e("sort-change", R, le);
    }, me = (R, le, $e) => {
      ye(R, le), $e && $e();
    };
    function ie(R) {
      const le = t.appliedFilters.filter(($e) => $e.id !== R);
      e("update:appliedFilters", le);
    }
    function I(R, le) {
      const $e = t.filters.find((ae) => ae.id === R);
      if (!$e)
        throw new Error(
          `Failed to add filter option: Filter with the id "${R}" is not correct`
        );
      if (!!!t.appliedFilters.find((ae) => ae.id === $e.id)) {
        e("update:appliedFilters", [
          ...t.appliedFilters,
          {
            ...$e,
            type: {
              ...$e.type,
              options: [$e.type.options.find((ae) => ae.id === le)]
            }
          }
        ]);
        return;
      }
      e("update:appliedFilters", [
        ...t.appliedFilters.map((ae) => ae.id === $e.id ? {
          ...ae,
          type: {
            ...ae.type,
            options: [
              ...ae.type.options,
              $e.type.options.find((Me) => Me.id === le)
            ]
          }
        } : ae)
      ]);
    }
    function ge(R, le) {
      if (t.appliedFilters.some((ae) => ae.id === R && ae.type.options.length === 1)) {
        const ae = t.appliedFilters.filter(
          (Me) => Me.id !== R
        );
        e("update:appliedFilters", ae);
        return;
      }
      const z = t.appliedFilters.map((ae) => ae.id === R ? {
        ...ae,
        type: {
          ...ae.type,
          options: ae.type.options.filter((Me) => Me.id !== le)
        }
      } : ae);
      e("update:appliedFilters", z);
    }
    function ze(R, le) {
      const $e = t.appliedFilters.find((z) => z.id === R);
      return $e ? !!$e.type.options.find((z) => z.id === le) : !1;
    }
    const Se = re();
    kW(Se);
    const st = J(() => ({
      "mt-data-table__layout-default": t.layout === "default",
      "mt-data-table__layout-full": t.layout === "full",
      "mt-data-table__first-column-fixed": t.allowRowSelection,
      // could be relevant in the feature when you can disable the context button
      "mt-data-table__last-column-fixed": !0,
      "mt-data-table__stripes": t.showStripes,
      "mt-data-table__outlines": t.showOutlines,
      "mt-data-table__column-outline-framing-active": t.enableOutlineFraming
    })), D = (R) => [`mt-data-table__table-head-inner-wrapper-${R.renderer}-renderer`], x = re(0), U = () => {
      if (y.value) {
        const R = y.value.querySelectorAll("thead th[data-sticky-column]"), le = R[R.length - 1];
        if (!le)
          return;
        const $e = le.dataset.stickyColumnRight;
        x.value = Number($e);
      }
    };
    let K;
    const ke = () => {
      y.value && (K = new MutationObserver(
        ab(() => {
          U();
        }, 60)
      ), K.observe(y.value, {
        childList: !0,
        subtree: !0,
        attributes: !0
      }));
    };
    Et(() => {
      ke(), U();
    }), Zs(() => {
      K && K.disconnect();
    });
    const Ve = J(() => ({
      "--fixed-left-column-width": `${x.value}px`,
      "--fixed-right-column-width": "105px"
    })), be = (R) => t.allowRowSelection ? t.selectedRows.includes(R) : !1, se = (R) => {
      if (t.allowRowSelection) {
        const le = be(R);
        e("selection-change", {
          id: R,
          value: !le
        });
      }
    }, Oe = J(() => t.selectedRows.length > 0), at = J(() => {
      const R = [
        {
          id: "item-selection-count",
          label: n("bulkEdit.itemsSelected", { n: t.selectedRows.length }),
          onClick: () => {
            e("multiple-selection-change", {
              selections: t.selectedRows,
              value: !1
            });
          },
          isPressed: !0,
          checked: !0,
          hasCheckbox: !0
        }
      ];
      return t.allowBulkEdit && !t.disableEdit && R.push({
        id: "edit",
        label: n("bulkEdit.edit"),
        onClick: () => e("bulk-edit")
      }), t.allowBulkDelete && !t.disableDelete && R.push({
        id: "delete",
        label: n("bulkEdit.delete"),
        onClick: () => e("bulk-delete"),
        isCritical: !0
      }), t.bulkEditMoreActions.length > 0 && R.push({
        id: "more",
        label: n("bulkEdit.more"),
        popover: {}
      }), R;
    }), $t = () => {
      e("multiple-selection-change", {
        selections: t.dataSource.map((R) => R.id),
        value: !0
      });
    }, Qn = (R) => {
      const le = r.value.filter((z) => Q(z)), $e = le.findIndex((z) => z.property === R.property);
      return $e <= 0 ? null : le[$e - 1];
    }, qi = J(() => Array.from({ length: t.paginationLimit }, () => ({})));
    return {
      t: n,
      sortedColumns: r,
      isFirstVisibleColumn: u,
      addColumnOptions: f,
      renderColumnDataCellStyle: P,
      renderColumnHeaderStyle: j,
      tableWrapper: Se,
      emitReload: pe,
      emitPaginationLimitChange: oe,
      emitPaginationCurrentPageChange: te,
      emitSearchValueChange: M,
      paginationOptionsConverted: G,
      startColumnResizing: w,
      columnHeaderRefs: b,
      columnDataCellRefs: v,
      setColumnDataCellRefs: k,
      dataTable: y,
      dragConfig: Be,
      dropConfig: lt,
      resetAllChanges: m,
      changeColumnPosition: ce,
      isColumnVisible: Q,
      changeColumnVisibility: de,
      emitSortChange: ye,
      onColumnSettingsSortChange: me,
      MtDataTableClasses: st,
      tableStylingVariables: Ve,
      getSelectionValue: be,
      onRowSelect: se,
      somethingSelected: Oe,
      bulkEditSegmentedControlActions: at,
      handleSelectAll: $t,
      highlightedColumn: q,
      setHighlightedColumn: B,
      getColumnDataCellClasses: A,
      getColumnHeaderClasses: T,
      getPreviousVisibleColumn: Qn,
      getColumnDataRowClasses: N,
      getColumnHeaderInnerWrapperClasses: D,
      forceHighlightedColumn: V,
      addColumnOptionsSearch: d,
      onAddColumnOptionClick: p,
      onAddColumnSearch: h,
      currentHoveredColumn: o,
      currentHoveredRow: s,
      setCurrentHoveredCell: a,
      isPrimaryColumn: c,
      emptyData: qi,
      getRealIndex: (R) => (t.currentPage - 1) * t.paginationLimit + R + 1,
      isDragging: F,
      filterChildViews: i,
      removeFilter: ie,
      addOption: I,
      removeOption: ge,
      isOptionSelected: ze
    };
  }
});
const ZX = { class: "mt-data-table__toolbar" }, FX = {
  key: 0,
  class: "mt-data-table__filter"
}, qX = { class: "mt-data-table__filter-list" }, WX = ["onClick", "aria-label"], XX = {
  key: 0,
  class: "mt-data-table__table-selection-bulk-edit"
}, zX = {
  ref: "tableWrapper",
  class: "mt-data-table__table-wrapper"
}, jX = { ref: "dataTable" }, YX = { class: "mt-data-table__caption" }, HX = {
  key: 0,
  class: "mt-data-table__table-row-number-head",
  scope: "col"
}, UX = {
  key: 1,
  class: "mt-data-table__table-selection-head",
  scope: "col"
}, GX = ["data-header-column-property", "data-testid", "onMouseenter"], KX = ["data-testid"], JX = ["data-testid"], ez = { class: "mt-data-table__table-head-dragzone-indicator" }, tz = {
  key: 0,
  class: "mt-data-table__table-head-sorting-icons"
}, nz = ["data-testid"], iz = ["data-testid"], rz = ["data-testid", "onClick"], oz = ["data-testid", "onMousedown", "onMouseenter"], sz = ["data-testid", "onMousedown", "onMouseenter"], az = {
  key: 2,
  class: "mt-data-table__table-settings-button",
  scope: "col"
}, lz = {
  key: 0,
  class: "mt-data-table__table-row-number"
}, uz = {
  key: 1,
  class: "mt-data-table__table-select-row"
}, cz = ["data-cell-column-property", "onMouseenter"], dz = {
  key: 2,
  class: "mt-data-table__table-context-button"
}, hz = ["onClick"], fz = {
  key: 1,
  class: "mt-data-table__empty-state"
}, pz = { class: "mt-data-table__footer-left" }, mz = { class: "mt-data-table__pagination-info-text" }, gz = { class: "mt-data-table__footer-right" };
function Oz(t, e, n, i, r, o) {
  const s = Ce("mt-search"), a = Ce("mt-icon"), l = Ce("mt-button"), u = Ce("mt-popover-item"), c = Ce("mt-popover"), d = Ce("mt-data-table-filter"), h = Ce("mt-data-table-reset-filter-button"), f = Ce("mt-segmented-control"), p = Ce("mt-checkbox"), m = Ce("mt-popover-item-result"), g = Ce("mt-floating-ui"), O = Ce("mt-data-table-settings"), y = Ce("mt-skeleton-bar"), b = Ce("mt-data-table-number-renderer"), v = Ce("mt-data-table-text-renderer"), k = Ce("mt-data-table-badge-renderer"), w = Ce("mt-data-table-price-renderer"), S = Ce("mt-context-menu-item"), $ = Ce("mt-context-button"), C = Ce("mt-empty-state"), L = Ce("mt-select"), j = Ce("mt-pagination"), P = Ce("mt-inset"), A = Ce("mt-card"), T = vr("stickyColumn"), N = vr("droppable"), Q = vr("tooltip"), Y = vr("draggable");
  return _(), ue(A, {
    class: Ae(["mt-data-table", t.MtDataTableClasses]),
    title: t.title,
    subtitle: t.subtitle
  }, {
    toolbar: H(() => [
      X("div", ZX, [
        t.disableSearch !== !0 ? (_(), ue(s, {
          key: 0,
          class: "mt-data-table__search",
          size: "small",
          "model-value": t.searchValue,
          onChange: t.emitSearchValueChange
        }, null, 8, ["model-value", "onChange"])) : W("", !0),
        t.filters.length > 0 ? (_(), ue(c, {
          key: 1,
          title: "Filters",
          "child-views": t.filterChildViews
        }, un({
          trigger: H(({ toggleFloatingUi: V }) => [
            fe(l, {
              variant: "secondary",
              onClick: V
            }, {
              default: H(() => [
                fe(a, {
                  name: "solid-filter-s",
                  "aria-hidden": "true"
                }),
                X("span", null, Pe(t.t("filter.addFilter")), 1)
              ]),
              _: 2
            }, 1032, ["onClick"])
          ]),
          "popover-items__base": H(({ changeView: V }) => [
            (_(!0), Z(Qe, null, Ge(t.filters, (q) => (_(), ue(u, {
              key: q.id,
              label: q.label,
              "show-options": "",
              onClickOptions: () => V(q.id)
            }, null, 8, ["label", "onClickOptions"]))), 128))
          ]),
          _: 2
        }, [
          Ge(t.filters, (V) => ({
            name: `popover-items__${V.id}`,
            fn: H(() => [
              (_(!0), Z(Qe, null, Ge(V.type.options, (q) => (_(), ue(u, {
                key: q.id,
                label: q.label,
                "show-checkbox": "",
                "checkbox-checked": t.isOptionSelected(V.id, q.id),
                onChangeCheckbox: (B) => B ? t.addOption(V.id, q.id) : t.removeOption(V.id, q.id)
              }, null, 8, ["label", "checkbox-checked", "onChangeCheckbox"]))), 128))
            ])
          }))
        ]), 1032, ["child-views"])) : W("", !0),
        ne(t.$slots, "toolbar")
      ]),
      t.appliedFilters.length > 0 ? (_(), Z("div", FX, [
        X("span", null, Pe(t.isLoading ? t.t("filter.fetchingFilteredResults") : t.t("filter.numberOfResults", { n: t.numberOfResults ?? 0 })), 1),
        X("div", qX, [
          (_(!0), Z(Qe, null, Ge(t.appliedFilters, (V) => (_(), ue(d, {
            key: V.id,
            filter: t.filters.find((q) => q.id === V.id),
            "applied-options": V.type.options,
            onAddOption: e[0] || (e[0] = (q, B) => t.addOption(q, B)),
            onRemoveOption: e[1] || (e[1] = (q, B) => t.removeOption(q, B)),
            onRemoveFilter: (q) => t.removeFilter(V.id)
          }, null, 8, ["filter", "applied-options", "onRemoveFilter"]))), 128))
        ]),
        fe(c, {
          title: "Filters",
          "child-views": t.filterChildViews
        }, un({
          trigger: H(({ toggleFloatingUi: V }) => [
            X("button", {
              onClick: V,
              class: "mt-data-table__add-filter-button",
              "aria-label": t.t("filter.addFilter")
            }, [
              fe(a, { name: "solid-plus-square-s" })
            ], 8, WX)
          ]),
          "popover-items__base": H(({ changeView: V }) => [
            (_(!0), Z(Qe, null, Ge(t.filters, (q) => (_(), ue(u, {
              key: q.id,
              label: q.label,
              "show-options": "",
              onClickOptions: () => V(q.id)
            }, null, 8, ["label", "onClickOptions"]))), 128))
          ]),
          _: 2
        }, [
          Ge(t.filters, (V) => ({
            name: `popover-items__${V.id}`,
            fn: H(() => [
              (_(!0), Z(Qe, null, Ge(V.type.options, (q) => (_(), ue(u, {
                key: q.id,
                label: q.label,
                "show-checkbox": "",
                "checkbox-checked": t.isOptionSelected(V.id, q.id),
                onChangeCheckbox: (B) => B ? t.addOption(V.id, q.id) : t.removeOption(V.id, q.id)
              }, null, 8, ["label", "checkbox-checked", "onChangeCheckbox"]))), 128))
            ])
          }))
        ]), 1032, ["child-views"]),
        fe(h, {
          "number-of-applied-filters": t.appliedFilters.length,
          onClick: e[2] || (e[2] = (V) => t.$emit("update:appliedFilters", []))
        }, null, 8, ["number-of-applied-filters"])
      ])) : W("", !0)
    ]),
    default: H(() => [
      t.somethingSelected ? (_(), Z("div", XX, [
        fe(f, {
          "disable-context": "",
          actions: t.bulkEditSegmentedControlActions
        }, {
          "more--popover-items__base": H(() => [
            (_(!0), Z(Qe, null, Ge(t.bulkEditMoreActions, (V) => (_(), ue(u, {
              key: V.id,
              label: V.label,
              "on-label-click": V.onClick,
              type: V.type,
              icon: V.icon,
              "meta-copy": V.metaCopy,
              "contextual-detail": V.contextualDetail
            }, null, 8, ["label", "on-label-click", "type", "icon", "meta-copy", "contextual-detail"]))), 128))
          ]),
          _: 1
        }, 8, ["actions"])
      ])) : W("", !0),
      X("div", zX, [
        X("table", jX, [
          X("caption", YX, Pe(t.caption), 1),
          X("thead", null, [
            X("tr", null, [
              t.enableRowNumbering ? yt((_(), Z("th", HX, e[15] || (e[15] = [
                X("span", null, " # ", -1)
              ]))), [
                [T]
              ]) : W("", !0),
              t.allowRowSelection ? yt((_(), Z("th", UX, [
                fe(p, {
                  checked: t.somethingSelected,
                  onChange: t.handleSelectAll
                }, null, 8, ["checked", "onChange"])
              ])), [
                [T]
              ]) : W("", !0),
              (_(!0), Z(Qe, null, Ge(t.sortedColumns, (V) => (_(), Z(Qe, null, [
                t.isColumnVisible(V) ? yt((_(), Z("th", {
                  key: V.property,
                  ref_for: !0,
                  ref: (q) => {
                    q && (t.columnHeaderRefs[V.property] = q);
                  },
                  scope: "col",
                  class: Ae(["mt-data-table__table-wrapper-table-head", t.getColumnHeaderClasses(V)]),
                  "data-header-column-property": V.property,
                  style: pt(t.renderColumnHeaderStyle(V)),
                  "data-testid": "column-table-head__" + V.property,
                  onMouseenter: () => t.currentHoveredColumn = V.property,
                  onMouseleave: e[7] || (e[7] = () => t.currentHoveredColumn = null)
                }, [
                  X("div", {
                    class: "mt-data-table__table-head-dragzone",
                    "data-testid": "column-dragzone__" + V.property
                  }, [
                    X("div", {
                      class: "mt-data-table__table-head-dragzone-bar",
                      "data-testid": "column-dragzone-bar__" + V.property
                    }, [
                      X("div", ez, [
                        fe(a, { name: "regular-grip-horizontal-s" })
                      ])
                    ], 8, JX)
                  ], 8, KX),
                  X("div", {
                    class: Ae(["mt-data-table__table-head-inner-wrapper", t.getColumnHeaderInnerWrapperClasses(V)])
                  }, [
                    X("span", null, Pe(V.label), 1),
                    t.sortBy === V.property ? (_(), Z("div", tz, [
                      fe(a, {
                        name: t.sortDirection === "ASC" ? "solid-long-arrow-up" : "solid-long-arrow-down",
                        class: "mt-data-table__table-head-sort"
                      }, null, 8, ["name"])
                    ])) : W("", !0)
                  ], 2),
                  yt(X("div", {
                    class: "mt-data-table__table-head-dropzone-before",
                    "data-testid": "column-dropzone-before__" + V.property
                  }, null, 8, nz), [
                    [N, { ...t.dropConfig, data: { ...V, dropZone: "before" } }]
                  ]),
                  yt(X("div", {
                    class: "mt-data-table__table-head-dropzone-after",
                    "data-testid": "column-dropzone-after__" + V.property
                  }, null, 8, iz), [
                    [N, { ...t.dropConfig, data: { ...V, dropZone: "after" } }]
                  ]),
                  fe(c, {
                    title: V.label,
                    class: "mt-data-table__table-head-column-settings"
                  }, {
                    trigger: H(({ toggleFloatingUi: q }) => [
                      X("div", {
                        class: "mt-data-table__table-head-column-settings-trigger",
                        "data-testid": "column-settings-trigger__" + V.property,
                        onClick: q
                      }, null, 8, rz)
                    ]),
                    "popover-items__base": H(({ toggleFloatingUi: q }) => [
                      V.sortable ? (_(), ue(u, {
                        key: 0,
                        label: t.t("columnSettings.sortAscending"),
                        icon: "regular-long-arrow-up",
                        "contextual-detail": "A -> Z",
                        "on-label-click": () => t.onColumnSettingsSortChange(V.property, "ASC", q)
                      }, null, 8, ["label", "on-label-click"])) : W("", !0),
                      V.sortable ? (_(), ue(u, {
                        key: 1,
                        label: t.t("columnSettings.sortDescending"),
                        icon: "regular-long-arrow-down",
                        "contextual-detail": "Z -> A",
                        "on-label-click": () => t.onColumnSettingsSortChange(V.property, "DESC", q)
                      }, null, 8, ["label", "on-label-click"])) : W("", !0),
                      t.isPrimaryColumn(V) ? W("", !0) : (_(), ue(u, {
                        key: 2,
                        label: t.t("columnSettings.hideColumn"),
                        icon: "regular-eye-slash",
                        "on-label-click": () => t.changeColumnVisibility(V.property, !1),
                        "border-top": ""
                      }, null, 8, ["label", "on-label-click"]))
                    ]),
                    _: 2
                  }, 1032, ["title"]),
                  t.highlightedColumn === V.property && !t.isDragging ? (_(), ue(g, {
                    key: 0,
                    "is-opened": !0,
                    offset: 0,
                    class: "mt-data-table__table-head-add-column-indicator",
                    "auto-update-options": { animationFrame: !0 }
                  }, {
                    default: H(() => [
                      fe(c, {
                        title: t.t("addColumnIndicator.popoverTitle"),
                        "onUpdate:isOpened": e[4] || (e[4] = (q) => {
                          q === !1 && (t.forceHighlightedColumn = !1, t.setHighlightedColumn(null));
                        })
                      }, {
                        trigger: H(({ toggleFloatingUi: q }) => [
                          yt(fe(a, {
                            name: "solid-plus-square-s",
                            "data-testid": "add-column-indicator-icon__" + V.property,
                            onMouseenter: () => t.setHighlightedColumn(V),
                            onMouseleave: e[3] || (e[3] = () => t.setHighlightedColumn(null)),
                            onClick: () => {
                              t.forceHighlightedColumn = !0, q();
                            }
                          }, null, 8, ["data-testid", "onMouseenter", "onClick"]), [
                            [Q, {
                              message: t.t("addColumnIndicator.tooltipMessage"),
                              width: "auto"
                            }]
                          ])
                        ]),
                        "popover-items__base": H(({ toggleFloatingUi: q }) => [
                          fe(m, {
                            options: t.addColumnOptions,
                            onSearch: t.onAddColumnSearch,
                            onClickOption: (B) => {
                              t.onAddColumnOptionClick(B, V.property), q();
                            }
                          }, null, 8, ["options", "onSearch", "onClickOption"])
                        ]),
                        _: 2
                      }, 1032, ["title"])
                    ]),
                    _: 2
                  }, 1024)) : W("", !0),
                  V.allowResize !== !1 ? (_(), Z("div", {
                    key: 1,
                    class: "mt-data-table__table-head-resizable mt-data-table__table-head-resizable-before",
                    "data-testid": "mt-data-table__table-head-resizable-before__" + V.property,
                    onMousedown: Tt(
                      () => t.startColumnResizing(t.getPreviousVisibleColumn(V)),
                      ["prevent", "stop"]
                    ),
                    onMouseenter: () => t.setHighlightedColumn(t.getPreviousVisibleColumn(V)),
                    onMouseleave: e[5] || (e[5] = () => t.setHighlightedColumn(null))
                  }, null, 40, oz)) : W("", !0),
                  V.allowResize !== !1 ? (_(), Z("div", {
                    key: 2,
                    class: "mt-data-table__table-head-resizable mt-data-table__table-head-resizable-after",
                    "data-testid": "mt-data-table__table-head-resizable-after__" + V.property,
                    onMousedown: Tt(() => t.startColumnResizing(V), ["prevent", "stop"]),
                    onMouseenter: () => t.setHighlightedColumn(V),
                    onMouseleave: e[6] || (e[6] = () => t.setHighlightedColumn(null))
                  }, null, 40, sz)) : W("", !0)
                ], 46, GX)), [
                  [Y, { ...t.dragConfig, data: V }]
                ]) : W("", !0)
              ], 64))), 256)),
              t.disableSettingsTable && t.disableEdit && t.disableDelete ? W("", !0) : (_(), Z("th", az, [
                t.disableSettingsTable ? W("", !0) : (_(), ue(O, {
                  key: 0,
                  columns: t.sortedColumns,
                  "show-outlines": t.showOutlines,
                  "show-stripes": t.showStripes,
                  "enable-outline-framing": t.enableOutlineFraming,
                  "enable-row-numbering": t.enableRowNumbering,
                  onChangeShowOutlines: e[8] || (e[8] = (V) => t.$emit("change-show-outlines", V)),
                  onChangeShowStripes: e[9] || (e[9] = (V) => t.$emit("change-show-stripes", V)),
                  onChangeOutlineFraming: e[10] || (e[10] = (V) => t.$emit("change-outline-framing", V)),
                  onChangeEnableRowNumbering: e[11] || (e[11] = (V) => t.$emit("change-enable-row-numbering", V)),
                  onResetAllChanges: t.resetAllChanges,
                  onChangeColumnOrder: e[12] || (e[12] = ({ itemId: V, dropId: q, dropZone: B }) => t.changeColumnPosition(V, q, B)),
                  onChangeColumnVisibility: e[13] || (e[13] = (V, q) => t.changeColumnVisibility(V, q))
                }, null, 8, ["columns", "show-outlines", "show-stripes", "enable-outline-framing", "enable-row-numbering", "onResetAllChanges"]))
              ]))
            ])
          ]),
          X("tbody", null, [
            t.dataSource.length > 0 || t.isLoading ? (_(!0), Z(Qe, { key: 0 }, Ge(t.isLoading ? t.emptyData : t.dataSource, (V, q) => (_(), Z("tr", {
              key: V.id,
              class: Ae(t.getColumnDataRowClasses(V.id))
            }, [
              t.enableRowNumbering ? yt((_(), Z("td", lz, [
                X("span", null, Pe(t.getRealIndex(q)), 1)
              ])), [
                [T]
              ]) : W("", !0),
              t.allowRowSelection ? yt((_(), Z("td", uz, [
                fe(p, {
                  checked: t.getSelectionValue(V.id),
                  onChange: (B) => t.onRowSelect(V.id)
                }, null, 8, ["checked", "onChange"])
              ])), [
                [T]
              ]) : W("", !0),
              (_(!0), Z(Qe, null, Ge(t.sortedColumns, (B) => (_(), Z(Qe, null, [
                t.isColumnVisible(B) ? (_(), Z("td", {
                  key: B.property + JSON.stringify(t.columnChanges[B.property]),
                  ref_for: !0,
                  ref: (pe) => {
                    t.setColumnDataCellRefs({ el: pe, column: B, index: q });
                  },
                  "data-cell-column-property": B.property,
                  style: pt(t.renderColumnDataCellStyle(B)),
                  class: Ae(t.getColumnDataCellClasses(B)),
                  onMouseenter: () => t.setCurrentHoveredCell(B.property, V.id),
                  onMouseleave: e[14] || (e[14] = () => t.setCurrentHoveredCell(null, null))
                }, [
                  t.isLoading ? (_(), ue(y, { key: 0 })) : (_(), Z(Qe, { key: 1 }, [
                    B.renderer === "number" ? (_(), ue(b, {
                      key: 0,
                      data: V,
                      "column-definition": B,
                      onClick: (pe) => t.$emit("open-details", V)
                    }, null, 8, ["data", "column-definition", "onClick"])) : B.renderer === "text" ? (_(), ue(v, {
                      key: 1,
                      data: V,
                      "column-definition": B,
                      onClick: (pe) => t.$emit("open-details", V)
                    }, null, 8, ["data", "column-definition", "onClick"])) : B.renderer === "badge" ? (_(), ue(k, {
                      key: 2,
                      data: V,
                      "column-definition": B,
                      onClick: (pe) => t.$emit("open-details", V)
                    }, null, 8, ["data", "column-definition", "onClick"])) : B.renderer === "price" ? (_(), ue(w, {
                      key: 3,
                      data: V,
                      "column-definition": B,
                      onClick: (pe) => t.$emit("open-details", V)
                    }, null, 8, ["data", "column-definition", "onClick"])) : W("", !0)
                  ], 64))
                ], 46, cz)) : W("", !0)
              ], 64))), 256)),
              t.disableSettingsTable && t.disableEdit && t.disableDelete ? W("", !0) : (_(), Z("td", dz, [
                t.disableEdit ? W("", !0) : (_(), Z("a", {
                  key: 0,
                  href: "#",
                  onClick: Tt((B) => t.$emit("open-details", V), ["prevent"])
                }, Pe(t.t("contextButtons.edit")), 9, hz)),
                t.disableDelete && t.disableEdit ? W("", !0) : (_(), ue($, { key: 1 }, {
                  default: H(() => [
                    t.disableEdit ? W("", !0) : (_(), ue(S, {
                      key: 0,
                      label: t.t("contextButtons.edit"),
                      onClick: (B) => t.$emit("open-details", V)
                    }, null, 8, ["label", "onClick"])),
                    t.disableDelete ? W("", !0) : (_(), ue(S, {
                      key: 1,
                      type: "critical",
                      label: t.t("contextButtons.delete"),
                      onClick: (B) => t.$emit("item-delete", V)
                    }, null, 8, ["label", "onClick"]))
                  ]),
                  _: 2
                }, 1024))
              ]))
            ], 2))), 128)) : (_(), Z("div", fz, [
              ne(t.$slots, "empty-state", {}, () => [
                fe(C, {
                  icon: "solid-products",
                  headline: t.t("emptyState.headline"),
                  description: t.t("emptyState.description")
                }, null, 8, ["headline", "description"])
              ])
            ]))
          ])
        ], 512)
      ], 512),
      X("div", {
        style: pt(t.tableStylingVariables),
        class: "mt-data-table__scroll-shadow mt-data-table__scroll-shadow-top"
      }, null, 4),
      X("div", {
        style: pt(t.tableStylingVariables),
        class: "mt-data-table__scroll-shadow mt-data-table__scroll-shadow-right"
      }, null, 4),
      X("div", {
        style: pt(t.tableStylingVariables),
        class: "mt-data-table__scroll-shadow mt-data-table__scroll-shadow-bottom"
      }, null, 4),
      X("div", {
        style: pt(t.tableStylingVariables),
        class: "mt-data-table__scroll-shadow mt-data-table__scroll-shadow-left"
      }, null, 4)
    ]),
    footer: H(() => [
      fe(P, { class: "mt-data-table__footer-inset" }, {
        default: H(() => [
          X("div", pz, [
            fe(L, {
              small: "",
              "hide-clearable-button": "",
              options: t.paginationOptionsConverted,
              "model-value": t.paginationLimit,
              onChange: t.emitPaginationLimitChange
            }, null, 8, ["options", "model-value", "onChange"]),
            X("span", mz, Pe(t.t("itemsPerPage")), 1)
          ]),
          X("div", gz, [
            fe(j, {
              limit: t.paginationLimit,
              "current-page": t.currentPage,
              "total-items": t.paginationTotalItems,
              onChangeCurrentPage: t.emitPaginationCurrentPageChange
            }, null, 8, ["limit", "current-page", "total-items", "onChangeCurrentPage"]),
            t.enableReload ? yt((_(), ue(l, {
              key: 0,
              square: "",
              "aria-label": "reload-data",
              variant: "secondary",
              onClick: t.emitReload
            }, {
              default: H(() => [
                fe(a, { name: "solid-undo-s" })
              ]),
              _: 1
            }, 8, ["onClick"])), [
              [Q, {
                message: t.t("reload.tooltip"),
                width: "auto"
              }]
            ]) : W("", !0)
          ])
        ]),
        _: 1
      })
    ]),
    _: 3
  }, 8, ["class", "title", "subtitle"]);
}
const Zae = /* @__PURE__ */ je(BX, [["render", Oz]]), vz = ["role", "aria-live"], yz = { class: "mt-toast-notification__content" }, bz = { class: "mt-toast-notification__content-left" }, wz = { class: "mt-toast-notification__content-right" }, kz = {
  key: 0,
  class: "mt-toast-notification__timer"
}, Sz = /* @__PURE__ */ Te({
  __name: "mt-toast-notification",
  props: {
    toast: {
      type: Object,
      required: !0
    },
    quickDisplay: {
      type: Boolean,
      required: !1,
      default: !1
    },
    index: {
      type: Number,
      required: !1,
      default: NaN
    }
  },
  emits: ["remove-toast"],
  setup(t, { emit: e }) {
    const n = e, i = t, r = J(() => ({
      "mt-toast-notification--positive": u.value.type === "positive",
      "mt-toast-notification--critical": u.value.type === "critical",
      "mt-toast-notification--informal": u.value.type === "informal"
    })), o = J(() => ({
      "mt-toast-notification__message-space": !!u.value.icon
    })), s = J(() => !(c.value || d.value !== 0 || u.value.type === "critical" && u.value.action)), a = J(() => {
      if (u.value.type === "critical" && u.value.action)
        return "alertdialog";
      switch (u.value.type) {
        case "positive":
        case "informal":
        default:
          return "log";
        case "critical":
          return "alert";
      }
    }), l = J(() => {
      switch (u.value.type) {
        case "positive":
        case "informal":
        default:
          return "polite";
        case "critical":
          return "assertive";
      }
    }), { toast: u, quickDisplay: c, index: d } = zD(i), h = re(null);
    let f = re(void 0), p = re(void 0), m = re(c.value ? 3700 : 10500);
    gt(
      s,
      (v) => {
        if (!v && !c.value) {
          f.value && (window.clearTimeout(f.value), f.value = void 0, m.value = 10500);
          return;
        }
        p.value = Date.now(), f.value = window.setTimeout(() => {
          y();
        }, m.value);
      },
      { immediate: !0 }
    );
    function g() {
      if (!f.value || c.value)
        return;
      window.clearTimeout(f.value);
      const v = p.value ?? Date.now();
      m.value = m.value - (Date.now() - v);
    }
    function O() {
      !s.value || c.value || (p.value = Date.now(), f.value = window.setTimeout(() => {
        y();
      }, m.value));
    }
    function y() {
      f.value && window.clearTimeout(f.value), n("remove-toast", u.value.id);
    }
    function b() {
      var v, k;
      (k = (v = u.value) == null ? void 0 : v.action) == null || k.callback(), y();
    }
    return Et(() => {
      var v;
      !h.value || !u.value.action || u.value.type !== "critical" || (v = h.value) == null || v.focus();
    }), Zs(() => {
      f.value && window.clearTimeout(f.value);
    }), (v, k) => (_(), Z("div", {
      class: Ae(["mt-toast-notification", r.value]),
      ref_key: "toastEl",
      ref: h,
      role: a.value,
      "aria-live": l.value,
      tabindex: "0",
      onMouseenter: g,
      onMouseleave: O,
      onKeydown: ai(y, ["esc"])
    }, [
      X("div", yz, [
        X("div", bz, [
          E(u).icon ? (_(), ue(mt, {
            key: 0,
            class: "mt-toast-notification__icon",
            name: E(u).icon,
            size: "20px"
          }, null, 8, ["name"])) : W("", !0),
          fe(Pi, {
            class: Ae(["mt-toast-notification__message", o.value]),
            color: "color-text-static-default",
            weight: "bold",
            size: "xs",
            title: E(u).msg
          }, {
            default: H(() => [
              He(Pe(E(u).msg), 1)
            ]),
            _: 1
          }, 8, ["class", "title"])
        ]),
        X("div", wz, [
          E(u).action ? (_(), ue(Sr, {
            key: 0,
            onClick: b,
            size: "small"
          }, {
            default: H(() => [
              He(Pe(E(u).action.label), 1)
            ]),
            _: 1
          })) : W("", !0)
        ]),
        E(u).dismissible || E(u).action ? (_(), Z("div", {
          key: 0,
          class: "mt-toast-notification__close-action",
          "aria-hidden": "true",
          "data-testid": "dismiss-toast",
          onClick: y
        }, [
          fe(mt, {
            name: "solid-times-circle",
            size: "20px"
          })
        ])) : W("", !0)
      ]),
      s.value ? (_(), Z("div", kz, k[0] || (k[0] = [
        X("div", { class: "mt-toast-notification__timer-loader" }, null, -1)
      ]))) : W("", !0)
    ], 42, vz));
  }
});
const Ok = /* @__PURE__ */ je(Sz, [["__scopeId", "data-v-eca0bfdc"]]), _z = { class: "mt-toast--bottom-center" }, xz = { class: "mt-toast--bottom-right" }, Cz = /* @__PURE__ */ Te({
  __name: "mt-toast",
  props: {
    /**
     * A collection of toasts. The most current one needs to be prepended.
     */
    toasts: {
      type: Array,
      required: !0
    }
  },
  emits: ["remove-toast"],
  setup(t, { emit: e }) {
    const n = e, i = t, r = re(!1), o = Ca(() => i.toasts), s = re(void 0), a = J(() => o.value.filter((f) => !f.action && f.type !== "critical" && !f.dismissible)[0]), l = J(() => o.value.filter((h) => h.action || h.type === "critical" || h.dismissible)), u = J(() => ({
      "mt-toast--collapsed": !r.value,
      "mt-toast--expanded": r.value
    }));
    gt(a, (h, f) => {
      f && n("remove-toast", f.id);
    });
    function c() {
      s.value && window.clearTimeout(s.value), r.value = !0;
    }
    function d() {
      s.value = window.setTimeout(() => {
        r.value = !1;
      }, 500);
    }
    return (h, f) => (_(), Z("div", {
      class: Ae(["mt-toast", u.value]),
      onMouseenter: c,
      onMouseleave: d
    }, [
      f[1] || (f[1] = X("div", { class: "mt-toast--bottom-left" }, null, -1)),
      X("div", _z, [
        fe(Fn, { name: "quick-toasts" }, {
          default: H(() => [
            a.value ? (_(), ue(Ok, {
              toast: a.value,
              onRemoveToast: f[0] || (f[0] = (p) => h.$emit("remove-toast", a.value.id)),
              "quick-display": !0,
              key: a.value.id
            }, null, 8, ["toast"])) : W("", !0)
          ]),
          _: 1
        })
      ]),
      X("div", xz, [
        fe(Ux, { name: "toasts" }, {
          default: H(() => [
            (_(!0), Z(Qe, null, Ge(l.value, (p, m) => (_(), ue(Ok, {
              key: p.id,
              toast: p,
              onRemoveToast: (g) => h.$emit("remove-toast", p.id),
              style: pt({ "--num": m }),
              index: m
            }, null, 8, ["toast", "onRemoveToast", "style", "index"]))), 128))
          ]),
          _: 1
        })
      ])
    ], 34));
  }
});
const Fae = /* @__PURE__ */ je(Cz, [["__scopeId", "data-v-20c87f8d"]]), o$ = Symbol("DialogContext");
function Td(t) {
  const e = fs(o$, null);
  if (e === null) {
    const n = new Error(`<${t} /> is missing a parent <mt-modal-root /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(n, Td), n;
  }
  return e;
}
const yb = /* @__PURE__ */ Te({
  __name: "mt-modal-close",
  props: {
    as: {}
  },
  setup(t) {
    const { setIsOpen: e } = Td("mt-modal-trigger");
    return (n, i) => (_(), ue(ar(n.as ?? "button"), {
      onClick: i[0] || (i[0] = () => E(e)(!1))
    }, {
      default: H(() => [
        ne(n.$slots, "default")
      ]),
      _: 3
    }));
  }
});
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var s$ = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], Of = /* @__PURE__ */ s$.join(","), a$ = typeof Element > "u", Ra = a$ ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, vf = !a$ && Element.prototype.getRootNode ? function(t) {
  var e;
  return t == null || (e = t.getRootNode) === null || e === void 0 ? void 0 : e.call(t);
} : function(t) {
  return t == null ? void 0 : t.ownerDocument;
}, yf = function t(e, n) {
  var i;
  n === void 0 && (n = !0);
  var r = e == null || (i = e.getAttribute) === null || i === void 0 ? void 0 : i.call(e, "inert"), o = r === "" || r === "true", s = o || n && e && t(e.parentNode);
  return s;
}, Tz = function(e) {
  var n, i = e == null || (n = e.getAttribute) === null || n === void 0 ? void 0 : n.call(e, "contenteditable");
  return i === "" || i === "true";
}, l$ = function(e, n, i) {
  if (yf(e))
    return [];
  var r = Array.prototype.slice.apply(e.querySelectorAll(Of));
  return n && Ra.call(e, Of) && r.unshift(e), r = r.filter(i), r;
}, u$ = function t(e, n, i) {
  for (var r = [], o = Array.from(e); o.length; ) {
    var s = o.shift();
    if (!yf(s, !1))
      if (s.tagName === "SLOT") {
        var a = s.assignedElements(), l = a.length ? a : s.children, u = t(l, !0, i);
        i.flatten ? r.push.apply(r, u) : r.push({
          scopeParent: s,
          candidates: u
        });
      } else {
        var c = Ra.call(s, Of);
        c && i.filter(s) && (n || !e.includes(s)) && r.push(s);
        var d = s.shadowRoot || // check for an undisclosed shadow
        typeof i.getShadowRoot == "function" && i.getShadowRoot(s), h = !yf(d, !1) && (!i.shadowRootFilter || i.shadowRootFilter(s));
        if (d && h) {
          var f = t(d === !0 ? s.children : d.children, !0, i);
          i.flatten ? r.push.apply(r, f) : r.push({
            scopeParent: s,
            candidates: f
          });
        } else
          o.unshift.apply(o, s.children);
      }
  }
  return r;
}, c$ = function(e) {
  return !isNaN(parseInt(e.getAttribute("tabindex"), 10));
}, ra = function(e) {
  if (!e)
    throw new Error("No node provided");
  return e.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName) || Tz(e)) && !c$(e) ? 0 : e.tabIndex;
}, $z = function(e, n) {
  var i = ra(e);
  return i < 0 && n && !c$(e) ? 0 : i;
}, Pz = function(e, n) {
  return e.tabIndex === n.tabIndex ? e.documentOrder - n.documentOrder : e.tabIndex - n.tabIndex;
}, d$ = function(e) {
  return e.tagName === "INPUT";
}, Mz = function(e) {
  return d$(e) && e.type === "hidden";
}, Ez = function(e) {
  var n = e.tagName === "DETAILS" && Array.prototype.slice.apply(e.children).some(function(i) {
    return i.tagName === "SUMMARY";
  });
  return n;
}, Az = function(e, n) {
  for (var i = 0; i < e.length; i++)
    if (e[i].checked && e[i].form === n)
      return e[i];
}, Rz = function(e) {
  if (!e.name)
    return !0;
  var n = e.form || vf(e), i = function(a) {
    return n.querySelectorAll('input[type="radio"][name="' + a + '"]');
  }, r;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    r = i(window.CSS.escape(e.name));
  else
    try {
      r = i(e.name);
    } catch (s) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", s.message), !1;
    }
  var o = Az(r, e.form);
  return !o || o === e;
}, Dz = function(e) {
  return d$(e) && e.type === "radio";
}, Qz = function(e) {
  return Dz(e) && !Rz(e);
}, Nz = function(e) {
  var n, i = e && vf(e), r = (n = i) === null || n === void 0 ? void 0 : n.host, o = !1;
  if (i && i !== e) {
    var s, a, l;
    for (o = !!((s = r) !== null && s !== void 0 && (a = s.ownerDocument) !== null && a !== void 0 && a.contains(r) || e != null && (l = e.ownerDocument) !== null && l !== void 0 && l.contains(e)); !o && r; ) {
      var u, c, d;
      i = vf(r), r = (u = i) === null || u === void 0 ? void 0 : u.host, o = !!((c = r) !== null && c !== void 0 && (d = c.ownerDocument) !== null && d !== void 0 && d.contains(r));
    }
  }
  return o;
}, vk = function(e) {
  var n = e.getBoundingClientRect(), i = n.width, r = n.height;
  return i === 0 && r === 0;
}, Iz = function(e, n) {
  var i = n.displayCheck, r = n.getShadowRoot;
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  var o = Ra.call(e, "details>summary:first-of-type"), s = o ? e.parentElement : e;
  if (Ra.call(s, "details:not([open]) *"))
    return !0;
  if (!i || i === "full" || i === "legacy-full") {
    if (typeof r == "function") {
      for (var a = e; e; ) {
        var l = e.parentElement, u = vf(e);
        if (l && !l.shadowRoot && r(l) === !0)
          return vk(e);
        e.assignedSlot ? e = e.assignedSlot : !l && u !== e.ownerDocument ? e = u.host : e = l;
      }
      e = a;
    }
    if (Nz(e))
      return !e.getClientRects().length;
    if (i !== "legacy-full")
      return !0;
  } else if (i === "non-zero-area")
    return vk(e);
  return !1;
}, Lz = function(e) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))
    for (var n = e.parentElement; n; ) {
      if (n.tagName === "FIELDSET" && n.disabled) {
        for (var i = 0; i < n.children.length; i++) {
          var r = n.children.item(i);
          if (r.tagName === "LEGEND")
            return Ra.call(n, "fieldset[disabled] *") ? !0 : !r.contains(e);
        }
        return !0;
      }
      n = n.parentElement;
    }
  return !1;
}, bf = function(e, n) {
  return !(n.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  yf(n) || Mz(n) || Iz(n, e) || // For a details element with a summary, the summary element gets the focus
  Ez(n) || Lz(n));
}, VO = function(e, n) {
  return !(Qz(n) || ra(n) < 0 || !bf(e, n));
}, Vz = function(e) {
  var n = parseInt(e.getAttribute("tabindex"), 10);
  return !!(isNaN(n) || n >= 0);
}, Bz = function t(e) {
  var n = [], i = [];
  return e.forEach(function(r, o) {
    var s = !!r.scopeParent, a = s ? r.scopeParent : r, l = $z(a, s), u = s ? t(r.candidates) : a;
    l === 0 ? s ? n.push.apply(n, u) : n.push(a) : i.push({
      documentOrder: o,
      tabIndex: l,
      item: r,
      isScope: s,
      content: u
    });
  }), i.sort(Pz).reduce(function(r, o) {
    return o.isScope ? r.push.apply(r, o.content) : r.push(o.content), r;
  }, []).concat(n);
}, Zz = function(e, n) {
  n = n || {};
  var i;
  return n.getShadowRoot ? i = u$([e], n.includeContainer, {
    filter: VO.bind(null, n),
    flatten: !1,
    getShadowRoot: n.getShadowRoot,
    shadowRootFilter: Vz
  }) : i = l$(e, n.includeContainer, VO.bind(null, n)), Bz(i);
}, Fz = function(e, n) {
  n = n || {};
  var i;
  return n.getShadowRoot ? i = u$([e], n.includeContainer, {
    filter: bf.bind(null, n),
    flatten: !0,
    getShadowRoot: n.getShadowRoot
  }) : i = l$(e, n.includeContainer, bf.bind(null, n)), i;
}, el = function(e, n) {
  if (n = n || {}, !e)
    throw new Error("No node provided");
  return Ra.call(e, Of) === !1 ? !1 : VO(n, e);
}, qz = /* @__PURE__ */ s$.concat("iframe").join(","), sg = function(e, n) {
  if (n = n || {}, !e)
    throw new Error("No node provided");
  return Ra.call(e, qz) === !1 ? !1 : bf(n, e);
};
/*!
* focus-trap 7.5.4
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
function yk(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function bk(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? yk(Object(n), !0).forEach(function(i) {
      Wz(t, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : yk(Object(n)).forEach(function(i) {
      Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t;
}
function Wz(t, e, n) {
  return e = zz(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function Xz(t, e) {
  if (typeof t != "object" || t === null)
    return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var i = n.call(t, e || "default");
    if (typeof i != "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function zz(t) {
  var e = Xz(t, "string");
  return typeof e == "symbol" ? e : String(e);
}
var wk = {
  activateTrap: function(e, n) {
    if (e.length > 0) {
      var i = e[e.length - 1];
      i !== n && i.pause();
    }
    var r = e.indexOf(n);
    r === -1 || e.splice(r, 1), e.push(n);
  },
  deactivateTrap: function(e, n) {
    var i = e.indexOf(n);
    i !== -1 && e.splice(i, 1), e.length > 0 && e[e.length - 1].unpause();
  }
}, jz = function(e) {
  return e.tagName && e.tagName.toLowerCase() === "input" && typeof e.select == "function";
}, Yz = function(e) {
  return (e == null ? void 0 : e.key) === "Escape" || (e == null ? void 0 : e.key) === "Esc" || (e == null ? void 0 : e.keyCode) === 27;
}, dc = function(e) {
  return (e == null ? void 0 : e.key) === "Tab" || (e == null ? void 0 : e.keyCode) === 9;
}, Hz = function(e) {
  return dc(e) && !e.shiftKey;
}, Uz = function(e) {
  return dc(e) && e.shiftKey;
}, kk = function(e) {
  return setTimeout(e, 0);
}, Sk = function(e, n) {
  var i = -1;
  return e.every(function(r, o) {
    return n(r) ? (i = o, !1) : !0;
  }), i;
}, Ru = function(e) {
  for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++)
    i[r - 1] = arguments[r];
  return typeof e == "function" ? e.apply(void 0, i) : e;
}, zd = function(e) {
  return e.target.shadowRoot && typeof e.composedPath == "function" ? e.composedPath()[0] : e.target;
}, Gz = [], Kz = function(e, n) {
  var i = (n == null ? void 0 : n.document) || document, r = (n == null ? void 0 : n.trapStack) || Gz, o = bk({
    returnFocusOnDeactivate: !0,
    escapeDeactivates: !0,
    delayInitialFocus: !0,
    isKeyForward: Hz,
    isKeyBackward: Uz
  }, n), s = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: !1,
    paused: !1,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  }, a, l = function(P, A, T) {
    return P && P[A] !== void 0 ? P[A] : o[T || A];
  }, u = function(P, A) {
    var T = typeof (A == null ? void 0 : A.composedPath) == "function" ? A.composedPath() : void 0;
    return s.containerGroups.findIndex(function(N) {
      var Q = N.container, Y = N.tabbableNodes;
      return Q.contains(P) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (T == null ? void 0 : T.includes(Q)) || Y.find(function(V) {
        return V === P;
      });
    });
  }, c = function(P) {
    var A = o[P];
    if (typeof A == "function") {
      for (var T = arguments.length, N = new Array(T > 1 ? T - 1 : 0), Q = 1; Q < T; Q++)
        N[Q - 1] = arguments[Q];
      A = A.apply(void 0, N);
    }
    if (A === !0 && (A = void 0), !A) {
      if (A === void 0 || A === !1)
        return A;
      throw new Error("`".concat(P, "` was specified but was not a node, or did not return a node"));
    }
    var Y = A;
    if (typeof A == "string" && (Y = i.querySelector(A), !Y))
      throw new Error("`".concat(P, "` as selector refers to no known node"));
    return Y;
  }, d = function() {
    var P = c("initialFocus");
    if (P === !1)
      return !1;
    if (P === void 0 || !sg(P, o.tabbableOptions))
      if (u(i.activeElement) >= 0)
        P = i.activeElement;
      else {
        var A = s.tabbableGroups[0], T = A && A.firstTabbableNode;
        P = T || c("fallbackFocus");
      }
    if (!P)
      throw new Error("Your focus-trap needs to have at least one focusable element");
    return P;
  }, h = function() {
    if (s.containerGroups = s.containers.map(function(P) {
      var A = Zz(P, o.tabbableOptions), T = Fz(P, o.tabbableOptions), N = A.length > 0 ? A[0] : void 0, Q = A.length > 0 ? A[A.length - 1] : void 0, Y = T.find(function(B) {
        return el(B);
      }), V = T.slice().reverse().find(function(B) {
        return el(B);
      }), q = !!A.find(function(B) {
        return ra(B) > 0;
      });
      return {
        container: P,
        tabbableNodes: A,
        focusableNodes: T,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound: q,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode: N,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode: Q,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode: Y,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode: V,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function(pe) {
          var oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, te = A.indexOf(pe);
          return te < 0 ? oe ? T.slice(T.indexOf(pe) + 1).find(function(M) {
            return el(M);
          }) : T.slice(0, T.indexOf(pe)).reverse().find(function(M) {
            return el(M);
          }) : A[te + (oe ? 1 : -1)];
        }
      };
    }), s.tabbableGroups = s.containerGroups.filter(function(P) {
      return P.tabbableNodes.length > 0;
    }), s.tabbableGroups.length <= 0 && !c("fallbackFocus"))
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    if (s.containerGroups.find(function(P) {
      return P.posTabIndexesFound;
    }) && s.containerGroups.length > 1)
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
  }, f = function j(P) {
    var A = P.activeElement;
    if (A)
      return A.shadowRoot && A.shadowRoot.activeElement !== null ? j(A.shadowRoot) : A;
  }, p = function j(P) {
    if (P !== !1 && P !== f(document)) {
      if (!P || !P.focus) {
        j(d());
        return;
      }
      P.focus({
        preventScroll: !!o.preventScroll
      }), s.mostRecentlyFocusedNode = P, jz(P) && P.select();
    }
  }, m = function(P) {
    var A = c("setReturnFocus", P);
    return A || (A === !1 ? !1 : P);
  }, g = function(P) {
    var A = P.target, T = P.event, N = P.isBackward, Q = N === void 0 ? !1 : N;
    A = A || zd(T), h();
    var Y = null;
    if (s.tabbableGroups.length > 0) {
      var V = u(A, T), q = V >= 0 ? s.containerGroups[V] : void 0;
      if (V < 0)
        Q ? Y = s.tabbableGroups[s.tabbableGroups.length - 1].lastTabbableNode : Y = s.tabbableGroups[0].firstTabbableNode;
      else if (Q) {
        var B = Sk(s.tabbableGroups, function(ce) {
          var F = ce.firstTabbableNode;
          return A === F;
        });
        if (B < 0 && (q.container === A || sg(A, o.tabbableOptions) && !el(A, o.tabbableOptions) && !q.nextTabbableNode(A, !1)) && (B = V), B >= 0) {
          var pe = B === 0 ? s.tabbableGroups.length - 1 : B - 1, oe = s.tabbableGroups[pe];
          Y = ra(A) >= 0 ? oe.lastTabbableNode : oe.lastDomTabbableNode;
        } else
          dc(T) || (Y = q.nextTabbableNode(A, !1));
      } else {
        var te = Sk(s.tabbableGroups, function(ce) {
          var F = ce.lastTabbableNode;
          return A === F;
        });
        if (te < 0 && (q.container === A || sg(A, o.tabbableOptions) && !el(A, o.tabbableOptions) && !q.nextTabbableNode(A)) && (te = V), te >= 0) {
          var M = te === s.tabbableGroups.length - 1 ? 0 : te + 1, G = s.tabbableGroups[M];
          Y = ra(A) >= 0 ? G.firstTabbableNode : G.firstDomTabbableNode;
        } else
          dc(T) || (Y = q.nextTabbableNode(A));
      }
    } else
      Y = c("fallbackFocus");
    return Y;
  }, O = function(P) {
    var A = zd(P);
    if (!(u(A, P) >= 0)) {
      if (Ru(o.clickOutsideDeactivates, P)) {
        a.deactivate({
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked (and if not focusable, to "nothing"); by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node), whether the
          //  outside click was on a focusable node or not
          returnFocus: o.returnFocusOnDeactivate
        });
        return;
      }
      Ru(o.allowOutsideClick, P) || P.preventDefault();
    }
  }, y = function(P) {
    var A = zd(P), T = u(A, P) >= 0;
    if (T || A instanceof Document)
      T && (s.mostRecentlyFocusedNode = A);
    else {
      P.stopImmediatePropagation();
      var N, Q = !0;
      if (s.mostRecentlyFocusedNode)
        if (ra(s.mostRecentlyFocusedNode) > 0) {
          var Y = u(s.mostRecentlyFocusedNode), V = s.containerGroups[Y].tabbableNodes;
          if (V.length > 0) {
            var q = V.findIndex(function(B) {
              return B === s.mostRecentlyFocusedNode;
            });
            q >= 0 && (o.isKeyForward(s.recentNavEvent) ? q + 1 < V.length && (N = V[q + 1], Q = !1) : q - 1 >= 0 && (N = V[q - 1], Q = !1));
          }
        } else
          s.containerGroups.some(function(B) {
            return B.tabbableNodes.some(function(pe) {
              return ra(pe) > 0;
            });
          }) || (Q = !1);
      else
        Q = !1;
      Q && (N = g({
        // move FROM the MRU node, not event-related node (which will be the node that is
        //  outside the trap causing the focus escape we're trying to fix)
        target: s.mostRecentlyFocusedNode,
        isBackward: o.isKeyBackward(s.recentNavEvent)
      })), p(N || s.mostRecentlyFocusedNode || d());
    }
    s.recentNavEvent = void 0;
  }, b = function(P) {
    var A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    s.recentNavEvent = P;
    var T = g({
      event: P,
      isBackward: A
    });
    T && (dc(P) && P.preventDefault(), p(T));
  }, v = function(P) {
    if (Yz(P) && Ru(o.escapeDeactivates, P) !== !1) {
      P.preventDefault(), a.deactivate();
      return;
    }
    (o.isKeyForward(P) || o.isKeyBackward(P)) && b(P, o.isKeyBackward(P));
  }, k = function(P) {
    var A = zd(P);
    u(A, P) >= 0 || Ru(o.clickOutsideDeactivates, P) || Ru(o.allowOutsideClick, P) || (P.preventDefault(), P.stopImmediatePropagation());
  }, w = function() {
    if (s.active)
      return wk.activateTrap(r, a), s.delayInitialFocusTimer = o.delayInitialFocus ? kk(function() {
        p(d());
      }) : p(d()), i.addEventListener("focusin", y, !0), i.addEventListener("mousedown", O, {
        capture: !0,
        passive: !1
      }), i.addEventListener("touchstart", O, {
        capture: !0,
        passive: !1
      }), i.addEventListener("click", k, {
        capture: !0,
        passive: !1
      }), i.addEventListener("keydown", v, {
        capture: !0,
        passive: !1
      }), a;
  }, S = function() {
    if (s.active)
      return i.removeEventListener("focusin", y, !0), i.removeEventListener("mousedown", O, !0), i.removeEventListener("touchstart", O, !0), i.removeEventListener("click", k, !0), i.removeEventListener("keydown", v, !0), a;
  }, $ = function(P) {
    var A = P.some(function(T) {
      var N = Array.from(T.removedNodes);
      return N.some(function(Q) {
        return Q === s.mostRecentlyFocusedNode;
      });
    });
    A && p(d());
  }, C = typeof window < "u" && "MutationObserver" in window ? new MutationObserver($) : void 0, L = function() {
    C && (C.disconnect(), s.active && !s.paused && s.containers.map(function(P) {
      C.observe(P, {
        subtree: !0,
        childList: !0
      });
    }));
  };
  return a = {
    get active() {
      return s.active;
    },
    get paused() {
      return s.paused;
    },
    activate: function(P) {
      if (s.active)
        return this;
      var A = l(P, "onActivate"), T = l(P, "onPostActivate"), N = l(P, "checkCanFocusTrap");
      N || h(), s.active = !0, s.paused = !1, s.nodeFocusedBeforeActivation = i.activeElement, A == null || A();
      var Q = function() {
        N && h(), w(), L(), T == null || T();
      };
      return N ? (N(s.containers.concat()).then(Q, Q), this) : (Q(), this);
    },
    deactivate: function(P) {
      if (!s.active)
        return this;
      var A = bk({
        onDeactivate: o.onDeactivate,
        onPostDeactivate: o.onPostDeactivate,
        checkCanReturnFocus: o.checkCanReturnFocus
      }, P);
      clearTimeout(s.delayInitialFocusTimer), s.delayInitialFocusTimer = void 0, S(), s.active = !1, s.paused = !1, L(), wk.deactivateTrap(r, a);
      var T = l(A, "onDeactivate"), N = l(A, "onPostDeactivate"), Q = l(A, "checkCanReturnFocus"), Y = l(A, "returnFocus", "returnFocusOnDeactivate");
      T == null || T();
      var V = function() {
        kk(function() {
          Y && p(m(s.nodeFocusedBeforeActivation)), N == null || N();
        });
      };
      return Y && Q ? (Q(m(s.nodeFocusedBeforeActivation)).then(V, V), this) : (V(), this);
    },
    pause: function(P) {
      if (s.paused || !s.active)
        return this;
      var A = l(P, "onPause"), T = l(P, "onPostPause");
      return s.paused = !0, A == null || A(), S(), L(), T == null || T(), this;
    },
    unpause: function(P) {
      if (!s.paused || !s.active)
        return this;
      var A = l(P, "onUnpause"), T = l(P, "onPostUnpause");
      return s.paused = !1, A == null || A(), h(), w(), L(), T == null || T(), this;
    },
    updateContainerElements: function(P) {
      var A = [].concat(P).filter(Boolean);
      return s.containers = A.map(function(T) {
        return typeof T == "string" ? i.querySelector(T) : T;
      }), s.active && h(), L(), this;
    }
  }, a.updateContainerElements(e), a;
};
const Jz = { class: "mt-modal__header" }, ej = { class: "mt-modal__header-content" }, tj = {
  key: 0,
  class: "mt-modal__scroll-shadow mt-modal__scroll-shadow--top"
}, nj = {
  key: 0,
  class: "mt-modal__scroll-shadow mt-modal__scroll-shadow--bottom"
}, ij = { class: "mt-modal__footer" }, rj = 24, oj = /* @__PURE__ */ Te({
  __name: "mt-modal",
  props: {
    title: {
      type: String,
      required: !0
    },
    width: {
      type: String,
      required: !1,
      default: "m"
    },
    inset: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(t) {
    const e = `mt-modal--${za()}`, { isOpen: n, setIsOpen: i } = Td("mt-modal");
    let r;
    gt(
      n,
      (c) => {
        c ? (r = (d) => {
          d.key === "Escape" && i(!1);
        }, document.addEventListener("keydown", r)) : r && document.removeEventListener("keydown", r);
      },
      { immediate: !0 }
    ), to(() => {
      r && document.removeEventListener("keydown", r);
    });
    const o = re(null);
    let s;
    gt(
      n,
      async () => {
        const c = !!n.value;
        if (c && await nn(), !!o.value) {
          if (c) {
            s = Kz(o.value, {
              tabbableOptions: { displayCheck: "none" },
              allowOutsideClick: !0
            }), s.activate();
            return;
          }
          s && s.deactivate();
        }
      },
      { immediate: !0 }
    ), to(() => {
      s && s.deactivate();
    });
    const a = re(null), l = re("none");
    Et(async () => {
      if (!n.value || !a.value)
        return;
      await nn(), a.value.scrollHeight > a.value.clientHeight && (l.value = "top");
    });
    function u(c) {
      if (!(c.target instanceof Element))
        return;
      if (!(c.target.scrollHeight > c.target.clientHeight)) {
        l.value = "none";
        return;
      }
      if (c.target.scrollTop < rj) {
        l.value = "top";
        return;
      }
      if (Math.abs(c.target.scrollHeight - c.target.scrollTop - c.target.clientHeight) < 1) {
        l.value = "bottom";
        return;
      }
      l.value = "middle";
    }
    return gt(
      n,
      async () => {
        if (!n.value) {
          if (l.value = "top", !a.value)
            return;
          a.value.removeEventListener("scroll", u);
          return;
        }
        await nn(), a.value && a.value.addEventListener("scroll", u);
      },
      { immediate: !0 }
    ), to(() => {
      a.value && a.value.removeEventListener("scroll", u);
    }), (c, d) => (_(), ue(Fn, { name: "modal" }, {
      default: H(() => [
        (_(), ue(My, { to: "body" }, [
          E(n) ? (_(), Z("div", {
            key: 0,
            ref_key: "modalRef",
            ref: o,
            class: Ae(["mt-modal", `mt-modal--width-${t.width}`]),
            role: "dialog",
            "aria-modal": "true",
            "aria-labelledby": e
          }, [
            X("div", Jz, [
              X("div", ej, [
                fe(Pi, {
                  as: "h2",
                  class: "mt-modal__title",
                  size: "m",
                  weight: "semibold",
                  id: e
                }, {
                  default: H(() => [
                    He(Pe(t.title), 1)
                  ]),
                  _: 1
                }),
                ne(c.$slots, "title-after", {}, void 0, !0)
              ]),
              fe(yb, {
                class: "mt-modal__close-button",
                "aria-label": "Close"
              }, {
                default: H(() => [
                  fe(mt, {
                    "aria-hidden": "",
                    name: "regular-times-xs"
                  })
                ]),
                _: 1
              })
            ]),
            X("div", {
              class: "mt-modal__content",
              ref_key: "modalContentRef",
              ref: a
            }, [
              fe(Fn, { name: "shadow-fade" }, {
                default: H(() => [
                  ["bottom", "middle"].includes(l.value) ? (_(), Z("div", tj)) : W("", !0)
                ]),
                _: 1
              }),
              X("div", {
                class: Ae({
                  "mt-modal__content-inner": !0,
                  "mt-modal__content-inner--no-padding": t.inset
                })
              }, [
                ne(c.$slots, "default", {}, void 0, !0)
              ], 2),
              fe(Fn, { name: "shadow-fade" }, {
                default: H(() => [
                  ["top", "middle"].includes(l.value) ? (_(), Z("div", nj)) : W("", !0)
                ]),
                _: 1
              })
            ], 512),
            X("div", ij, [
              ne(c.$slots, "footer", {}, void 0, !0)
            ])
          ], 2)) : W("", !0)
        ]))
      ]),
      _: 3
    }));
  }
});
const h$ = /* @__PURE__ */ je(oj, [["__scopeId", "data-v-6ea188e0"]]), sj = /* @__PURE__ */ Te({
  __name: "mt-modal-root",
  props: {
    isOpen: { type: Boolean }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const n = t, i = e, r = re(n.isOpen);
    gt(r, () => {
      i("change", r.value);
    }), gt(
      () => n.isOpen,
      (s) => {
        r.value = s;
      }
    );
    function o(s) {
      r.value = s;
    }
    return ua(o$, {
      isOpen: r,
      setIsOpen: o
    }), (s, a) => (_(), Z(Qe, null, [
      ne(s.$slots, "default", {}, void 0, !0),
      fe(Fn, { name: "fade" }, {
        default: H(() => [
          (_(), ue(My, { to: "body" }, [
            r.value ? (_(), Z("div", {
              key: 0,
              class: "mt-modal-root__backdrop",
              "aria-hidden": "",
              "data-testid": "modal-backdrop",
              onClick: a[0] || (a[0] = () => o(!1))
            })) : W("", !0)
          ]))
        ]),
        _: 1
      })
    ], 64));
  }
});
const f$ = /* @__PURE__ */ je(sj, [["__scopeId", "data-v-9f7d61dc"]]), qae = /* @__PURE__ */ Te({
  __name: "mt-modal-trigger",
  props: {
    as: {}
  },
  setup(t) {
    const { setIsOpen: e } = Td("mt-modal-trigger");
    return (n, i) => (_(), ue(ar(n.as), {
      onClick: i[0] || (i[0] = () => E(e)(!0))
    }, {
      default: H(() => [
        ne(n.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Wae = /* @__PURE__ */ Te({
  __name: "mt-modal-action",
  props: {
    as: {}
  },
  emits: ["click"],
  setup(t) {
    const { setIsOpen: e } = Td("mt-modal-trigger"), n = () => e(!1);
    return (i, r) => (_(), ue(ar(i.as), {
      onClick: r[0] || (r[0] = (o) => i.$emit("click", n))
    }, {
      default: H(() => [
        ne(i.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Xae = /* @__PURE__ */ Te({
  __name: "mt-theme-provider",
  props: {
    future: {}
  },
  setup(t) {
    return hB(t.future), (n, i) => ne(n.$slots, "default");
  }
});
function BO() {
  this.listeners = [], window.addEventListener("resize", this.resize.bind(this));
}
BO.prototype = Object.assign(BO.prototype, {
  /**
   * Resize method which will be fired when the user resizes the browser.
   *
   * @returns {void}
   */
  resize: Kp(function(e) {
    this.listeners.forEach((n) => {
      n.listener.call(n.scope, e);
    });
  }, 100),
  /**
   * Registers an event register for the browser "resize" event.
   *
   * @param {Function} callback
   * @param {Any} scope
   * @param {Object} component
   * @returns {number}
   */
  onResize({ listener: t, scope: e, component: n }) {
    return e || (e = window), this.listeners.push({ listener: t, scope: e, component: n }), this.listeners.length - 1;
  },
  removeResizeListener(t) {
    return this.listeners = this.listeners.filter(
      (e) => t !== e.component
    ), !0;
  },
  /**
   * Returns the user agent string.
   *
   * @returns {string}
   */
  getUserAgent() {
    return window.navigator.userAgent;
  },
  /**
   * Returns the current viewport with in pixels.
   * @returns {number}
   */
  getViewportWidth() {
    return window.innerWidth;
  },
  /**
   * Returns the current viewport height in pixels.
   *
   * @returns {number}
   */
  getViewportHeight() {
    return window.innerHeight;
  },
  /**
   * Returns the pixel ratio of the device as a number.
   *
   * @returns {number}
   */
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  },
  /**
   * Returns the device screen width in pixels.
   *
   * @returns {number}
   */
  getScreenWidth() {
    return window.screen.width;
  },
  /**
   * Returns the device screen height in pixels.
   *
   * @returns {number}
   */
  getScreenHeight() {
    return window.screen.height;
  },
  /**
   * Returns information about the screen orientation.
   *
   * @returns {object}
   */
  getScreenOrientation() {
    return window.screen.orientation;
  },
  /**
   * Returns the current browser language as a string.
   *
   * @returns {string}
   */
  getBrowserLanguage() {
    return window.navigator.language;
  },
  /**
   * Returns the current platform (e.g. "Win32") as a string.
   *
   * @returns {string}
   */
  getPlatform() {
    return window.navigator.platform;
  },
  /**
   * Returns the system-key (e.g. "CTRL") as a string depending of the current operating system.
   *
   * @returns {string}
   */
  getSystemKey() {
    return this.getPlatform().indexOf("Mac") > -1 ? "CTRL" : "ALT";
  }
});
const zae = {
  install(t) {
    const e = new BO();
    return t.config.globalProperties.$device = e, t.mixin({
      unmounted() {
        this.$device.removeResizeListener(this);
      }
    }), !0;
  }
};
function aj() {
  return typeof window < "u";
}
function lj(t) {
  return p$(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function uj(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function p$(t) {
  return aj() ? t instanceof Node || t instanceof uj(t).Node : !1;
}
function cj(t) {
  return t != null && typeof t == "object" && "$el" in t;
}
function ZO(t) {
  if (cj(t)) {
    const e = t.$el;
    return p$(e) && lj(e) === "#comment" ? null : e;
  }
  return t;
}
function al(t) {
  return typeof t == "function" ? t() : E(t);
}
function dj(t) {
  return {
    name: "arrow",
    options: t,
    fn(e) {
      const n = ZO(al(t.element));
      return n == null ? {} : BT({
        element: n,
        padding: t.padding
      }).fn(e);
    }
  };
}
function m$(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function _k(t, e) {
  const n = m$(t);
  return Math.round(e * n) / n;
}
function hj(t, e, n) {
  n === void 0 && (n = {});
  const i = n.whileElementsMounted, r = J(() => {
    var S;
    return (S = al(n.open)) != null ? S : !0;
  }), o = J(() => al(n.middleware)), s = J(() => {
    var S;
    return (S = al(n.placement)) != null ? S : "bottom";
  }), a = J(() => {
    var S;
    return (S = al(n.strategy)) != null ? S : "absolute";
  }), l = J(() => {
    var S;
    return (S = al(n.transform)) != null ? S : !0;
  }), u = J(() => ZO(t.value)), c = J(() => ZO(e.value)), d = re(0), h = re(0), f = re(a.value), p = re(s.value), m = vd({}), g = re(!1), O = J(() => {
    const S = {
      position: f.value,
      left: "0",
      top: "0"
    };
    if (!c.value)
      return S;
    const $ = _k(c.value, d.value), C = _k(c.value, h.value);
    return l.value ? {
      ...S,
      transform: "translate(" + $ + "px, " + C + "px)",
      ...m$(c.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: f.value,
      left: $ + "px",
      top: C + "px"
    };
  });
  let y;
  function b() {
    if (u.value == null || c.value == null)
      return;
    const S = r.value;
    ZT(u.value, c.value, {
      middleware: o.value,
      placement: s.value,
      strategy: a.value
    }).then(($) => {
      d.value = $.x, h.value = $.y, f.value = $.strategy, p.value = $.placement, m.value = $.middlewareData, g.value = S !== !1;
    });
  }
  function v() {
    typeof y == "function" && (y(), y = void 0);
  }
  function k() {
    if (v(), i === void 0) {
      b();
      return;
    }
    if (u.value != null && c.value != null) {
      y = i(u.value, c.value, b);
      return;
    }
  }
  function w() {
    r.value || (g.value = !1);
  }
  return gt([o, s, a, r], b, {
    flush: "sync"
  }), gt([u, c], k, {
    flush: "sync"
  }), gt(r, w, {
    flush: "sync"
  }), Ey() && Ay(v), {
    x: Ga(d),
    y: Ga(h),
    strategy: Ga(f),
    placement: Ga(p),
    middlewareData: Ga(m),
    isPositioned: Ga(g),
    floatingStyles: O,
    update: b
  };
}
function fj() {
  const t = re();
  return Et(() => t.value = za()), t;
}
function pj() {
  const t = re(!1), e = Bs({
    isFocusingTrigger: !1,
    isPressingTrigger: !1,
    isHoveringTrigger: !1,
    isHoveringTooltip: !1,
    gotOpenedBy: null
  });
  function n(o) {
    Object.assign(e, o);
  }
  function i({ gotOpenedBy: o }) {
    !e.isFocusingTrigger && !e.isHoveringTrigger || e.isPressingTrigger || e.isFocusingTrigger && e.isHoveringTrigger && e.gotOpenedBy === "focus" || (t.value = !0, e.gotOpenedBy = o);
  }
  function r({ causedByKeyPress: o } = { causedByKeyPress: !1 }) {
    if (e.isFocusingTrigger && e.gotOpenedBy === "hover") {
      e.gotOpenedBy = null, t.value = !1;
      return;
    }
    if (t.value && e.isPressingTrigger) {
      e.gotOpenedBy = null, t.value = !1;
      return;
    }
    if (e.isHoveringTrigger && e.isFocusingTrigger && o) {
      e.gotOpenedBy = null, t.value = !1;
      return;
    }
    e.isFocusingTrigger && !o || e.isHoveringTooltip || e.isHoveringTrigger || (e.gotOpenedBy = null, t.value = !1);
  }
  return { isVisible: t, show: i, hide: r, setState: n };
}
const mj = ["data-placement"], gj = ["id"], Oj = /* @__PURE__ */ Te({
  __name: "mt-tooltip",
  props: {
    content: {},
    delayDurationInMs: { default: 500 },
    hideDelayDurationInMs: { default: 300 },
    placement: { default: "top" }
  },
  setup(t) {
    const e = t, n = fj();
    Et(() => {
      nn(() => {
        const k = document.querySelector(
          `#mt-tooltip--${n.value}__trigger`
        );
        if (!k)
          throw new Error(
            `Failed to render mt-tooltip; Could not find trigger element with id: "mt-tooltip-${n.value}__trigger"`
          );
        p.value = k;
      });
    });
    const { isVisible: i, show: r, hide: o, setState: s } = pj();
    function a(k) {
      var S;
      if ((S = k == null ? void 0 : k.relatedTarget) == null ? void 0 : S.closest(`#${n.value}`)) {
        k.target.focus();
        return;
      }
      s({ isFocusingTrigger: !1 }), o();
    }
    const l = lk(e.delayDurationInMs, {
      controls: !0,
      callback: () => r({ gotOpenedBy: "hover" })
    }), u = lk(e.hideDelayDurationInMs, {
      controls: !0,
      callback: o
    });
    function c() {
      s({ isHoveringTrigger: !0 }), l.start();
    }
    function d() {
      l.stop(), s({ isHoveringTrigger: !1 }), u.start();
    }
    function h() {
      l.stop(), s({ isPressingTrigger: !0 }), o();
    }
    function f() {
      s({ isHoveringTooltip: !1 }), u.start();
    }
    const p = re(null), m = re(null), g = re(null), {
      floatingStyles: O,
      middlewareData: y,
      placement: b
      // @ts-ignore
    } = hj(p, m, {
      // @ts-ignore
      middleware: [LT(8), VT(), PZ(), dj({ element: g, padding: 8 })],
      whileElementsMounted: IT,
      placement: e.placement
    }), v = J(() => {
      const k = b.value.split("-")[0];
      return {
        top: "bottom",
        right: "left",
        bottom: "top",
        left: "right"
      }[k] ?? "";
    });
    return ua(bT, !0), (k, w) => (_(), Z(Qe, null, [
      ne(k.$slots, "default", Ct(Zt({
        id: `mt-tooltip--${E(n)}__trigger`,
        onFocus: () => {
          E(s)({ isFocusingTrigger: !0 }), E(r)({ gotOpenedBy: "focus" });
        },
        onBlur: a,
        onKeydown: (S) => {
          ["Escape", " ", "Enter"].includes(S.key) && E(o)({ causedByKeyPress: !0 }), E(l).stop();
        },
        onMouseover: c,
        onMouseleave: d,
        onMousedown: h,
        onMouseup: () => E(s)({ isPressingTrigger: !1 }),
        "aria-describedby": E(i) ? `mt-tooltip--${E(n)}__tooltip` : null
      })), void 0, !0),
      fe(Fn, null, {
        default: H(() => {
          var S, $;
          return [
            yt(X("div", {
              "data-placement": E(b),
              style: { position: "absolute" }
            }, [
              X("div", {
                role: "tooltip",
                id: `mt-tooltip--${E(n)}__tooltip`,
                class: "tooltip",
                ref_key: "tooltipRef",
                ref: m,
                style: pt(E(O)),
                tabindex: "-1",
                onMouseover: w[0] || (w[0] = (C) => E(s)({ isHoveringTooltip: !0 })),
                onMouseleave: f
              }, [
                X("span", null, Pe(k.content), 1),
                (_(), Z("svg", {
                  ref_key: "arrowRef",
                  ref: g,
                  width: "8",
                  height: "4",
                  viewBox: "0 0 8 4",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  style: pt({
                    background: "var(--color-elevation-surface-floating)",
                    height: "0.5rem",
                    width: "0.5rem",
                    borderRadius: "2px",
                    position: "absolute",
                    left: ((S = E(y).arrow) == null ? void 0 : S.x) != null ? `${E(y).arrow.x}px` : "",
                    top: (($ = E(y).arrow) == null ? void 0 : $.y) != null ? `${E(y).arrow.y}px` : "",
                    rotate: "45deg",
                    [v.value]: "-0.125rem"
                  })
                }, w[1] || (w[1] = [
                  X("path", {
                    d: "M8 0L4.70711 3.29289C4.31658 3.68342 3.68342 3.68342 3.29289 3.29289L0 0H8Z",
                    fill: "var(--color-elevation-surface-floating)"
                  }, null, -1)
                ]), 4))
              ], 44, gj)
            ], 8, mj), [
              [sc, E(i)]
            ])
          ];
        }),
        _: 1
      })
    ], 64));
  }
});
const jae = /* @__PURE__ */ je(Oj, [["__scopeId", "data-v-ff1c3ce6"]]);
function Nn(t) {
  this.content = t;
}
Nn.prototype = {
  constructor: Nn,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t)
        return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, n) {
    var i = n && n != t ? this.remove(n) : this, r = i.find(t), o = i.content.slice();
    return r == -1 ? o.push(n || t, e) : (o[r + 1] = e, n && (o[r] = n)), new Nn(o);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1)
      return this;
    var n = this.content.slice();
    return n.splice(e, 2), new Nn(n);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new Nn([t, e].concat(this.remove(t).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new Nn(n);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, n) {
    var i = this.remove(e), r = i.content.slice(), o = i.find(t);
    return r.splice(o == -1 ? r.length : o, 0, e, n), new Nn(r);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = Nn.from(t), t.size ? new Nn(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = Nn.from(t), t.size ? new Nn(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = Nn.from(t);
    for (var n = 0; n < t.content.length; n += 2)
      e = e.remove(t.content[n]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, n) {
      t[e] = n;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Nn.from = function(t) {
  if (t instanceof Nn)
    return t;
  var e = [];
  if (t)
    for (var n in t)
      e.push(n, t[n]);
  return new Nn(e);
};
function g$(t, e, n) {
  for (let i = 0; ; i++) {
    if (i == t.childCount || i == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let r = t.child(i), o = e.child(i);
    if (r == o) {
      n += r.nodeSize;
      continue;
    }
    if (!r.sameMarkup(o))
      return n;
    if (r.isText && r.text != o.text) {
      for (let s = 0; r.text[s] == o.text[s]; s++)
        n++;
      return n;
    }
    if (r.content.size || o.content.size) {
      let s = g$(r.content, o.content, n + 1);
      if (s != null)
        return s;
    }
    n += r.nodeSize;
  }
}
function O$(t, e, n, i) {
  for (let r = t.childCount, o = e.childCount; ; ) {
    if (r == 0 || o == 0)
      return r == o ? null : { a: n, b: i };
    let s = t.child(--r), a = e.child(--o), l = s.nodeSize;
    if (s == a) {
      n -= l, i -= l;
      continue;
    }
    if (!s.sameMarkup(a))
      return { a: n, b: i };
    if (s.isText && s.text != a.text) {
      let u = 0, c = Math.min(s.text.length, a.text.length);
      for (; u < c && s.text[s.text.length - u - 1] == a.text[a.text.length - u - 1]; )
        u++, n--, i--;
      return { a: n, b: i };
    }
    if (s.content.size || a.content.size) {
      let u = O$(s.content, a.content, n - 1, i - 1);
      if (u)
        return u;
    }
    n -= l, i -= l;
  }
}
class we {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let i = 0; i < e.length; i++)
        this.size += e[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, i, r = 0, o) {
    for (let s = 0, a = 0; a < n; s++) {
      let l = this.content[s], u = a + l.nodeSize;
      if (u > e && i(l, r + a, o || null, s) !== !1 && l.content.size) {
        let c = a + 1;
        l.nodesBetween(Math.max(0, e - c), Math.min(l.content.size, n - c), i, r + c);
      }
      a = u;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, i, r) {
    let o = "", s = !0;
    return this.nodesBetween(e, n, (a, l) => {
      let u = a.isText ? a.text.slice(Math.max(e, l) - l, n - l) : a.isLeaf ? r ? typeof r == "function" ? r(a) : r : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && u || a.isTextblock) && i && (s ? s = !1 : o += i), o += u;
    }, 0), o;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, i = e.firstChild, r = this.content.slice(), o = 0;
    for (n.isText && n.sameMarkup(i) && (r[r.length - 1] = n.withText(n.text + i.text), o = 1); o < e.content.length; o++)
      r.push(e.content[o]);
    return new we(r, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let i = [], r = 0;
    if (n > e)
      for (let o = 0, s = 0; s < n; o++) {
        let a = this.content[o], l = s + a.nodeSize;
        l > e && ((s < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - s), Math.min(a.text.length, n - s)) : a = a.cut(Math.max(0, e - s - 1), Math.min(a.content.size, n - s - 1))), i.push(a), r += a.nodeSize), s = l;
      }
    return new we(i, r);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? we.empty : e == 0 && n == this.content.length ? this : new we(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let i = this.content[e];
    if (i == n)
      return this;
    let r = this.content.slice(), o = this.size + n.nodeSize - i.nodeSize;
    return r[e] = n, new we(r, o);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new we([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new we(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, i = 0; n < this.content.length; n++) {
      let r = this.content[n];
      e(r, i, n), i += r.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return g$(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, i = e.size) {
    return O$(this, e, n, i);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e, n = -1) {
    if (e == 0)
      return jd(0, e);
    if (e == this.size)
      return jd(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let i = 0, r = 0; ; i++) {
      let o = this.child(i), s = r + o.nodeSize;
      if (s >= e)
        return s == e || n > 0 ? jd(i + 1, s) : jd(i, r);
      r = s;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return we.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new we(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return we.empty;
    let n, i = 0;
    for (let r = 0; r < e.length; r++) {
      let o = e[r];
      i += o.nodeSize, r && o.isText && e[r - 1].sameMarkup(o) ? (n || (n = e.slice(0, r)), n[n.length - 1] = o.withText(n[n.length - 1].text + o.text)) : n && n.push(o);
    }
    return new we(n || e, i);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return we.empty;
    if (e instanceof we)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new we([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
we.empty = new we([], 0);
const ag = { index: 0, offset: 0 };
function jd(t, e) {
  return ag.index = t, ag.offset = e, ag;
}
function wf(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let i = 0; i < t.length; i++)
      if (!wf(t[i], e[i]))
        return !1;
  } else {
    for (let i in t)
      if (!(i in e) || !wf(t[i], e[i]))
        return !1;
    for (let i in e)
      if (!(i in t))
        return !1;
  }
  return !0;
}
let Nt = class FO {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, i = !1;
    for (let r = 0; r < e.length; r++) {
      let o = e[r];
      if (this.eq(o))
        return e;
      if (this.type.excludes(o.type))
        n || (n = e.slice(0, r));
      else {
        if (o.type.excludes(this.type))
          return e;
        !i && o.type.rank > this.type.rank && (n || (n = e.slice(0, r)), n.push(this), i = !0), n && n.push(o);
      }
    }
    return n || (n = e.slice()), i || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && wf(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let i = e.marks[n.type];
    if (!i)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let r = i.create(n.attrs);
    return i.checkAttrs(r.attrs), r;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let i = 0; i < e.length; i++)
      if (!e[i].eq(n[i]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return FO.none;
    if (e instanceof FO)
      return [e];
    let n = e.slice();
    return n.sort((i, r) => i.type.rank - r.type.rank), n;
  }
};
Nt.none = [];
class kf extends Error {
}
class Ne {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, i) {
    this.content = e, this.openStart = n, this.openEnd = i;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let i = y$(this.content, e + this.openStart, n);
    return i && new Ne(i, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new Ne(v$(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return Ne.empty;
    let i = n.openStart || 0, r = n.openEnd || 0;
    if (typeof i != "number" || typeof r != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Ne(we.fromJSON(e, n.content), i, r);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let i = 0, r = 0;
    for (let o = e.firstChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.firstChild)
      i++;
    for (let o = e.lastChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.lastChild)
      r++;
    return new Ne(e, i, r);
  }
}
Ne.empty = new Ne(we.empty, 0, 0);
function v$(t, e, n) {
  let { index: i, offset: r } = t.findIndex(e), o = t.maybeChild(i), { index: s, offset: a } = t.findIndex(n);
  if (r == e || o.isText) {
    if (a != n && !t.child(s).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (i != s)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(i, o.copy(v$(o.content, e - r - 1, n - r - 1)));
}
function y$(t, e, n, i) {
  let { index: r, offset: o } = t.findIndex(e), s = t.maybeChild(r);
  if (o == e || s.isText)
    return i && !i.canReplace(r, r, n) ? null : t.cut(0, e).append(n).append(t.cut(e));
  let a = y$(s.content, e - o - 1, n);
  return a && t.replaceChild(r, s.copy(a));
}
function vj(t, e, n) {
  if (n.openStart > t.depth)
    throw new kf("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new kf("Inconsistent open depths");
  return b$(t, e, n, 0);
}
function b$(t, e, n, i) {
  let r = t.index(i), o = t.node(i);
  if (r == e.index(i) && i < t.depth - n.openStart) {
    let s = b$(t, e, n, i + 1);
    return o.copy(o.content.replaceChild(r, s));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == i && e.depth == i) {
      let s = t.parent, a = s.content;
      return ba(s, a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: s, end: a } = yj(n, t);
      return ba(o, k$(t, s, a, e, i));
    }
  else
    return ba(o, Sf(t, e, i));
}
function w$(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new kf("Cannot join " + e.type.name + " onto " + t.type.name);
}
function qO(t, e, n) {
  let i = t.node(n);
  return w$(i, e.node(n)), i;
}
function ya(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function hc(t, e, n, i) {
  let r = (e || t).node(n), o = 0, s = e ? e.index(n) : r.childCount;
  t && (o = t.index(n), t.depth > n ? o++ : t.textOffset && (ya(t.nodeAfter, i), o++));
  for (let a = o; a < s; a++)
    ya(r.child(a), i);
  e && e.depth == n && e.textOffset && ya(e.nodeBefore, i);
}
function ba(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function k$(t, e, n, i, r) {
  let o = t.depth > r && qO(t, e, r + 1), s = i.depth > r && qO(n, i, r + 1), a = [];
  return hc(null, t, r, a), o && s && e.index(r) == n.index(r) ? (w$(o, s), ya(ba(o, k$(t, e, n, i, r + 1)), a)) : (o && ya(ba(o, Sf(t, e, r + 1)), a), hc(e, n, r, a), s && ya(ba(s, Sf(n, i, r + 1)), a)), hc(i, null, r, a), new we(a);
}
function Sf(t, e, n) {
  let i = [];
  if (hc(null, t, n, i), t.depth > n) {
    let r = qO(t, e, n + 1);
    ya(ba(r, Sf(t, e, n + 1)), i);
  }
  return hc(e, null, n, i), new we(i);
}
function yj(t, e) {
  let n = e.depth - t.openStart, r = e.node(n).copy(t.content);
  for (let o = n - 1; o >= 0; o--)
    r = e.node(o).copy(we.from(r));
  return {
    start: r.resolveNoCache(t.openStart + n),
    end: r.resolveNoCache(r.content.size - t.openEnd - n)
  };
}
class Vc {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.pos = e, this.path = n, this.parentOffset = i, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let i = this.pos - this.path[this.path.length - 1], r = e.child(n);
    return i ? e.child(n).cut(i) : r;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let i = this.path[n * 3], r = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let o = 0; o < e; o++)
      r += i.child(o).nodeSize;
    return r;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return Nt.none;
    if (this.textOffset)
      return e.child(n).marks;
    let i = e.maybeChild(n - 1), r = e.maybeChild(n);
    if (!i) {
      let a = i;
      i = r, r = a;
    }
    let o = i.marks;
    for (var s = 0; s < o.length; s++)
      o[s].type.spec.inclusive === !1 && (!r || !o[s].isInSet(r.marks)) && (o = o[s--].removeFromSet(o));
    return o;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let i = n.marks, r = e.parent.maybeChild(e.index());
    for (var o = 0; o < i.length; o++)
      i[o].type.spec.inclusive === !1 && (!r || !i[o].isInSet(r.marks)) && (i = i[o--].removeFromSet(i));
    return i;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let i = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); i >= 0; i--)
      if (e.pos <= this.end(i) && (!n || n(this.node(i))))
        return new _f(this, e, i);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let i = [], r = 0, o = n;
    for (let s = e; ; ) {
      let { index: a, offset: l } = s.content.findIndex(o), u = o - l;
      if (i.push(s, a, r + l), !u || (s = s.child(a), s.isText))
        break;
      o = u - 1, r += l + 1;
    }
    return new Vc(n, i, o);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    let i = xk.get(e);
    if (i)
      for (let o = 0; o < i.elts.length; o++) {
        let s = i.elts[o];
        if (s.pos == n)
          return s;
      }
    else
      xk.set(e, i = new bj());
    let r = i.elts[i.i] = Vc.resolve(e, n);
    return i.i = (i.i + 1) % wj, r;
  }
}
class bj {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const wj = 12, xk = /* @__PURE__ */ new WeakMap();
class _f {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, i) {
    this.$from = e, this.$to = n, this.depth = i;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const kj = /* @__PURE__ */ Object.create(null);
let xs = class WO {
  /**
  @internal
  */
  constructor(e, n, i, r = Nt.none) {
    this.type = e, this.attrs = n, this.marks = r, this.content = i || we.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, i, r = 0) {
    this.content.nodesBetween(e, n, i, r, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, n, i, r) {
    return this.content.textBetween(e, n, i, r);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, i) {
    return this.type == e && wf(this.attrs, n || e.defaultAttrs || kj) && Nt.sameSet(this.marks, i || Nt.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new WO(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new WO(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, i = !1) {
    if (e == n)
      return Ne.empty;
    let r = this.resolve(e), o = this.resolve(n), s = i ? 0 : r.sharedDepth(n), a = r.start(s), u = r.node(s).content.cut(r.pos - a, o.pos - a);
    return new Ne(u, r.depth - s, o.depth - s);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, i) {
    return vj(this.resolve(e), this.resolve(n), i);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: i, offset: r } = n.content.findIndex(e);
      if (n = n.maybeChild(i), !n)
        return null;
      if (r == e || n.isText)
        return n;
      e -= r + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: i } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: i };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: i } = this.content.findIndex(e);
    if (i < e)
      return { node: this.content.child(n), index: n, offset: i };
    let r = this.content.child(n - 1);
    return { node: r, index: n - 1, offset: i - r.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return Vc.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return Vc.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, i) {
    let r = !1;
    return n > e && this.nodesBetween(e, n, (o) => (i.isInSet(o.marks) && (r = !0), !r)), r;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), S$(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, i = we.empty, r = 0, o = i.childCount) {
    let s = this.contentMatchAt(e).matchFragment(i, r, o), a = s && s.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let l = r; l < o; l++)
      if (!this.type.allowsMarks(i.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, i, r) {
    if (r && !this.type.allowsMarks(r))
      return !1;
    let o = this.contentMatchAt(e).matchType(i), s = o && o.matchFragment(this.content, n);
    return s ? s.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = Nt.none;
    for (let n = 0; n < this.marks.length; n++) {
      let i = this.marks[n];
      i.type.checkAttrs(i.attrs), e = i.addToSet(e);
    }
    if (!Nt.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let i;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      i = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, i);
    }
    let r = we.fromJSON(e, n.content), o = e.nodeType(n.type).create(n.attrs, r, i);
    return o.type.checkAttrs(o.attrs), o;
  }
};
xs.prototype.text = void 0;
let Sj = class XO extends xs {
  /**
  @internal
  */
  constructor(e, n, i, r) {
    if (super(e, n, null, r), !i)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = i;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : S$(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new XO(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new XO(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
};
function S$(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
class Da {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let i = new _j(e, n);
    if (i.next == null)
      return Da.empty;
    let r = _$(i);
    i.next && i.err("Unexpected trailing text");
    let o = Ej(Mj(r));
    return Aj(o, i), o;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, i = e.childCount) {
    let r = this;
    for (let o = n; r && o < i; o++)
      r = r.matchType(e.child(o).type);
    return r;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let i = 0; i < e.next.length; i++)
        if (this.next[n].type == e.next[i].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, i = 0) {
    let r = [this];
    function o(s, a) {
      let l = s.matchFragment(e, i);
      if (l && (!n || l.validEnd))
        return we.from(a.map((u) => u.createAndFill()));
      for (let u = 0; u < s.next.length; u++) {
        let { type: c, next: d } = s.next[u];
        if (!(c.isText || c.hasRequiredAttrs()) && r.indexOf(d) == -1) {
          r.push(d);
          let h = o(d, a.concat(c));
          if (h)
            return h;
        }
      }
      return null;
    }
    return o(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == e)
        return this.wrapCache[i + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), i = [{ match: this, type: null, via: null }];
    for (; i.length; ) {
      let r = i.shift(), o = r.match;
      if (o.matchType(e)) {
        let s = [];
        for (let a = r; a.type; a = a.via)
          s.push(a.type);
        return s.reverse();
      }
      for (let s = 0; s < o.next.length; s++) {
        let { type: a, next: l } = o.next[s];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!r.type || l.validEnd) && (i.push({ match: a.contentMatch, type: a, via: r }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(i) {
      e.push(i);
      for (let r = 0; r < i.next.length; r++)
        e.indexOf(i.next[r].next) == -1 && n(i.next[r].next);
    }
    return n(this), e.map((i, r) => {
      let o = r + (i.validEnd ? "*" : " ") + " ";
      for (let s = 0; s < i.next.length; s++)
        o += (s ? ", " : "") + i.next[s].type.name + "->" + e.indexOf(i.next[s].next);
      return o;
    }).join(`
`);
  }
}
Da.empty = new Da(!0);
class _j {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function _$(t) {
  let e = [];
  do
    e.push(xj(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function xj(t) {
  let e = [];
  do
    e.push(Cj(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function Cj(t) {
  let e = Pj(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = Tj(t, e);
    else
      break;
  return e;
}
function Ck(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function Tj(t, e) {
  let n = Ck(t), i = n;
  return t.eat(",") && (t.next != "}" ? i = Ck(t) : i = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: i, expr: e };
}
function $j(t, e) {
  let n = t.nodeTypes, i = n[e];
  if (i)
    return [i];
  let r = [];
  for (let o in n) {
    let s = n[o];
    s.isInGroup(e) && r.push(s);
  }
  return r.length == 0 && t.err("No node type or group '" + e + "' found"), r;
}
function Pj(t) {
  if (t.eat("(")) {
    let e = _$(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = $j(t, t.next).map((n) => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function Mj(t) {
  let e = [[]];
  return r(o(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function i(s, a, l) {
    let u = { term: l, to: a };
    return e[s].push(u), u;
  }
  function r(s, a) {
    s.forEach((l) => l.to = a);
  }
  function o(s, a) {
    if (s.type == "choice")
      return s.exprs.reduce((l, u) => l.concat(o(u, a)), []);
    if (s.type == "seq")
      for (let l = 0; ; l++) {
        let u = o(s.exprs[l], a);
        if (l == s.exprs.length - 1)
          return u;
        r(u, a = n());
      }
    else if (s.type == "star") {
      let l = n();
      return i(a, l), r(o(s.expr, l), l), [i(l)];
    } else if (s.type == "plus") {
      let l = n();
      return r(o(s.expr, a), l), r(o(s.expr, l), l), [i(l)];
    } else {
      if (s.type == "opt")
        return [i(a)].concat(o(s.expr, a));
      if (s.type == "range") {
        let l = a;
        for (let u = 0; u < s.min; u++) {
          let c = n();
          r(o(s.expr, l), c), l = c;
        }
        if (s.max == -1)
          r(o(s.expr, l), l);
        else
          for (let u = s.min; u < s.max; u++) {
            let c = n();
            i(l, c), r(o(s.expr, l), c), l = c;
          }
        return [i(l)];
      } else {
        if (s.type == "name")
          return [i(a, void 0, s.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function x$(t, e) {
  return e - t;
}
function Tk(t, e) {
  let n = [];
  return i(e), n.sort(x$);
  function i(r) {
    let o = t[r];
    if (o.length == 1 && !o[0].term)
      return i(o[0].to);
    n.push(r);
    for (let s = 0; s < o.length; s++) {
      let { term: a, to: l } = o[s];
      !a && n.indexOf(l) == -1 && i(l);
    }
  }
}
function Ej(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(Tk(t, 0));
  function n(i) {
    let r = [];
    i.forEach((s) => {
      t[s].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let u;
        for (let c = 0; c < r.length; c++)
          r[c][0] == a && (u = r[c][1]);
        Tk(t, l).forEach((c) => {
          u || r.push([a, u = []]), u.indexOf(c) == -1 && u.push(c);
        });
      });
    });
    let o = e[i.join(",")] = new Da(i.indexOf(t.length - 1) > -1);
    for (let s = 0; s < r.length; s++) {
      let a = r[s][1].sort(x$);
      o.next.push({ type: r[s][0], next: e[a.join(",")] || n(a) });
    }
    return o;
  }
}
function Aj(t, e) {
  for (let n = 0, i = [t]; n < i.length; n++) {
    let r = i[n], o = !r.validEnd, s = [];
    for (let a = 0; a < r.next.length; a++) {
      let { type: l, next: u } = r.next[a];
      s.push(l.name), o && !(l.isText || l.hasRequiredAttrs()) && (o = !1), i.indexOf(u) == -1 && i.push(u);
    }
    o && e.err("Only non-generatable nodes (" + s.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function C$(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let i = t[n];
    if (!i.hasDefault)
      return null;
    e[n] = i.default;
  }
  return e;
}
function T$(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let i in t) {
    let r = e && e[i];
    if (r === void 0) {
      let o = t[i];
      if (o.hasDefault)
        r = o.default;
      else
        throw new RangeError("No value supplied for attribute " + i);
    }
    n[i] = r;
  }
  return n;
}
function $$(t, e, n, i) {
  for (let r in e)
    if (!(r in t))
      throw new RangeError(`Unsupported attribute ${r} for ${n} of type ${r}`);
  for (let r in t) {
    let o = t[r];
    o.validate && o.validate(e[r]);
  }
}
function P$(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let i in e)
      n[i] = new Dj(t, i, e[i]);
  return n;
}
let $k = class M$ {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.name = e, this.schema = n, this.spec = i, this.markSet = null, this.groups = i.group ? i.group.split(" ") : [], this.attrs = P$(e, i.attrs), this.defaultAttrs = C$(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(i.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Da.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : T$(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, i) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new xs(this, this.computeAttrs(e), we.from(n), Nt.setFrom(i));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, i) {
    return n = we.from(n), this.checkContent(n), new xs(this, this.computeAttrs(e), n, Nt.setFrom(i));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, i) {
    if (e = this.computeAttrs(e), n = we.from(n), n.size) {
      let s = this.contentMatch.fillBefore(n);
      if (!s)
        return null;
      n = s.append(n);
    }
    let r = this.contentMatch.matchFragment(n), o = r && r.fillBefore(we.empty, !0);
    return o ? new xs(this, e, n.append(o), Nt.setFrom(i)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return !1;
    for (let i = 0; i < e.childCount; i++)
      if (!this.allowsMarks(e.child(i).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    $$(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let i = 0; i < e.length; i++)
      this.allowsMarkType(e[i].type) ? n && n.push(e[i]) : n || (n = e.slice(0, i));
    return n ? n.length ? n : Nt.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let i = /* @__PURE__ */ Object.create(null);
    e.forEach((o, s) => i[o] = new M$(o, n, s));
    let r = n.spec.topNode || "doc";
    if (!i[r])
      throw new RangeError("Schema is missing its top node type ('" + r + "')");
    if (!i.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let o in i.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return i;
  }
};
function Rj(t, e, n) {
  let i = n.split("|");
  return (r) => {
    let o = r === null ? "null" : typeof r;
    if (i.indexOf(o) < 0)
      throw new RangeError(`Expected value of type ${i} for attribute ${e} on type ${t}, got ${o}`);
  };
}
let Dj = class {
  constructor(e, n, i) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(i, "default"), this.default = i.default, this.validate = typeof i.validate == "string" ? Rj(e, n, i.validate) : i.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
class om {
  /**
  @internal
  */
  constructor(e, n, i, r) {
    this.name = e, this.rank = n, this.schema = i, this.spec = r, this.attrs = P$(e, r.attrs), this.excluded = null;
    let o = C$(this.attrs);
    this.instance = o ? new Nt(this, o) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new Nt(this, T$(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let i = /* @__PURE__ */ Object.create(null), r = 0;
    return e.forEach((o, s) => i[o] = new om(o, r++, n, s)), i;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    $$(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
let E$ = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let r in e)
      n[r] = e[r];
    n.nodes = Nn.from(e.nodes), n.marks = Nn.from(e.marks || {}), this.nodes = $k.compile(this.spec.nodes, this), this.marks = om.compile(this.spec.marks, this);
    let i = /* @__PURE__ */ Object.create(null);
    for (let r in this.nodes) {
      if (r in this.marks)
        throw new RangeError(r + " can not be both a node and a mark");
      let o = this.nodes[r], s = o.spec.content || "", a = o.spec.marks;
      if (o.contentMatch = i[s] || (i[s] = Da.parse(s, this.nodes)), o.inlineContent = o.contentMatch.inlineContent, o.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!o.isInline || !o.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = o;
      }
      o.markSet = a == "_" ? null : a ? Pk(this, a.split(" ")) : a == "" || !o.inlineContent ? [] : null;
    }
    for (let r in this.marks) {
      let o = this.marks[r], s = o.spec.excludes;
      o.excluded = s == null ? [o] : s == "" ? [] : Pk(this, s.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, i, r) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof $k) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else
      throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, i, r);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let i = this.nodes.text;
    return new Sj(i, i.defaultAttrs, e, Nt.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return xs.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return Nt.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
};
function Pk(t, e) {
  let n = [];
  for (let i = 0; i < e.length; i++) {
    let r = e[i], o = t.marks[r], s = o;
    if (o)
      n.push(o);
    else
      for (let a in t.marks) {
        let l = t.marks[a];
        (r == "_" || l.spec.group && l.spec.group.split(" ").indexOf(r) > -1) && n.push(s = l);
      }
    if (!s)
      throw new SyntaxError("Unknown mark type: '" + e[i] + "'");
  }
  return n;
}
function Qj(t) {
  return t.tag != null;
}
function Nj(t) {
  return t.style != null;
}
class Cs {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [];
    let i = this.matchedStyles = [];
    n.forEach((r) => {
      if (Qj(r))
        this.tags.push(r);
      else if (Nj(r)) {
        let o = /[^=]*/.exec(r.style)[0];
        i.indexOf(o) < 0 && i.push(o), this.styles.push(r);
      }
    }), this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return !1;
      let o = e.nodes[r.node];
      return o.contentMatch.matchType(o);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let i = new Ek(this, n, !1);
    return i.addAll(e, Nt.none, n.from, n.to), i.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let i = new Ek(this, n, !0);
    return i.addAll(e, Nt.none, n.from, n.to), Ne.maxOpen(i.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, i) {
    for (let r = i ? this.tags.indexOf(i) + 1 : 0; r < this.tags.length; r++) {
      let o = this.tags[r];
      if (Vj(e, o.tag) && (o.namespace === void 0 || e.namespaceURI == o.namespace) && (!o.context || n.matchesContext(o.context))) {
        if (o.getAttrs) {
          let s = o.getAttrs(e);
          if (s === !1)
            continue;
          o.attrs = s || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, i, r) {
    for (let o = r ? this.styles.indexOf(r) + 1 : 0; o < this.styles.length; o++) {
      let s = this.styles[o], a = s.style;
      if (!(a.indexOf(e) != 0 || s.context && !i.matchesContext(s.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
        if (s.getAttrs) {
          let l = s.getAttrs(n);
          if (l === !1)
            continue;
          s.attrs = l || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function i(r) {
      let o = r.priority == null ? 50 : r.priority, s = 0;
      for (; s < n.length; s++) {
        let a = n[s];
        if ((a.priority == null ? 50 : a.priority) < o)
          break;
      }
      n.splice(s, 0, r);
    }
    for (let r in e.marks) {
      let o = e.marks[r].spec.parseDOM;
      o && o.forEach((s) => {
        i(s = Ak(s)), s.mark || s.ignore || s.clearMark || (s.mark = r);
      });
    }
    for (let r in e.nodes) {
      let o = e.nodes[r].spec.parseDOM;
      o && o.forEach((s) => {
        i(s = Ak(s)), s.node || s.ignore || s.mark || (s.node = r);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new Cs(e, Cs.schemaRules(e)));
  }
}
const A$ = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, Ij = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, R$ = { ol: !0, ul: !0 }, Bc = 1, zO = 2, fc = 4;
function Mk(t, e, n) {
  return e != null ? (e ? Bc : 0) | (e === "full" ? zO : 0) : t && t.whitespace == "pre" ? Bc | zO : n & ~fc;
}
class Yd {
  constructor(e, n, i, r, o, s) {
    this.type = e, this.attrs = n, this.marks = i, this.solid = r, this.options = s, this.content = [], this.activeMarks = Nt.none, this.match = o || (s & fc ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(we.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let i = this.type.contentMatch, r;
        return (r = i.findWrapping(e.type)) ? (this.match = i, r) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & Bc)) {
      let i = this.content[this.content.length - 1], r;
      if (i && i.isText && (r = /[ \t\r\n\u000c]+$/.exec(i.text))) {
        let o = i;
        i.text.length == r[0].length ? this.content.pop() : this.content[this.content.length - 1] = o.withText(o.text.slice(0, o.text.length - r[0].length));
      }
    }
    let n = we.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(we.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !A$.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
let Ek = class {
  constructor(e, n, i) {
    this.parser = e, this.options = n, this.isOpen = i, this.open = 0, this.localPreserveWS = !1;
    let r = n.topNode, o, s = Mk(null, n.preserveWhitespace, 0) | (i ? fc : 0);
    r ? o = new Yd(r.type, r.attrs, Nt.none, !0, n.topMatch || r.type.contentMatch, s) : i ? o = new Yd(null, null, Nt.none, !0, null, s) : o = new Yd(e.schema.topNodeType, null, Nt.none, !0, null, s), this.nodes = [o], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, n) {
    e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n);
  }
  addTextNode(e, n) {
    let i = e.nodeValue, r = this.top, o = r.options & zO ? "full" : this.localPreserveWS || (r.options & Bc) > 0;
    if (o === "full" || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(i)) {
      if (o)
        o !== "full" ? i = i.replace(/\r?\n|\r/g, " ") : i = i.replace(/\r\n?/g, `
`);
      else if (i = i.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(i) && this.open == this.nodes.length - 1) {
        let s = r.content[r.content.length - 1], a = e.previousSibling;
        (!s || a && a.nodeName == "BR" || s.isText && /[ \t\r\n\u000c]$/.test(s.text)) && (i = i.slice(1));
      }
      i && this.insertNode(this.parser.schema.text(i), n), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n, i) {
    let r = this.localPreserveWS, o = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let s = e.nodeName.toLowerCase(), a;
    R$.hasOwnProperty(s) && this.parser.normalizeLists && Lj(e);
    let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, i));
    e:
      if (l ? l.ignore : Ij.hasOwnProperty(s))
        this.findInside(e), this.ignoreFallback(e, n);
      else if (!l || l.skip || l.closeParent) {
        l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
        let u, c = this.needsBlock;
        if (A$.hasOwnProperty(s))
          o.content.length && o.content[0].isInline && this.open && (this.open--, o = this.top), u = !0, o.type || (this.needsBlock = !0);
        else if (!e.firstChild) {
          this.leafFallback(e, n);
          break e;
        }
        let d = l && l.skip ? n : this.readStyles(e, n);
        d && this.addAll(e, d), u && this.sync(o), this.needsBlock = c;
      } else {
        let u = this.readStyles(e, n);
        u && this.addElementByRule(e, l, u, l.consuming === !1 ? a : void 0);
      }
    this.localPreserveWS = r;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, n) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(e, n) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, n) {
    let i = e.style;
    if (i && i.length)
      for (let r = 0; r < this.parser.matchedStyles.length; r++) {
        let o = this.parser.matchedStyles[r], s = i.getPropertyValue(o);
        if (s)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(o, s, this, a);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? n = n.filter((u) => !l.clearMark(u)) : n = n.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              a = l;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, i, r) {
    let o, s;
    if (n.node)
      if (s = this.parser.schema.nodes[n.node], s.isLeaf)
        this.insertNode(s.create(n.attrs), i) || this.leafFallback(e, i);
      else {
        let l = this.enter(s, n.attrs || null, i, n.preserveWhitespace);
        l && (o = !0, i = l);
      }
    else {
      let l = this.parser.schema.marks[n.mark];
      i = i.concat(l.create(n.attrs));
    }
    let a = this.top;
    if (s && s.isLeaf)
      this.findInside(e);
    else if (r)
      this.addElement(e, i, r);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, i));
    else {
      let l = e;
      typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, !0), this.addAll(l, i), this.findAround(e, l, !1);
    }
    o && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, i, r) {
    let o = i || 0;
    for (let s = i ? e.childNodes[i] : e.firstChild, a = r == null ? null : e.childNodes[r]; s != a; s = s.nextSibling, ++o)
      this.findAtPoint(e, o), this.addDOM(s, n);
    this.findAtPoint(e, o);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, n) {
    let i, r;
    for (let o = this.open; o >= 0; o--) {
      let s = this.nodes[o], a = s.findWrapping(e);
      if (a && (!i || i.length > a.length) && (i = a, r = s, !a.length) || s.solid)
        break;
    }
    if (!i)
      return null;
    this.sync(r);
    for (let o = 0; o < i.length; o++)
      n = this.enterInner(i[o], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, n) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let r = this.textblockFromContext();
      r && (n = this.enterInner(r, null, n));
    }
    let i = this.findPlace(e, n);
    if (i) {
      this.closeExtra();
      let r = this.top;
      r.match && (r.match = r.match.matchType(e.type));
      let o = Nt.none;
      for (let s of i.concat(e.marks))
        (r.type ? r.type.allowsMarkType(s.type) : Rk(s.type, e.type)) && (o = s.addToSet(o));
      return r.content.push(e.mark(o)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, i, r) {
    let o = this.findPlace(e.create(n), i);
    return o && (o = this.enterInner(e, n, i, !0, r)), o;
  }
  // Open a node of the given type
  enterInner(e, n, i, r = !1, o) {
    this.closeExtra();
    let s = this.top;
    s.match = s.match && s.match.matchType(e);
    let a = Mk(e, o, s.options);
    s.options & fc && s.content.length == 0 && (a |= fc);
    let l = Nt.none;
    return i = i.filter((u) => (s.type ? s.type.allowsMarkType(u.type) : Rk(u.type, e)) ? (l = u.addToSet(l), !1) : !0), this.nodes.push(new Yd(e, n, l, r, null, a)), this.open++, i;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == e)
        return this.open = n, !0;
      this.localPreserveWS && (this.nodes[n].options |= Bc);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let i = this.nodes[n].content;
      for (let r = i.length - 1; r >= 0; r--)
        e += i[r].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].node == e && this.find[i].offset == n && (this.find[i].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, i) {
    if (e != n && this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].pos == null && e.nodeType == 1 && e.contains(this.find[r].node) && n.compareDocumentPosition(this.find[r].node) & (i ? 2 : 4) && (this.find[r].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), i = this.options.context, r = !this.isOpen && (!i || i.parent.type == this.nodes[0].type), o = -(i ? i.depth + 1 : 0) + (r ? 0 : 1), s = (a, l) => {
      for (; a >= 0; a--) {
        let u = n[a];
        if (u == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; l >= o; l--)
            if (s(a - 1, l))
              return !0;
          return !1;
        } else {
          let c = l > 0 || l == 0 && r ? this.nodes[l].type : i && l >= o ? i.node(l - o).type : null;
          if (!c || c.name != u && !c.isInGroup(u))
            return !1;
          l--;
        }
      }
      return !0;
    };
    return s(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let i = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (i && i.isTextblock && i.defaultAttrs)
          return i;
      }
    for (let n in this.parser.schema.nodes) {
      let i = this.parser.schema.nodes[n];
      if (i.isTextblock && i.defaultAttrs)
        return i;
    }
  }
};
function Lj(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let i = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    i && R$.hasOwnProperty(i) && n ? (n.appendChild(e), e = n) : i == "li" ? n = e : i && (n = null);
  }
}
function Vj(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function Ak(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function Rk(t, e) {
  let n = e.schema.nodes;
  for (let i in n) {
    let r = n[i];
    if (!r.allowsMarkType(t))
      continue;
    let o = [], s = (a) => {
      o.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: u, next: c } = a.edge(l);
        if (u == e || o.indexOf(c) < 0 && s(c))
          return !0;
      }
    };
    if (s(r.contentMatch))
      return !0;
  }
}
class Ha {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, i) {
    i || (i = lg(n).createDocumentFragment());
    let r = i, o = [];
    return e.forEach((s) => {
      if (o.length || s.marks.length) {
        let a = 0, l = 0;
        for (; a < o.length && l < s.marks.length; ) {
          let u = s.marks[l];
          if (!this.marks[u.type.name]) {
            l++;
            continue;
          }
          if (!u.eq(o[a][0]) || u.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < o.length; )
          r = o.pop()[1];
        for (; l < s.marks.length; ) {
          let u = s.marks[l++], c = this.serializeMark(u, s.isInline, n);
          c && (o.push([u, r]), r.appendChild(c.dom), r = c.contentDOM || c.dom);
        }
      }
      r.appendChild(this.serializeNodeInner(s, n));
    }), i;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: i, contentDOM: r } = Rh(lg(n), this.nodes[e.type.name](e), null, e.attrs);
    if (r) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, r);
    }
    return i;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let i = this.serializeNodeInner(e, n);
    for (let r = e.marks.length - 1; r >= 0; r--) {
      let o = this.serializeMark(e.marks[r], e.isInline, n);
      o && ((o.contentDOM || o.dom).appendChild(i), i = o.dom);
    }
    return i;
  }
  /**
  @internal
  */
  serializeMark(e, n, i = {}) {
    let r = this.marks[e.type.name];
    return r && Rh(lg(i), r(e, n), null, e.attrs);
  }
  static renderSpec(e, n, i = null, r) {
    return Rh(e, n, i, r);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Ha(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = Dk(e.nodes);
    return n.text || (n.text = (i) => i.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return Dk(e.marks);
  }
}
function Dk(t) {
  let e = {};
  for (let n in t) {
    let i = t[n].spec.toDOM;
    i && (e[n] = i);
  }
  return e;
}
function lg(t) {
  return t.document || window.document;
}
const Qk = /* @__PURE__ */ new WeakMap();
function Bj(t) {
  let e = Qk.get(t);
  return e === void 0 && Qk.set(t, e = Zj(t)), e;
}
function Zj(t) {
  let e = null;
  function n(i) {
    if (i && typeof i == "object")
      if (Array.isArray(i))
        if (typeof i[0] == "string")
          e || (e = []), e.push(i);
        else
          for (let r = 0; r < i.length; r++)
            n(i[r]);
      else
        for (let r in i)
          n(i[r]);
  }
  return n(t), e;
}
function Rh(t, e, n, i) {
  if (typeof e == "string")
    return { dom: t.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let r = e[0], o;
  if (typeof r != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (i && (o = Bj(i)) && o.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let s = r.indexOf(" ");
  s > 0 && (n = r.slice(0, s), r = r.slice(s + 1));
  let a, l = n ? t.createElementNS(n, r) : t.createElement(r), u = e[1], c = 1;
  if (u && typeof u == "object" && u.nodeType == null && !Array.isArray(u)) {
    c = 2;
    for (let d in u)
      if (u[d] != null) {
        let h = d.indexOf(" ");
        h > 0 ? l.setAttributeNS(d.slice(0, h), d.slice(h + 1), u[d]) : l.setAttribute(d, u[d]);
      }
  }
  for (let d = c; d < e.length; d++) {
    let h = e[d];
    if (h === 0) {
      if (d < e.length - 1 || d > c)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: f, contentDOM: p } = Rh(t, h, n, i);
      if (l.appendChild(f), p) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = p;
      }
    }
  }
  return { dom: l, contentDOM: a };
}
const D$ = 65535, Q$ = Math.pow(2, 16);
function Fj(t, e) {
  return t + e * Q$;
}
function Nk(t) {
  return t & D$;
}
function qj(t) {
  return (t - (t & D$)) / Q$;
}
const N$ = 1, I$ = 2, Dh = 4, L$ = 8;
class jO {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.pos = e, this.delInfo = n, this.recover = i;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & L$) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (N$ | Dh)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (I$ | Dh)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & Dh) > 0;
  }
}
class Qi {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && Qi.empty)
      return Qi.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, i = Nk(e);
    if (!this.inverted)
      for (let r = 0; r < i; r++)
        n += this.ranges[r * 3 + 2] - this.ranges[r * 3 + 1];
    return this.ranges[i * 3] + n + qj(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, i) {
    let r = 0, o = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let u = this.ranges[a + o], c = this.ranges[a + s], d = l + u;
      if (e <= d) {
        let h = u ? e == l ? -1 : e == d ? 1 : n : n, f = l + r + (h < 0 ? 0 : c);
        if (i)
          return f;
        let p = e == (n < 0 ? l : d) ? null : Fj(a / 3, e - l), m = e == l ? I$ : e == d ? N$ : Dh;
        return (n < 0 ? e != l : e != d) && (m |= L$), new jO(f, m, p);
      }
      r += c - u;
    }
    return i ? e + r : new jO(e + r, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let i = 0, r = Nk(n), o = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let u = this.ranges[a + o], c = l + u;
      if (e <= c && a == r * 3)
        return !0;
      i += this.ranges[a + s] - u;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, i = this.inverted ? 1 : 2;
    for (let r = 0, o = 0; r < this.ranges.length; r += 3) {
      let s = this.ranges[r], a = s - (this.inverted ? o : 0), l = s + (this.inverted ? 0 : o), u = this.ranges[r + n], c = this.ranges[r + i];
      e(a, a + u, l, l + c), o += c - u;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Qi(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Qi.empty : new Qi(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Qi.empty = new Qi([]);
class kl {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], n, i = 0, r = e.length) {
    this.maps = e, this.mirror = n, this.from = i, this.to = r;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new kl(this.maps, this.mirror, e, n);
  }
  /**
  @internal
  */
  copy() {
    return new kl(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.to = this.maps.push(e), n != null && this.setMirror(this.maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, i = this.maps.length; n < e.maps.length; n++) {
      let r = e.getMirror(n);
      this.appendMap(e.maps[n], r != null && r < n ? i + r : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, i = this.maps.length + e.maps.length; n >= 0; n--) {
      let r = e.getMirror(n);
      this.appendMap(e.maps[n].invert(), r != null && r > n ? i - r - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new kl();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let i = this.from; i < this.to; i++)
      e = this.maps[i].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, i) {
    let r = 0;
    for (let o = this.from; o < this.to; o++) {
      let s = this.maps[o], a = s.mapResult(e, n);
      if (a.recover != null) {
        let l = this.getMirror(o);
        if (l != null && l > o && l < this.to) {
          o = l, e = this.maps[l].recover(a.recover);
          continue;
        }
      }
      r |= a.delInfo, e = a.pos;
    }
    return i ? e : new jO(e, r, null);
  }
}
const ug = /* @__PURE__ */ Object.create(null);
class Jn {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Qi.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let i = ug[n.stepType];
    if (!i)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return i.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in ug)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return ug[e] = n, n.prototype.jsonID = e, n;
  }
}
class kn {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new kn(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new kn(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, i, r) {
    try {
      return kn.ok(e.replace(n, i, r));
    } catch (o) {
      if (o instanceof kf)
        return kn.fail(o.message);
      throw o;
    }
  }
}
function bb(t, e, n) {
  let i = [];
  for (let r = 0; r < t.childCount; r++) {
    let o = t.child(r);
    o.content.size && (o = o.copy(bb(o.content, e, o))), o.isInline && (o = e(o, n, r)), i.push(o);
  }
  return we.fromArray(i);
}
class ms extends Jn {
  /**
  Create a mark step.
  */
  constructor(e, n, i) {
    super(), this.from = e, this.to = n, this.mark = i;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), i = e.resolve(this.from), r = i.node(i.sharedDepth(this.to)), o = new Ne(bb(n.content, (s, a) => !s.isAtom || !a.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), r), n.openStart, n.openEnd);
    return kn.fromReplace(e, this.from, this.to, o);
  }
  invert() {
    return new Ur(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return n.deleted && i.deleted || n.pos >= i.pos ? null : new ms(n.pos, i.pos, this.mark);
  }
  merge(e) {
    return e instanceof ms && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ms(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new ms(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Jn.jsonID("addMark", ms);
class Ur extends Jn {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, i) {
    super(), this.from = e, this.to = n, this.mark = i;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), i = new Ne(bb(n.content, (r) => r.mark(this.mark.removeFromSet(r.marks)), e), n.openStart, n.openEnd);
    return kn.fromReplace(e, this.from, this.to, i);
  }
  invert() {
    return new ms(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return n.deleted && i.deleted || n.pos >= i.pos ? null : new Ur(n.pos, i.pos, this.mark);
  }
  merge(e) {
    return e instanceof Ur && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Ur(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Ur(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Jn.jsonID("removeMark", Ur);
class gs extends Jn {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return kn.fail("No node at mark step's position");
    let i = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return kn.fromReplace(e, this.pos, this.pos + 1, new Ne(we.from(i), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let i = this.mark.addToSet(n.marks);
      if (i.length == n.marks.length) {
        for (let r = 0; r < n.marks.length; r++)
          if (!n.marks[r].isInSet(i))
            return new gs(this.pos, n.marks[r]);
        return new gs(this.pos, this.mark);
      }
    }
    return new Xl(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new gs(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new gs(n.pos, e.markFromJSON(n.mark));
  }
}
Jn.jsonID("addNodeMark", gs);
class Xl extends Jn {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return kn.fail("No node at mark step's position");
    let i = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return kn.fromReplace(e, this.pos, this.pos + 1, new Ne(we.from(i), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new gs(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Xl(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Xl(n.pos, e.markFromJSON(n.mark));
  }
}
Jn.jsonID("removeNodeMark", Xl);
class Mn extends Jn {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, i, r = !1) {
    super(), this.from = e, this.to = n, this.slice = i, this.structure = r;
  }
  apply(e) {
    return this.structure && YO(e, this.from, this.to) ? kn.fail("Structure replace would overwrite content") : kn.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Qi([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new Mn(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return n.deletedAcross && i.deletedAcross ? null : new Mn(n.pos, Math.max(n.pos, i.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof Mn) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? Ne.empty : new Ne(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new Mn(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? Ne.empty : new Ne(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new Mn(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new Mn(n.from, n.to, Ne.fromJSON(e, n.slice), !!n.structure);
  }
}
Jn.jsonID("replace", Mn);
class An extends Jn {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, i, r, o, s, a = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = i, this.gapTo = r, this.slice = o, this.insert = s, this.structure = a;
  }
  apply(e) {
    if (this.structure && (YO(e, this.from, this.gapFrom) || YO(e, this.gapTo, this.to)))
      return kn.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return kn.fail("Gap is not a flat range");
    let i = this.slice.insertAt(this.insert, n.content);
    return i ? kn.fromReplace(e, this.from, this.to, i) : kn.fail("Content does not fit in gap");
  }
  getMap() {
    return new Qi([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new An(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1), r = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), o = this.to == this.gapTo ? i.pos : e.map(this.gapTo, 1);
    return n.deletedAcross && i.deletedAcross || r < n.pos || o > i.pos ? null : new An(n.pos, i.pos, r, o, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new An(n.from, n.to, n.gapFrom, n.gapTo, Ne.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
}
Jn.jsonID("replaceAround", An);
function YO(t, e, n) {
  let i = t.resolve(e), r = n - e, o = i.depth;
  for (; r > 0 && o > 0 && i.indexAfter(o) == i.node(o).childCount; )
    o--, r--;
  if (r > 0) {
    let s = i.node(o).maybeChild(i.indexAfter(o));
    for (; r > 0; ) {
      if (!s || s.isLeaf)
        return !0;
      s = s.firstChild, r--;
    }
  }
  return !1;
}
function Wj(t, e, n, i) {
  let r = [], o = [], s, a;
  t.doc.nodesBetween(e, n, (l, u, c) => {
    if (!l.isInline)
      return;
    let d = l.marks;
    if (!i.isInSet(d) && c.type.allowsMarkType(i.type)) {
      let h = Math.max(u, e), f = Math.min(u + l.nodeSize, n), p = i.addToSet(d);
      for (let m = 0; m < d.length; m++)
        d[m].isInSet(p) || (s && s.to == h && s.mark.eq(d[m]) ? s.to = f : r.push(s = new Ur(h, f, d[m])));
      a && a.to == h ? a.to = f : o.push(a = new ms(h, f, i));
    }
  }), r.forEach((l) => t.step(l)), o.forEach((l) => t.step(l));
}
function Xj(t, e, n, i) {
  let r = [], o = 0;
  t.doc.nodesBetween(e, n, (s, a) => {
    if (!s.isInline)
      return;
    o++;
    let l = null;
    if (i instanceof om) {
      let u = s.marks, c;
      for (; c = i.isInSet(u); )
        (l || (l = [])).push(c), u = c.removeFromSet(u);
    } else
      i ? i.isInSet(s.marks) && (l = [i]) : l = s.marks;
    if (l && l.length) {
      let u = Math.min(a + s.nodeSize, n);
      for (let c = 0; c < l.length; c++) {
        let d = l[c], h;
        for (let f = 0; f < r.length; f++) {
          let p = r[f];
          p.step == o - 1 && d.eq(r[f].style) && (h = p);
        }
        h ? (h.to = u, h.step = o) : r.push({ style: d, from: Math.max(a, e), to: u, step: o });
      }
    }
  }), r.forEach((s) => t.step(new Ur(s.from, s.to, s.style)));
}
function wb(t, e, n, i = n.contentMatch, r = !0) {
  let o = t.doc.nodeAt(e), s = [], a = e + 1;
  for (let l = 0; l < o.childCount; l++) {
    let u = o.child(l), c = a + u.nodeSize, d = i.matchType(u.type);
    if (!d)
      s.push(new Mn(a, c, Ne.empty));
    else {
      i = d;
      for (let h = 0; h < u.marks.length; h++)
        n.allowsMarkType(u.marks[h].type) || t.step(new Ur(a, c, u.marks[h]));
      if (r && u.isText && n.whitespace != "pre") {
        let h, f = /\r?\n|\r/g, p;
        for (; h = f.exec(u.text); )
          p || (p = new Ne(we.from(n.schema.text(" ", n.allowedMarks(u.marks))), 0, 0)), s.push(new Mn(a + h.index, a + h.index + h[0].length, p));
      }
    }
    a = c;
  }
  if (!i.validEnd) {
    let l = i.fillBefore(we.empty, !0);
    t.replace(a, a, new Ne(l, 0, 0));
  }
  for (let l = s.length - 1; l >= 0; l--)
    t.step(s[l]);
}
function zj(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function vu(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let i = t.depth; ; --i) {
    let r = t.$from.node(i), o = t.$from.index(i), s = t.$to.indexAfter(i);
    if (i < t.depth && r.canReplace(o, s, n))
      return i;
    if (i == 0 || r.type.spec.isolating || !zj(r, o, s))
      break;
  }
  return null;
}
function jj(t, e, n) {
  let { $from: i, $to: r, depth: o } = e, s = i.before(o + 1), a = r.after(o + 1), l = s, u = a, c = we.empty, d = 0;
  for (let p = o, m = !1; p > n; p--)
    m || i.index(p) > 0 ? (m = !0, c = we.from(i.node(p).copy(c)), d++) : l--;
  let h = we.empty, f = 0;
  for (let p = o, m = !1; p > n; p--)
    m || r.after(p + 1) < r.end(p) ? (m = !0, h = we.from(r.node(p).copy(h)), f++) : u++;
  t.step(new An(l, u, s, a, new Ne(c.append(h), d, f), c.size - d, !0));
}
function kb(t, e, n = null, i = t) {
  let r = Yj(t, e), o = r && Hj(i, e);
  return o ? r.map(Ik).concat({ type: e, attrs: n }).concat(o.map(Ik)) : null;
}
function Ik(t) {
  return { type: t, attrs: null };
}
function Yj(t, e) {
  let { parent: n, startIndex: i, endIndex: r } = t, o = n.contentMatchAt(i).findWrapping(e);
  if (!o)
    return null;
  let s = o.length ? o[0] : e;
  return n.canReplaceWith(i, r, s) ? o : null;
}
function Hj(t, e) {
  let { parent: n, startIndex: i, endIndex: r } = t, o = n.child(i), s = e.contentMatch.findWrapping(o.type);
  if (!s)
    return null;
  let l = (s.length ? s[s.length - 1] : e).contentMatch;
  for (let u = i; l && u < r; u++)
    l = l.matchType(n.child(u).type);
  return !l || !l.validEnd ? null : s;
}
function Uj(t, e, n) {
  let i = we.empty;
  for (let s = n.length - 1; s >= 0; s--) {
    if (i.size) {
      let a = n[s].type.contentMatch.matchFragment(i);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    i = we.from(n[s].type.create(n[s].attrs, i));
  }
  let r = e.start, o = e.end;
  t.step(new An(r, o, r, o, new Ne(i, 0, 0), n.length, !0));
}
function Gj(t, e, n, i, r) {
  if (!i.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let o = t.steps.length;
  t.doc.nodesBetween(e, n, (s, a) => {
    let l = typeof r == "function" ? r(s) : r;
    if (s.isTextblock && !s.hasMarkup(i, l) && Kj(t.doc, t.mapping.slice(o).map(a), i)) {
      let u = null;
      if (i.schema.linebreakReplacement) {
        let f = i.whitespace == "pre", p = !!i.contentMatch.matchType(i.schema.linebreakReplacement);
        f && !p ? u = !1 : !f && p && (u = !0);
      }
      u === !1 && B$(t, s, a, o), wb(t, t.mapping.slice(o).map(a, 1), i, void 0, u === null);
      let c = t.mapping.slice(o), d = c.map(a, 1), h = c.map(a + s.nodeSize, 1);
      return t.step(new An(d, h, d + 1, h - 1, new Ne(we.from(i.create(l, null, s.marks)), 0, 0), 1, !0)), u === !0 && V$(t, s, a, o), !1;
    }
  });
}
function V$(t, e, n, i) {
  e.forEach((r, o) => {
    if (r.isText) {
      let s, a = /\r?\n|\r/g;
      for (; s = a.exec(r.text); ) {
        let l = t.mapping.slice(i).map(n + 1 + o + s.index);
        t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function B$(t, e, n, i) {
  e.forEach((r, o) => {
    if (r.type == r.type.schema.linebreakReplacement) {
      let s = t.mapping.slice(i).map(n + 1 + o);
      t.replaceWith(s, s + 1, e.type.schema.text(`
`));
    }
  });
}
function Kj(t, e, n) {
  let i = t.resolve(e), r = i.index();
  return i.parent.canReplaceWith(r, r + 1, n);
}
function Jj(t, e, n, i, r) {
  let o = t.doc.nodeAt(e);
  if (!o)
    throw new RangeError("No node at given position");
  n || (n = o.type);
  let s = n.create(i, null, r || o.marks);
  if (o.isLeaf)
    return t.replaceWith(e, e + o.nodeSize, s);
  if (!n.validContent(o.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new An(e, e + o.nodeSize, e + 1, e + o.nodeSize - 1, new Ne(we.from(s), 0, 0), 1, !0));
}
function Sl(t, e, n = 1, i) {
  let r = t.resolve(e), o = r.depth - n, s = i && i[i.length - 1] || r.parent;
  if (o < 0 || r.parent.type.spec.isolating || !r.parent.canReplace(r.index(), r.parent.childCount) || !s.type.validContent(r.parent.content.cutByIndex(r.index(), r.parent.childCount)))
    return !1;
  for (let u = r.depth - 1, c = n - 2; u > o; u--, c--) {
    let d = r.node(u), h = r.index(u);
    if (d.type.spec.isolating)
      return !1;
    let f = d.content.cutByIndex(h, d.childCount), p = i && i[c + 1];
    p && (f = f.replaceChild(0, p.type.create(p.attrs)));
    let m = i && i[c] || d;
    if (!d.canReplace(h + 1, d.childCount) || !m.type.validContent(f))
      return !1;
  }
  let a = r.indexAfter(o), l = i && i[0];
  return r.node(o).canReplaceWith(a, a, l ? l.type : r.node(o + 1).type);
}
function e4(t, e, n = 1, i) {
  let r = t.doc.resolve(e), o = we.empty, s = we.empty;
  for (let a = r.depth, l = r.depth - n, u = n - 1; a > l; a--, u--) {
    o = we.from(r.node(a).copy(o));
    let c = i && i[u];
    s = we.from(c ? c.type.create(c.attrs, s) : r.node(a).copy(s));
  }
  t.step(new Mn(e, e, new Ne(o.append(s), n, n), !0));
}
function zs(t, e) {
  let n = t.resolve(e), i = n.index();
  return Z$(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(i, i + 1);
}
function t4(t, e) {
  e.content.size || t.type.compatibleContent(e.type);
  let n = t.contentMatchAt(t.childCount), { linebreakReplacement: i } = t.type.schema;
  for (let r = 0; r < e.childCount; r++) {
    let o = e.child(r), s = o.type == i ? t.type.schema.nodes.text : o.type;
    if (n = n.matchType(s), !n || !t.type.allowsMarks(o.marks))
      return !1;
  }
  return n.validEnd;
}
function Z$(t, e) {
  return !!(t && e && !t.isLeaf && t4(t, e));
}
function sm(t, e, n = -1) {
  let i = t.resolve(e);
  for (let r = i.depth; ; r--) {
    let o, s, a = i.index(r);
    if (r == i.depth ? (o = i.nodeBefore, s = i.nodeAfter) : n > 0 ? (o = i.node(r + 1), a++, s = i.node(r).maybeChild(a)) : (o = i.node(r).maybeChild(a - 1), s = i.node(r + 1)), o && !o.isTextblock && Z$(o, s) && i.node(r).canReplace(a, a + 1))
      return e;
    if (r == 0)
      break;
    e = n < 0 ? i.before(r) : i.after(r);
  }
}
function n4(t, e, n) {
  let i = null, { linebreakReplacement: r } = t.doc.type.schema, o = t.doc.resolve(e - n), s = o.node().type;
  if (r && s.inlineContent) {
    let c = s.whitespace == "pre", d = !!s.contentMatch.matchType(r);
    c && !d ? i = !1 : !c && d && (i = !0);
  }
  let a = t.steps.length;
  if (i === !1) {
    let c = t.doc.resolve(e + n);
    B$(t, c.node(), c.before(), a);
  }
  s.inlineContent && wb(t, e + n - 1, s, o.node().contentMatchAt(o.index()), i == null);
  let l = t.mapping.slice(a), u = l.map(e - n);
  if (t.step(new Mn(u, l.map(e + n, -1), Ne.empty, !0)), i === !0) {
    let c = t.doc.resolve(u);
    V$(t, c.node(), c.before(), t.steps.length);
  }
  return t;
}
function i4(t, e, n) {
  let i = t.resolve(e);
  if (i.parent.canReplaceWith(i.index(), i.index(), n))
    return e;
  if (i.parentOffset == 0)
    for (let r = i.depth - 1; r >= 0; r--) {
      let o = i.index(r);
      if (i.node(r).canReplaceWith(o, o, n))
        return i.before(r + 1);
      if (o > 0)
        return null;
    }
  if (i.parentOffset == i.parent.content.size)
    for (let r = i.depth - 1; r >= 0; r--) {
      let o = i.indexAfter(r);
      if (i.node(r).canReplaceWith(o, o, n))
        return i.after(r + 1);
      if (o < i.node(r).childCount)
        return null;
    }
  return null;
}
function F$(t, e, n) {
  let i = t.resolve(e);
  if (!n.content.size)
    return e;
  let r = n.content;
  for (let o = 0; o < n.openStart; o++)
    r = r.firstChild.content;
  for (let o = 1; o <= (n.openStart == 0 && n.size ? 2 : 1); o++)
    for (let s = i.depth; s >= 0; s--) {
      let a = s == i.depth ? 0 : i.pos <= (i.start(s + 1) + i.end(s + 1)) / 2 ? -1 : 1, l = i.index(s) + (a > 0 ? 1 : 0), u = i.node(s), c = !1;
      if (o == 1)
        c = u.canReplace(l, l, r);
      else {
        let d = u.contentMatchAt(l).findWrapping(r.firstChild.type);
        c = d && u.canReplaceWith(l, l, d[0]);
      }
      if (c)
        return a == 0 ? i.pos : a < 0 ? i.before(s + 1) : i.after(s + 1);
    }
  return null;
}
function am(t, e, n = e, i = Ne.empty) {
  if (e == n && !i.size)
    return null;
  let r = t.resolve(e), o = t.resolve(n);
  return q$(r, o, i) ? new Mn(e, n, i) : new r4(r, o, i).fit();
}
function q$(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
class r4 {
  constructor(e, n, i) {
    this.$from = e, this.$to = n, this.unplaced = i, this.frontier = [], this.placed = we.empty;
    for (let r = 0; r <= e.depth; r++) {
      let o = e.node(r);
      this.frontier.push({
        type: o.type,
        match: o.contentMatchAt(e.indexAfter(r))
      });
    }
    for (let r = e.depth; r > 0; r--)
      this.placed = we.from(e.node(r).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let u = this.findFittable();
      u ? this.placeNodes(u) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, i = this.$from, r = this.close(e < 0 ? this.$to : i.doc.resolve(e));
    if (!r)
      return null;
    let o = this.placed, s = i.depth, a = r.depth;
    for (; s && a && o.childCount == 1; )
      o = o.firstChild.content, s--, a--;
    let l = new Ne(o, s, a);
    return e > -1 ? new An(i.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || i.pos != this.$to.pos ? new Mn(i.pos, r.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, i = 0, r = this.unplaced.openEnd; i < e; i++) {
      let o = n.firstChild;
      if (n.childCount > 1 && (r = 0), o.type.spec.isolating && r <= i) {
        e = i;
        break;
      }
      n = o.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let i = n == 1 ? e : this.unplaced.openStart; i >= 0; i--) {
        let r, o = null;
        i ? (o = cg(this.unplaced.content, i - 1).firstChild, r = o.content) : r = this.unplaced.content;
        let s = r.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: u } = this.frontier[a], c, d = null;
          if (n == 1 && (s ? u.matchType(s.type) || (d = u.fillBefore(we.from(s), !1)) : o && l.compatibleContent(o.type)))
            return { sliceDepth: i, frontierDepth: a, parent: o, inject: d };
          if (n == 2 && s && (c = u.findWrapping(s.type)))
            return { sliceDepth: i, frontierDepth: a, parent: o, wrap: c };
          if (o && u.matchType(o.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: i } = this.unplaced, r = cg(e, n);
    return !r.childCount || r.firstChild.isLeaf ? !1 : (this.unplaced = new Ne(e, n + 1, Math.max(i, r.size + n >= e.size - i ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: i } = this.unplaced, r = cg(e, n);
    if (r.childCount <= 1 && n > 0) {
      let o = e.size - n <= n + r.size;
      this.unplaced = new Ne(Yu(e, n - 1, 1), n - 1, o ? n - 1 : i);
    } else
      this.unplaced = new Ne(Yu(e, n, 1), n, i);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: i, inject: r, wrap: o }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (o)
      for (let m = 0; m < o.length; m++)
        this.openFrontierNode(o[m]);
    let s = this.unplaced, a = i ? i.content : s.content, l = s.openStart - e, u = 0, c = [], { match: d, type: h } = this.frontier[n];
    if (r) {
      for (let m = 0; m < r.childCount; m++)
        c.push(r.child(m));
      d = d.matchFragment(r);
    }
    let f = a.size + e - (s.content.size - s.openEnd);
    for (; u < a.childCount; ) {
      let m = a.child(u), g = d.matchType(m.type);
      if (!g)
        break;
      u++, (u > 1 || l == 0 || m.content.size) && (d = g, c.push(W$(m.mark(h.allowedMarks(m.marks)), u == 1 ? l : 0, u == a.childCount ? f : -1)));
    }
    let p = u == a.childCount;
    p || (f = -1), this.placed = Hu(this.placed, n, we.from(c)), this.frontier[n].match = d, p && f < 0 && i && i.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let m = 0, g = a; m < f; m++) {
      let O = g.lastChild;
      this.frontier.push({ type: O.type, match: O.contentMatchAt(O.childCount) }), g = O.content;
    }
    this.unplaced = p ? e == 0 ? Ne.empty : new Ne(Yu(s.content, e - 1, 1), e - 1, f < 0 ? s.openEnd : e - 1) : new Ne(Yu(s.content, e, u), s.openStart, s.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !dg(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: i } = this.$to, r = this.$to.after(i);
    for (; i > 1 && r == this.$to.end(--i); )
      ++r;
    return r;
  }
  findCloseLevel(e) {
    e:
      for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
        let { match: i, type: r } = this.frontier[n], o = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), s = dg(e, n, r, i, o);
        if (s) {
          for (let a = n - 1; a >= 0; a--) {
            let { match: l, type: u } = this.frontier[a], c = dg(e, a, u, l, !0);
            if (!c || c.childCount)
              continue e;
          }
          return { depth: n, fit: s, move: o ? e.doc.resolve(e.after(n + 1)) : e };
        }
      }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = Hu(this.placed, n.depth, n.fit)), e = n.move;
    for (let i = n.depth + 1; i <= e.depth; i++) {
      let r = e.node(i), o = r.type.contentMatch.fillBefore(r.content, !0, e.index(i));
      this.openFrontierNode(r.type, r.attrs, o);
    }
    return e;
  }
  openFrontierNode(e, n = null, i) {
    let r = this.frontier[this.depth];
    r.match = r.match.matchType(e), this.placed = Hu(this.placed, this.depth, we.from(e.create(n, i))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(we.empty, !0);
    n.childCount && (this.placed = Hu(this.placed, this.frontier.length, n));
  }
}
function Yu(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(Yu(t.firstChild.content, e - 1, n)));
}
function Hu(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(Hu(t.lastChild.content, e - 1, n)));
}
function cg(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function W$(t, e, n) {
  if (e <= 0)
    return t;
  let i = t.content;
  return e > 1 && (i = i.replaceChild(0, W$(i.firstChild, e - 1, i.childCount == 1 ? n - 1 : 0))), e > 0 && (i = t.type.contentMatch.fillBefore(i).append(i), n <= 0 && (i = i.append(t.type.contentMatch.matchFragment(i).fillBefore(we.empty, !0)))), t.copy(i);
}
function dg(t, e, n, i, r) {
  let o = t.node(e), s = r ? t.indexAfter(e) : t.index(e);
  if (s == o.childCount && !n.compatibleContent(o.type))
    return null;
  let a = i.fillBefore(o.content, !0, s);
  return a && !o4(n, o.content, s) ? a : null;
}
function o4(t, e, n) {
  for (let i = n; i < e.childCount; i++)
    if (!t.allowsMarks(e.child(i).marks))
      return !0;
  return !1;
}
function s4(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function a4(t, e, n, i) {
  if (!i.size)
    return t.deleteRange(e, n);
  let r = t.doc.resolve(e), o = t.doc.resolve(n);
  if (q$(r, o, i))
    return t.step(new Mn(e, n, i));
  let s = z$(r, t.doc.resolve(n));
  s[s.length - 1] == 0 && s.pop();
  let a = -(r.depth + 1);
  s.unshift(a);
  for (let h = r.depth, f = r.pos - 1; h > 0; h--, f--) {
    let p = r.node(h).type.spec;
    if (p.defining || p.definingAsContext || p.isolating)
      break;
    s.indexOf(h) > -1 ? a = h : r.before(h) == f && s.splice(1, 0, -h);
  }
  let l = s.indexOf(a), u = [], c = i.openStart;
  for (let h = i.content, f = 0; ; f++) {
    let p = h.firstChild;
    if (u.push(p), f == i.openStart)
      break;
    h = p.content;
  }
  for (let h = c - 1; h >= 0; h--) {
    let f = u[h], p = s4(f.type);
    if (p && !f.sameMarkup(r.node(Math.abs(a) - 1)))
      c = h;
    else if (p || !f.type.isTextblock)
      break;
  }
  for (let h = i.openStart; h >= 0; h--) {
    let f = (h + c + 1) % (i.openStart + 1), p = u[f];
    if (p)
      for (let m = 0; m < s.length; m++) {
        let g = s[(m + l) % s.length], O = !0;
        g < 0 && (O = !1, g = -g);
        let y = r.node(g - 1), b = r.index(g - 1);
        if (y.canReplaceWith(b, b, p.type, p.marks))
          return t.replace(r.before(g), O ? o.after(g) : n, new Ne(X$(i.content, 0, i.openStart, f), f, i.openEnd));
      }
  }
  let d = t.steps.length;
  for (let h = s.length - 1; h >= 0 && (t.replace(e, n, i), !(t.steps.length > d)); h--) {
    let f = s[h];
    f < 0 || (e = r.before(f), n = o.after(f));
  }
}
function X$(t, e, n, i, r) {
  if (e < n) {
    let o = t.firstChild;
    t = t.replaceChild(0, o.copy(X$(o.content, e + 1, n, i, o)));
  }
  if (e > i) {
    let o = r.contentMatchAt(0), s = o.fillBefore(t).append(t);
    t = s.append(o.matchFragment(s).fillBefore(we.empty, !0));
  }
  return t;
}
function l4(t, e, n, i) {
  if (!i.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let r = i4(t.doc, e, i.type);
    r != null && (e = n = r);
  }
  t.replaceRange(e, n, new Ne(we.from(i), 0, 0));
}
function u4(t, e, n) {
  let i = t.doc.resolve(e), r = t.doc.resolve(n), o = z$(i, r);
  for (let s = 0; s < o.length; s++) {
    let a = o[s], l = s == o.length - 1;
    if (l && a == 0 || i.node(a).type.contentMatch.validEnd)
      return t.delete(i.start(a), r.end(a));
    if (a > 0 && (l || i.node(a - 1).canReplace(i.index(a - 1), r.indexAfter(a - 1))))
      return t.delete(i.before(a), r.after(a));
  }
  for (let s = 1; s <= i.depth && s <= r.depth; s++)
    if (e - i.start(s) == i.depth - s && n > i.end(s) && r.end(s) - n != r.depth - s && i.start(s - 1) == r.start(s - 1) && i.node(s - 1).canReplace(i.index(s - 1), r.index(s - 1)))
      return t.delete(i.before(s), n);
  t.delete(e, n);
}
function z$(t, e) {
  let n = [], i = Math.min(t.depth, e.depth);
  for (let r = i; r >= 0; r--) {
    let o = t.start(r);
    if (o < t.pos - (t.depth - r) || e.end(r) > e.pos + (e.depth - r) || t.node(r).type.spec.isolating || e.node(r).type.spec.isolating)
      break;
    (o == e.start(r) || r == t.depth && r == e.depth && t.parent.inlineContent && e.parent.inlineContent && r && e.start(r - 1) == o - 1) && n.push(r);
  }
  return n;
}
class _l extends Jn {
  /**
  Construct an attribute step.
  */
  constructor(e, n, i) {
    super(), this.pos = e, this.attr = n, this.value = i;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return kn.fail("No node at attribute step's position");
    let i = /* @__PURE__ */ Object.create(null);
    for (let o in n.attrs)
      i[o] = n.attrs[o];
    i[this.attr] = this.value;
    let r = n.type.create(i, null, n.marks);
    return kn.fromReplace(e, this.pos, this.pos + 1, new Ne(we.from(r), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return Qi.empty;
  }
  invert(e) {
    return new _l(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new _l(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new _l(n.pos, n.attr, n.value);
  }
}
Jn.jsonID("attr", _l);
class Zc extends Jn {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let r in e.attrs)
      n[r] = e.attrs[r];
    n[this.attr] = this.value;
    let i = e.type.create(n, e.content, e.marks);
    return kn.ok(i);
  }
  getMap() {
    return Qi.empty;
  }
  invert(e) {
    return new Zc(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new Zc(n.attr, n.value);
  }
}
Jn.jsonID("docAttr", Zc);
let zl = class extends Error {
};
zl = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
zl.prototype = Object.create(Error.prototype);
zl.prototype.constructor = zl;
zl.prototype.name = "TransformError";
class Sb {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new kl();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new zl(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, i = Ne.empty) {
    let r = am(this.doc, e, n, i);
    return r && this.step(r), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, i) {
    return this.replace(e, n, new Ne(we.from(i), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, Ne.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, i) {
    return a4(this, e, n, i), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, i) {
    return l4(this, e, n, i), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return u4(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return jj(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return n4(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return Uj(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, i, r = null) {
    return Gj(this, e, n, i, r), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, i = null, r) {
    return Jj(this, e, n, i, r), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, i) {
    return this.step(new _l(e, n, i)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new Zc(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new gs(e, n)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    if (!(n instanceof Nt)) {
      let i = this.doc.nodeAt(e);
      if (!i)
        throw new RangeError("No node at position " + e);
      if (n = n.isInSet(i.marks), !n)
        return this;
    }
    return this.step(new Xl(e, n)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, n = 1, i) {
    return e4(this, e, n, i), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, i) {
    return Wj(this, e, n, i), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, i) {
    return Xj(this, e, n, i), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, i) {
    return wb(this, e, n, i), this;
  }
}
const hg = /* @__PURE__ */ Object.create(null);
class tt {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, i) {
    this.$anchor = e, this.$head = n, this.ranges = i || [new j$(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = Ne.empty) {
    let i = n.content.lastChild, r = null;
    for (let a = 0; a < n.openEnd; a++)
      r = i, i = i.lastChild;
    let o = e.steps.length, s = this.ranges;
    for (let a = 0; a < s.length; a++) {
      let { $from: l, $to: u } = s[a], c = e.mapping.slice(o);
      e.replaceRange(c.map(l.pos), c.map(u.pos), a ? Ne.empty : n), a == 0 && Bk(e, o, (i ? i.isInline : r && r.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let i = e.steps.length, r = this.ranges;
    for (let o = 0; o < r.length; o++) {
      let { $from: s, $to: a } = r[o], l = e.mapping.slice(i), u = l.map(s.pos), c = l.map(a.pos);
      o ? e.deleteRange(u, c) : (e.replaceRangeWith(u, c, n), Bk(e, i, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, i = !1) {
    let r = e.parent.inlineContent ? new Je(e) : ll(e.node(0), e.parent, e.pos, e.index(), n, i);
    if (r)
      return r;
    for (let o = e.depth - 1; o >= 0; o--) {
      let s = n < 0 ? ll(e.node(0), e.node(o), e.before(o + 1), e.index(o), n, i) : ll(e.node(0), e.node(o), e.after(o + 1), e.index(o) + 1, n, i);
      if (s)
        return s;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new wr(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return ll(e, e, 0, 0, 1) || new wr(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return ll(e, e, e.content.size, e.childCount, -1) || new wr(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let i = hg[n.type];
    if (!i)
      throw new RangeError(`No selection type ${n.type} defined`);
    return i.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in hg)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return hg[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return Je.between(this.$anchor, this.$head).getBookmark();
  }
}
tt.prototype.visible = !0;
let j$ = class {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
}, Lk = !1;
function Vk(t) {
  !Lk && !t.parent.inlineContent && (Lk = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class Je extends tt {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    Vk(e), Vk(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let i = e.resolve(n.map(this.head));
    if (!i.parent.inlineContent)
      return tt.near(i);
    let r = e.resolve(n.map(this.anchor));
    return new Je(r.parent.inlineContent ? r : i, i);
  }
  replace(e, n = Ne.empty) {
    if (super.replace(e, n), n == Ne.empty) {
      let i = this.$from.marksAcross(this.$to);
      i && e.ensureMarks(i);
    }
  }
  eq(e) {
    return e instanceof Je && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new lm(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new Je(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, i = n) {
    let r = e.resolve(n);
    return new this(r, i == n ? r : e.resolve(i));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, i) {
    let r = e.pos - n.pos;
    if ((!i || r) && (i = r >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let o = tt.findFrom(n, i, !0) || tt.findFrom(n, -i, !0);
      if (o)
        n = o.$head;
      else
        return tt.near(n, i);
    }
    return e.parent.inlineContent || (r == 0 ? e = n : (e = (tt.findFrom(e, -i, !0) || tt.findFrom(e, i, !0)).$anchor, e.pos < n.pos != r < 0 && (e = n))), new Je(e, n);
  }
}
tt.jsonID("text", Je);
class lm {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new lm(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return Je.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class Ke extends tt {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, i = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, i), this.node = n;
  }
  map(e, n) {
    let { deleted: i, pos: r } = n.mapResult(this.anchor), o = e.resolve(r);
    return i ? tt.near(o) : new Ke(o);
  }
  content() {
    return new Ne(we.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof Ke && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new _b(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new Ke(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new Ke(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
Ke.prototype.visible = !1;
tt.jsonID("node", Ke);
class _b {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: i } = e.mapResult(this.anchor);
    return n ? new lm(i, i) : new _b(i);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), i = n.nodeAfter;
    return i && Ke.isSelectable(i) ? new Ke(n) : tt.near(n);
  }
}
class wr extends tt {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = Ne.empty) {
    if (n == Ne.empty) {
      e.delete(0, e.doc.content.size);
      let i = tt.atStart(e.doc);
      i.eq(e.selection) || e.setSelection(i);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new wr(e);
  }
  map(e) {
    return new wr(e);
  }
  eq(e) {
    return e instanceof wr;
  }
  getBookmark() {
    return c4;
  }
}
tt.jsonID("all", wr);
const c4 = {
  map() {
    return this;
  },
  resolve(t) {
    return new wr(t);
  }
};
function ll(t, e, n, i, r, o = !1) {
  if (e.inlineContent)
    return Je.create(t, n);
  for (let s = i - (r > 0 ? 0 : 1); r > 0 ? s < e.childCount : s >= 0; s += r) {
    let a = e.child(s);
    if (a.isAtom) {
      if (!o && Ke.isSelectable(a))
        return Ke.create(t, n - (r < 0 ? a.nodeSize : 0));
    } else {
      let l = ll(t, a, n + r, r < 0 ? a.childCount : 0, r, o);
      if (l)
        return l;
    }
    n += a.nodeSize * r;
  }
  return null;
}
function Bk(t, e, n) {
  let i = t.steps.length - 1;
  if (i < e)
    return;
  let r = t.steps[i];
  if (!(r instanceof Mn || r instanceof An))
    return;
  let o = t.mapping.maps[i], s;
  o.forEach((a, l, u, c) => {
    s == null && (s = c);
  }), t.setSelection(tt.near(t.doc.resolve(s), n));
}
const Zk = 1, Hd = 2, Fk = 4;
let d4 = class extends Sb {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Zk) & ~Hd, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & Zk) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= Hd, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return Nt.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & Hd) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & ~Hd, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let i = this.selection;
    return n && (e = e.mark(this.storedMarks || (i.empty ? i.$from.marks() : i.$from.marksAcross(i.$to) || Nt.none))), i.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, i) {
    let r = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(r.text(e), !0) : this.deleteSelection();
    {
      if (i == null && (i = n), i = i ?? n, !e)
        return this.deleteRange(n, i);
      let o = this.storedMarks;
      if (!o) {
        let s = this.doc.resolve(n);
        o = i == n ? s.marks() : s.marksAcross(this.doc.resolve(i));
      }
      return this.replaceRangeWith(n, i, r.text(e, o)), this.selection.empty || this.setSelection(tt.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= Fk, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & Fk) > 0;
  }
};
function qk(t, e) {
  return !e || !t ? t : t.bind(e);
}
class Uu {
  constructor(e, n, i) {
    this.name = e, this.init = qk(n.init, i), this.apply = qk(n.apply, i);
  }
}
const h4 = [
  new Uu("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    }
  }),
  new Uu("selection", {
    init(t, e) {
      return t.selection || tt.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    }
  }),
  new Uu("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, i) {
      return i.selection.$cursor ? t.storedMarks : null;
    }
  }),
  new Uu("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })
];
let fg = class {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = h4.slice(), n && n.forEach((i) => {
      if (this.pluginsByKey[i.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + i.key + ")");
      this.plugins.push(i), this.pluginsByKey[i.key] = i, i.spec.state && this.fields.push(new Uu(i.key, i.spec.state, i));
    });
  }
}, f4 = class Gu {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != n) {
        let r = this.config.plugins[i];
        if (r.spec.filterTransaction && !r.spec.filterTransaction.call(r, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], i = this.applyInner(e), r = null;
    for (; ; ) {
      let o = !1;
      for (let s = 0; s < this.config.plugins.length; s++) {
        let a = this.config.plugins[s];
        if (a.spec.appendTransaction) {
          let l = r ? r[s].n : 0, u = r ? r[s].state : this, c = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, u, i);
          if (c && i.filterTransaction(c, s)) {
            if (c.setMeta("appendedTransaction", e), !r) {
              r = [];
              for (let d = 0; d < this.config.plugins.length; d++)
                r.push(d < s ? { state: i, n: n.length } : { state: this, n: 0 });
            }
            n.push(c), i = i.applyInner(c), o = !0;
          }
          r && (r[s] = { state: i, n: n.length });
        }
      }
      if (!o)
        return { state: i, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new Gu(this.config), i = this.config.fields;
    for (let r = 0; r < i.length; r++) {
      let o = i[r];
      n[o.name] = o.apply(e, this[o.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new d4(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new fg(e.doc ? e.doc.type.schema : e.schema, e.plugins), i = new Gu(n);
    for (let r = 0; r < n.fields.length; r++)
      i[n.fields[r].name] = n.fields[r].init(e, i);
    return i;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new fg(this.schema, e.plugins), i = n.fields, r = new Gu(n);
    for (let o = 0; o < i.length; o++) {
      let s = i[o].name;
      r[s] = this.hasOwnProperty(s) ? this[s] : i[o].init(e, r);
    }
    return r;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((i) => i.toJSON())), e && typeof e == "object")
      for (let i in e) {
        if (i == "doc" || i == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let r = e[i], o = r.spec.state;
        o && o.toJSON && (n[i] = o.toJSON.call(r, this[r.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, i) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let r = new fg(e.schema, e.plugins), o = new Gu(r);
    return r.fields.forEach((s) => {
      if (s.name == "doc")
        o.doc = xs.fromJSON(e.schema, n.doc);
      else if (s.name == "selection")
        o.selection = tt.fromJSON(o.doc, n.selection);
      else if (s.name == "storedMarks")
        n.storedMarks && (o.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (i)
          for (let a in i) {
            let l = i[a], u = l.spec.state;
            if (l.key == s.name && u && u.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              o[s.name] = u.fromJSON.call(l, e, n[a], o);
              return;
            }
          }
        o[s.name] = s.init(e, o);
      }
    }), o;
  }
};
function Y$(t, e, n) {
  for (let i in t) {
    let r = t[i];
    r instanceof Function ? r = r.bind(e) : i == "handleDOMEvents" && (r = Y$(r, e, {})), n[i] = r;
  }
  return n;
}
class rn {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && Y$(e.props, this, this.props), this.key = e.key ? e.key.key : H$("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const pg = /* @__PURE__ */ Object.create(null);
function H$(t) {
  return t in pg ? t + "$" + ++pg[t] : (pg[t] = 0, t + "$");
}
class _n {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = H$(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Ln = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, Fc = function(t) {
  let e = t.assignedSlot || t.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let HO = null;
const xo = function(t, e, n) {
  let i = HO || (HO = document.createRange());
  return i.setEnd(t, n ?? t.nodeValue.length), i.setStart(t, e || 0), i;
}, p4 = function() {
  HO = null;
}, Qa = function(t, e, n, i) {
  return n && (Wk(t, e, n, i, -1) || Wk(t, e, n, i, 1));
}, m4 = /^(img|br|input|textarea|hr)$/i;
function Wk(t, e, n, i, r) {
  for (; ; ) {
    if (t == n && e == i)
      return !0;
    if (e == (r < 0 ? 0 : Ui(t))) {
      let o = t.parentNode;
      if (!o || o.nodeType != 1 || $d(t) || m4.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = Ln(t) + (r < 0 ? 0 : 1), t = o;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (r < 0 ? -1 : 0)], t.contentEditable == "false")
        return !1;
      e = r < 0 ? Ui(t) : 0;
    } else
      return !1;
  }
}
function Ui(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function g4(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e)
      return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e - 1], e = Ui(t);
    } else if (t.parentNode && !$d(t))
      e = Ln(t), t = t.parentNode;
    else
      return null;
  }
}
function O4(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e < t.nodeValue.length)
      return t;
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e], e = 0;
    } else if (t.parentNode && !$d(t))
      e = Ln(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
function v4(t, e, n) {
  for (let i = e == 0, r = e == Ui(t); i || r; ) {
    if (t == n)
      return !0;
    let o = Ln(t);
    if (t = t.parentNode, !t)
      return !1;
    i = i && o == 0, r = r && o == Ui(t);
  }
}
function $d(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const um = function(t) {
  return t.focusNode && Qa(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function oa(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
function y4(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function b4(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let i = t.caretPositionFromPoint(e, n);
      if (i)
        return { node: i.offsetNode, offset: Math.min(Ui(i.offsetNode), i.offset) };
    } catch {
    }
  if (t.caretRangeFromPoint) {
    let i = t.caretRangeFromPoint(e, n);
    if (i)
      return { node: i.startContainer, offset: Math.min(Ui(i.startContainer), i.startOffset) };
  }
}
const lo = typeof navigator < "u" ? navigator : null, Xk = typeof document < "u" ? document : null, js = lo && lo.userAgent || "", UO = /Edge\/(\d+)/.exec(js), U$ = /MSIE \d/.exec(js), GO = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(js), Ci = !!(U$ || GO || UO), Ts = U$ ? document.documentMode : GO ? +GO[1] : UO ? +UO[1] : 0, xr = !Ci && /gecko\/(\d+)/i.test(js);
xr && +(/Firefox\/(\d+)/.exec(js) || [0, 0])[1];
const KO = !Ci && /Chrome\/(\d+)/.exec(js), Hn = !!KO, G$ = KO ? +KO[1] : 0, di = !Ci && !!lo && /Apple Computer/.test(lo.vendor), jl = di && (/Mobile\/\w+/.test(js) || !!lo && lo.maxTouchPoints > 2), ji = jl || (lo ? /Mac/.test(lo.platform) : !1), w4 = lo ? /Win/.test(lo.platform) : !1, pr = /Android \d/.test(js), Pd = !!Xk && "webkitFontSmoothing" in Xk.documentElement.style, k4 = Pd ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function S4(t) {
  let e = t.defaultView && t.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.documentElement.clientWidth,
    top: 0,
    bottom: t.documentElement.clientHeight
  };
}
function yo(t, e) {
  return typeof t == "number" ? t : t[e];
}
function _4(t) {
  let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, i = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * i
  };
}
function zk(t, e, n) {
  let i = t.someProp("scrollThreshold") || 0, r = t.someProp("scrollMargin") || 5, o = t.dom.ownerDocument;
  for (let s = n || t.dom; s; s = Fc(s)) {
    if (s.nodeType != 1)
      continue;
    let a = s, l = a == o.body, u = l ? S4(o) : _4(a), c = 0, d = 0;
    if (e.top < u.top + yo(i, "top") ? d = -(u.top - e.top + yo(r, "top")) : e.bottom > u.bottom - yo(i, "bottom") && (d = e.bottom - e.top > u.bottom - u.top ? e.top + yo(r, "top") - u.top : e.bottom - u.bottom + yo(r, "bottom")), e.left < u.left + yo(i, "left") ? c = -(u.left - e.left + yo(r, "left")) : e.right > u.right - yo(i, "right") && (c = e.right - u.right + yo(r, "right")), c || d)
      if (l)
        o.defaultView.scrollBy(c, d);
      else {
        let h = a.scrollLeft, f = a.scrollTop;
        d && (a.scrollTop += d), c && (a.scrollLeft += c);
        let p = a.scrollLeft - h, m = a.scrollTop - f;
        e = { left: e.left - p, top: e.top - m, right: e.right - p, bottom: e.bottom - m };
      }
    if (l || /^(fixed|sticky)$/.test(getComputedStyle(s).position))
      break;
  }
}
function x4(t) {
  let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), i, r;
  for (let o = (e.left + e.right) / 2, s = n + 1; s < Math.min(innerHeight, e.bottom); s += 5) {
    let a = t.root.elementFromPoint(o, s);
    if (!a || a == t.dom || !t.dom.contains(a))
      continue;
    let l = a.getBoundingClientRect();
    if (l.top >= n - 20) {
      i = a, r = l.top;
      break;
    }
  }
  return { refDOM: i, refTop: r, stack: K$(t.dom) };
}
function K$(t) {
  let e = [], n = t.ownerDocument;
  for (let i = t; i && (e.push({ dom: i, top: i.scrollTop, left: i.scrollLeft }), t != n); i = Fc(i))
    ;
  return e;
}
function C4({ refDOM: t, refTop: e, stack: n }) {
  let i = t ? t.getBoundingClientRect().top : 0;
  J$(n, i == 0 ? 0 : i - e);
}
function J$(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: i, top: r, left: o } = t[n];
    i.scrollTop != r + e && (i.scrollTop = r + e), i.scrollLeft != o && (i.scrollLeft = o);
  }
}
let tl = null;
function T4(t) {
  if (t.setActive)
    return t.setActive();
  if (tl)
    return t.focus(tl);
  let e = K$(t);
  t.focus(tl == null ? {
    get preventScroll() {
      return tl = { preventScroll: !0 }, !0;
    }
  } : void 0), tl || (tl = !1, J$(e, 0));
}
function eP(t, e) {
  let n, i = 2e8, r, o = 0, s = e.top, a = e.top, l, u;
  for (let c = t.firstChild, d = 0; c; c = c.nextSibling, d++) {
    let h;
    if (c.nodeType == 1)
      h = c.getClientRects();
    else if (c.nodeType == 3)
      h = xo(c).getClientRects();
    else
      continue;
    for (let f = 0; f < h.length; f++) {
      let p = h[f];
      if (p.top <= s && p.bottom >= a) {
        s = Math.max(p.bottom, s), a = Math.min(p.top, a);
        let m = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0;
        if (m < i) {
          n = c, i = m, r = m && n.nodeType == 3 ? {
            left: p.right < e.left ? p.right : p.left,
            top: e.top
          } : e, c.nodeType == 1 && m && (o = d + (e.left >= (p.left + p.right) / 2 ? 1 : 0));
          continue;
        }
      } else
        p.top > e.top && !l && p.left <= e.left && p.right >= e.left && (l = c, u = { left: Math.max(p.left, Math.min(p.right, e.left)), top: p.top });
      !n && (e.left >= p.right && e.top >= p.top || e.left >= p.left && e.top >= p.bottom) && (o = d + 1);
    }
  }
  return !n && l && (n = l, r = u, i = 0), n && n.nodeType == 3 ? $4(n, r) : !n || i && n.nodeType == 1 ? { node: t, offset: o } : eP(n, r);
}
function $4(t, e) {
  let n = t.nodeValue.length, i = document.createRange();
  for (let r = 0; r < n; r++) {
    i.setEnd(t, r + 1), i.setStart(t, r);
    let o = ts(i, 1);
    if (o.top != o.bottom && xb(e, o))
      return { node: t, offset: r + (e.left >= (o.left + o.right) / 2 ? 1 : 0) };
  }
  return { node: t, offset: 0 };
}
function xb(t, e) {
  return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function P4(t, e) {
  let n = t.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function M4(t, e, n) {
  let { node: i, offset: r } = eP(e, n), o = -1;
  if (i.nodeType == 1 && !i.firstChild) {
    let s = i.getBoundingClientRect();
    o = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(i, r, o);
}
function E4(t, e, n, i) {
  let r = -1;
  for (let o = e, s = !1; o != t.dom; ) {
    let a = t.docView.nearestDesc(o, !0);
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM)) {
      let l = a.dom.getBoundingClientRect();
      if (a.node.isBlock && a.parent && (!s && l.left > i.left || l.top > i.top ? r = a.posBefore : (!s && l.right < i.left || l.bottom < i.top) && (r = a.posAfter), s = !0), !a.contentDOM && r < 0 && !a.node.isText)
        return (a.node.isBlock ? i.top < (l.top + l.bottom) / 2 : i.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
    }
    o = a.dom.parentNode;
  }
  return r > -1 ? r : t.docView.posFromDOM(e, n, -1);
}
function tP(t, e, n) {
  let i = t.childNodes.length;
  if (i && n.top < n.bottom)
    for (let r = Math.max(0, Math.min(i - 1, Math.floor(i * (e.top - n.top) / (n.bottom - n.top)) - 2)), o = r; ; ) {
      let s = t.childNodes[o];
      if (s.nodeType == 1) {
        let a = s.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let u = a[l];
          if (xb(e, u))
            return tP(s, e, u);
        }
      }
      if ((o = (o + 1) % i) == r)
        break;
    }
  return t;
}
function A4(t, e) {
  let n = t.dom.ownerDocument, i, r = 0, o = b4(n, e.left, e.top);
  o && ({ node: i, offset: r } = o);
  let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), a;
  if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let u = t.dom.getBoundingClientRect();
    if (!xb(e, u) || (s = tP(t.dom, e, u), !s))
      return null;
  }
  if (di)
    for (let u = s; i && u; u = Fc(u))
      u.draggable && (i = void 0);
  if (s = P4(s, e), i) {
    if (xr && i.nodeType == 1 && (r = Math.min(r, i.childNodes.length), r < i.childNodes.length)) {
      let c = i.childNodes[r], d;
      c.nodeName == "IMG" && (d = c.getBoundingClientRect()).right <= e.left && d.bottom > e.top && r++;
    }
    let u;
    Pd && r && i.nodeType == 1 && (u = i.childNodes[r - 1]).nodeType == 1 && u.contentEditable == "false" && u.getBoundingClientRect().top >= e.top && r--, i == t.dom && r == i.childNodes.length - 1 && i.lastChild.nodeType == 1 && e.top > i.lastChild.getBoundingClientRect().bottom ? a = t.state.doc.content.size : (r == 0 || i.nodeType != 1 || i.childNodes[r - 1].nodeName != "BR") && (a = E4(t, i, r, e));
  }
  a == null && (a = M4(t, s, e));
  let l = t.docView.nearestDesc(s, !0);
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
}
function jk(t) {
  return t.top < t.bottom || t.left < t.right;
}
function ts(t, e) {
  let n = t.getClientRects();
  if (n.length) {
    let i = n[e < 0 ? 0 : n.length - 1];
    if (jk(i))
      return i;
  }
  return Array.prototype.find.call(n, jk) || t.getBoundingClientRect();
}
const R4 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function nP(t, e, n) {
  let { node: i, offset: r, atom: o } = t.docView.domFromPos(e, n < 0 ? -1 : 1), s = Pd || xr;
  if (i.nodeType == 3)
    if (s && (R4.test(i.nodeValue) || (n < 0 ? !r : r == i.nodeValue.length))) {
      let l = ts(xo(i, r, r), n);
      if (xr && r && /\s/.test(i.nodeValue[r - 1]) && r < i.nodeValue.length) {
        let u = ts(xo(i, r - 1, r - 1), -1);
        if (u.top == l.top) {
          let c = ts(xo(i, r, r + 1), -1);
          if (c.top != l.top)
            return Du(c, c.left < u.left);
        }
      }
      return l;
    } else {
      let l = r, u = r, c = n < 0 ? 1 : -1;
      return n < 0 && !r ? (u++, c = -1) : n >= 0 && r == i.nodeValue.length ? (l--, c = 1) : n < 0 ? l-- : u++, Du(ts(xo(i, l, u), c), c < 0);
    }
  if (!t.state.doc.resolve(e - (o || 0)).parent.inlineContent) {
    if (o == null && r && (n < 0 || r == Ui(i))) {
      let l = i.childNodes[r - 1];
      if (l.nodeType == 1)
        return mg(l.getBoundingClientRect(), !1);
    }
    if (o == null && r < Ui(i)) {
      let l = i.childNodes[r];
      if (l.nodeType == 1)
        return mg(l.getBoundingClientRect(), !0);
    }
    return mg(i.getBoundingClientRect(), n >= 0);
  }
  if (o == null && r && (n < 0 || r == Ui(i))) {
    let l = i.childNodes[r - 1], u = l.nodeType == 3 ? xo(l, Ui(l) - (s ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (u)
      return Du(ts(u, 1), !1);
  }
  if (o == null && r < Ui(i)) {
    let l = i.childNodes[r];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let u = l ? l.nodeType == 3 ? xo(l, 0, s ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (u)
      return Du(ts(u, -1), !0);
  }
  return Du(ts(i.nodeType == 3 ? xo(i) : i, -n), n >= 0);
}
function Du(t, e) {
  if (t.width == 0)
    return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function mg(t, e) {
  if (t.height == 0)
    return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function iP(t, e, n) {
  let i = t.state, r = t.root.activeElement;
  i != e && t.updateState(e), r != t.dom && t.focus();
  try {
    return n();
  } finally {
    i != e && t.updateState(i), r != t.dom && r && r.focus();
  }
}
function D4(t, e, n) {
  let i = e.selection, r = n == "up" ? i.$from : i.$to;
  return iP(t, e, () => {
    let { node: o } = t.docView.domFromPos(r.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = t.docView.nearestDesc(o, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        o = a.contentDOM || a.dom;
        break;
      }
      o = a.dom.parentNode;
    }
    let s = nP(t, r.pos, 1);
    for (let a = o.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1)
        l = a.getClientRects();
      else if (a.nodeType == 3)
        l = xo(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let u = 0; u < l.length; u++) {
        let c = l[u];
        if (c.bottom > c.top + 1 && (n == "up" ? s.top - c.top > (c.bottom - s.top) * 2 : c.bottom - s.bottom > (s.bottom - c.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const Q4 = /[\u0590-\u08ac]/;
function N4(t, e, n) {
  let { $head: i } = e.selection;
  if (!i.parent.isTextblock)
    return !1;
  let r = i.parentOffset, o = !r, s = r == i.parent.content.size, a = t.domSelection();
  return a ? !Q4.test(i.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? o : s : iP(t, e, () => {
    let { focusNode: l, focusOffset: u, anchorNode: c, anchorOffset: d } = t.domSelectionRange(), h = a.caretBidiLevel;
    a.modify("move", n, "character");
    let f = i.depth ? t.docView.domAfterPos(i.before()) : t.dom, { focusNode: p, focusOffset: m } = t.domSelectionRange(), g = p && !f.contains(p.nodeType == 1 ? p : p.parentNode) || l == p && u == m;
    try {
      a.collapse(c, d), l && (l != c || u != d) && a.extend && a.extend(l, u);
    } catch {
    }
    return h != null && (a.caretBidiLevel = h), g;
  }) : i.pos == i.start() || i.pos == i.end();
}
let Yk = null, Hk = null, Uk = !1;
function I4(t, e, n) {
  return Yk == e && Hk == n ? Uk : (Yk = e, Hk = n, Uk = n == "up" || n == "down" ? D4(t, e, n) : N4(t, e, n));
}
const er = 0, Gk = 1, da = 2, uo = 3;
class Md {
  constructor(e, n, i, r) {
    this.parent = e, this.children = n, this.dom = i, this.contentDOM = r, this.dirty = er, i.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, i) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, i = this.posAtStart; ; n++) {
      let r = this.children[n];
      if (r == e)
        return i;
      i += r.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, i) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (i < 0) {
        let o, s;
        if (e == this.contentDOM)
          o = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.previousSibling;
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this); )
          o = o.previousSibling;
        return o ? this.posBeforeChild(s) + s.size : this.posAtStart;
      } else {
        let o, s;
        if (e == this.contentDOM)
          o = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.nextSibling;
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this); )
          o = o.nextSibling;
        return o ? this.posBeforeChild(s) : this.posAtEnd;
      }
    let r;
    if (e == this.dom && this.contentDOM)
      r = n > Ln(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      r = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            r = !1;
            break;
          }
          if (o.previousSibling)
            break;
        }
      if (r == null && n == e.childNodes.length)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            r = !0;
            break;
          }
          if (o.nextSibling)
            break;
        }
    }
    return r ?? i > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let i = !0, r = e; r; r = r.parentNode) {
      let o = this.getDesc(r), s;
      if (o && (!n || o.node))
        if (i && (s = o.nodeDOM) && !(s.nodeType == 1 ? s.contains(e.nodeType == 1 ? e : e.parentNode) : s == e))
          i = !1;
        else
          return o;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let i = n; i; i = i.parent)
      if (i == this)
        return n;
  }
  posFromDOM(e, n, i) {
    for (let r = e; r; r = r.parentNode) {
      let o = this.getDesc(r);
      if (o)
        return o.localPosFromDOM(e, n, i);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, i = 0; n < this.children.length; n++) {
      let r = this.children[n], o = i + r.size;
      if (i == e && o != i) {
        for (; !r.border && r.children.length; )
          r = r.children[0];
        return r;
      }
      if (e < o)
        return r.descAt(e - i - r.border);
      i = o;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let i = 0, r = 0;
    for (let o = 0; i < this.children.length; i++) {
      let s = this.children[i], a = o + s.size;
      if (a > e || s instanceof oP) {
        r = e - o;
        break;
      }
      o = a;
    }
    if (r)
      return this.children[i].domFromPos(r - this.children[i].border, n);
    for (let o; i && !(o = this.children[i - 1]).size && o instanceof rP && o.side >= 0; i--)
      ;
    if (n <= 0) {
      let o, s = !0;
      for (; o = i ? this.children[i - 1] : null, !(!o || o.dom.parentNode == this.contentDOM); i--, s = !1)
        ;
      return o && n && s && !o.border && !o.domAtom ? o.domFromPos(o.size, n) : { node: this.contentDOM, offset: o ? Ln(o.dom) + 1 : 0 };
    } else {
      let o, s = !0;
      for (; o = i < this.children.length ? this.children[i] : null, !(!o || o.dom.parentNode == this.contentDOM); i++, s = !1)
        ;
      return o && s && !o.border && !o.domAtom ? o.domFromPos(0, n) : { node: this.contentDOM, offset: o ? Ln(o.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, i = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let r = -1, o = -1;
    for (let s = i, a = 0; ; a++) {
      let l = this.children[a], u = s + l.size;
      if (r == -1 && e <= u) {
        let c = s + l.border;
        if (e >= c && n <= u - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, n, c);
        e = s;
        for (let d = a; d > 0; d--) {
          let h = this.children[d - 1];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(1)) {
            r = Ln(h.dom) + 1;
            break;
          }
          e -= h.size;
        }
        r == -1 && (r = 0);
      }
      if (r > -1 && (u > n || a == this.children.length - 1)) {
        n = u;
        for (let c = a + 1; c < this.children.length; c++) {
          let d = this.children[c];
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
            o = Ln(d.dom);
            break;
          }
          n += d.size;
        }
        o == -1 && (o = this.contentDOM.childNodes.length);
        break;
      }
      s = u;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: r, toOffset: o };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: i } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || i == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[i];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, i, r = !1) {
    let o = Math.min(e, n), s = Math.max(e, n);
    for (let f = 0, p = 0; f < this.children.length; f++) {
      let m = this.children[f], g = p + m.size;
      if (o > p && s < g)
        return m.setSelection(e - p - m.border, n - p - m.border, i, r);
      p = g;
    }
    let a = this.domFromPos(e, e ? -1 : 1), l = n == e ? a : this.domFromPos(n, n ? -1 : 1), u = i.root.getSelection(), c = i.domSelectionRange(), d = !1;
    if ((xr || di) && e == n) {
      let { node: f, offset: p } = a;
      if (f.nodeType == 3) {
        if (d = !!(p && f.nodeValue[p - 1] == `
`), d && p == f.nodeValue.length)
          for (let m = f, g; m; m = m.parentNode) {
            if (g = m.nextSibling) {
              g.nodeName == "BR" && (a = l = { node: g.parentNode, offset: Ln(g) + 1 });
              break;
            }
            let O = m.pmViewDesc;
            if (O && O.node && O.node.isBlock)
              break;
          }
      } else {
        let m = f.childNodes[p - 1];
        d = m && (m.nodeName == "BR" || m.contentEditable == "false");
      }
    }
    if (xr && c.focusNode && c.focusNode != l.node && c.focusNode.nodeType == 1) {
      let f = c.focusNode.childNodes[c.focusOffset];
      f && f.contentEditable == "false" && (r = !0);
    }
    if (!(r || d && di) && Qa(a.node, a.offset, c.anchorNode, c.anchorOffset) && Qa(l.node, l.offset, c.focusNode, c.focusOffset))
      return;
    let h = !1;
    if ((u.extend || e == n) && !d) {
      u.collapse(a.node, a.offset);
      try {
        e != n && u.extend(l.node, l.offset), h = !0;
      } catch {
      }
    }
    if (!h) {
      if (e > n) {
        let p = a;
        a = l, l = p;
      }
      let f = document.createRange();
      f.setEnd(l.node, l.offset), f.setStart(a.node, a.offset), u.removeAllRanges(), u.addRange(f);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let i = 0, r = 0; r < this.children.length; r++) {
      let o = this.children[r], s = i + o.size;
      if (i == s ? e <= s && n >= i : e < s && n > i) {
        let a = i + o.border, l = s - o.border;
        if (e >= a && n <= l) {
          this.dirty = e == i || n == s ? da : Gk, e == a && n == l && (o.contentLost || o.dom.parentNode != this.contentDOM) ? o.dirty = uo : o.markDirty(e - a, n - a);
          return;
        } else
          o.dirty = o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length ? da : uo;
      }
      i = s;
    }
    this.dirty = da;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let i = e == 1 ? da : Gk;
      n.dirty < i && (n.dirty = i);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class rP extends Md {
  constructor(e, n, i, r) {
    let o, s = n.type.toDOM;
    if (typeof s == "function" && (s = s(i, () => {
      if (!o)
        return r;
      if (o.parent)
        return o.parent.posBeforeChild(o);
    })), !n.type.spec.raw) {
      if (s.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(s), s = a;
      }
      s.contentEditable = "false", s.classList.add("ProseMirror-widget");
    }
    super(e, [], s, null), this.widget = n, this.widget = n, o = this;
  }
  matchesWidget(e) {
    return this.dirty == er && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class L4 extends Md {
  constructor(e, n, i, r) {
    super(e, [], n, null), this.textDOM = i, this.text = r;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Na extends Md {
  constructor(e, n, i, r, o) {
    super(e, [], i, r), this.mark = n, this.spec = o;
  }
  static create(e, n, i, r) {
    let o = r.nodeViews[n.type.name], s = o && o(n, r, i);
    return (!s || !s.dom) && (s = Ha.renderSpec(document, n.type.spec.toDOM(n, i), null, n.attrs)), new Na(e, n, s.dom, s.contentDOM || s.dom, s);
  }
  parseRule() {
    return this.dirty & uo || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != uo && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != er) {
      let i = this.parent;
      for (; !i.node; )
        i = i.parent;
      i.dirty < this.dirty && (i.dirty = this.dirty), this.dirty = er;
    }
  }
  slice(e, n, i) {
    let r = Na.create(this.parent, this.mark, !0, i), o = this.children, s = this.size;
    n < s && (o = ev(o, n, s, i)), e > 0 && (o = ev(o, 0, e, i));
    for (let a = 0; a < o.length; a++)
      o[a].parent = r;
    return r.children = o, r;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class $s extends Md {
  constructor(e, n, i, r, o, s, a, l, u) {
    super(e, [], o, s), this.node = n, this.outerDeco = i, this.innerDeco = r, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, i, r, o, s) {
    let a = o.nodeViews[n.type.name], l, u = a && a(n, o, () => {
      if (!l)
        return s;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, i, r), c = u && u.dom, d = u && u.contentDOM;
    if (n.isText) {
      if (!c)
        c = document.createTextNode(n.text);
      else if (c.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else
      c || ({ dom: c, contentDOM: d } = Ha.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !d && !n.isText && c.nodeName != "BR" && (c.hasAttribute("contenteditable") || (c.contentEditable = "false"), n.type.spec.draggable && (c.draggable = !0));
    let h = c;
    return c = lP(c, i, n), u ? l = new V4(e, n, i, r, c, d || null, h, u, o, s + 1) : n.isText ? new cm(e, n, i, r, c, h, o) : new $s(e, n, i, r, c, d || null, h, o, s + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let i = this.children[n];
        if (this.dom.contains(i.dom.parentNode)) {
          e.contentElement = i.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => we.empty);
    }
    return e;
  }
  matchesNode(e, n, i) {
    return this.dirty == er && e.eq(this.node) && xf(n, this.outerDeco) && i.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let i = this.node.inlineContent, r = n, o = e.composing ? this.localCompositionInfo(e, n) : null, s = o && o.pos > -1 ? o : null, a = o && o.pos < 0, l = new Z4(this, s && s.node, e);
    W4(this.node, this.innerDeco, (u, c, d) => {
      u.spec.marks ? l.syncToMarks(u.spec.marks, i, e) : u.type.side >= 0 && !d && l.syncToMarks(c == this.node.childCount ? Nt.none : this.node.child(c).marks, i, e), l.placeWidget(u, e, r);
    }, (u, c, d, h) => {
      l.syncToMarks(u.marks, i, e);
      let f;
      l.findNodeMatch(u, c, d, h) || a && e.state.selection.from > r && e.state.selection.to < r + u.nodeSize && (f = l.findIndexWithChild(o.node)) > -1 && l.updateNodeAt(u, c, d, f, e) || l.updateNextNode(u, c, d, e, h, r) || l.addNode(u, c, d, e, r), r += u.nodeSize;
    }), l.syncToMarks([], i, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == da) && (s && this.protectLocalComposition(e, s), sP(this.contentDOM, this.children, e), jl && X4(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: i, to: r } = e.state.selection;
    if (!(e.state.selection instanceof Je) || i < n || r > n + this.node.content.size)
      return null;
    let o = e.input.compositionNode;
    if (!o || !this.dom.contains(o.parentNode))
      return null;
    if (this.node.inlineContent) {
      let s = o.nodeValue, a = z4(this.node.content, s, i - n, r - n);
      return a < 0 ? null : { node: o, pos: a, text: s };
    } else
      return { node: o, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: i, text: r }) {
    if (this.getDesc(n))
      return;
    let o = n;
    for (; o.parentNode != this.contentDOM; o = o.parentNode) {
      for (; o.previousSibling; )
        o.parentNode.removeChild(o.previousSibling);
      for (; o.nextSibling; )
        o.parentNode.removeChild(o.nextSibling);
      o.pmViewDesc && (o.pmViewDesc = void 0);
    }
    let s = new L4(this, o, n, r);
    e.input.compositionNodes.push(s), this.children = ev(this.children, i, i + r.length, e, s);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, i, r) {
    return this.dirty == uo || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, i, r), !0);
  }
  updateInner(e, n, i, r) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = i, this.contentDOM && this.updateChildren(r, this.posAtStart), this.dirty = er;
  }
  updateOuterDeco(e) {
    if (xf(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, i = this.dom;
    this.dom = aP(this.dom, this.nodeDOM, JO(this.outerDeco, this.node, n), JO(e, this.node, n)), this.dom != i && (i.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function Kk(t, e, n, i, r) {
  lP(i, e, t);
  let o = new $s(void 0, t, e, n, i, i, i, r, 0);
  return o.contentDOM && o.updateChildren(r, 0), o;
}
class cm extends $s {
  constructor(e, n, i, r, o, s, a) {
    super(e, n, i, r, o, null, s, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, i, r) {
    return this.dirty == uo || this.dirty != er && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != er || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, r.trackWrites == this.nodeDOM && (r.trackWrites = null)), this.node = e, this.dirty = er, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, i) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, i);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, i) {
    let r = this.node.cut(e, n), o = document.createTextNode(r.text);
    return new cm(this.parent, r, this.outerDeco, this.innerDeco, o, o, i);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = uo);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class oP extends Md {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == er && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class V4 extends $s {
  constructor(e, n, i, r, o, s, a, l, u, c) {
    super(e, n, i, r, o, s, a, u, c), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, i, r) {
    if (this.dirty == uo)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let o = this.spec.update(e, n, i);
      return o && this.updateInner(e, n, i, r), o;
    } else
      return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, i, r);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, i, r) {
    this.spec.setSelection ? this.spec.setSelection(e, n, i.root) : super.setSelection(e, n, i, r);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function sP(t, e, n) {
  let i = t.firstChild, r = !1;
  for (let o = 0; o < e.length; o++) {
    let s = e[o], a = s.dom;
    if (a.parentNode == t) {
      for (; a != i; )
        i = Jk(i), r = !0;
      i = i.nextSibling;
    } else
      r = !0, t.insertBefore(a, i);
    if (s instanceof Na) {
      let l = i ? i.previousSibling : t.lastChild;
      sP(s.contentDOM, s.children, n), i = l ? l.nextSibling : t.firstChild;
    }
  }
  for (; i; )
    i = Jk(i), r = !0;
  r && n.trackWrites == t && (n.trackWrites = null);
}
const pc = function(t) {
  t && (this.nodeName = t);
};
pc.prototype = /* @__PURE__ */ Object.create(null);
const ha = [new pc()];
function JO(t, e, n) {
  if (t.length == 0)
    return ha;
  let i = n ? ha[0] : new pc(), r = [i];
  for (let o = 0; o < t.length; o++) {
    let s = t[o].type.attrs;
    if (s) {
      s.nodeName && r.push(i = new pc(s.nodeName));
      for (let a in s) {
        let l = s[a];
        l != null && (n && r.length == 1 && r.push(i = new pc(e.isInline ? "span" : "div")), a == "class" ? i.class = (i.class ? i.class + " " : "") + l : a == "style" ? i.style = (i.style ? i.style + ";" : "") + l : a != "nodeName" && (i[a] = l));
      }
    }
  }
  return r;
}
function aP(t, e, n, i) {
  if (n == ha && i == ha)
    return e;
  let r = e;
  for (let o = 0; o < i.length; o++) {
    let s = i[o], a = n[o];
    if (o) {
      let l;
      a && a.nodeName == s.nodeName && r != t && (l = r.parentNode) && l.nodeName.toLowerCase() == s.nodeName || (l = document.createElement(s.nodeName), l.pmIsDeco = !0, l.appendChild(r), a = ha[0]), r = l;
    }
    B4(r, a || ha[0], s);
  }
  return r;
}
function B4(t, e, n) {
  for (let i in e)
    i != "class" && i != "style" && i != "nodeName" && !(i in n) && t.removeAttribute(i);
  for (let i in n)
    i != "class" && i != "style" && i != "nodeName" && n[i] != e[i] && t.setAttribute(i, n[i]);
  if (e.class != n.class) {
    let i = e.class ? e.class.split(" ").filter(Boolean) : [], r = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let o = 0; o < i.length; o++)
      r.indexOf(i[o]) == -1 && t.classList.remove(i[o]);
    for (let o = 0; o < r.length; o++)
      i.indexOf(r[o]) == -1 && t.classList.add(r[o]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let i = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, r;
      for (; r = i.exec(e.style); )
        t.style.removeProperty(r[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function lP(t, e, n) {
  return aP(t, t, ha, JO(e, n, t.nodeType != 1));
}
function xf(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].type.eq(e[n].type))
      return !1;
  return !0;
}
function Jk(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class Z4 {
  constructor(e, n, i) {
    this.lock = n, this.view = i, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = F4(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let i = e; i < n; i++)
        this.top.children[i].destroy();
      this.top.children.splice(e, n - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, i) {
    let r = 0, o = this.stack.length >> 1, s = Math.min(o, e.length);
    for (; r < s && (r == o - 1 ? this.top : this.stack[r + 1 << 1]).matchesMark(e[r]) && e[r].type.spec.spanning !== !1; )
      r++;
    for (; r < o; )
      this.destroyRest(), this.top.dirty = er, this.index = this.stack.pop(), this.top = this.stack.pop(), o--;
    for (; o < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let a = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let u = this.top.children[l];
        if (u.matchesMark(e[o]) && !this.isLocked(u.dom)) {
          a = l;
          break;
        }
      }
      if (a > -1)
        a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
      else {
        let l = Na.create(this.top, e[o], n, i);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, o++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, i, r) {
    let o = -1, s;
    if (r >= this.preMatch.index && (s = this.preMatch.matches[r - this.preMatch.index]).parent == this.top && s.matchesNode(e, n, i))
      o = this.top.children.indexOf(s, this.index);
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let u = this.top.children[a];
        if (u.matchesNode(e, n, i) && !this.preMatch.matched.has(u)) {
          o = a;
          break;
        }
      }
    return o < 0 ? !1 : (this.destroyBetween(this.index, o), this.index++, !0);
  }
  updateNodeAt(e, n, i, r, o) {
    let s = this.top.children[r];
    return s.dirty == uo && s.dom == s.contentDOM && (s.dirty = da), s.update(e, n, i, o) ? (this.destroyBetween(this.index, r), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let i = e.pmViewDesc;
        if (i) {
          for (let r = this.index; r < this.top.children.length; r++)
            if (this.top.children[r] == i)
              return r;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, i, r, o, s) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a];
      if (l instanceof $s) {
        let u = this.preMatch.matched.get(l);
        if (u != null && u != o)
          return !1;
        let c = l.dom, d, h = this.isLocked(c) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != uo && xf(n, l.outerDeco));
        if (!h && l.update(e, n, i, r))
          return this.destroyBetween(this.index, a), l.dom != c && (this.changed = !0), this.index++, !0;
        if (!h && (d = this.recreateWrapper(l, e, n, i, r, s)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = d, d.contentDOM && (d.dirty = da, d.updateChildren(r, s + 1), d.dirty = er), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, n, i, r, o, s) {
    if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !xf(i, e.outerDeco) || !r.eq(e.innerDeco))
      return null;
    let a = $s.create(this.top, n, i, r, o, s);
    if (a.contentDOM) {
      a.children = e.children, e.children = [];
      for (let l of a.children)
        l.parent = a;
    }
    return e.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, i, r, o) {
    let s = $s.create(this.top, e, n, i, r, o);
    s.contentDOM && s.updateChildren(r, o + 1), this.top.children.splice(this.index++, 0, s), this.changed = !0;
  }
  placeWidget(e, n, i) {
    let r = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (r && r.matchesWidget(e) && (e == r.widget || !r.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let o = new rP(this.top, e, n, i);
      this.top.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof Na; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof cm) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((di || Hn) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let i = document.createElement(e);
      e == "IMG" && (i.className = "ProseMirror-separator", i.alt = ""), e == "BR" && (i.className = "ProseMirror-trailingBreak");
      let r = new oP(this.top, [], i, null);
      n != this.top ? n.children.push(r) : n.children.splice(this.index++, 0, r), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function F4(t, e) {
  let n = e, i = n.children.length, r = t.childCount, o = /* @__PURE__ */ new Map(), s = [];
  e:
    for (; r > 0; ) {
      let a;
      for (; ; )
        if (i) {
          let u = n.children[i - 1];
          if (u instanceof Na)
            n = u, i = u.children.length;
          else {
            a = u, i--;
            break;
          }
        } else {
          if (n == e)
            break e;
          i = n.parent.children.indexOf(n), n = n.parent;
        }
      let l = a.node;
      if (l) {
        if (l != t.child(r - 1))
          break;
        --r, o.set(a, r), s.push(a);
      }
    }
  return { index: r, matched: o, matches: s.reverse() };
}
function q4(t, e) {
  return t.type.side - e.type.side;
}
function W4(t, e, n, i) {
  let r = e.locals(t), o = 0;
  if (r.length == 0) {
    for (let u = 0; u < t.childCount; u++) {
      let c = t.child(u);
      i(c, r, e.forChild(o, c), u), o += c.nodeSize;
    }
    return;
  }
  let s = 0, a = [], l = null;
  for (let u = 0; ; ) {
    let c, d;
    for (; s < r.length && r[s].to == o; ) {
      let g = r[s++];
      g.widget && (c ? (d || (d = [c])).push(g) : c = g);
    }
    if (c)
      if (d) {
        d.sort(q4);
        for (let g = 0; g < d.length; g++)
          n(d[g], u, !!l);
      } else
        n(c, u, !!l);
    let h, f;
    if (l)
      f = -1, h = l, l = null;
    else if (u < t.childCount)
      f = u, h = t.child(u++);
    else
      break;
    for (let g = 0; g < a.length; g++)
      a[g].to <= o && a.splice(g--, 1);
    for (; s < r.length && r[s].from <= o && r[s].to > o; )
      a.push(r[s++]);
    let p = o + h.nodeSize;
    if (h.isText) {
      let g = p;
      s < r.length && r[s].from < g && (g = r[s].from);
      for (let O = 0; O < a.length; O++)
        a[O].to < g && (g = a[O].to);
      g < p && (l = h.cut(g - o), h = h.cut(0, g - o), p = g, f = -1);
    } else
      for (; s < r.length && r[s].to < p; )
        s++;
    let m = h.isInline && !h.isLeaf ? a.filter((g) => !g.inline) : a.slice();
    i(h, m, e.forChild(o, h), f), o = p;
  }
}
function X4(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
  }
}
function z4(t, e, n, i) {
  for (let r = 0, o = 0; r < t.childCount && o <= i; ) {
    let s = t.child(r++), a = o;
    if (o += s.nodeSize, !s.isText)
      continue;
    let l = s.text;
    for (; r < t.childCount; ) {
      let u = t.child(r++);
      if (o += u.nodeSize, !u.isText)
        break;
      l += u.text;
    }
    if (o >= n) {
      if (o >= i && l.slice(i - e.length - a, i - a) == e)
        return i - e.length;
      let u = a < i ? l.lastIndexOf(e, i - a - 1) : -1;
      if (u >= 0 && u + e.length + a >= n)
        return a + u;
      if (n == i && l.length >= i + e.length - a && l.slice(i - a, i - a + e.length) == e)
        return i;
    }
  }
  return -1;
}
function ev(t, e, n, i, r) {
  let o = [];
  for (let s = 0, a = 0; s < t.length; s++) {
    let l = t[s], u = a, c = a += l.size;
    u >= n || c <= e ? o.push(l) : (u < e && o.push(l.slice(0, e - u, i)), r && (o.push(r), r = void 0), c > n && o.push(l.slice(n - u, l.size, i)));
  }
  return o;
}
function Cb(t, e = null) {
  let n = t.domSelectionRange(), i = t.state.doc;
  if (!n.focusNode)
    return null;
  let r = t.docView.nearestDesc(n.focusNode), o = r && r.size == 0, s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (s < 0)
    return null;
  let a = i.resolve(s), l, u;
  if (um(n)) {
    for (l = s; r && !r.node; )
      r = r.parent;
    let d = r.node;
    if (r && d.isAtom && Ke.isSelectable(d) && r.parent && !(d.isInline && v4(n.focusNode, n.focusOffset, r.dom))) {
      let h = r.posBefore;
      u = new Ke(s == h ? a : i.resolve(h));
    }
  } else {
    if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let d = s, h = s;
      for (let f = 0; f < n.rangeCount; f++) {
        let p = n.getRangeAt(f);
        d = Math.min(d, t.docView.posFromDOM(p.startContainer, p.startOffset, 1)), h = Math.max(h, t.docView.posFromDOM(p.endContainer, p.endOffset, -1));
      }
      if (d < 0)
        return null;
      [l, s] = h == t.state.selection.anchor ? [h, d] : [d, h], a = i.resolve(s);
    } else
      l = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let c = i.resolve(l);
  if (!u) {
    let d = e == "pointer" || t.state.selection.head < a.pos && !o ? 1 : -1;
    u = Tb(t, c, a, d);
  }
  return u;
}
function uP(t) {
  return t.editable ? t.hasFocus() : dP(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function Do(t, e = !1) {
  let n = t.state.selection;
  if (cP(t, n), !!uP(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Hn) {
      let i = t.domSelectionRange(), r = t.domObserver.currentSelection;
      if (i.anchorNode && r.anchorNode && Qa(i.anchorNode, i.anchorOffset, r.anchorNode, r.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      Y4(t);
    else {
      let { anchor: i, head: r } = n, o, s;
      e1 && !(n instanceof Je) && (n.$from.parent.inlineContent || (o = t1(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (s = t1(t, n.to))), t.docView.setSelection(i, r, t, e), e1 && (o && n1(o), s && n1(s)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && j4(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const e1 = di || Hn && G$ < 63;
function t1(t, e) {
  let { node: n, offset: i } = t.docView.domFromPos(e, 0), r = i < n.childNodes.length ? n.childNodes[i] : null, o = i ? n.childNodes[i - 1] : null;
  if (di && r && r.contentEditable == "false")
    return gg(r);
  if ((!r || r.contentEditable == "false") && (!o || o.contentEditable == "false")) {
    if (r)
      return gg(r);
    if (o)
      return gg(o);
  }
}
function gg(t) {
  return t.contentEditable = "true", di && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function n1(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function j4(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), i = n.anchorNode, r = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != i || n.anchorOffset != r) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!uP(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function Y4(t) {
  let e = t.domSelection(), n = document.createRange();
  if (!e)
    return;
  let i = t.cursorWrapper.dom, r = i.nodeName == "IMG";
  r ? n.setStart(i.parentNode, Ln(i) + 1) : n.setStart(i, 0), n.collapse(!0), e.removeAllRanges(), e.addRange(n), !r && !t.state.selection.visible && Ci && Ts <= 11 && (i.disabled = !0, i.disabled = !1);
}
function cP(t, e) {
  if (e instanceof Ke) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (i1(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    i1(t);
}
function i1(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function Tb(t, e, n, i) {
  return t.someProp("createSelectionBetween", (r) => r(t, e, n)) || Je.between(e, n, i);
}
function r1(t) {
  return t.editable && !t.hasFocus() ? !1 : dP(t);
}
function dP(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function H4(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
  return Qa(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function tv(t, e) {
  let { $anchor: n, $head: i } = t.selection, r = e > 0 ? n.max(i) : n.min(i), o = r.parent.inlineContent ? r.depth ? t.doc.resolve(e > 0 ? r.after() : r.before()) : null : r;
  return o && tt.findFrom(o, e);
}
function is(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function o1(t, e, n) {
  let i = t.state.selection;
  if (i instanceof Je)
    if (n.indexOf("s") > -1) {
      let { $head: r } = i, o = r.textOffset ? null : e < 0 ? r.nodeBefore : r.nodeAfter;
      if (!o || o.isText || !o.isLeaf)
        return !1;
      let s = t.state.doc.resolve(r.pos + o.nodeSize * (e < 0 ? -1 : 1));
      return is(t, new Je(i.$anchor, s));
    } else if (i.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let r = tv(t.state, e);
        return r && r instanceof Ke ? is(t, r) : !1;
      } else if (!(ji && n.indexOf("m") > -1)) {
        let r = i.$head, o = r.textOffset ? null : e < 0 ? r.nodeBefore : r.nodeAfter, s;
        if (!o || o.isText)
          return !1;
        let a = e < 0 ? r.pos - o.nodeSize : r.pos;
        return o.isAtom || (s = t.docView.descAt(a)) && !s.contentDOM ? Ke.isSelectable(o) ? is(t, new Ke(e < 0 ? t.state.doc.resolve(r.pos - o.nodeSize) : r)) : Pd ? is(t, new Je(t.state.doc.resolve(e < 0 ? a : a + o.nodeSize))) : !1 : !1;
      }
    } else
      return !1;
  else {
    if (i instanceof Ke && i.node.isInline)
      return is(t, new Je(e > 0 ? i.$to : i.$from));
    {
      let r = tv(t.state, e);
      return r ? is(t, r) : !1;
    }
  }
}
function Cf(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function mc(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function nl(t, e) {
  return e < 0 ? U4(t) : G4(t);
}
function U4(t) {
  let e = t.domSelectionRange(), n = e.focusNode, i = e.focusOffset;
  if (!n)
    return;
  let r, o, s = !1;
  for (xr && n.nodeType == 1 && i < Cf(n) && mc(n.childNodes[i], -1) && (s = !0); ; )
    if (i > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[i - 1];
        if (mc(a, -1))
          r = n, o = --i;
        else if (a.nodeType == 3)
          n = a, i = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (hP(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && mc(a, -1); )
          r = n.parentNode, o = Ln(a), a = a.previousSibling;
        if (a)
          n = a, i = Cf(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          i = 0;
        }
      }
    }
  s ? nv(t, n, i) : r && nv(t, r, o);
}
function G4(t) {
  let e = t.domSelectionRange(), n = e.focusNode, i = e.focusOffset;
  if (!n)
    return;
  let r = Cf(n), o, s;
  for (; ; )
    if (i < r) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[i];
      if (mc(a, 1))
        o = n, s = ++i;
      else
        break;
    } else {
      if (hP(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && mc(a, 1); )
          o = a.parentNode, s = Ln(a) + 1, a = a.nextSibling;
        if (a)
          n = a, i = 0, r = Cf(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          i = r = 0;
        }
      }
    }
  o && nv(t, o, s);
}
function hP(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function K4(t, e) {
  for (; t && e == t.childNodes.length && !$d(t); )
    e = Ln(t) + 1, t = t.parentNode;
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = 0;
  }
}
function J4(t, e) {
  for (; t && !e && !$d(t); )
    e = Ln(t), t = t.parentNode;
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = t.childNodes.length;
  }
}
function nv(t, e, n) {
  if (e.nodeType != 3) {
    let o, s;
    (s = K4(e, n)) ? (e = s, n = 0) : (o = J4(e, n)) && (e = o, n = o.nodeValue.length);
  }
  let i = t.domSelection();
  if (!i)
    return;
  if (um(i)) {
    let o = document.createRange();
    o.setEnd(e, n), o.setStart(e, n), i.removeAllRanges(), i.addRange(o);
  } else
    i.extend && i.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: r } = t;
  setTimeout(() => {
    t.state == r && Do(t);
  }, 50);
}
function s1(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(Hn || w4) && n.parent.inlineContent) {
    let r = t.coordsAtPos(e);
    if (e > n.start()) {
      let o = t.coordsAtPos(e - 1), s = (o.top + o.bottom) / 2;
      if (s > r.top && s < r.bottom && Math.abs(o.left - r.left) > 1)
        return o.left < r.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let o = t.coordsAtPos(e + 1), s = (o.top + o.bottom) / 2;
      if (s > r.top && s < r.bottom && Math.abs(o.left - r.left) > 1)
        return o.left > r.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function a1(t, e, n) {
  let i = t.state.selection;
  if (i instanceof Je && !i.empty || n.indexOf("s") > -1 || ji && n.indexOf("m") > -1)
    return !1;
  let { $from: r, $to: o } = i;
  if (!r.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let s = tv(t.state, e);
    if (s && s instanceof Ke)
      return is(t, s);
  }
  if (!r.parent.inlineContent) {
    let s = e < 0 ? r : o, a = i instanceof wr ? tt.near(s, e) : tt.findFrom(s, e);
    return a ? is(t, a) : !1;
  }
  return !1;
}
function l1(t, e) {
  if (!(t.state.selection instanceof Je))
    return !0;
  let { $head: n, $anchor: i, empty: r } = t.state.selection;
  if (!n.sameParent(i))
    return !0;
  if (!r)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let o = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (o && !o.isText) {
    let s = t.state.tr;
    return e < 0 ? s.delete(n.pos - o.nodeSize, n.pos) : s.delete(n.pos, n.pos + o.nodeSize), t.dispatch(s), !0;
  }
  return !1;
}
function u1(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function eY(t) {
  if (!di || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let i = e.firstChild;
    u1(t, i, "true"), setTimeout(() => u1(t, i, "false"), 20);
  }
  return !1;
}
function tY(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function nY(t, e) {
  let n = e.keyCode, i = tY(e);
  if (n == 8 || ji && n == 72 && i == "c")
    return l1(t, -1) || nl(t, -1);
  if (n == 46 && !e.shiftKey || ji && n == 68 && i == "c")
    return l1(t, 1) || nl(t, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || ji && n == 66 && i == "c") {
    let r = n == 37 ? s1(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return o1(t, r, i) || nl(t, r);
  } else if (n == 39 || ji && n == 70 && i == "c") {
    let r = n == 39 ? s1(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return o1(t, r, i) || nl(t, r);
  } else {
    if (n == 38 || ji && n == 80 && i == "c")
      return a1(t, -1, i) || nl(t, -1);
    if (n == 40 || ji && n == 78 && i == "c")
      return eY(t) || a1(t, 1, i) || nl(t, 1);
    if (i == (ji ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function fP(t, e) {
  t.someProp("transformCopied", (f) => {
    e = f(e, t);
  });
  let n = [], { content: i, openStart: r, openEnd: o } = e;
  for (; r > 1 && o > 1 && i.childCount == 1 && i.firstChild.childCount == 1; ) {
    r--, o--;
    let f = i.firstChild;
    n.push(f.type.name, f.attrs != f.type.defaultAttrs ? f.attrs : null), i = f.content;
  }
  let s = t.someProp("clipboardSerializer") || Ha.fromSchema(t.state.schema), a = yP(), l = a.createElement("div");
  l.appendChild(s.serializeFragment(i, { document: a }));
  let u = l.firstChild, c, d = 0;
  for (; u && u.nodeType == 1 && (c = vP[u.nodeName.toLowerCase()]); ) {
    for (let f = c.length - 1; f >= 0; f--) {
      let p = a.createElement(c[f]);
      for (; l.firstChild; )
        p.appendChild(l.firstChild);
      l.appendChild(p), d++;
    }
    u = l.firstChild;
  }
  u && u.nodeType == 1 && u.setAttribute("data-pm-slice", `${r} ${o}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`);
  let h = t.someProp("clipboardTextSerializer", (f) => f(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: h, slice: e };
}
function pP(t, e, n, i, r) {
  let o = r.parent.type.spec.code, s, a;
  if (!n && !e)
    return null;
  let l = e && (i || o || !n);
  if (l) {
    if (t.someProp("transformPastedText", (h) => {
      e = h(e, o || i, t);
    }), o)
      return e ? new Ne(we.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : Ne.empty;
    let d = t.someProp("clipboardTextParser", (h) => h(e, r, i, t));
    if (d)
      a = d;
    else {
      let h = r.marks(), { schema: f } = t.state, p = Ha.fromSchema(f);
      s = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((m) => {
        let g = s.appendChild(document.createElement("p"));
        m && g.appendChild(p.serializeNode(f.text(m, h)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (d) => {
      n = d(n, t);
    }), s = sY(n), Pd && aY(s);
  let u = s && s.querySelector("[data-pm-slice]"), c = u && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(u.getAttribute("data-pm-slice") || "");
  if (c && c[3])
    for (let d = +c[3]; d > 0; d--) {
      let h = s.firstChild;
      for (; h && h.nodeType != 1; )
        h = h.nextSibling;
      if (!h)
        break;
      s = h;
    }
  if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || Cs.fromSchema(t.state.schema)).parseSlice(s, {
    preserveWhitespace: !!(l || c),
    context: r,
    ruleFromNode(h) {
      return h.nodeName == "BR" && !h.nextSibling && h.parentNode && !iY.test(h.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), c)
    a = lY(c1(a, +c[1], +c[2]), c[4]);
  else if (a = Ne.maxOpen(rY(a.content, r), !0), a.openStart || a.openEnd) {
    let d = 0, h = 0;
    for (let f = a.content.firstChild; d < a.openStart && !f.type.spec.isolating; d++, f = f.firstChild)
      ;
    for (let f = a.content.lastChild; h < a.openEnd && !f.type.spec.isolating; h++, f = f.lastChild)
      ;
    a = c1(a, d, h);
  }
  return t.someProp("transformPasted", (d) => {
    a = d(a, t);
  }), a;
}
const iY = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function rY(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let r = e.node(n).contentMatchAt(e.index(n)), o, s = [];
    if (t.forEach((a) => {
      if (!s)
        return;
      let l = r.findWrapping(a.type), u;
      if (!l)
        return s = null;
      if (u = s.length && o.length && gP(l, o, a, s[s.length - 1], 0))
        s[s.length - 1] = u;
      else {
        s.length && (s[s.length - 1] = OP(s[s.length - 1], o.length));
        let c = mP(a, l);
        s.push(c), r = r.matchType(c.type), o = l;
      }
    }), s)
      return we.from(s);
  }
  return t;
}
function mP(t, e, n = 0) {
  for (let i = e.length - 1; i >= n; i--)
    t = e[i].create(null, we.from(t));
  return t;
}
function gP(t, e, n, i, r) {
  if (r < t.length && r < e.length && t[r] == e[r]) {
    let o = gP(t, e, n, i.lastChild, r + 1);
    if (o)
      return i.copy(i.content.replaceChild(i.childCount - 1, o));
    if (i.contentMatchAt(i.childCount).matchType(r == t.length - 1 ? n.type : t[r + 1]))
      return i.copy(i.content.append(we.from(mP(n, t, r + 1))));
  }
}
function OP(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, OP(t.lastChild, e - 1)), i = t.contentMatchAt(t.childCount).fillBefore(we.empty, !0);
  return t.copy(n.append(i));
}
function iv(t, e, n, i, r, o) {
  let s = e < 0 ? t.firstChild : t.lastChild, a = s.content;
  return t.childCount > 1 && (o = 0), r < i - 1 && (a = iv(a, e, n, i, r + 1, o)), r >= n && (a = e < 0 ? s.contentMatchAt(0).fillBefore(a, o <= r).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore(we.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(a));
}
function c1(t, e, n) {
  return e < t.openStart && (t = new Ne(iv(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new Ne(iv(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const vP = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let d1 = null;
function yP() {
  return d1 || (d1 = document.implementation.createHTMLDocument("title"));
}
let Og = null;
function oY(t) {
  let e = window.trustedTypes;
  return e ? (Og || (Og = e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), Og.createHTML(t)) : t;
}
function sY(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = yP().createElement("div"), i = /<([a-z][^>\s]+)/i.exec(t), r;
  if ((r = i && vP[i[1].toLowerCase()]) && (t = r.map((o) => "<" + o + ">").join("") + t + r.map((o) => "</" + o + ">").reverse().join("")), n.innerHTML = oY(t), r)
    for (let o = 0; o < r.length; o++)
      n = n.querySelector(r[o]) || n;
  return n;
}
function aY(t) {
  let e = t.querySelectorAll(Hn ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    i.childNodes.length == 1 && i.textContent == " " && i.parentNode && i.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), i);
  }
}
function lY(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, i;
  try {
    i = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: r, openStart: o, openEnd: s } = t;
  for (let a = i.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[i[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    r = we.from(l.create(i[a + 1], r)), o++, s++;
  }
  return new Ne(r, o, s);
}
const hi = {}, fi = {}, uY = { touchstart: !0, touchmove: !0 };
let cY = class {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
};
function dY(t) {
  for (let e in hi) {
    let n = hi[e];
    t.dom.addEventListener(e, t.input.eventHandlers[e] = (i) => {
      fY(t, i) && !$b(t, i) && (t.editable || !(i.type in fi)) && n(t, i);
    }, uY[e] ? { passive: !0 } : void 0);
  }
  di && t.dom.addEventListener("input", () => null), rv(t);
}
function Os(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
function hY(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function rv(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (i) => $b(t, i));
  });
}
function $b(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let i = n[e.type];
    return i ? i(t, e) || e.defaultPrevented : !1;
  });
}
function fY(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function pY(t, e) {
  !$b(t, e) && hi[e.type] && (t.editable || !(e.type in fi)) && hi[e.type](t, e);
}
fi.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !wP(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(pr && Hn && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), jl && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let i = Date.now();
      t.input.lastIOSEnter = i, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == i && (t.someProp("handleKeyDown", (r) => r(t, oa(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else
      t.someProp("handleKeyDown", (i) => i(t, n)) || nY(t, n) ? n.preventDefault() : Os(t, "key");
};
fi.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
fi.keypress = (t, e) => {
  let n = e;
  if (wP(t, n) || !n.charCode || n.ctrlKey && !n.altKey || ji && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (r) => r(t, n))) {
    n.preventDefault();
    return;
  }
  let i = t.state.selection;
  if (!(i instanceof Je) || !i.$from.sameParent(i.$to)) {
    let r = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(r) && !t.someProp("handleTextInput", (o) => o(t, i.$from.pos, i.$to.pos, r)) && t.dispatch(t.state.tr.insertText(r).scrollIntoView()), n.preventDefault();
  }
};
function dm(t) {
  return { left: t.clientX, top: t.clientY };
}
function mY(t, e) {
  let n = e.x - t.clientX, i = e.y - t.clientY;
  return n * n + i * i < 100;
}
function Pb(t, e, n, i, r) {
  if (i == -1)
    return !1;
  let o = t.state.doc.resolve(i);
  for (let s = o.depth + 1; s > 0; s--)
    if (t.someProp(e, (a) => s > o.depth ? a(t, n, o.nodeAfter, o.before(s), r, !0) : a(t, n, o.node(s), o.before(s), r, !1)))
      return !0;
  return !1;
}
function xl(t, e, n) {
  if (t.focused || t.focus(), t.state.selection.eq(e))
    return;
  let i = t.state.tr.setSelection(e);
  n == "pointer" && i.setMeta("pointer", !0), t.dispatch(i);
}
function gY(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), i = n.nodeAfter;
  return i && i.isAtom && Ke.isSelectable(i) ? (xl(t, new Ke(n), "pointer"), !0) : !1;
}
function OY(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, i, r;
  n instanceof Ke && (i = n.node);
  let o = t.state.doc.resolve(e);
  for (let s = o.depth + 1; s > 0; s--) {
    let a = s > o.depth ? o.nodeAfter : o.node(s);
    if (Ke.isSelectable(a)) {
      i && n.$from.depth > 0 && s >= n.$from.depth && o.before(n.$from.depth + 1) == n.$from.pos ? r = o.before(n.$from.depth) : r = o.before(s);
      break;
    }
  }
  return r != null ? (xl(t, Ke.create(t.state.doc, r), "pointer"), !0) : !1;
}
function vY(t, e, n, i, r) {
  return Pb(t, "handleClickOn", e, n, i) || t.someProp("handleClick", (o) => o(t, e, i)) || (r ? OY(t, n) : gY(t, n));
}
function yY(t, e, n, i) {
  return Pb(t, "handleDoubleClickOn", e, n, i) || t.someProp("handleDoubleClick", (r) => r(t, e, i));
}
function bY(t, e, n, i) {
  return Pb(t, "handleTripleClickOn", e, n, i) || t.someProp("handleTripleClick", (r) => r(t, e, i)) || wY(t, n, i);
}
function wY(t, e, n) {
  if (n.button != 0)
    return !1;
  let i = t.state.doc;
  if (e == -1)
    return i.inlineContent ? (xl(t, Je.create(i, 0, i.content.size), "pointer"), !0) : !1;
  let r = i.resolve(e);
  for (let o = r.depth + 1; o > 0; o--) {
    let s = o > r.depth ? r.nodeAfter : r.node(o), a = r.before(o);
    if (s.inlineContent)
      xl(t, Je.create(i, a + 1, a + 1 + s.content.size), "pointer");
    else if (Ke.isSelectable(s))
      xl(t, Ke.create(i, a), "pointer");
    else
      continue;
    return !0;
  }
}
function Mb(t) {
  return Tf(t);
}
const bP = ji ? "metaKey" : "ctrlKey";
hi.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let i = Mb(t), r = Date.now(), o = "singleClick";
  r - t.input.lastClick.time < 500 && mY(n, t.input.lastClick) && !n[bP] && (t.input.lastClick.type == "singleClick" ? o = "doubleClick" : t.input.lastClick.type == "doubleClick" && (o = "tripleClick")), t.input.lastClick = { time: r, x: n.clientX, y: n.clientY, type: o };
  let s = t.posAtCoords(dm(n));
  s && (o == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new kY(t, s, n, !!i)) : (o == "doubleClick" ? yY : bY)(t, s.pos, s.inside, n) ? n.preventDefault() : Os(t, "pointer"));
};
class kY {
  constructor(e, n, i, r) {
    this.view = e, this.pos = n, this.event = i, this.flushed = r, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!i[bP], this.allowDefault = i.shiftKey;
    let o, s;
    if (n.inside > -1)
      o = e.state.doc.nodeAt(n.inside), s = n.inside;
    else {
      let c = e.state.doc.resolve(n.pos);
      o = c.parent, s = c.depth ? c.before() : 0;
    }
    const a = r ? null : i.target, l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: u } = e.state;
    (i.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1 || u instanceof Ke && u.from <= s && u.to > s) && (this.mightDrag = {
      node: o,
      pos: s,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && xr && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Os(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Do(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(dm(e))), this.updateAllowDefault(e), this.allowDefault || !n ? Os(this.view, "pointer") : vY(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    di && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Hn && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (xl(this.view, tt.near(this.view.state.doc.resolve(n.pos)), "pointer"), e.preventDefault()) : Os(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), Os(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
hi.touchstart = (t) => {
  t.input.lastTouch = Date.now(), Mb(t), Os(t, "pointer");
};
hi.touchmove = (t) => {
  t.input.lastTouch = Date.now(), Os(t, "pointer");
};
hi.contextmenu = (t) => Mb(t);
function wP(t, e) {
  return t.composing ? !0 : di && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const SY = pr ? 5e3 : -1;
fi.compositionstart = fi.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$to;
    if (e.selection instanceof Je && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((i) => i.type.spec.inclusive === !1)))
      t.markCursor = t.state.storedMarks || n.marks(), Tf(t, !0), t.markCursor = null;
    else if (Tf(t, !e.selection.empty), xr && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let i = t.domSelectionRange();
      for (let r = i.focusNode, o = i.focusOffset; r && r.nodeType == 1 && o != 0; ) {
        let s = o < 0 ? r.lastChild : r.childNodes[o - 1];
        if (!s)
          break;
        if (s.nodeType == 3) {
          let a = t.domSelection();
          a && a.collapse(s, s.nodeValue.length);
          break;
        } else
          r = s, o = -1;
      }
    }
    t.input.composing = !0;
  }
  kP(t, SY);
};
fi.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, kP(t, 20));
};
function kP(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => Tf(t), e));
}
function SP(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = xY()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function _Y(t) {
  let e = t.domSelectionRange();
  if (!e.focusNode)
    return null;
  let n = g4(e.focusNode, e.focusOffset), i = O4(e.focusNode, e.focusOffset);
  if (n && i && n != i) {
    let r = i.pmViewDesc, o = t.domObserver.lastChangedTextNode;
    if (n == o || i == o)
      return o;
    if (!r || !r.isText(i.nodeValue))
      return i;
    if (t.input.compositionNode == i) {
      let s = n.pmViewDesc;
      if (!(!s || !s.isText(n.nodeValue)))
        return i;
    }
  }
  return n || i;
}
function xY() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function Tf(t, e = !1) {
  if (!(pr && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), SP(t), e || t.docView && t.docView.dirty) {
      let n = Cb(t);
      return n && !n.eq(t.state.selection) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !t.state.selection.empty ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function CY(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let i = getSelection(), r = document.createRange();
  r.selectNodeContents(e), t.dom.blur(), i.removeAllRanges(), i.addRange(r), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const qc = Ci && Ts < 15 || jl && k4 < 604;
hi.copy = fi.cut = (t, e) => {
  let n = e, i = t.state.selection, r = n.type == "cut";
  if (i.empty)
    return;
  let o = qc ? null : n.clipboardData, s = i.content(), { dom: a, text: l } = fP(t, s);
  o ? (n.preventDefault(), o.clearData(), o.setData("text/html", a.innerHTML), o.setData("text/plain", l)) : CY(t, a), r && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function TY(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function $Y(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, i = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (i.contentEditable = "true"), i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.focus();
  let r = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(), i.parentNode && i.parentNode.removeChild(i), n ? Wc(t, i.value, null, r, e) : Wc(t, i.textContent, i.innerHTML, r, e);
  }, 50);
}
function Wc(t, e, n, i, r) {
  let o = pP(t, e, n, i, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, r, o || Ne.empty)))
    return !0;
  if (!o)
    return !1;
  let s = TY(o), a = s ? t.state.tr.replaceSelectionWith(s, i) : t.state.tr.replaceSelection(o);
  return t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function _P(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e)
    return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
fi.paste = (t, e) => {
  let n = e;
  if (t.composing && !pr)
    return;
  let i = qc ? null : n.clipboardData, r = t.input.shiftKey && t.input.lastKeyCode != 45;
  i && Wc(t, _P(i), i.getData("text/html"), r, n) ? n.preventDefault() : $Y(t, n);
};
class xP {
  constructor(e, n, i) {
    this.slice = e, this.move = n, this.node = i;
  }
}
const CP = ji ? "altKey" : "ctrlKey";
hi.dragstart = (t, e) => {
  let n = e, i = t.input.mouseDown;
  if (i && i.done(), !n.dataTransfer)
    return;
  let r = t.state.selection, o = r.empty ? null : t.posAtCoords(dm(n)), s;
  if (!(o && o.pos >= r.from && o.pos <= (r instanceof Ke ? r.to - 1 : r.to))) {
    if (i && i.mightDrag)
      s = Ke.create(t.state.doc, i.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let d = t.docView.nearestDesc(n.target, !0);
      d && d.node.type.spec.draggable && d != t.docView && (s = Ke.create(t.state.doc, d.posBefore));
    }
  }
  let a = (s || t.state.selection).content(), { dom: l, text: u, slice: c } = fP(t, a);
  (!n.dataTransfer.files.length || !Hn || G$ > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(qc ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", qc || n.dataTransfer.setData("text/plain", u), t.dragging = new xP(c, !n[CP], s);
};
hi.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
fi.dragover = fi.dragenter = (t, e) => e.preventDefault();
fi.drop = (t, e) => {
  let n = e, i = t.dragging;
  if (t.dragging = null, !n.dataTransfer)
    return;
  let r = t.posAtCoords(dm(n));
  if (!r)
    return;
  let o = t.state.doc.resolve(r.pos), s = i && i.slice;
  s ? t.someProp("transformPasted", (p) => {
    s = p(s, t);
  }) : s = pP(t, _P(n.dataTransfer), qc ? null : n.dataTransfer.getData("text/html"), !1, o);
  let a = !!(i && !n[CP]);
  if (t.someProp("handleDrop", (p) => p(t, n, s || Ne.empty, a))) {
    n.preventDefault();
    return;
  }
  if (!s)
    return;
  n.preventDefault();
  let l = s ? F$(t.state.doc, o.pos, s) : o.pos;
  l == null && (l = o.pos);
  let u = t.state.tr;
  if (a) {
    let { node: p } = i;
    p ? p.replace(u) : u.deleteSelection();
  }
  let c = u.mapping.map(l), d = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1, h = u.doc;
  if (d ? u.replaceRangeWith(c, c, s.content.firstChild) : u.replaceRange(c, c, s), u.doc.eq(h))
    return;
  let f = u.doc.resolve(c);
  if (d && Ke.isSelectable(s.content.firstChild) && f.nodeAfter && f.nodeAfter.sameMarkup(s.content.firstChild))
    u.setSelection(new Ke(f));
  else {
    let p = u.mapping.map(l);
    u.mapping.maps[u.mapping.maps.length - 1].forEach((m, g, O, y) => p = y), u.setSelection(Tb(t, f, u.doc.resolve(p)));
  }
  t.focus(), t.dispatch(u.setMeta("uiEvent", "drop"));
};
hi.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Do(t);
  }, 20));
};
hi.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
hi.beforeinput = (t, e) => {
  if (Hn && pr && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: i } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != i || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (o) => o(t, oa(8, "Backspace")))))
        return;
      let { $cursor: r } = t.state.selection;
      r && r.pos > 0 && t.dispatch(t.state.tr.delete(r.pos - 1, r.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in fi)
  hi[t] = fi[t];
function Xc(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
let h1 = class TP {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || wa, this.side = this.spec.side || 0;
  }
  map(e, n, i, r) {
    let { pos: o, deleted: s } = e.mapResult(n.from + r, this.side < 0 ? -1 : 1);
    return s ? null : new Cr(o - i, o - i, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof TP && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Xc(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
};
class Ps {
  constructor(e, n) {
    this.attrs = e, this.spec = n || wa;
  }
  map(e, n, i, r) {
    let o = e.map(n.from + r, this.spec.inclusiveStart ? -1 : 1) - i, s = e.map(n.to + r, this.spec.inclusiveEnd ? 1 : -1) - i;
    return o >= s ? null : new Cr(o, s, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof Ps && Xc(this.attrs, e.attrs) && Xc(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Ps;
  }
  destroy() {
  }
}
let PY = class $P {
  constructor(e, n) {
    this.attrs = e, this.spec = n || wa;
  }
  map(e, n, i, r) {
    let o = e.mapResult(n.from + r, 1);
    if (o.deleted)
      return null;
    let s = e.mapResult(n.to + r, -1);
    return s.deleted || s.pos <= o.pos ? null : new Cr(o.pos - i, s.pos - i, this);
  }
  valid(e, n) {
    let { index: i, offset: r } = e.content.findIndex(n.from), o;
    return r == n.from && !(o = e.child(i)).isText && r + o.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof $P && Xc(this.attrs, e.attrs) && Xc(this.spec, e.spec);
  }
  destroy() {
  }
}, Cr = class Ku {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.from = e, this.to = n, this.type = i;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new Ku(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, i) {
    return this.type.map(e, this, n, i);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, i) {
    return new Ku(e, e, new h1(n, i));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, i, r) {
    return new Ku(e, n, new Ps(i, r));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, i, r) {
    return new Ku(e, n, new PY(i, r));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Ps;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof h1;
  }
};
const ul = [], wa = {};
class Jt {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : ul, this.children = n.length ? n : ul;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? $f(n, e, 0, wa) : Wn;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, i) {
    let r = [];
    return this.findInner(e ?? 0, n ?? 1e9, r, 0, i), r;
  }
  findInner(e, n, i, r, o) {
    for (let s = 0; s < this.local.length; s++) {
      let a = this.local[s];
      a.from <= n && a.to >= e && (!o || o(a.spec)) && i.push(a.copy(a.from + r, a.to + r));
    }
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] < n && this.children[s + 1] > e) {
        let a = this.children[s] + 1;
        this.children[s + 2].findInner(e - a, n - a, i, r + a, o);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, i) {
    return this == Wn || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, i || wa);
  }
  /**
  @internal
  */
  mapInner(e, n, i, r, o) {
    let s;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, i, r);
      l && l.type.valid(n, l) ? (s || (s = [])).push(l) : o.onRemove && o.onRemove(this.local[a].spec);
    }
    return this.children.length ? MY(this.children, s || [], e, n, i, r, o) : s ? new Jt(s.sort(ka), ul) : Wn;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length ? this == Wn ? Jt.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, i) {
    let r, o = 0;
    e.forEach((a, l) => {
      let u = l + i, c;
      if (c = MP(n, a, u)) {
        for (r || (r = this.children.slice()); o < r.length && r[o] < l; )
          o += 3;
        r[o] == l ? r[o + 2] = r[o + 2].addInner(a, c, u + 1) : r.splice(o, 0, l, l + a.nodeSize, $f(c, a, u + 1, wa)), o += 3;
      }
    });
    let s = PP(o ? EP(n) : n, -i);
    for (let a = 0; a < s.length; a++)
      s[a].type.valid(e, s[a]) || s.splice(a--, 1);
    return new Jt(s.length ? this.local.concat(s).sort(ka) : this.local, r || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == Wn ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let i = this.children, r = this.local;
    for (let o = 0; o < i.length; o += 3) {
      let s, a = i[o] + n, l = i[o + 1] + n;
      for (let c = 0, d; c < e.length; c++)
        (d = e[c]) && d.from > a && d.to < l && (e[c] = null, (s || (s = [])).push(d));
      if (!s)
        continue;
      i == this.children && (i = this.children.slice());
      let u = i[o + 2].removeInner(s, a + 1);
      u != Wn ? i[o + 2] = u : (i.splice(o, 3), o -= 3);
    }
    if (r.length) {
      for (let o = 0, s; o < e.length; o++)
        if (s = e[o])
          for (let a = 0; a < r.length; a++)
            r[a].eq(s, n) && (r == this.local && (r = this.local.slice()), r.splice(a--, 1));
    }
    return i == this.children && r == this.local ? this : r.length || i.length ? new Jt(r, i) : Wn;
  }
  forChild(e, n) {
    if (this == Wn)
      return this;
    if (n.isLeaf)
      return Jt.empty;
    let i, r;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (i = this.children[a + 2]);
        break;
      }
    let o = e + 1, s = o + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < s && l.to > o && l.type instanceof Ps) {
        let u = Math.max(o, l.from) - o, c = Math.min(s, l.to) - o;
        u < c && (r || (r = [])).push(l.copy(u, c));
      }
    }
    if (r) {
      let a = new Jt(r.sort(ka), ul);
      return i ? new us([a, i]) : a;
    }
    return i || Wn;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Jt) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return Eb(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == Wn)
      return ul;
    if (e.inlineContent || !this.local.some(Ps.is))
      return this.local;
    let n = [];
    for (let i = 0; i < this.local.length; i++)
      this.local[i].type instanceof Ps || n.push(this.local[i]);
    return n;
  }
  forEachSet(e) {
    e(this);
  }
}
Jt.empty = new Jt([], []);
Jt.removeOverlap = Eb;
const Wn = Jt.empty;
class us {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const i = this.members.map((r) => r.map(e, n, wa));
    return us.from(i);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return Jt.empty;
    let i = [];
    for (let r = 0; r < this.members.length; r++) {
      let o = this.members[r].forChild(e, n);
      o != Wn && (o instanceof us ? i = i.concat(o.members) : i.push(o));
    }
    return us.from(i);
  }
  eq(e) {
    if (!(e instanceof us) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, i = !0;
    for (let r = 0; r < this.members.length; r++) {
      let o = this.members[r].localsInner(e);
      if (o.length)
        if (!n)
          n = o;
        else {
          i && (n = n.slice(), i = !1);
          for (let s = 0; s < o.length; s++)
            n.push(o[s]);
        }
    }
    return n ? Eb(i ? n : n.sort(ka)) : ul;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return Wn;
      case 1:
        return e[0];
      default:
        return new us(e.every((n) => n instanceof Jt) ? e : e.reduce((n, i) => n.concat(i instanceof Jt ? i : i.members), []));
    }
  }
  forEachSet(e) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(e);
  }
}
function MY(t, e, n, i, r, o, s) {
  let a = t.slice();
  for (let u = 0, c = o; u < n.maps.length; u++) {
    let d = 0;
    n.maps[u].forEach((h, f, p, m) => {
      let g = m - p - (f - h);
      for (let O = 0; O < a.length; O += 3) {
        let y = a[O + 1];
        if (y < 0 || h > y + c - d)
          continue;
        let b = a[O] + c - d;
        f >= b ? a[O + 1] = h <= b ? -2 : -1 : h >= c && g && (a[O] += g, a[O + 1] += g);
      }
      d += g;
    }), c = n.maps[u].map(c, -1);
  }
  let l = !1;
  for (let u = 0; u < a.length; u += 3)
    if (a[u + 1] < 0) {
      if (a[u + 1] == -2) {
        l = !0, a[u + 1] = -1;
        continue;
      }
      let c = n.map(t[u] + o), d = c - r;
      if (d < 0 || d >= i.content.size) {
        l = !0;
        continue;
      }
      let h = n.map(t[u + 1] + o, -1), f = h - r, { index: p, offset: m } = i.content.findIndex(d), g = i.maybeChild(p);
      if (g && m == d && m + g.nodeSize == f) {
        let O = a[u + 2].mapInner(n, g, c + 1, t[u] + o + 1, s);
        O != Wn ? (a[u] = d, a[u + 1] = f, a[u + 2] = O) : (a[u + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let u = EY(a, t, e, n, r, o, s), c = $f(u, i, 0, s);
    e = c.local;
    for (let d = 0; d < a.length; d += 3)
      a[d + 1] < 0 && (a.splice(d, 3), d -= 3);
    for (let d = 0, h = 0; d < c.children.length; d += 3) {
      let f = c.children[d];
      for (; h < a.length && a[h] < f; )
        h += 3;
      a.splice(h, 0, c.children[d], c.children[d + 1], c.children[d + 2]);
    }
  }
  return new Jt(e.sort(ka), a);
}
function PP(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let i = 0; i < t.length; i++) {
    let r = t[i];
    n.push(new Cr(r.from + e, r.to + e, r.type));
  }
  return n;
}
function EY(t, e, n, i, r, o, s) {
  function a(l, u) {
    for (let c = 0; c < l.local.length; c++) {
      let d = l.local[c].map(i, r, u);
      d ? n.push(d) : s.onRemove && s.onRemove(l.local[c].spec);
    }
    for (let c = 0; c < l.children.length; c += 3)
      a(l.children[c + 2], l.children[c] + u + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && a(t[l + 2], e[l] + o + 1);
  return n;
}
function MP(t, e, n) {
  if (e.isLeaf)
    return null;
  let i = n + e.nodeSize, r = null;
  for (let o = 0, s; o < t.length; o++)
    (s = t[o]) && s.from > n && s.to < i && ((r || (r = [])).push(s), t[o] = null);
  return r;
}
function EP(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function $f(t, e, n, i) {
  let r = [], o = !1;
  e.forEach((a, l) => {
    let u = MP(t, a, l + n);
    if (u) {
      o = !0;
      let c = $f(u, a, n + l + 1, i);
      c != Wn && r.push(l, l + a.nodeSize, c);
    }
  });
  let s = PP(o ? EP(t) : t, -n).sort(ka);
  for (let a = 0; a < s.length; a++)
    s[a].type.valid(e, s[a]) || (i.onRemove && i.onRemove(s[a].spec), s.splice(a--, 1));
  return s.length || r.length ? new Jt(s, r) : Wn;
}
function ka(t, e) {
  return t.from - e.from || t.to - e.to;
}
function Eb(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let i = e[n];
    if (i.from != i.to)
      for (let r = n + 1; r < e.length; r++) {
        let o = e[r];
        if (o.from == i.from) {
          o.to != i.to && (e == t && (e = t.slice()), e[r] = o.copy(o.from, i.to), f1(e, r + 1, o.copy(i.to, o.to)));
          continue;
        } else {
          o.from < i.to && (e == t && (e = t.slice()), e[n] = i.copy(i.from, o.from), f1(e, r, i.copy(o.from, i.to)));
          break;
        }
      }
  }
  return e;
}
function f1(t, e, n) {
  for (; e < t.length && ka(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
function vg(t) {
  let e = [];
  return t.someProp("decorations", (n) => {
    let i = n(t.state);
    i && i != Wn && e.push(i);
  }), t.cursorWrapper && e.push(Jt.create(t.state.doc, [t.cursorWrapper.deco])), us.from(e);
}
const AY = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, RY = Ci && Ts <= 11;
class DY {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
let QY = class {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new DY(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((i) => {
      for (let r = 0; r < i.length; r++)
        this.queue.push(i[r]);
      Ci && Ts <= 11 && i.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), RY && (this.onCharData = (i) => {
      this.queue.push({ target: i.target, type: "characterData", oldValue: i.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, AY)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (r1(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Do(this.view);
      if (Ci && Ts <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Qa(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), i;
    for (let o = e.focusNode; o; o = Fc(o))
      n.add(o);
    for (let o = e.anchorNode; o; o = Fc(o))
      if (n.has(o)) {
        i = o;
        break;
      }
    let r = i && this.view.docView.nearestDesc(i);
    if (r && r.ignoreMutation({
      type: "selection",
      target: i.nodeType == 3 ? i.parentNode : i
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let i = e.domSelectionRange(), r = !this.suppressingSelectionUpdates && !this.currentSelection.eq(i) && r1(e) && !this.ignoreSelectionChange(i), o = -1, s = -1, a = !1, l = [];
    if (e.editable)
      for (let c = 0; c < n.length; c++) {
        let d = this.registerMutation(n[c], l);
        d && (o = o < 0 ? d.from : Math.min(d.from, o), s = s < 0 ? d.to : Math.max(d.to, s), d.typeOver && (a = !0));
      }
    if (xr && l.length) {
      let c = l.filter((d) => d.nodeName == "BR");
      if (c.length == 2) {
        let [d, h] = c;
        d.parentNode && d.parentNode.parentNode == h.parentNode ? h.remove() : d.remove();
      } else {
        let { focusNode: d } = this.currentSelection;
        for (let h of c) {
          let f = h.parentNode;
          f && f.nodeName == "LI" && (!d || LY(e, d) != f) && h.remove();
        }
      }
    }
    let u = null;
    o < 0 && r && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && um(i) && (u = Cb(e)) && u.eq(tt.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Do(e), this.currentSelection.set(i), e.scrollToSelection()) : (o > -1 || r) && (o > -1 && (e.docView.markDirty(o, s), NY(e)), this.handleDOMChange(o, s, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(i) || Do(e), this.currentSelection.set(i));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let i = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (i == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !i || i.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let c = 0; c < e.addedNodes.length; c++) {
        let d = e.addedNodes[c];
        n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
      }
      if (i.contentDOM && i.contentDOM != i.dom && !i.contentDOM.contains(e.target))
        return { from: i.posBefore, to: i.posAfter };
      let r = e.previousSibling, o = e.nextSibling;
      if (Ci && Ts <= 11 && e.addedNodes.length)
        for (let c = 0; c < e.addedNodes.length; c++) {
          let { previousSibling: d, nextSibling: h } = e.addedNodes[c];
          (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (r = d), (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (o = h);
        }
      let s = r && r.parentNode == e.target ? Ln(r) + 1 : 0, a = i.localPosFromDOM(e.target, s, -1), l = o && o.parentNode == e.target ? Ln(o) : e.target.childNodes.length, u = i.localPosFromDOM(e.target, l, 1);
      return { from: a, to: u };
    } else
      return e.type == "attributes" ? { from: i.posAtStart - i.border, to: i.posAtEnd + i.border } : (this.lastChangedTextNode = e.target, {
        from: i.posAtStart,
        to: i.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: e.target.nodeValue == e.oldValue
      });
  }
}, p1 = /* @__PURE__ */ new WeakMap(), m1 = !1;
function NY(t) {
  if (!p1.has(t) && (p1.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
    if (t.requiresGeckoHackNode = xr, m1)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), m1 = !0;
  }
}
function g1(t, e) {
  let n = e.startContainer, i = e.startOffset, r = e.endContainer, o = e.endOffset, s = t.domAtPos(t.state.selection.anchor);
  return Qa(s.node, s.offset, r, o) && ([n, i, r, o] = [r, o, n, i]), { anchorNode: n, anchorOffset: i, focusNode: r, focusOffset: o };
}
function IY(t, e) {
  if (e.getComposedRanges) {
    let r = e.getComposedRanges(t.root)[0];
    if (r)
      return g1(t, r);
  }
  let n;
  function i(r) {
    r.preventDefault(), r.stopImmediatePropagation(), n = r.getTargetRanges()[0];
  }
  return t.dom.addEventListener("beforeinput", i, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", i, !0), n ? g1(t, n) : null;
}
function LY(t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    let i = t.docView.nearestDesc(n, !0);
    if (i && i.node.isBlock)
      return n;
  }
  return null;
}
function VY(t, e, n) {
  let { node: i, fromOffset: r, toOffset: o, from: s, to: a } = t.docView.parseRange(e, n), l = t.domSelectionRange(), u, c = l.anchorNode;
  if (c && t.dom.contains(c.nodeType == 1 ? c : c.parentNode) && (u = [{ node: c, offset: l.anchorOffset }], um(l) || u.push({ node: l.focusNode, offset: l.focusOffset })), Hn && t.input.lastKeyCode === 8)
    for (let g = o; g > r; g--) {
      let O = i.childNodes[g - 1], y = O.pmViewDesc;
      if (O.nodeName == "BR" && !y) {
        o = g;
        break;
      }
      if (!y || y.size)
        break;
    }
  let d = t.state.doc, h = t.someProp("domParser") || Cs.fromSchema(t.state.schema), f = d.resolve(s), p = null, m = h.parse(i, {
    topNode: f.parent,
    topMatch: f.parent.contentMatchAt(f.index()),
    topOpen: !0,
    from: r,
    to: o,
    preserveWhitespace: f.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: u,
    ruleFromNode: BY,
    context: f
  });
  if (u && u[0].pos != null) {
    let g = u[0].pos, O = u[1] && u[1].pos;
    O == null && (O = g), p = { anchor: g + s, head: O + s };
  }
  return { doc: m, sel: p, from: s, to: a };
}
function BY(t) {
  let e = t.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (di && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t.parentNode.lastChild == t || di && /^(tr|table)$/i.test(t.parentNode.nodeName))
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const ZY = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function FY(t, e, n, i, r) {
  let o = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
  if (t.input.compositionPendingChanges = 0, e < 0) {
    let C = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, L = Cb(t, C);
    if (L && !t.state.selection.eq(L)) {
      if (Hn && pr && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (P) => P(t, oa(13, "Enter"))))
        return;
      let j = t.state.tr.setSelection(L);
      C == "pointer" ? j.setMeta("pointer", !0) : C == "key" && j.scrollIntoView(), o && j.setMeta("composition", o), t.dispatch(j);
    }
    return;
  }
  let s = t.state.doc.resolve(e), a = s.sharedDepth(n);
  e = s.before(a + 1), n = t.state.doc.resolve(n).after(a + 1);
  let l = t.state.selection, u = VY(t, e, n), c = t.state.doc, d = c.slice(u.from, u.to), h, f;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (h = t.state.selection.to, f = "end") : (h = t.state.selection.from, f = "start"), t.input.lastKeyCode = null;
  let p = XY(d.content, u.doc.content, u.from, h, f);
  if (p && t.input.domChangeCount++, (jl && t.input.lastIOSEnter > Date.now() - 225 || pr) && r.some((C) => C.nodeType == 1 && !ZY.test(C.nodeName)) && (!p || p.endA >= p.endB) && t.someProp("handleKeyDown", (C) => C(t, oa(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!p)
    if (i && l instanceof Je && !l.empty && l.$head.sameParent(l.$anchor) && !t.composing && !(u.sel && u.sel.anchor != u.sel.head))
      p = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (u.sel) {
        let C = O1(t, t.state.doc, u.sel);
        if (C && !C.eq(t.state.selection)) {
          let L = t.state.tr.setSelection(C);
          o && L.setMeta("composition", o), t.dispatch(L);
        }
      }
      return;
    }
  t.state.selection.from < t.state.selection.to && p.start == p.endB && t.state.selection instanceof Je && (p.start > t.state.selection.from && p.start <= t.state.selection.from + 2 && t.state.selection.from >= u.from ? p.start = t.state.selection.from : p.endA < t.state.selection.to && p.endA >= t.state.selection.to - 2 && t.state.selection.to <= u.to && (p.endB += t.state.selection.to - p.endA, p.endA = t.state.selection.to)), Ci && Ts <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > u.from && u.doc.textBetween(p.start - u.from - 1, p.start - u.from + 1) == "  " && (p.start--, p.endA--, p.endB--);
  let m = u.doc.resolveNoCache(p.start - u.from), g = u.doc.resolveNoCache(p.endB - u.from), O = c.resolve(p.start), y = m.sameParent(g) && m.parent.inlineContent && O.end() >= p.endA, b;
  if ((jl && t.input.lastIOSEnter > Date.now() - 225 && (!y || r.some((C) => C.nodeName == "DIV" || C.nodeName == "P")) || !y && m.pos < u.doc.content.size && !m.sameParent(g) && (b = tt.findFrom(u.doc.resolve(m.pos + 1), 1, !0)) && b.head == g.pos) && t.someProp("handleKeyDown", (C) => C(t, oa(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (t.state.selection.anchor > p.start && WY(c, p.start, p.endA, m, g) && t.someProp("handleKeyDown", (C) => C(t, oa(8, "Backspace")))) {
    pr && Hn && t.domObserver.suppressSelectionUpdates();
    return;
  }
  Hn && pr && p.endB == p.start && (t.input.lastAndroidDelete = Date.now()), pr && !y && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && u.sel && u.sel.anchor == u.sel.head && u.sel.head == p.endA && (p.endB -= 2, g = u.doc.resolveNoCache(p.endB - u.from), setTimeout(() => {
    t.someProp("handleKeyDown", function(C) {
      return C(t, oa(13, "Enter"));
    });
  }, 20));
  let v = p.start, k = p.endA, w, S, $;
  if (y) {
    if (m.pos == g.pos)
      Ci && Ts <= 11 && m.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Do(t), 20)), w = t.state.tr.delete(v, k), S = c.resolve(p.start).marksAcross(c.resolve(p.endA));
    else if (
      // Adding or removing a mark
      p.endA == p.endB && ($ = qY(m.parent.content.cut(m.parentOffset, g.parentOffset), O.parent.content.cut(O.parentOffset, p.endA - O.start())))
    )
      w = t.state.tr, $.type == "add" ? w.addMark(v, k, $.mark) : w.removeMark(v, k, $.mark);
    else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
      let C = m.parent.textBetween(m.parentOffset, g.parentOffset);
      if (t.someProp("handleTextInput", (L) => L(t, v, k, C)))
        return;
      w = t.state.tr.insertText(C, v, k);
    }
  }
  if (w || (w = t.state.tr.replace(v, k, u.doc.slice(p.start - u.from, p.endB - u.from))), u.sel) {
    let C = O1(t, w.doc, u.sel);
    C && !(Hn && pr && t.composing && C.empty && (p.start != p.endB || t.input.lastAndroidDelete < Date.now() - 100) && (C.head == v || C.head == w.mapping.map(k) - 1) || Ci && C.empty && C.head == v) && w.setSelection(C);
  }
  S && w.ensureMarks(S), o && w.setMeta("composition", o), t.dispatch(w.scrollIntoView());
}
function O1(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : Tb(t, e.resolve(n.anchor), e.resolve(n.head));
}
function qY(t, e) {
  let n = t.firstChild.marks, i = e.firstChild.marks, r = n, o = i, s, a, l;
  for (let c = 0; c < i.length; c++)
    r = i[c].removeFromSet(r);
  for (let c = 0; c < n.length; c++)
    o = n[c].removeFromSet(o);
  if (r.length == 1 && o.length == 0)
    a = r[0], s = "add", l = (c) => c.mark(a.addToSet(c.marks));
  else if (r.length == 0 && o.length == 1)
    a = o[0], s = "remove", l = (c) => c.mark(a.removeFromSet(c.marks));
  else
    return null;
  let u = [];
  for (let c = 0; c < e.childCount; c++)
    u.push(l(e.child(c)));
  if (we.from(u).eq(t))
    return { mark: a, type: s };
}
function WY(t, e, n, i, r) {
  if (
    // The content must have shrunk
    n - e <= r.pos - i.pos || // newEnd must point directly at or after the end of the block that newStart points into
    yg(i, !0, !1) < r.pos
  )
    return !1;
  let o = t.resolve(e);
  if (!i.parent.isTextblock) {
    let a = o.nodeAfter;
    return a != null && n == e + a.nodeSize;
  }
  if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock)
    return !1;
  let s = t.resolve(yg(o, !0, !0));
  return !s.parent.isTextblock || s.pos > n || yg(s, !0, !1) < n ? !1 : i.parent.content.cut(i.parentOffset).eq(s.parent.content);
}
function yg(t, e, n) {
  let i = t.depth, r = e ? t.end() : t.pos;
  for (; i > 0 && (e || t.indexAfter(i) == t.node(i).childCount); )
    i--, r++, e = !1;
  if (n) {
    let o = t.node(i).maybeChild(t.indexAfter(i));
    for (; o && !o.isLeaf; )
      o = o.firstChild, r++;
  }
  return r;
}
function XY(t, e, n, i, r) {
  let o = t.findDiffStart(e, n);
  if (o == null)
    return null;
  let { a: s, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (r == "end") {
    let l = Math.max(0, o - Math.min(s, a));
    i -= s + l - o;
  }
  if (s < o && t.size < e.size) {
    let l = i <= o && i >= s ? o - i : 0;
    o -= l, o && o < e.size && v1(e.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1), a = o + (a - s), s = o;
  } else if (a < o) {
    let l = i <= o && i >= a ? o - i : 0;
    o -= l, o && o < t.size && v1(t.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1), s = o + (s - a), a = o;
  }
  return { start: o, endA: s, endB: a };
}
function v1(t) {
  if (t.length != 2)
    return !1;
  let e = t.charCodeAt(0), n = t.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
let zY = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new cY(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(S1), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = w1(this), b1(this), this.nodeViews = k1(this), this.docView = Kk(this.state.doc, y1(this), vg(this), this.dom, this), this.domObserver = new QY(this, (i, r, o, s) => FY(this, i, r, o, s)), this.domObserver.start(), dY(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && rv(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(S1), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let i in this._props)
      n[i] = this._props[i];
    n.state = this.state;
    for (let i in e)
      n[i] = e[i];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var i;
    let r = this.state, o = !1, s = !1;
    e.storedMarks && this.composing && (SP(this), s = !0), this.state = e;
    let a = r.plugins != e.plugins || this._props.plugins != n.plugins;
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let f = k1(this);
      YY(f, this.nodeViews) && (this.nodeViews = f, o = !0);
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && rv(this), this.editable = w1(this), b1(this);
    let l = vg(this), u = y1(this), c = r.plugins != e.plugins && !r.doc.eq(e.doc) ? "reset" : e.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve", d = o || !this.docView.matchesNode(e.doc, u, l);
    (d || !e.selection.eq(r.selection)) && (s = !0);
    let h = c == "preserve" && s && this.dom.style.overflowAnchor == null && x4(this);
    if (s) {
      this.domObserver.stop();
      let f = d && (Ci || Hn) && !this.composing && !r.selection.empty && !e.selection.empty && jY(r.selection, e.selection);
      if (d) {
        let p = Hn ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = _Y(this)), (o || !this.docView.update(e.doc, u, l, this)) && (this.docView.updateOuterDeco(u), this.docView.destroy(), this.docView = Kk(e.doc, u, l, this.dom, this)), p && !this.trackWrites && (f = !0);
      }
      f || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && H4(this)) ? Do(this, f) : (cP(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(r), !((i = this.dragging) === null || i === void 0) && i.node && !r.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, r), c == "reset" ? this.dom.scrollTop = 0 : c == "to selection" ? this.scrollToSelection() : h && C4(h);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (n) => n(this)))
      if (this.state.selection instanceof Ke) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && zk(this, n.getBoundingClientRect(), e);
      } else
        zk(this, this.coordsAtPos(this.state.selection.head, 1), e);
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let i = this.directPlugins[n];
        i.spec.view && this.pluginViews.push(i.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let i = this.state.plugins[n];
        i.spec.view && this.pluginViews.push(i.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let i = this.pluginViews[n];
        i.update && i.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let i = e.node, r = -1;
    if (this.state.doc.nodeAt(i.from) == i.node)
      r = i.from;
    else {
      let o = i.from + (this.state.doc.content.size - n.doc.content.size);
      (o > 0 && this.state.doc.nodeAt(o)) == i.node && (r = o);
    }
    this.dragging = new xP(e.slice, e.move, r < 0 ? void 0 : Ke.create(this.state.doc, r));
  }
  someProp(e, n) {
    let i = this._props && this._props[e], r;
    if (i != null && (r = n ? n(i) : i))
      return r;
    for (let s = 0; s < this.directPlugins.length; s++) {
      let a = this.directPlugins[s].props[e];
      if (a != null && (r = n ? n(a) : a))
        return r;
    }
    let o = this.state.plugins;
    if (o)
      for (let s = 0; s < o.length; s++) {
        let a = o[s].props[e];
        if (a != null && (r = n ? n(a) : a))
          return r;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Ci) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && T4(this.dom), Do(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return A4(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return nP(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, i = -1) {
    let r = this.docView.posFromDOM(e, n, i);
    if (r == null)
      throw new RangeError("DOM position not inside the editor");
    return r;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return I4(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return Wc(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return Wc(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (hY(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], vg(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, p4());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return pY(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let n = this._props.dispatchTransaction;
    n ? n.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? di && this.root.nodeType === 11 && y4(this.dom.ownerDocument) == this.dom && IY(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
function y1(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t.state)), n)
      for (let i in n)
        i == "class" ? e.class += " " + n[i] : i == "style" ? e.style = (e.style ? e.style + ";" : "") + n[i] : !e[i] && i != "contenteditable" && i != "nodeName" && (e[i] = String(n[i]));
  }), e.translate || (e.translate = "no"), [Cr.node(0, t.state.doc.content.size, e)];
}
function b1(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: Cr.widget(t.state.selection.from, e, { raw: !0, marks: t.markCursor }) };
  } else
    t.cursorWrapper = null;
}
function w1(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function jY(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function k1(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(i) {
    for (let r in i)
      Object.prototype.hasOwnProperty.call(e, r) || (e[r] = i[r]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function YY(t, e) {
  let n = 0, i = 0;
  for (let r in t) {
    if (t[r] != e[r])
      return !0;
    n++;
  }
  for (let r in e)
    i++;
  return n != i;
}
function S1(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Fo = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, zc = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, HY = typeof navigator < "u" && /Mac/.test(navigator.platform), UY = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Vn = 0; Vn < 10; Vn++)
  Fo[48 + Vn] = Fo[96 + Vn] = String(Vn);
for (var Vn = 1; Vn <= 24; Vn++)
  Fo[Vn + 111] = "F" + Vn;
for (var Vn = 65; Vn <= 90; Vn++)
  Fo[Vn] = String.fromCharCode(Vn + 32), zc[Vn] = String.fromCharCode(Vn);
for (var bg in Fo)
  zc.hasOwnProperty(bg) || (zc[bg] = Fo[bg]);
function AP(t) {
  var e = HY && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || UY && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? zc : Fo)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const GY = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function KY(t) {
  let e = t.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let i, r, o, s;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      r = !0;
    else if (/^s(hift)?$/i.test(l))
      o = !0;
    else if (/^mod$/i.test(l))
      GY ? s = !0 : r = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return i && (n = "Alt-" + n), r && (n = "Ctrl-" + n), s && (n = "Meta-" + n), o && (n = "Shift-" + n), n;
}
function JY(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t)
    e[KY(n)] = t[n];
  return e;
}
function wg(t, e, n = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
}
function eH(t) {
  return new rn({ props: { handleKeyDown: Ab(t) } });
}
function Ab(t) {
  let e = JY(t);
  return function(n, i) {
    let r = AP(i), o, s = e[wg(r, i)];
    if (s && s(n.state, n.dispatch, n))
      return !0;
    if (r.length == 1 && r != " ") {
      if (i.shiftKey) {
        let a = e[wg(r, i, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((i.shiftKey || i.altKey || i.metaKey || r.charCodeAt(0) > 127) && (o = Fo[i.keyCode]) && o != r) {
        let a = e[wg(o, i)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
const tH = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function RP(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
}
const nH = (t, e, n) => {
  let i = RP(t, n);
  if (!i)
    return !1;
  let r = Rb(i);
  if (!r) {
    let s = i.blockRange(), a = s && vu(s);
    return a == null ? !1 : (e && e(t.tr.lift(s, a).scrollIntoView()), !0);
  }
  let o = r.nodeBefore;
  if (IP(t, r, e, -1))
    return !0;
  if (i.parent.content.size == 0 && (Yl(o, "end") || Ke.isSelectable(o)))
    for (let s = i.depth; ; s--) {
      let a = am(t.doc, i.before(s), i.after(s), Ne.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (e) {
          let l = t.tr.step(a);
          l.setSelection(Yl(o, "end") ? tt.findFrom(l.doc.resolve(l.mapping.map(r.pos, -1)), -1) : Ke.create(l.doc, r.pos - o.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (s == 1 || i.node(s - 1).childCount > 1)
        break;
    }
  return o.isAtom && r.depth == i.depth - 1 ? (e && e(t.tr.delete(r.pos - o.nodeSize, r.pos).scrollIntoView()), !0) : !1;
}, iH = (t, e, n) => {
  let i = RP(t, n);
  if (!i)
    return !1;
  let r = Rb(i);
  return r ? DP(t, r, e) : !1;
}, rH = (t, e, n) => {
  let i = QP(t, n);
  if (!i)
    return !1;
  let r = Db(i);
  return r ? DP(t, r, e) : !1;
};
function DP(t, e, n) {
  let i = e.nodeBefore, r = i, o = e.pos - 1;
  for (; !r.isTextblock; o--) {
    if (r.type.spec.isolating)
      return !1;
    let c = r.lastChild;
    if (!c)
      return !1;
    r = c;
  }
  let s = e.nodeAfter, a = s, l = e.pos + 1;
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating)
      return !1;
    let c = a.firstChild;
    if (!c)
      return !1;
    a = c;
  }
  let u = am(t.doc, o, l, Ne.empty);
  if (!u || u.from != o || u instanceof Mn && u.slice.size >= l - o)
    return !1;
  if (n) {
    let c = t.tr.step(u);
    c.setSelection(Je.create(c.doc, o)), n(c.scrollIntoView());
  }
  return !0;
}
function Yl(t, e, n = !1) {
  for (let i = t; i; i = e == "start" ? i.firstChild : i.lastChild) {
    if (i.isTextblock)
      return !0;
    if (n && i.childCount != 1)
      return !1;
  }
  return !1;
}
const oH = (t, e, n) => {
  let { $head: i, empty: r } = t.selection, o = i;
  if (!r)
    return !1;
  if (i.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : i.parentOffset > 0)
      return !1;
    o = Rb(i);
  }
  let s = o && o.nodeBefore;
  return !s || !Ke.isSelectable(s) ? !1 : (e && e(t.tr.setSelection(Ke.create(t.doc, o.pos - s.nodeSize)).scrollIntoView()), !0);
};
function Rb(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function QP(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
}
const sH = (t, e, n) => {
  let i = QP(t, n);
  if (!i)
    return !1;
  let r = Db(i);
  if (!r)
    return !1;
  let o = r.nodeAfter;
  if (IP(t, r, e, 1))
    return !0;
  if (i.parent.content.size == 0 && (Yl(o, "start") || Ke.isSelectable(o))) {
    let s = am(t.doc, i.before(), i.after(), Ne.empty);
    if (s && s.slice.size < s.to - s.from) {
      if (e) {
        let a = t.tr.step(s);
        a.setSelection(Yl(o, "start") ? tt.findFrom(a.doc.resolve(a.mapping.map(r.pos)), 1) : Ke.create(a.doc, a.mapping.map(r.pos))), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return o.isAtom && r.depth == i.depth - 1 ? (e && e(t.tr.delete(r.pos, r.pos + o.nodeSize).scrollIntoView()), !0) : !1;
}, aH = (t, e, n) => {
  let { $head: i, empty: r } = t.selection, o = i;
  if (!r)
    return !1;
  if (i.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t) : i.parentOffset < i.parent.content.size)
      return !1;
    o = Db(i);
  }
  let s = o && o.nodeAfter;
  return !s || !Ke.isSelectable(s) ? !1 : (e && e(t.tr.setSelection(Ke.create(t.doc, o.pos)).scrollIntoView()), !0);
};
function Db(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const lH = (t, e) => {
  let n = t.selection, i = n instanceof Ke, r;
  if (i) {
    if (n.node.isTextblock || !zs(t.doc, n.from))
      return !1;
    r = n.from;
  } else if (r = sm(t.doc, n.from, -1), r == null)
    return !1;
  if (e) {
    let o = t.tr.join(r);
    i && o.setSelection(Ke.create(o.doc, r - t.doc.resolve(r).nodeBefore.nodeSize)), e(o.scrollIntoView());
  }
  return !0;
}, uH = (t, e) => {
  let n = t.selection, i;
  if (n instanceof Ke) {
    if (n.node.isTextblock || !zs(t.doc, n.to))
      return !1;
    i = n.to;
  } else if (i = sm(t.doc, n.to, 1), i == null)
    return !1;
  return e && e(t.tr.join(i).scrollIntoView()), !0;
}, cH = (t, e) => {
  let { $from: n, $to: i } = t.selection, r = n.blockRange(i), o = r && vu(r);
  return o == null ? !1 : (e && e(t.tr.lift(r, o).scrollIntoView()), !0);
}, dH = (t, e) => {
  let { $head: n, $anchor: i } = t.selection;
  return !n.parent.type.spec.code || !n.sameParent(i) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function NP(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const hH = (t, e) => {
  let { $head: n, $anchor: i } = t.selection;
  if (!n.parent.type.spec.code || !n.sameParent(i))
    return !1;
  let r = n.node(-1), o = n.indexAfter(-1), s = NP(r.contentMatchAt(o));
  if (!s || !r.canReplaceWith(o, o, s))
    return !1;
  if (e) {
    let a = n.after(), l = t.tr.replaceWith(a, a, s.createAndFill());
    l.setSelection(tt.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
  }
  return !0;
}, fH = (t, e) => {
  let n = t.selection, { $from: i, $to: r } = n;
  if (n instanceof wr || i.parent.inlineContent || r.parent.inlineContent)
    return !1;
  let o = NP(r.parent.contentMatchAt(r.indexAfter()));
  if (!o || !o.isTextblock)
    return !1;
  if (e) {
    let s = (!i.parentOffset && r.index() < r.parent.childCount ? i : r).pos, a = t.tr.insert(s, o.createAndFill());
    a.setSelection(Je.create(a.doc, s + 1)), e(a.scrollIntoView());
  }
  return !0;
}, pH = (t, e) => {
  let { $cursor: n } = t.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let o = n.before();
    if (Sl(t.doc, o))
      return e && e(t.tr.split(o).scrollIntoView()), !0;
  }
  let i = n.blockRange(), r = i && vu(i);
  return r == null ? !1 : (e && e(t.tr.lift(i, r).scrollIntoView()), !0);
}, mH = (t, e) => {
  let { $from: n, to: i } = t.selection, r, o = n.sharedDepth(i);
  return o == 0 ? !1 : (r = n.before(o), e && e(t.tr.setSelection(Ke.create(t.doc, r))), !0);
};
function gH(t, e, n) {
  let i = e.nodeBefore, r = e.nodeAfter, o = e.index();
  return !i || !r || !i.type.compatibleContent(r.type) ? !1 : !i.content.size && e.parent.canReplace(o - 1, o) ? (n && n(t.tr.delete(e.pos - i.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(o, o + 1) || !(r.isTextblock || zs(t.doc, e.pos)) ? !1 : (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
}
function IP(t, e, n, i) {
  let r = e.nodeBefore, o = e.nodeAfter, s, a, l = r.type.spec.isolating || o.type.spec.isolating;
  if (!l && gH(t, e, n))
    return !0;
  let u = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (u && (s = (a = r.contentMatchAt(r.childCount)).findWrapping(o.type)) && a.matchType(s[0] || o.type).validEnd) {
    if (n) {
      let f = e.pos + o.nodeSize, p = we.empty;
      for (let O = s.length - 1; O >= 0; O--)
        p = we.from(s[O].create(null, p));
      p = we.from(r.copy(p));
      let m = t.tr.step(new An(e.pos - 1, f, e.pos, f, new Ne(p, 1, 0), s.length, !0)), g = m.doc.resolve(f + 2 * s.length);
      g.nodeAfter && g.nodeAfter.type == r.type && zs(m.doc, g.pos) && m.join(g.pos), n(m.scrollIntoView());
    }
    return !0;
  }
  let c = o.type.spec.isolating || i > 0 && l ? null : tt.findFrom(e, 1), d = c && c.$from.blockRange(c.$to), h = d && vu(d);
  if (h != null && h >= e.depth)
    return n && n(t.tr.lift(d, h).scrollIntoView()), !0;
  if (u && Yl(o, "start", !0) && Yl(r, "end")) {
    let f = r, p = [];
    for (; p.push(f), !f.isTextblock; )
      f = f.lastChild;
    let m = o, g = 1;
    for (; !m.isTextblock; m = m.firstChild)
      g++;
    if (f.canReplace(f.childCount, f.childCount, m.content)) {
      if (n) {
        let O = we.empty;
        for (let b = p.length - 1; b >= 0; b--)
          O = we.from(p[b].copy(O));
        let y = t.tr.step(new An(e.pos - p.length, e.pos + o.nodeSize, e.pos + g, e.pos + o.nodeSize - g, new Ne(O, p.length, 0), 0, !0));
        n(y.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function LP(t) {
  return function(e, n) {
    let i = e.selection, r = t < 0 ? i.$from : i.$to, o = r.depth;
    for (; r.node(o).isInline; ) {
      if (!o)
        return !1;
      o--;
    }
    return r.node(o).isTextblock ? (n && n(e.tr.setSelection(Je.create(e.doc, t < 0 ? r.start(o) : r.end(o)))), !0) : !1;
  };
}
const OH = LP(-1), vH = LP(1);
function yH(t, e = null) {
  return function(n, i) {
    let { $from: r, $to: o } = n.selection, s = r.blockRange(o), a = s && kb(s, t, e);
    return a ? (i && i(n.tr.wrap(s, a).scrollIntoView()), !0) : !1;
  };
}
function _1(t, e = null) {
  return function(n, i) {
    let r = !1;
    for (let o = 0; o < n.selection.ranges.length && !r; o++) {
      let { $from: { pos: s }, $to: { pos: a } } = n.selection.ranges[o];
      n.doc.nodesBetween(s, a, (l, u) => {
        if (r)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t)
            r = !0;
          else {
            let c = n.doc.resolve(u), d = c.index();
            r = c.parent.canReplaceWith(d, d + 1, t);
          }
      });
    }
    if (!r)
      return !1;
    if (i) {
      let o = n.tr;
      for (let s = 0; s < n.selection.ranges.length; s++) {
        let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[s];
        o.setBlockType(a, l, t, e);
      }
      i(o.scrollIntoView());
    }
    return !0;
  };
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function bH(t, e = null) {
  return function(n, i) {
    let { $from: r, $to: o } = n.selection, s = r.blockRange(o);
    if (!s)
      return !1;
    let a = i ? n.tr : null;
    return wH(a, s, t, e) ? (i && i(a.scrollIntoView()), !0) : !1;
  };
}
function wH(t, e, n, i = null) {
  let r = !1, o = e, s = e.$from.doc;
  if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(n) && e.startIndex == 0) {
    if (e.$from.index(e.depth - 1) == 0)
      return !1;
    let l = s.resolve(e.start - 2);
    o = new _f(l, l, e.depth), e.endIndex < e.parent.childCount && (e = new _f(e.$from, s.resolve(e.$to.end(e.depth)), e.depth)), r = !0;
  }
  let a = kb(o, n, i, e);
  return a ? (t && kH(t, e, a, r, n), !0) : !1;
}
function kH(t, e, n, i, r) {
  let o = we.empty;
  for (let c = n.length - 1; c >= 0; c--)
    o = we.from(n[c].type.create(n[c].attrs, o));
  t.step(new An(e.start - (i ? 2 : 0), e.end, e.start, e.end, new Ne(o, 0, 0), n.length, !0));
  let s = 0;
  for (let c = 0; c < n.length; c++)
    n[c].type == r && (s = c + 1);
  let a = n.length - s, l = e.start + n.length - (i ? 2 : 0), u = e.parent;
  for (let c = e.startIndex, d = e.endIndex, h = !0; c < d; c++, h = !1)
    !h && Sl(t.doc, l, a) && (t.split(l, a), l += 2 * a), l += u.child(c).nodeSize;
  return t;
}
function SH(t) {
  return function(e, n) {
    let { $from: i, $to: r } = e.selection, o = i.blockRange(r, (s) => s.childCount > 0 && s.firstChild.type == t);
    return o ? n ? i.node(o.depth - 1).type == t ? _H(e, n, t, o) : xH(e, n, o) : !0 : !1;
  };
}
function _H(t, e, n, i) {
  let r = t.tr, o = i.end, s = i.$to.end(i.depth);
  o < s && (r.step(new An(o - 1, s, o, s, new Ne(we.from(n.create(null, i.parent.copy())), 1, 0), 1, !0)), i = new _f(r.doc.resolve(i.$from.pos), r.doc.resolve(s), i.depth));
  const a = vu(i);
  if (a == null)
    return !1;
  r.lift(i, a);
  let l = r.mapping.map(o, -1) - 1;
  return zs(r.doc, l) && r.join(l), e(r.scrollIntoView()), !0;
}
function xH(t, e, n) {
  let i = t.tr, r = n.parent;
  for (let f = n.end, p = n.endIndex - 1, m = n.startIndex; p > m; p--)
    f -= r.child(p).nodeSize, i.delete(f - 1, f + 1);
  let o = i.doc.resolve(n.start), s = o.nodeAfter;
  if (i.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, l = n.endIndex == r.childCount, u = o.node(-1), c = o.index(-1);
  if (!u.canReplace(c + (a ? 0 : 1), c + 1, s.content.append(l ? we.empty : we.from(r))))
    return !1;
  let d = o.pos, h = d + s.nodeSize;
  return i.step(new An(d - (a ? 1 : 0), h + (l ? 1 : 0), d + 1, h - 1, new Ne((a ? we.empty : we.from(r.copy(we.empty))).append(l ? we.empty : we.from(r.copy(we.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(i.scrollIntoView()), !0;
}
function CH(t) {
  return function(e, n) {
    let { $from: i, $to: r } = e.selection, o = i.blockRange(r, (u) => u.childCount > 0 && u.firstChild.type == t);
    if (!o)
      return !1;
    let s = o.startIndex;
    if (s == 0)
      return !1;
    let a = o.parent, l = a.child(s - 1);
    if (l.type != t)
      return !1;
    if (n) {
      let u = l.lastChild && l.lastChild.type == a.type, c = we.from(u ? t.create() : null), d = new Ne(we.from(t.create(null, we.from(a.type.create(null, c)))), u ? 3 : 1, 0), h = o.start, f = o.end;
      n(e.tr.step(new An(h - (u ? 3 : 1), f, h, f, d, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function hm(t) {
  const { state: e, transaction: n } = t;
  let { selection: i } = n, { doc: r } = n, { storedMarks: o } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return o;
    },
    get selection() {
      return i;
    },
    get doc() {
      return r;
    },
    get tr() {
      return i = n.selection, r = n.doc, o = n.storedMarks, n;
    }
  };
}
class fm {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: n, state: i } = this, { view: r } = n, { tr: o } = i, s = this.buildProps(o);
    return Object.fromEntries(Object.entries(e).map(([a, l]) => [a, (...c) => {
      const d = l(...c)(s);
      return !o.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(o), d;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, n = !0) {
    const { rawCommands: i, editor: r, state: o } = this, { view: s } = r, a = [], l = !!e, u = e || o.tr, c = () => (!l && n && !u.getMeta("preventDispatch") && !this.hasCustomState && s.dispatch(u), a.every((h) => h === !0)), d = {
      ...Object.fromEntries(Object.entries(i).map(([h, f]) => [h, (...m) => {
        const g = this.buildProps(u, n), O = f(...m)(g);
        return a.push(O), d;
      }])),
      run: c
    };
    return d;
  }
  createCan(e) {
    const { rawCommands: n, state: i } = this, r = !1, o = e || i.tr, s = this.buildProps(o, r);
    return {
      ...Object.fromEntries(Object.entries(n).map(([l, u]) => [l, (...c) => u(...c)({ ...s, dispatch: void 0 })])),
      chain: () => this.createChain(o, r)
    };
  }
  buildProps(e, n = !0) {
    const { rawCommands: i, editor: r, state: o } = this, { view: s } = r, a = {
      tr: e,
      editor: r,
      view: s,
      state: hm({
        state: o,
        transaction: e
      }),
      dispatch: n ? () => {
      } : void 0,
      chain: () => this.createChain(e, n),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(i).map(([l, u]) => [l, (...c) => u(...c)(a)]));
      }
    };
    return a;
  }
}
class TH {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
  }
  emit(e, ...n) {
    const i = this.callbacks[e];
    return i && i.forEach((r) => r.apply(this, n)), this;
  }
  off(e, n) {
    const i = this.callbacks[e];
    return i && (n ? this.callbacks[e] = i.filter((r) => r !== n) : delete this.callbacks[e]), this;
  }
  once(e, n) {
    const i = (...r) => {
      this.off(e, i), n.apply(this, r);
    };
    return this.on(e, i);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function Xe(t, e, n) {
  return t.config[e] === void 0 && t.parent ? Xe(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
    ...n,
    parent: t.parent ? Xe(t.parent, e, n) : null
  }) : t.config[e];
}
function pm(t) {
  const e = t.filter((r) => r.type === "extension"), n = t.filter((r) => r.type === "node"), i = t.filter((r) => r.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: i
  };
}
function VP(t) {
  const e = [], { nodeExtensions: n, markExtensions: i } = pm(t), r = [...n, ...i], o = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return t.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage,
      extensions: r
    }, l = Xe(s, "addGlobalAttributes", a);
    if (!l)
      return;
    l().forEach((c) => {
      c.types.forEach((d) => {
        Object.entries(c.attributes).forEach(([h, f]) => {
          e.push({
            type: d,
            name: h,
            attribute: {
              ...o,
              ...f
            }
          });
        });
      });
    });
  }), r.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage
    }, l = Xe(s, "addAttributes", a);
    if (!l)
      return;
    const u = l();
    Object.entries(u).forEach(([c, d]) => {
      const h = {
        ...o,
        ...d
      };
      typeof (h == null ? void 0 : h.default) == "function" && (h.default = h.default()), h != null && h.isRequired && (h == null ? void 0 : h.default) === void 0 && delete h.default, e.push({
        type: s.name,
        name: c,
        attribute: h
      });
    });
  }), e;
}
function Dn(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
    return e.nodes[t];
  }
  return t;
}
function Ht(...t) {
  return t.filter((e) => !!e).reduce((e, n) => {
    const i = { ...e };
    return Object.entries(n).forEach(([r, o]) => {
      if (!i[r]) {
        i[r] = o;
        return;
      }
      if (r === "class") {
        const a = o ? o.split(" ") : [], l = i[r] ? i[r].split(" ") : [], u = a.filter((c) => !l.includes(c));
        i[r] = [...l, ...u].join(" ");
      } else if (r === "style") {
        const a = o ? o.split(";").map((c) => c.trim()).filter(Boolean) : [], l = i[r] ? i[r].split(";").map((c) => c.trim()).filter(Boolean) : [], u = /* @__PURE__ */ new Map();
        l.forEach((c) => {
          const [d, h] = c.split(":").map((f) => f.trim());
          u.set(d, h);
        }), a.forEach((c) => {
          const [d, h] = c.split(":").map((f) => f.trim());
          u.set(d, h);
        }), i[r] = Array.from(u.entries()).map(([c, d]) => `${c}: ${d}`).join("; ");
      } else
        i[r] = o;
    }), i;
  }, {});
}
function ov(t, e) {
  return e.filter((n) => n.type === t.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
    [n.name]: t.attrs[n.name]
  }).reduce((n, i) => Ht(n, i), {});
}
function BP(t) {
  return typeof t == "function";
}
function ct(t, e = void 0, ...n) {
  return BP(t) ? e ? t.bind(e)(...n) : t(...n) : t;
}
function $H(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function PH(t) {
  return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t;
}
function x1(t, e) {
  return "style" in t ? t : {
    ...t,
    getAttrs: (n) => {
      const i = t.getAttrs ? t.getAttrs(n) : t.attrs;
      if (i === !1)
        return !1;
      const r = e.reduce((o, s) => {
        const a = s.attribute.parseHTML ? s.attribute.parseHTML(n) : PH(n.getAttribute(s.name));
        return a == null ? o : {
          ...o,
          [s.name]: a
        };
      }, {});
      return { ...i, ...r };
    }
  };
}
function C1(t) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(t).filter(([e, n]) => e === "attrs" && $H(n) ? !1 : n != null)
  );
}
function MH(t, e) {
  var n;
  const i = VP(t), { nodeExtensions: r, markExtensions: o } = pm(t), s = (n = r.find((u) => Xe(u, "topNode"))) === null || n === void 0 ? void 0 : n.name, a = Object.fromEntries(r.map((u) => {
    const c = i.filter((O) => O.type === u.name), d = {
      name: u.name,
      options: u.options,
      storage: u.storage,
      editor: e
    }, h = t.reduce((O, y) => {
      const b = Xe(y, "extendNodeSchema", d);
      return {
        ...O,
        ...b ? b(u) : {}
      };
    }, {}), f = C1({
      ...h,
      content: ct(Xe(u, "content", d)),
      marks: ct(Xe(u, "marks", d)),
      group: ct(Xe(u, "group", d)),
      inline: ct(Xe(u, "inline", d)),
      atom: ct(Xe(u, "atom", d)),
      selectable: ct(Xe(u, "selectable", d)),
      draggable: ct(Xe(u, "draggable", d)),
      code: ct(Xe(u, "code", d)),
      whitespace: ct(Xe(u, "whitespace", d)),
      linebreakReplacement: ct(Xe(u, "linebreakReplacement", d)),
      defining: ct(Xe(u, "defining", d)),
      isolating: ct(Xe(u, "isolating", d)),
      attrs: Object.fromEntries(c.map((O) => {
        var y;
        return [O.name, { default: (y = O == null ? void 0 : O.attribute) === null || y === void 0 ? void 0 : y.default }];
      }))
    }), p = ct(Xe(u, "parseHTML", d));
    p && (f.parseDOM = p.map((O) => x1(O, c)));
    const m = Xe(u, "renderHTML", d);
    m && (f.toDOM = (O) => m({
      node: O,
      HTMLAttributes: ov(O, c)
    }));
    const g = Xe(u, "renderText", d);
    return g && (f.toText = g), [u.name, f];
  })), l = Object.fromEntries(o.map((u) => {
    const c = i.filter((g) => g.type === u.name), d = {
      name: u.name,
      options: u.options,
      storage: u.storage,
      editor: e
    }, h = t.reduce((g, O) => {
      const y = Xe(O, "extendMarkSchema", d);
      return {
        ...g,
        ...y ? y(u) : {}
      };
    }, {}), f = C1({
      ...h,
      inclusive: ct(Xe(u, "inclusive", d)),
      excludes: ct(Xe(u, "excludes", d)),
      group: ct(Xe(u, "group", d)),
      spanning: ct(Xe(u, "spanning", d)),
      code: ct(Xe(u, "code", d)),
      attrs: Object.fromEntries(c.map((g) => {
        var O;
        return [g.name, { default: (O = g == null ? void 0 : g.attribute) === null || O === void 0 ? void 0 : O.default }];
      }))
    }), p = ct(Xe(u, "parseHTML", d));
    p && (f.parseDOM = p.map((g) => x1(g, c)));
    const m = Xe(u, "renderHTML", d);
    return m && (f.toDOM = (g) => m({
      mark: g,
      HTMLAttributes: ov(g, c)
    })), [u.name, f];
  }));
  return new E$({
    topNode: s,
    nodes: a,
    marks: l
  });
}
function kg(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function T1(t, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name) : e;
}
function Qb(t, e) {
  const n = Ha.fromSchema(e).serializeFragment(t), r = document.implementation.createHTMLDocument().createElement("div");
  return r.appendChild(n), r.innerHTML;
}
const EH = (t, e = 500) => {
  let n = "";
  const i = t.parentOffset;
  return t.parent.nodesBetween(Math.max(0, i - e), i, (r, o, s, a) => {
    var l, u;
    const c = ((u = (l = r.type.spec).toText) === null || u === void 0 ? void 0 : u.call(l, {
      node: r,
      pos: o,
      parent: s,
      index: a
    })) || r.textContent || "%leaf%";
    n += r.isAtom && !r.isText ? c : c.slice(0, Math.max(0, i - o));
  }), n;
};
function Nb(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
class mm {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const AH = (t, e) => {
  if (Nb(e))
    return e.exec(t);
  const n = e(t);
  if (!n)
    return null;
  const i = [n.text];
  return i.index = n.index, i.input = t, i.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), i.push(n.replaceWith)), i;
};
function Ud(t) {
  var e;
  const { editor: n, from: i, to: r, text: o, rules: s, plugin: a } = t, { view: l } = n;
  if (l.composing)
    return !1;
  const u = l.state.doc.resolve(i);
  if (
    // check for code node
    u.parent.type.spec.code || !((e = u.nodeBefore || u.nodeAfter) === null || e === void 0) && e.marks.find((h) => h.type.spec.code)
  )
    return !1;
  let c = !1;
  const d = EH(u) + o;
  return s.forEach((h) => {
    if (c)
      return;
    const f = AH(d, h.find);
    if (!f)
      return;
    const p = l.state.tr, m = hm({
      state: l.state,
      transaction: p
    }), g = {
      from: i - (f[0].length - o.length),
      to: r
    }, { commands: O, chain: y, can: b } = new fm({
      editor: n,
      state: m
    });
    h.handler({
      state: m,
      range: g,
      match: f,
      commands: O,
      chain: y,
      can: b
    }) === null || !p.steps.length || (p.setMeta(a, {
      transform: p,
      from: i,
      to: r,
      text: o
    }), l.dispatch(p), c = !0);
  }), c;
}
function RH(t) {
  const { editor: e, rules: n } = t, i = new rn({
    state: {
      init() {
        return null;
      },
      apply(r, o, s) {
        const a = r.getMeta(i);
        if (a)
          return a;
        const l = r.getMeta("applyInputRules");
        return !!l && setTimeout(() => {
          let { text: c } = l;
          typeof c == "string" ? c = c : c = Qb(we.from(c), s.schema);
          const { from: d } = l, h = d + c.length;
          Ud({
            editor: e,
            from: d,
            to: h,
            text: c,
            rules: n,
            plugin: i
          });
        }), r.selectionSet || r.docChanged ? null : o;
      }
    },
    props: {
      handleTextInput(r, o, s, a) {
        return Ud({
          editor: e,
          from: o,
          to: s,
          text: a,
          rules: n,
          plugin: i
        });
      },
      handleDOMEvents: {
        compositionend: (r) => (setTimeout(() => {
          const { $cursor: o } = r.state.selection;
          o && Ud({
            editor: e,
            from: o.pos,
            to: o.pos,
            text: "",
            rules: n,
            plugin: i
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(r, o) {
        if (o.key !== "Enter")
          return !1;
        const { $cursor: s } = r.state.selection;
        return s ? Ud({
          editor: e,
          from: s.pos,
          to: s.pos,
          text: `
`,
          rules: n,
          plugin: i
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return i;
}
function DH(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function Gd(t) {
  return DH(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function gm(t, e) {
  const n = { ...t };
  return Gd(t) && Gd(e) && Object.keys(e).forEach((i) => {
    Gd(e[i]) && Gd(t[i]) ? n[i] = gm(t[i], e[i]) : n[i] = e[i];
  }), n;
}
class Zi {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = ct(Xe(this, "addOptions", {
      name: this.name
    }))), this.storage = ct(Xe(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Zi(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => gm(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new Zi(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = ct(Xe(n, "addOptions", {
      name: n.name
    })), n.storage = ct(Xe(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: i } = e.state, r = e.state.selection.$from;
    if (r.pos === r.end()) {
      const s = r.marks();
      if (!!!s.find((u) => (u == null ? void 0 : u.type.name) === n.name))
        return !1;
      const l = s.find((u) => (u == null ? void 0 : u.type.name) === n.name);
      return l && i.removeStoredMark(l), i.insertText(" ", r.pos), e.view.dispatch(i), !0;
    }
    return !1;
  }
}
function QH(t) {
  return typeof t == "number";
}
class NH {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const IH = (t, e, n) => {
  if (Nb(e))
    return [...t.matchAll(e)];
  const i = e(t, n);
  return i ? i.map((r) => {
    const o = [r.text];
    return o.index = r.index, o.input = t, o.data = r.data, r.replaceWith && (r.text.includes(r.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), o.push(r.replaceWith)), o;
  }) : [];
};
function LH(t) {
  const { editor: e, state: n, from: i, to: r, rule: o, pasteEvent: s, dropEvent: a } = t, { commands: l, chain: u, can: c } = new fm({
    editor: e,
    state: n
  }), d = [];
  return n.doc.nodesBetween(i, r, (f, p) => {
    if (!f.isTextblock || f.type.spec.code)
      return;
    const m = Math.max(i, p), g = Math.min(r, p + f.content.size), O = f.textBetween(m - p, g - p, void 0, "￼");
    IH(O, o.find, s).forEach((b) => {
      if (b.index === void 0)
        return;
      const v = m + b.index + 1, k = v + b[0].length, w = {
        from: n.tr.mapping.map(v),
        to: n.tr.mapping.map(k)
      }, S = o.handler({
        state: n,
        range: w,
        match: b,
        commands: l,
        chain: u,
        can: c,
        pasteEvent: s,
        dropEvent: a
      });
      d.push(S);
    });
  }), d.every((f) => f !== null);
}
const VH = (t) => {
  var e;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t), n;
};
function BH(t) {
  const { editor: e, rules: n } = t;
  let i = null, r = !1, o = !1, s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const l = ({ state: c, from: d, to: h, rule: f, pasteEvt: p }) => {
    const m = c.tr, g = hm({
      state: c,
      transaction: m
    });
    if (!(!LH({
      editor: e,
      state: g,
      from: Math.max(d - 1, 0),
      to: h.b - 1,
      rule: f,
      pasteEvent: p,
      dropEvent: a
    }) || !m.steps.length)) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, m;
    }
  };
  return n.map((c) => new rn({
    // we register a global drag handler to track the current drag source element
    view(d) {
      const h = (f) => {
        var p;
        i = !((p = d.dom.parentElement) === null || p === void 0) && p.contains(f.target) ? d.dom.parentElement : null;
      };
      return window.addEventListener("dragstart", h), {
        destroy() {
          window.removeEventListener("dragstart", h);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (d, h) => (o = i === d.dom.parentElement, a = h, !1),
        paste: (d, h) => {
          var f;
          const p = (f = h.clipboardData) === null || f === void 0 ? void 0 : f.getData("text/html");
          return s = h, r = !!(p != null && p.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (d, h, f) => {
      const p = d[0], m = p.getMeta("uiEvent") === "paste" && !r, g = p.getMeta("uiEvent") === "drop" && !o, O = p.getMeta("applyPasteRules"), y = !!O;
      if (!m && !g && !y)
        return;
      if (y) {
        let { text: k } = O;
        typeof k == "string" ? k = k : k = Qb(we.from(k), f.schema);
        const { from: w } = O, S = w + k.length, $ = VH(k);
        return l({
          rule: c,
          state: f,
          from: w,
          to: { b: S },
          pasteEvt: $
        });
      }
      const b = h.doc.content.findDiffStart(f.doc.content), v = h.doc.content.findDiffEnd(f.doc.content);
      if (!(!QH(b) || !v || b === v.b))
        return l({
          rule: c,
          state: f,
          from: b,
          to: v,
          pasteEvt: s
        });
    }
  }));
}
function ZH(t) {
  const e = t.filter((n, i) => t.indexOf(n) !== i);
  return Array.from(new Set(e));
}
class gl {
  constructor(e, n) {
    this.splittableMarks = [], this.editor = n, this.extensions = gl.resolve(e), this.schema = MH(this.extensions, n), this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(e) {
    const n = gl.sort(gl.flatten(e)), i = ZH(n.map((r) => r.name));
    return i.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${i.map((r) => `'${r}'`).join(", ")}]. This can lead to issues.`), n;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(e) {
    return e.map((n) => {
      const i = {
        name: n.name,
        options: n.options,
        storage: n.storage
      }, r = Xe(n, "addExtensions", i);
      return r ? [n, ...this.flatten(r())] : n;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(e) {
    return e.sort((i, r) => {
      const o = Xe(i, "priority") || 100, s = Xe(r, "priority") || 100;
      return o > s ? -1 : o < s ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, n) => {
      const i = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: this.editor,
        type: kg(n.name, this.schema)
      }, r = Xe(n, "addCommands", i);
      return r ? {
        ...e,
        ...r()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this, n = gl.sort([...this.extensions].reverse()), i = [], r = [], o = n.map((s) => {
      const a = {
        name: s.name,
        options: s.options,
        storage: s.storage,
        editor: e,
        type: kg(s.name, this.schema)
      }, l = [], u = Xe(s, "addKeyboardShortcuts", a);
      let c = {};
      if (s.type === "mark" && Xe(s, "exitable", a) && (c.ArrowRight = () => Zi.handleExit({ editor: e, mark: s })), u) {
        const m = Object.fromEntries(Object.entries(u()).map(([g, O]) => [g, () => O({ editor: e })]));
        c = { ...c, ...m };
      }
      const d = eH(c);
      l.push(d);
      const h = Xe(s, "addInputRules", a);
      T1(s, e.options.enableInputRules) && h && i.push(...h());
      const f = Xe(s, "addPasteRules", a);
      T1(s, e.options.enablePasteRules) && f && r.push(...f());
      const p = Xe(s, "addProseMirrorPlugins", a);
      if (p) {
        const m = p();
        l.push(...m);
      }
      return l;
    }).flat();
    return [
      RH({
        editor: e,
        rules: i
      }),
      ...BH({
        editor: e,
        rules: r
      }),
      ...o
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return VP(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: n } = pm(this.extensions);
    return Object.fromEntries(n.filter((i) => !!Xe(i, "addNodeView")).map((i) => {
      const r = this.attributes.filter((l) => l.type === i.name), o = {
        name: i.name,
        options: i.options,
        storage: i.storage,
        editor: e,
        type: Dn(i.name, this.schema)
      }, s = Xe(i, "addNodeView", o);
      if (!s)
        return [];
      const a = (l, u, c, d, h) => {
        const f = ov(l, r);
        return s()({
          // pass-through
          node: l,
          view: u,
          getPos: c,
          decorations: d,
          innerDecorations: h,
          // tiptap-specific
          editor: e,
          extension: i,
          HTMLAttributes: f
        });
      };
      return [i.name, a];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((e) => {
      var n;
      this.editor.extensionStorage[e.name] = e.storage;
      const i = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: kg(e.name, this.schema)
      };
      e.type === "mark" && (!((n = ct(Xe(e, "keepOnSplit", i))) !== null && n !== void 0) || n) && this.splittableMarks.push(e.name);
      const r = Xe(e, "onBeforeCreate", i), o = Xe(e, "onCreate", i), s = Xe(e, "onUpdate", i), a = Xe(e, "onSelectionUpdate", i), l = Xe(e, "onTransaction", i), u = Xe(e, "onFocus", i), c = Xe(e, "onBlur", i), d = Xe(e, "onDestroy", i);
      r && this.editor.on("beforeCreate", r), o && this.editor.on("create", o), s && this.editor.on("update", s), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), u && this.editor.on("focus", u), c && this.editor.on("blur", c), d && this.editor.on("destroy", d);
    });
  }
}
class yn {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = ct(Xe(this, "addOptions", {
      name: this.name
    }))), this.storage = ct(Xe(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new yn(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => gm(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new yn({ ...this.config, ...e });
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = ct(Xe(n, "addOptions", {
      name: n.name
    })), n.storage = ct(Xe(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
function ZP(t, e, n) {
  const { from: i, to: r } = e, { blockSeparator: o = `

`, textSerializers: s = {} } = n || {};
  let a = "";
  return t.nodesBetween(i, r, (l, u, c, d) => {
    var h;
    l.isBlock && u > i && (a += o);
    const f = s == null ? void 0 : s[l.type.name];
    if (f)
      return c && (a += f({
        node: l,
        pos: u,
        parent: c,
        index: d,
        range: e
      })), !1;
    l.isText && (a += (h = l == null ? void 0 : l.text) === null || h === void 0 ? void 0 : h.slice(Math.max(i, u) - u, r - u));
  }), a;
}
function FP(t) {
  return Object.fromEntries(Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]));
}
const FH = yn.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new rn({
        key: new _n("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this, { state: e, schema: n } = t, { doc: i, selection: r } = e, { ranges: o } = r, s = Math.min(...o.map((c) => c.$from.pos)), a = Math.max(...o.map((c) => c.$to.pos)), l = FP(n);
            return ZP(i, { from: s, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), qH = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
  var n;
  t.isDestroyed || (e.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
}), !0), WH = (t = !1) => ({ commands: e }) => e.setContent("", t), XH = () => ({ state: t, tr: e, dispatch: n }) => {
  const { selection: i } = e, { ranges: r } = i;
  return n && r.forEach(({ $from: o, $to: s }) => {
    t.doc.nodesBetween(o.pos, s.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: u, mapping: c } = e, d = u.resolve(c.map(l)), h = u.resolve(c.map(l + a.nodeSize)), f = d.blockRange(h);
      if (!f)
        return;
      const p = vu(f);
      if (a.type.isTextblock) {
        const { defaultType: m } = d.parent.contentMatchAt(d.index());
        e.setNodeMarkup(f.start, m);
      }
      (p || p === 0) && e.lift(f, p);
    });
  }), !0;
}, zH = (t) => (e) => t(e), jH = () => ({ state: t, dispatch: e }) => fH(t, e), YH = (t, e) => ({ editor: n, tr: i }) => {
  const { state: r } = n, o = r.doc.slice(t.from, t.to);
  i.deleteRange(t.from, t.to);
  const s = i.mapping.map(e);
  return i.insert(s, o.content), i.setSelection(new Je(i.doc.resolve(s - 1))), !0;
}, HH = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, i = n.$anchor.node();
  if (i.content.size > 0)
    return !1;
  const r = t.selection.$anchor;
  for (let o = r.depth; o > 0; o -= 1)
    if (r.node(o).type === i.type) {
      if (e) {
        const a = r.before(o), l = r.after(o);
        t.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, UH = (t) => ({ tr: e, state: n, dispatch: i }) => {
  const r = Dn(t, n.schema), o = e.selection.$anchor;
  for (let s = o.depth; s > 0; s -= 1)
    if (o.node(s).type === r) {
      if (i) {
        const l = o.before(s), u = o.after(s);
        e.delete(l, u).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, GH = (t) => ({ tr: e, dispatch: n }) => {
  const { from: i, to: r } = t;
  return n && e.delete(i, r), !0;
}, KH = () => ({ state: t, dispatch: e }) => tH(t, e), JH = () => ({ commands: t }) => t.keyboardShortcut("Enter"), eU = () => ({ state: t, dispatch: e }) => hH(t, e);
function Pf(t, e, n = { strict: !0 }) {
  const i = Object.keys(e);
  return i.length ? i.every((r) => n.strict ? e[r] === t[r] : Nb(e[r]) ? e[r].test(t[r]) : e[r] === t[r]) : !0;
}
function qP(t, e, n = {}) {
  return t.find((i) => i.type === e && Pf(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((r) => [r, i.attrs[r]])),
    n
  ));
}
function $1(t, e, n = {}) {
  return !!qP(t, e, n);
}
function Ib(t, e, n) {
  var i;
  if (!t || !e)
    return;
  let r = t.parent.childAfter(t.parentOffset);
  if ((!r.node || !r.node.marks.some((c) => c.type === e)) && (r = t.parent.childBefore(t.parentOffset)), !r.node || !r.node.marks.some((c) => c.type === e) || (n = n || ((i = r.node.marks[0]) === null || i === void 0 ? void 0 : i.attrs), !qP([...r.node.marks], e, n)))
    return;
  let s = r.index, a = t.start() + r.offset, l = s + 1, u = a + r.node.nodeSize;
  for (; s > 0 && $1([...t.parent.child(s - 1).marks], e, n); )
    s -= 1, a -= t.parent.child(s).nodeSize;
  for (; l < t.parent.childCount && $1([...t.parent.child(l).marks], e, n); )
    u += t.parent.child(l).nodeSize, l += 1;
  return {
    from: a,
    to: u
  };
}
function Ys(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
    return e.marks[t];
  }
  return t;
}
const tU = (t, e = {}) => ({ tr: n, state: i, dispatch: r }) => {
  const o = Ys(t, i.schema), { doc: s, selection: a } = n, { $from: l, from: u, to: c } = a;
  if (r) {
    const d = Ib(l, o, e);
    if (d && d.from <= u && d.to >= c) {
      const h = Je.create(s, d.from, d.to);
      n.setSelection(h);
    }
  }
  return !0;
}, nU = (t) => (e) => {
  const n = typeof t == "function" ? t(e) : t;
  for (let i = 0; i < n.length; i += 1)
    if (n[i](e))
      return !0;
  return !1;
};
function Lb(t) {
  return t instanceof Je;
}
function Ao(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function WP(t, e = null) {
  if (!e)
    return null;
  const n = tt.atStart(t), i = tt.atEnd(t);
  if (e === "start" || e === !0)
    return n;
  if (e === "end")
    return i;
  const r = n.from, o = i.to;
  return e === "all" ? Je.create(t, Ao(0, r, o), Ao(t.content.size, r, o)) : Je.create(t, Ao(e, r, o), Ao(e, r, o));
}
function Vb() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const iU = (t = null, e = {}) => ({ editor: n, view: i, tr: r, dispatch: o }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const s = () => {
    Vb() && i.dom.focus(), requestAnimationFrame(() => {
      n.isDestroyed || (i.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  if (i.hasFocus() && t === null || t === !1)
    return !0;
  if (o && t === null && !Lb(n.state.selection))
    return s(), !0;
  const a = WP(r.doc, t) || n.state.selection, l = n.state.selection.eq(a);
  return o && (l || r.setSelection(a), l && r.storedMarks && r.setStoredMarks(r.storedMarks), s()), !0;
}, rU = (t, e) => (n) => t.every((i, r) => e(i, { ...n, index: r })), oU = (t, e) => ({ tr: n, commands: i }) => i.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e), XP = (t) => {
  const e = t.childNodes;
  for (let n = e.length - 1; n >= 0; n -= 1) {
    const i = e[n];
    i.nodeType === 3 && i.nodeValue && /^(\n\s\s|\n)$/.test(i.nodeValue) ? t.removeChild(i) : i.nodeType === 1 && XP(i);
  }
  return t;
};
function Kd(t) {
  const e = `<body>${t}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
  return XP(n);
}
function Mf(t, e, n) {
  if (t instanceof xs || t instanceof we)
    return t;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const i = typeof t == "object" && t !== null, r = typeof t == "string";
  if (i)
    try {
      if (Array.isArray(t) && t.length > 0)
        return we.fromArray(t.map((a) => e.nodeFromJSON(a)));
      const s = e.nodeFromJSON(t);
      return n.errorOnInvalidContent && s.check(), s;
    } catch (o) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: o });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", o), Mf("", e, n);
    }
  if (r) {
    if (n.errorOnInvalidContent) {
      let s = !1, a = "";
      const l = new E$({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (u) => (s = !0, a = typeof u == "string" ? u : u.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? Cs.fromSchema(l).parseSlice(Kd(t), n.parseOptions) : Cs.fromSchema(l).parse(Kd(t), n.parseOptions), n.errorOnInvalidContent && s)
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${a}`) });
    }
    const o = Cs.fromSchema(e);
    return n.slice ? o.parseSlice(Kd(t), n.parseOptions).content : o.parse(Kd(t), n.parseOptions);
  }
  return Mf("", e, n);
}
function sU(t, e, n) {
  const i = t.steps.length - 1;
  if (i < e)
    return;
  const r = t.steps[i];
  if (!(r instanceof Mn || r instanceof An))
    return;
  const o = t.mapping.maps[i];
  let s = 0;
  o.forEach((a, l, u, c) => {
    s === 0 && (s = c);
  }), t.setSelection(tt.near(t.doc.resolve(s), n));
}
const aU = (t) => !("type" in t), lU = (t, e, n) => ({ tr: i, dispatch: r, editor: o }) => {
  var s;
  if (r) {
    n = {
      parseOptions: o.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    try {
      a = Mf(e, o.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...n.parseOptions
        },
        errorOnInvalidContent: (s = n.errorOnInvalidContent) !== null && s !== void 0 ? s : o.options.enableContentCheck
      });
    } catch (p) {
      return o.emit("contentError", {
        editor: o,
        error: p,
        disableCollaboration: () => {
          o.storage.collaboration && (o.storage.collaboration.isDisabled = !0);
        }
      }), !1;
    }
    let { from: l, to: u } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, c = !0, d = !0;
    if ((aU(a) ? a : [a]).forEach((p) => {
      p.check(), c = c ? p.isText && p.marks.length === 0 : !1, d = d ? p.isBlock : !1;
    }), l === u && d) {
      const { parent: p } = i.doc.resolve(l);
      p.isTextblock && !p.type.spec.code && !p.childCount && (l -= 1, u += 1);
    }
    let f;
    if (c) {
      if (Array.isArray(e))
        f = e.map((p) => p.text || "").join("");
      else if (e instanceof we) {
        let p = "";
        e.forEach((m) => {
          m.text && (p += m.text);
        }), f = p;
      } else
        typeof e == "object" && e && e.text ? f = e.text : f = e;
      i.insertText(f, l, u);
    } else
      f = a, i.replaceWith(l, u, f);
    n.updateSelection && sU(i, i.steps.length - 1, -1), n.applyInputRules && i.setMeta("applyInputRules", { from: l, text: f }), n.applyPasteRules && i.setMeta("applyPasteRules", { from: l, text: f });
  }
  return !0;
}, uU = () => ({ state: t, dispatch: e }) => lH(t, e), cU = () => ({ state: t, dispatch: e }) => uH(t, e), dU = () => ({ state: t, dispatch: e }) => nH(t, e), hU = () => ({ state: t, dispatch: e }) => sH(t, e), fU = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const i = sm(t.doc, t.selection.$from.pos, -1);
    return i == null ? !1 : (n.join(i, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, pU = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const i = sm(t.doc, t.selection.$from.pos, 1);
    return i == null ? !1 : (n.join(i, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, mU = () => ({ state: t, dispatch: e }) => iH(t, e), gU = () => ({ state: t, dispatch: e }) => rH(t, e);
function zP() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function OU(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let i, r, o, s;
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      r = !0;
    else if (/^s(hift)?$/i.test(l))
      o = !0;
    else if (/^mod$/i.test(l))
      Vb() || zP() ? s = !0 : r = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return i && (n = `Alt-${n}`), r && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), o && (n = `Shift-${n}`), n;
}
const vU = (t) => ({ editor: e, view: n, tr: i, dispatch: r }) => {
  const o = OU(t).split(/-(?!$)/), s = o.find((u) => !["Alt", "Ctrl", "Meta", "Shift"].includes(u)), a = new KeyboardEvent("keydown", {
    key: s === "Space" ? " " : s,
    altKey: o.includes("Alt"),
    ctrlKey: o.includes("Ctrl"),
    metaKey: o.includes("Meta"),
    shiftKey: o.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    n.someProp("handleKeyDown", (u) => u(n, a));
  });
  return l == null || l.steps.forEach((u) => {
    const c = u.map(i.mapping);
    c && r && i.maybeStep(c);
  }), !0;
};
function jc(t, e, n = {}) {
  const { from: i, to: r, empty: o } = t.selection, s = e ? Dn(e, t.schema) : null, a = [];
  t.doc.nodesBetween(i, r, (d, h) => {
    if (d.isText)
      return;
    const f = Math.max(i, h), p = Math.min(r, h + d.nodeSize);
    a.push({
      node: d,
      from: f,
      to: p
    });
  });
  const l = r - i, u = a.filter((d) => s ? s.name === d.node.type.name : !0).filter((d) => Pf(d.node.attrs, n, { strict: !1 }));
  return o ? !!u.length : u.reduce((d, h) => d + h.to - h.from, 0) >= l;
}
const yU = (t, e = {}) => ({ state: n, dispatch: i }) => {
  const r = Dn(t, n.schema);
  return jc(n, r, e) ? cH(n, i) : !1;
}, bU = () => ({ state: t, dispatch: e }) => pH(t, e), wU = (t) => ({ state: e, dispatch: n }) => {
  const i = Dn(t, e.schema);
  return SH(i)(e, n);
}, kU = () => ({ state: t, dispatch: e }) => dH(t, e);
function Om(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function P1(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce((i, r) => (n.includes(r) || (i[r] = t[r]), i), {});
}
const SU = (t, e) => ({ tr: n, state: i, dispatch: r }) => {
  let o = null, s = null;
  const a = Om(typeof t == "string" ? t : t.name, i.schema);
  return a ? (a === "node" && (o = Dn(t, i.schema)), a === "mark" && (s = Ys(t, i.schema)), r && n.selection.ranges.forEach((l) => {
    i.doc.nodesBetween(l.$from.pos, l.$to.pos, (u, c) => {
      o && o === u.type && n.setNodeMarkup(c, void 0, P1(u.attrs, e)), s && u.marks.length && u.marks.forEach((d) => {
        s === d.type && n.addMark(c, c + u.nodeSize, s.create(P1(d.attrs, e)));
      });
    });
  }), !0) : !1;
}, _U = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), xU = () => ({ tr: t, commands: e }) => e.setTextSelection({
  from: 0,
  to: t.doc.content.size
}), CU = () => ({ state: t, dispatch: e }) => oH(t, e), TU = () => ({ state: t, dispatch: e }) => aH(t, e), $U = () => ({ state: t, dispatch: e }) => mH(t, e), PU = () => ({ state: t, dispatch: e }) => vH(t, e), MU = () => ({ state: t, dispatch: e }) => OH(t, e);
function sv(t, e, n = {}, i = {}) {
  return Mf(t, e, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: i.errorOnInvalidContent
  });
}
const EU = (t, e = !1, n = {}, i = {}) => ({ editor: r, tr: o, dispatch: s, commands: a }) => {
  var l, u;
  const { doc: c } = o;
  if (n.preserveWhitespace !== "full") {
    const d = sv(t, r.schema, n, {
      errorOnInvalidContent: (l = i.errorOnInvalidContent) !== null && l !== void 0 ? l : r.options.enableContentCheck
    });
    return s && o.replaceWith(0, c.content.size, d).setMeta("preventUpdate", !e), !0;
  }
  return s && o.setMeta("preventUpdate", !e), a.insertContentAt({ from: 0, to: c.content.size }, t, {
    parseOptions: n,
    errorOnInvalidContent: (u = i.errorOnInvalidContent) !== null && u !== void 0 ? u : r.options.enableContentCheck
  });
};
function Bb(t, e) {
  const n = Ys(e, t.schema), { from: i, to: r, empty: o } = t.selection, s = [];
  o ? (t.storedMarks && s.push(...t.storedMarks), s.push(...t.selection.$head.marks())) : t.doc.nodesBetween(i, r, (l) => {
    s.push(...l.marks);
  });
  const a = s.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function AU(t, e) {
  const n = new Sb(t);
  return e.forEach((i) => {
    i.steps.forEach((r) => {
      n.step(r);
    });
  }), n;
}
function RU(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function DU(t, e, n) {
  const i = [];
  return t.nodesBetween(e.from, e.to, (r, o) => {
    n(r) && i.push({
      node: r,
      pos: o
    });
  }), i;
}
function jP(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const i = t.node(n);
    if (e(i))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: i
      };
  }
}
function Zb(t) {
  return (e) => jP(e.$from, t);
}
function QU(t, e) {
  const n = {
    from: 0,
    to: t.content.size
  };
  return ZP(t, n, e);
}
function NU(t, e) {
  const n = Dn(e, t.schema), { from: i, to: r } = t.selection, o = [];
  t.doc.nodesBetween(i, r, (a) => {
    o.push(a);
  });
  const s = o.reverse().find((a) => a.type.name === n.name);
  return s ? { ...s.attrs } : {};
}
function YP(t, e) {
  const n = Om(typeof e == "string" ? e : e.name, t.schema);
  return n === "node" ? NU(t, e) : n === "mark" ? Bb(t, e) : {};
}
function IU(t, e = JSON.stringify) {
  const n = {};
  return t.filter((i) => {
    const r = e(i);
    return Object.prototype.hasOwnProperty.call(n, r) ? !1 : n[r] = !0;
  });
}
function LU(t) {
  const e = IU(t);
  return e.length === 1 ? e : e.filter((n, i) => !e.filter((o, s) => s !== i).some((o) => n.oldRange.from >= o.oldRange.from && n.oldRange.to <= o.oldRange.to && n.newRange.from >= o.newRange.from && n.newRange.to <= o.newRange.to));
}
function VU(t) {
  const { mapping: e, steps: n } = t, i = [];
  return e.maps.forEach((r, o) => {
    const s = [];
    if (r.ranges.length)
      r.forEach((a, l) => {
        s.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = n[o];
      if (a === void 0 || l === void 0)
        return;
      s.push({ from: a, to: l });
    }
    s.forEach(({ from: a, to: l }) => {
      const u = e.slice(o).map(a, -1), c = e.slice(o).map(l), d = e.invert().map(u, -1), h = e.invert().map(c);
      i.push({
        oldRange: {
          from: d,
          to: h
        },
        newRange: {
          from: u,
          to: c
        }
      });
    });
  }), LU(i);
}
function Fb(t, e, n) {
  const i = [];
  return t === e ? n.resolve(t).marks().forEach((r) => {
    const o = n.resolve(t), s = Ib(o, r.type);
    s && i.push({
      mark: r,
      ...s
    });
  }) : n.nodesBetween(t, e, (r, o) => {
    !r || (r == null ? void 0 : r.nodeSize) === void 0 || i.push(...r.marks.map((s) => ({
      from: o,
      to: o + r.nodeSize,
      mark: s
    })));
  }), i;
}
function Qh(t, e, n) {
  return Object.fromEntries(Object.entries(n).filter(([i]) => {
    const r = t.find((o) => o.type === e && o.name === i);
    return r ? r.attribute.keepOnSplit : !1;
  }));
}
function av(t, e, n = {}) {
  const { empty: i, ranges: r } = t.selection, o = e ? Ys(e, t.schema) : null;
  if (i)
    return !!(t.storedMarks || t.selection.$from.marks()).filter((d) => o ? o.name === d.type.name : !0).find((d) => Pf(d.attrs, n, { strict: !1 }));
  let s = 0;
  const a = [];
  if (r.forEach(({ $from: d, $to: h }) => {
    const f = d.pos, p = h.pos;
    t.doc.nodesBetween(f, p, (m, g) => {
      if (!m.isText && !m.marks.length)
        return;
      const O = Math.max(f, g), y = Math.min(p, g + m.nodeSize), b = y - O;
      s += b, a.push(...m.marks.map((v) => ({
        mark: v,
        from: O,
        to: y
      })));
    });
  }), s === 0)
    return !1;
  const l = a.filter((d) => o ? o.name === d.mark.type.name : !0).filter((d) => Pf(d.mark.attrs, n, { strict: !1 })).reduce((d, h) => d + h.to - h.from, 0), u = a.filter((d) => o ? d.mark.type !== o && d.mark.type.excludes(o) : !0).reduce((d, h) => d + h.to - h.from, 0);
  return (l > 0 ? l + u : l) >= s;
}
function BU(t, e, n = {}) {
  if (!e)
    return jc(t, null, n) || av(t, null, n);
  const i = Om(e, t.schema);
  return i === "node" ? jc(t, e, n) : i === "mark" ? av(t, e, n) : !1;
}
function M1(t, e) {
  const { nodeExtensions: n } = pm(e), i = n.find((s) => s.name === t);
  if (!i)
    return !1;
  const r = {
    name: i.name,
    options: i.options,
    storage: i.storage
  }, o = ct(Xe(i, "group", r));
  return typeof o != "string" ? !1 : o.split(" ").includes("list");
}
function vm(t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) {
  var i;
  if (n) {
    if (t.type.name === "hardBreak")
      return !0;
    if (t.isText)
      return /^\s*$/m.test((i = t.text) !== null && i !== void 0 ? i : "");
  }
  if (t.isText)
    return !t.text;
  if (t.isAtom || t.isLeaf)
    return !1;
  if (t.content.childCount === 0)
    return !0;
  if (e) {
    let r = !0;
    return t.content.forEach((o) => {
      r !== !1 && (vm(o, { ignoreWhitespace: n, checkChildren: e }) || (r = !1));
    }), r;
  }
  return !1;
}
function HP(t) {
  return t instanceof Ke;
}
function UP(t, e, n) {
  const r = t.state.doc.content.size, o = Ao(e, 0, r), s = Ao(n, 0, r), a = t.coordsAtPos(o), l = t.coordsAtPos(s, -1), u = Math.min(a.top, l.top), c = Math.max(a.bottom, l.bottom), d = Math.min(a.left, l.left), h = Math.max(a.right, l.right), f = h - d, p = c - u, O = {
    top: u,
    bottom: c,
    left: d,
    right: h,
    width: f,
    height: p,
    x: d,
    y: u
  };
  return {
    ...O,
    toJSON: () => O
  };
}
function ZU(t, e, n) {
  var i;
  const { selection: r } = e;
  let o = null;
  if (Lb(r) && (o = r.$cursor), o) {
    const a = (i = t.storedMarks) !== null && i !== void 0 ? i : o.marks();
    return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
  }
  const { ranges: s } = r;
  return s.some(({ $from: a, $to: l }) => {
    let u = a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return t.doc.nodesBetween(a.pos, l.pos, (c, d, h) => {
      if (u)
        return !1;
      if (c.isInline) {
        const f = !h || h.type.allowsMarkType(n), p = !!n.isInSet(c.marks) || !c.marks.some((m) => m.type.excludes(n));
        u = f && p;
      }
      return !u;
    }), u;
  });
}
const FU = (t, e = {}) => ({ tr: n, state: i, dispatch: r }) => {
  const { selection: o } = n, { empty: s, ranges: a } = o, l = Ys(t, i.schema);
  if (r)
    if (s) {
      const u = Bb(i, l);
      n.addStoredMark(l.create({
        ...u,
        ...e
      }));
    } else
      a.forEach((u) => {
        const c = u.$from.pos, d = u.$to.pos;
        i.doc.nodesBetween(c, d, (h, f) => {
          const p = Math.max(f, c), m = Math.min(f + h.nodeSize, d);
          h.marks.find((O) => O.type === l) ? h.marks.forEach((O) => {
            l === O.type && n.addMark(p, m, l.create({
              ...O.attrs,
              ...e
            }));
          }) : n.addMark(p, m, l.create(e));
        });
      });
  return ZU(i, n, l);
}, qU = (t, e) => ({ tr: n }) => (n.setMeta(t, e), !0), WU = (t, e = {}) => ({ state: n, dispatch: i, chain: r }) => {
  const o = Dn(t, n.schema);
  let s;
  return n.selection.$anchor.sameParent(n.selection.$head) && (s = n.selection.$anchor.parent.attrs), o.isTextblock ? r().command(({ commands: a }) => _1(o, { ...s, ...e })(n) ? !0 : a.clearNodes()).command(({ state: a }) => _1(o, { ...s, ...e })(a, i)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, XU = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: i } = e, r = Ao(t, 0, i.content.size), o = Ke.create(i, r);
    e.setSelection(o);
  }
  return !0;
}, zU = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: i } = e, { from: r, to: o } = typeof t == "number" ? { from: t, to: t } : t, s = Je.atStart(i).from, a = Je.atEnd(i).to, l = Ao(r, s, a), u = Ao(o, s, a), c = Je.create(i, l, u);
    e.setSelection(c);
  }
  return !0;
}, jU = (t) => ({ state: e, dispatch: n }) => {
  const i = Dn(t, e.schema);
  return CH(i)(e, n);
};
function E1(t, e) {
  const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  if (n) {
    const i = n.filter((r) => e == null ? void 0 : e.includes(r.type.name));
    t.tr.ensureMarks(i);
  }
}
const YU = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: i, editor: r }) => {
  const { selection: o, doc: s } = e, { $from: a, $to: l } = o, u = r.extensionManager.attributes, c = Qh(u, a.node().type.name, a.node().attrs);
  if (o instanceof Ke && o.node.isBlock)
    return !a.parentOffset || !Sl(s, a.pos) ? !1 : (i && (t && E1(n, r.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const d = l.parentOffset === l.parent.content.size, h = a.depth === 0 ? void 0 : RU(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let f = d && h ? [
    {
      type: h,
      attrs: c
    }
  ] : void 0, p = Sl(e.doc, e.mapping.map(a.pos), 1, f);
  if (!f && !p && Sl(e.doc, e.mapping.map(a.pos), 1, h ? [{ type: h }] : void 0) && (p = !0, f = h ? [
    {
      type: h,
      attrs: c
    }
  ] : void 0), i) {
    if (p && (o instanceof Je && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, f), h && !d && !a.parentOffset && a.parent.type !== h)) {
      const m = e.mapping.map(a.before()), g = e.doc.resolve(m);
      a.node(-1).canReplaceWith(g.index(), g.index() + 1, h) && e.setNodeMarkup(e.mapping.map(a.before()), h);
    }
    t && E1(n, r.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return p;
}, HU = (t, e = {}) => ({ tr: n, state: i, dispatch: r, editor: o }) => {
  var s;
  const a = Dn(t, i.schema), { $from: l, $to: u } = i.selection, c = i.selection.node;
  if (c && c.isBlock || l.depth < 2 || !l.sameParent(u))
    return !1;
  const d = l.node(-1);
  if (d.type !== a)
    return !1;
  const h = o.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (r) {
      let O = we.empty;
      const y = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let $ = l.depth - y; $ >= l.depth - 3; $ -= 1)
        O = we.from(l.node($).copy(O));
      const b = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, v = {
        ...Qh(h, l.node().type.name, l.node().attrs),
        ...e
      }, k = ((s = a.contentMatch.defaultType) === null || s === void 0 ? void 0 : s.createAndFill(v)) || void 0;
      O = O.append(we.from(a.createAndFill(null, k) || void 0));
      const w = l.before(l.depth - (y - 1));
      n.replace(w, l.after(-b), new Ne(O, 4 - y, 0));
      let S = -1;
      n.doc.nodesBetween(w, n.doc.content.size, ($, C) => {
        if (S > -1)
          return !1;
        $.isTextblock && $.content.size === 0 && (S = C + 1);
      }), S > -1 && n.setSelection(Je.near(n.doc.resolve(S))), n.scrollIntoView();
    }
    return !0;
  }
  const f = u.pos === l.end() ? d.contentMatchAt(0).defaultType : null, p = {
    ...Qh(h, d.type.name, d.attrs),
    ...e
  }, m = {
    ...Qh(h, l.node().type.name, l.node().attrs),
    ...e
  };
  n.delete(l.pos, u.pos);
  const g = f ? [
    { type: a, attrs: p },
    { type: f, attrs: m }
  ] : [{ type: a, attrs: p }];
  if (!Sl(n.doc, l.pos, 2))
    return !1;
  if (r) {
    const { selection: O, storedMarks: y } = i, { splittableMarks: b } = o.extensionManager, v = y || O.$to.parentOffset && O.$from.marks();
    if (n.split(l.pos, 2, g).scrollIntoView(), !v || !r)
      return !0;
    const k = v.filter((w) => b.includes(w.type.name));
    n.ensureMarks(k);
  }
  return !0;
}, Sg = (t, e) => {
  const n = Zb((s) => s.type === e)(t.selection);
  if (!n)
    return !0;
  const i = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (i === void 0)
    return !0;
  const r = t.doc.nodeAt(i);
  return n.node.type === (r == null ? void 0 : r.type) && zs(t.doc, n.pos) && t.join(n.pos), !0;
}, _g = (t, e) => {
  const n = Zb((s) => s.type === e)(t.selection);
  if (!n)
    return !0;
  const i = t.doc.resolve(n.start).after(n.depth);
  if (i === void 0)
    return !0;
  const r = t.doc.nodeAt(i);
  return n.node.type === (r == null ? void 0 : r.type) && zs(t.doc, i) && t.join(i), !0;
}, UU = (t, e, n, i = {}) => ({ editor: r, tr: o, state: s, dispatch: a, chain: l, commands: u, can: c }) => {
  const { extensions: d, splittableMarks: h } = r.extensionManager, f = Dn(t, s.schema), p = Dn(e, s.schema), { selection: m, storedMarks: g } = s, { $from: O, $to: y } = m, b = O.blockRange(y), v = g || m.$to.parentOffset && m.$from.marks();
  if (!b)
    return !1;
  const k = Zb((w) => M1(w.type.name, d))(m);
  if (b.depth >= 1 && k && b.depth - k.depth <= 1) {
    if (k.node.type === f)
      return u.liftListItem(p);
    if (M1(k.node.type.name, d) && f.validContent(k.node.content) && a)
      return l().command(() => (o.setNodeMarkup(k.pos, f), !0)).command(() => Sg(o, f)).command(() => _g(o, f)).run();
  }
  return !n || !v || !a ? l().command(() => c().wrapInList(f, i) ? !0 : u.clearNodes()).wrapInList(f, i).command(() => Sg(o, f)).command(() => _g(o, f)).run() : l().command(() => {
    const w = c().wrapInList(f, i), S = v.filter(($) => h.includes($.type.name));
    return o.ensureMarks(S), w ? !0 : u.clearNodes();
  }).wrapInList(f, i).command(() => Sg(o, f)).command(() => _g(o, f)).run();
}, GU = (t, e = {}, n = {}) => ({ state: i, commands: r }) => {
  const { extendEmptyMarkRange: o = !1 } = n, s = Ys(t, i.schema);
  return av(i, s, e) ? r.unsetMark(s, { extendEmptyMarkRange: o }) : r.setMark(s, e);
}, KU = (t, e, n = {}) => ({ state: i, commands: r }) => {
  const o = Dn(t, i.schema), s = Dn(e, i.schema), a = jc(i, o, n);
  let l;
  return i.selection.$anchor.sameParent(i.selection.$head) && (l = i.selection.$anchor.parent.attrs), a ? r.setNode(s, l) : r.setNode(o, { ...l, ...n });
}, JU = (t, e = {}) => ({ state: n, commands: i }) => {
  const r = Dn(t, n.schema);
  return jc(n, r, e) ? i.lift(r) : i.wrapIn(r, e);
}, e8 = () => ({ state: t, dispatch: e }) => {
  const n = t.plugins;
  for (let i = 0; i < n.length; i += 1) {
    const r = n[i];
    let o;
    if (r.spec.isInputRules && (o = r.getState(t))) {
      if (e) {
        const s = t.tr, a = o.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          s.step(a.steps[l].invert(a.docs[l]));
        if (o.text) {
          const l = s.doc.resolve(o.from).marks();
          s.replaceWith(o.from, o.to, t.schema.text(o.text, l));
        } else
          s.delete(o.from, o.to);
      }
      return !0;
    }
  }
  return !1;
}, t8 = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, { empty: i, ranges: r } = n;
  return i || e && r.forEach((o) => {
    t.removeMark(o.$from.pos, o.$to.pos);
  }), !0;
}, n8 = (t, e = {}) => ({ tr: n, state: i, dispatch: r }) => {
  var o;
  const { extendEmptyMarkRange: s = !1 } = e, { selection: a } = n, l = Ys(t, i.schema), { $from: u, empty: c, ranges: d } = a;
  if (!r)
    return !0;
  if (c && s) {
    let { from: h, to: f } = a;
    const p = (o = u.marks().find((g) => g.type === l)) === null || o === void 0 ? void 0 : o.attrs, m = Ib(u, l, p);
    m && (h = m.from, f = m.to), n.removeMark(h, f, l);
  } else
    d.forEach((h) => {
      n.removeMark(h.$from.pos, h.$to.pos, l);
    });
  return n.removeStoredMark(l), !0;
}, i8 = (t, e = {}) => ({ tr: n, state: i, dispatch: r }) => {
  let o = null, s = null;
  const a = Om(typeof t == "string" ? t : t.name, i.schema);
  return a ? (a === "node" && (o = Dn(t, i.schema)), a === "mark" && (s = Ys(t, i.schema)), r && n.selection.ranges.forEach((l) => {
    const u = l.$from.pos, c = l.$to.pos;
    let d, h, f, p;
    n.selection.empty ? i.doc.nodesBetween(u, c, (m, g) => {
      o && o === m.type && (f = Math.max(g, u), p = Math.min(g + m.nodeSize, c), d = g, h = m);
    }) : i.doc.nodesBetween(u, c, (m, g) => {
      g < u && o && o === m.type && (f = Math.max(g, u), p = Math.min(g + m.nodeSize, c), d = g, h = m), g >= u && g <= c && (o && o === m.type && n.setNodeMarkup(g, void 0, {
        ...m.attrs,
        ...e
      }), s && m.marks.length && m.marks.forEach((O) => {
        if (s === O.type) {
          const y = Math.max(g, u), b = Math.min(g + m.nodeSize, c);
          n.addMark(y, b, s.create({
            ...O.attrs,
            ...e
          }));
        }
      }));
    }), h && (d !== void 0 && n.setNodeMarkup(d, void 0, {
      ...h.attrs,
      ...e
    }), s && h.marks.length && h.marks.forEach((m) => {
      s === m.type && n.addMark(f, p, s.create({
        ...m.attrs,
        ...e
      }));
    }));
  }), !0) : !1;
}, r8 = (t, e = {}) => ({ state: n, dispatch: i }) => {
  const r = Dn(t, n.schema);
  return yH(r, e)(n, i);
}, o8 = (t, e = {}) => ({ state: n, dispatch: i }) => {
  const r = Dn(t, n.schema);
  return bH(r, e)(n, i);
};
var s8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: qH,
  clearContent: WH,
  clearNodes: XH,
  command: zH,
  createParagraphNear: jH,
  cut: YH,
  deleteCurrentNode: HH,
  deleteNode: UH,
  deleteRange: GH,
  deleteSelection: KH,
  enter: JH,
  exitCode: eU,
  extendMarkRange: tU,
  first: nU,
  focus: iU,
  forEach: rU,
  insertContent: oU,
  insertContentAt: lU,
  joinBackward: dU,
  joinDown: cU,
  joinForward: hU,
  joinItemBackward: fU,
  joinItemForward: pU,
  joinTextblockBackward: mU,
  joinTextblockForward: gU,
  joinUp: uU,
  keyboardShortcut: vU,
  lift: yU,
  liftEmptyBlock: bU,
  liftListItem: wU,
  newlineInCode: kU,
  resetAttributes: SU,
  scrollIntoView: _U,
  selectAll: xU,
  selectNodeBackward: CU,
  selectNodeForward: TU,
  selectParentNode: $U,
  selectTextblockEnd: PU,
  selectTextblockStart: MU,
  setContent: EU,
  setMark: FU,
  setMeta: qU,
  setNode: WU,
  setNodeSelection: XU,
  setTextSelection: zU,
  sinkListItem: jU,
  splitBlock: YU,
  splitListItem: HU,
  toggleList: UU,
  toggleMark: GU,
  toggleNode: KU,
  toggleWrap: JU,
  undoInputRule: e8,
  unsetAllMarks: t8,
  unsetMark: n8,
  updateAttributes: i8,
  wrapIn: r8,
  wrapInList: o8
});
const a8 = yn.create({
  name: "commands",
  addCommands() {
    return {
      ...s8
    };
  }
}), l8 = yn.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new rn({
        key: new _n("tiptapDrop"),
        props: {
          handleDrop: (t, e, n, i) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: n,
              moved: i
            });
          }
        }
      })
    ];
  }
}), u8 = yn.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new rn({
        key: new _n("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), c8 = yn.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new rn({
        key: new _n("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t.isFocused = !0;
              const i = t.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(i), !1;
            },
            blur: (e, n) => {
              t.isFocused = !1;
              const i = t.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(i), !1;
            }
          }
        }
      })
    ];
  }
}), d8 = yn.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t = () => this.editor.commands.first(({ commands: s }) => [
      () => s.undoInputRule(),
      // maybe convert first text block node to default node
      () => s.command(({ tr: a }) => {
        const { selection: l, doc: u } = a, { empty: c, $anchor: d } = l, { pos: h, parent: f } = d, p = d.parent.isTextblock && h > 0 ? a.doc.resolve(h - 1) : d, m = p.parent.type.spec.isolating, g = d.pos - d.parentOffset, O = m && p.parent.childCount === 1 ? g === d.pos : tt.atStart(u).from === h;
        return !c || !f.type.isTextblock || f.textContent.length || !O || O && d.parent.type.name === "paragraph" ? !1 : s.clearNodes();
      }),
      () => s.deleteSelection(),
      () => s.joinBackward(),
      () => s.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: s }) => [
      () => s.deleteSelection(),
      () => s.deleteCurrentNode(),
      () => s.joinForward(),
      () => s.selectNodeForward()
    ]), i = {
      Enter: () => this.editor.commands.first(({ commands: s }) => [
        () => s.newlineInCode(),
        () => s.createParagraphNear(),
        () => s.liftEmptyBlock(),
        () => s.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t,
      "Mod-Backspace": t,
      "Shift-Backspace": t,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, r = {
      ...i
    }, o = {
      ...i,
      "Ctrl-h": t,
      "Alt-Backspace": t,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return Vb() || zP() ? o : r;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new rn({
        key: new _n("clearDocument"),
        appendTransaction: (t, e, n) => {
          const i = t.some((m) => m.docChanged) && !e.doc.eq(n.doc), r = t.some((m) => m.getMeta("preventClearDocument"));
          if (!i || r)
            return;
          const { empty: o, from: s, to: a } = e.selection, l = tt.atStart(e.doc).from, u = tt.atEnd(e.doc).to;
          if (o || !(s === l && a === u) || !vm(n.doc))
            return;
          const h = n.tr, f = hm({
            state: n,
            transaction: h
          }), { commands: p } = new fm({
            editor: this.editor,
            state: f
          });
          if (p.clearNodes(), !!h.steps.length)
            return h;
        }
      })
    ];
  }
}), h8 = yn.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new rn({
        key: new _n("tiptapPaste"),
        props: {
          handlePaste: (t, e, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: n
            });
          }
        }
      })
    ];
  }
}), f8 = yn.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new rn({
        key: new _n("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
class sa {
  get name() {
    return this.node.type.name;
  }
  constructor(e, n, i = !1, r = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = i, this.resolvedPos = e, this.editor = n, this.currentNode = r;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let n = this.from, i = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, i = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: i }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e);
    return new sa(n, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new sa(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new sa(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((n, i) => {
      const r = n.isBlock && !n.isTextblock, o = n.isAtom && !n.isText, s = this.pos + i + (o ? 0 : 1), a = this.resolvedPos.doc.resolve(s);
      if (!r && a.depth <= this.depth)
        return;
      const l = new sa(a, this.editor, r, r ? n : null);
      r && (l.actualDepth = this.depth + 1), e.push(new sa(a, this.editor, r, r ? n : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, n = {}) {
    let i = null, r = this.parent;
    for (; r && !i; ) {
      if (r.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const o = r.node.attrs, s = Object.keys(n);
          for (let a = 0; a < s.length; a += 1) {
            const l = s[a];
            if (o[l] !== n[l])
              break;
          }
        } else
          i = r;
      r = r.parent;
    }
    return i;
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null;
  }
  querySelectorAll(e, n = {}, i = !1) {
    let r = [];
    if (!this.children || this.children.length === 0)
      return r;
    const o = Object.keys(n);
    return this.children.forEach((s) => {
      i && r.length > 0 || (s.node.type.name === e && o.every((l) => n[l] === s.node.attrs[l]) && r.push(s), !(i && r.length > 0) && (r = r.concat(s.querySelectorAll(e, n, i))));
    }), r;
  }
  setAttribute(e) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(n);
  }
}
const p8 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function m8(t, e, n) {
  const i = document.querySelector(`style[data-tiptap-style${n ? `-${n}` : ""}]`);
  if (i !== null)
    return i;
  const r = document.createElement("style");
  return e && r.setAttribute("nonce", e), r.setAttribute(`data-tiptap-style${n ? `-${n}` : ""}`, ""), r.innerHTML = t, document.getElementsByTagName("head")[0].appendChild(r), r;
}
let g8 = class extends TH {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: n }) => {
        throw n;
      },
      onPaste: () => null,
      onDrop: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: n, slice: i, moved: r }) => this.options.onDrop(n, i, r)), this.on("paste", ({ event: n, slice: i }) => this.options.onPaste(n, i)), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = m8(p8, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, n = !0) {
    this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, n) {
    const i = BP(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], r = this.state.reconfigure({ plugins: i });
    return this.view.updateState(r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const n = this.state.plugins;
    let i = n;
    if ([].concat(e).forEach((o) => {
      const s = typeof o == "string" ? `${o}$` : o.key;
      i = n.filter((a) => !a.key.startsWith(s));
    }), n.length === i.length)
      return;
    const r = this.state.reconfigure({
      plugins: i
    });
    return this.view.updateState(r), r;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, n;
    const r = [...this.options.enableCoreExtensions ? [
      u8,
      FH.configure({
        blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
      }),
      a8,
      c8,
      d8,
      f8,
      l8,
      h8
    ].filter((o) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[o.name] !== !1 : !0) : [], ...this.options.extensions].filter((o) => ["extension", "node", "mark"].includes(o == null ? void 0 : o.type));
    this.extensionManager = new gl(r, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new fm({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var e;
    let n;
    try {
      n = sv(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (s) {
      if (!(s instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(s.message))
        throw s;
      this.emit("contentError", {
        editor: this,
        error: s,
        disableCollaboration: () => {
          this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((a) => a.name !== "collaboration"), this.createExtensionManager();
        }
      }), n = sv(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 });
    }
    const i = WP(n, this.options.autofocus);
    this.view = new zY(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: f4.create({
        doc: n,
        selection: i || void 0
      })
    });
    const r = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(r), this.createNodeViews(), this.prependClass();
    const o = this.view.dom;
    o.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const n = this.capturedTransaction;
    return this.capturedTransaction = null, n;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((s) => {
        var a;
        return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(s);
      });
      return;
    }
    const n = this.state.apply(e), i = !this.state.selection.eq(n.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: n
    }), this.view.updateState(n), this.emit("transaction", {
      editor: this,
      transaction: e
    }), i && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const r = e.getMeta("focus"), o = e.getMeta("blur");
    r && this.emit("focus", {
      editor: this,
      event: r.event,
      transaction: e
    }), o && this.emit("blur", {
      editor: this,
      event: o.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return YP(this.state, e);
  }
  isActive(e, n) {
    const i = typeof e == "string" ? e : null, r = typeof e == "string" ? n : e;
    return BU(this.state, i, r);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return Qb(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: n = `

`, textSerializers: i = {} } = e || {};
    return QU(this.state.doc, {
      blockSeparator: n,
      textSerializers: {
        ...FP(this.schema),
        ...i
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return vm(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    if (this.emit("destroy"), this.view) {
      const e = this.view.dom;
      e && e.editor && delete e.editor, this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, n) {
    var i;
    return ((i = this.$doc) === null || i === void 0 ? void 0 : i.querySelector(e, n)) || null;
  }
  $nodes(e, n) {
    var i;
    return ((i = this.$doc) === null || i === void 0 ? void 0 : i.querySelectorAll(e, n)) || null;
  }
  $pos(e) {
    const n = this.state.doc.resolve(e);
    return new sa(n, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function Hl(t) {
  return new mm({
    find: t.find,
    handler: ({ state: e, range: n, match: i }) => {
      const r = ct(t.getAttributes, void 0, i);
      if (r === !1 || r === null)
        return null;
      const { tr: o } = e, s = i[i.length - 1], a = i[0];
      if (s) {
        const l = a.search(/\S/), u = n.from + a.indexOf(s), c = u + s.length;
        if (Fb(n.from, n.to, e.doc).filter((f) => f.mark.type.excluded.find((m) => m === t.type && m !== f.mark.type)).filter((f) => f.to > u).length)
          return null;
        c < n.to && o.delete(c, n.to), u > n.from && o.delete(n.from + l, u);
        const h = n.from + l + s.length;
        o.addMark(n.from + l, h, t.type.create(r || {})), o.removeStoredMark(t.type);
      }
    }
  });
}
function O8(t) {
  return new mm({
    find: t.find,
    handler: ({ state: e, range: n, match: i }) => {
      const r = ct(t.getAttributes, void 0, i) || {}, { tr: o } = e, s = n.from;
      let a = n.to;
      const l = t.type.create(r);
      if (i[1]) {
        const u = i[0].lastIndexOf(i[1]);
        let c = s + u;
        c > a ? c = a : a = c + i[1].length;
        const d = i[0][i[0].length - 1];
        o.insertText(d, s + i[0].length - 1), o.replaceWith(c, a, l);
      } else if (i[0]) {
        const u = t.type.isInline ? s : s - 1;
        o.insert(u, t.type.create(r)).delete(o.mapping.map(s), o.mapping.map(a));
      }
      o.scrollIntoView();
    }
  });
}
function lv(t) {
  return new mm({
    find: t.find,
    handler: ({ state: e, range: n, match: i }) => {
      const r = e.doc.resolve(n.from), o = ct(t.getAttributes, void 0, i) || {};
      if (!r.node(-1).canReplaceWith(r.index(-1), r.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, o);
    }
  });
}
function Yc(t) {
  return new mm({
    find: t.find,
    handler: ({ state: e, range: n, match: i, chain: r }) => {
      const o = ct(t.getAttributes, void 0, i) || {}, s = e.tr.delete(n.from, n.to), l = s.doc.resolve(n.from).blockRange(), u = l && kb(l, t.type, o);
      if (!u)
        return null;
      if (s.wrap(l, u), t.keepMarks && t.editor) {
        const { selection: d, storedMarks: h } = e, { splittableMarks: f } = t.editor.extensionManager, p = h || d.$to.parentOffset && d.$from.marks();
        if (p) {
          const m = p.filter((g) => f.includes(g.type.name));
          s.ensureMarks(m);
        }
      }
      if (t.keepAttributes) {
        const d = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
        r().updateAttributes(d, o).run();
      }
      const c = s.doc.resolve(n.from - 1).nodeBefore;
      c && c.type === t.type && zs(s.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(i, c)) && s.join(n.from - 1);
    }
  });
}
let mi = class uv {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = ct(Xe(this, "addOptions", {
      name: this.name
    }))), this.storage = ct(Xe(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new uv(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => gm(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new uv(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = ct(Xe(n, "addOptions", {
      name: n.name
    })), n.storage = ct(Xe(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
};
function Ia(t) {
  return new NH({
    find: t.find,
    handler: ({ state: e, range: n, match: i, pasteEvent: r }) => {
      const o = ct(t.getAttributes, void 0, i, r);
      if (o === !1 || o === null)
        return null;
      const { tr: s } = e, a = i[i.length - 1], l = i[0];
      let u = n.to;
      if (a) {
        const c = l.search(/\S/), d = n.from + l.indexOf(a), h = d + a.length;
        if (Fb(n.from, n.to, e.doc).filter((p) => p.mark.type.excluded.find((g) => g === t.type && g !== p.mark.type)).filter((p) => p.to > d).length)
          return null;
        h < n.to && s.delete(h, n.to), d > n.from && s.delete(n.from + c, d), u = n.from + c + a.length, s.addMark(n.from + c, u, t.type.create(o || {})), s.removeStoredMark(t.type);
      }
    }
  });
}
var Ti = "top", rr = "bottom", or = "right", $i = "left", qb = "auto", Ed = [Ti, rr, or, $i], Ul = "start", Hc = "end", v8 = "clippingParents", GP = "viewport", Qu = "popper", y8 = "reference", A1 = /* @__PURE__ */ Ed.reduce(function(t, e) {
  return t.concat([e + "-" + Ul, e + "-" + Hc]);
}, []), KP = /* @__PURE__ */ [].concat(Ed, [qb]).reduce(function(t, e) {
  return t.concat([e, e + "-" + Ul, e + "-" + Hc]);
}, []), b8 = "beforeRead", w8 = "read", k8 = "afterRead", S8 = "beforeMain", _8 = "main", x8 = "afterMain", C8 = "beforeWrite", T8 = "write", $8 = "afterWrite", P8 = [b8, w8, k8, S8, _8, x8, C8, T8, $8];
function co(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function Fi(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function La(t) {
  var e = Fi(t).Element;
  return t instanceof e || t instanceof Element;
}
function tr(t) {
  var e = Fi(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function Wb(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = Fi(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function M8(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var i = e.styles[n] || {}, r = e.attributes[n] || {}, o = e.elements[n];
    !tr(o) || !co(o) || (Object.assign(o.style, i), Object.keys(r).forEach(function(s) {
      var a = r[s];
      a === !1 ? o.removeAttribute(s) : o.setAttribute(s, a === !0 ? "" : a);
    }));
  });
}
function E8(t) {
  var e = t.state, n = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(i) {
      var r = e.elements[i], o = e.attributes[i] || {}, s = Object.keys(e.styles.hasOwnProperty(i) ? e.styles[i] : n[i]), a = s.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !tr(r) || !co(r) || (Object.assign(r.style, a), Object.keys(o).forEach(function(l) {
        r.removeAttribute(l);
      }));
    });
  };
}
const JP = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: M8,
  effect: E8,
  requires: ["computeStyles"]
};
function io(t) {
  return t.split("-")[0];
}
var Sa = Math.max, Ef = Math.min, Gl = Math.round;
function cv() {
  var t = navigator.userAgentData;
  return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function eM() {
  return !/^((?!chrome|android).)*safari/i.test(cv());
}
function Kl(t, e, n) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  var i = t.getBoundingClientRect(), r = 1, o = 1;
  e && tr(t) && (r = t.offsetWidth > 0 && Gl(i.width) / t.offsetWidth || 1, o = t.offsetHeight > 0 && Gl(i.height) / t.offsetHeight || 1);
  var s = La(t) ? Fi(t) : window, a = s.visualViewport, l = !eM() && n, u = (i.left + (l && a ? a.offsetLeft : 0)) / r, c = (i.top + (l && a ? a.offsetTop : 0)) / o, d = i.width / r, h = i.height / o;
  return {
    width: d,
    height: h,
    top: c,
    right: u + d,
    bottom: c + h,
    left: u,
    x: u,
    y: c
  };
}
function Xb(t) {
  var e = Kl(t), n = t.offsetWidth, i = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - i) <= 1 && (i = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: n,
    height: i
  };
}
function tM(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && Wb(n)) {
    var i = e;
    do {
      if (i && t.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function qo(t) {
  return Fi(t).getComputedStyle(t);
}
function A8(t) {
  return ["table", "td", "th"].indexOf(co(t)) >= 0;
}
function Hs(t) {
  return ((La(t) ? t.ownerDocument : (
    // $FlowFixMe[prop-missing]
    t.document
  )) || window.document).documentElement;
}
function ym(t) {
  return co(t) === "html" ? t : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    t.parentNode || // DOM Element detected
    (Wb(t) ? t.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Hs(t)
  );
}
function R1(t) {
  return !tr(t) || // https://github.com/popperjs/popper-core/issues/837
  qo(t).position === "fixed" ? null : t.offsetParent;
}
function R8(t) {
  var e = /firefox/i.test(cv()), n = /Trident/i.test(cv());
  if (n && tr(t)) {
    var i = qo(t);
    if (i.position === "fixed")
      return null;
  }
  var r = ym(t);
  for (Wb(r) && (r = r.host); tr(r) && ["html", "body"].indexOf(co(r)) < 0; ) {
    var o = qo(r);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || e && o.willChange === "filter" || e && o.filter && o.filter !== "none")
      return r;
    r = r.parentNode;
  }
  return null;
}
function Ad(t) {
  for (var e = Fi(t), n = R1(t); n && A8(n) && qo(n).position === "static"; )
    n = R1(n);
  return n && (co(n) === "html" || co(n) === "body" && qo(n).position === "static") ? e : n || R8(t) || e;
}
function zb(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function gc(t, e, n) {
  return Sa(t, Ef(e, n));
}
function D8(t, e, n) {
  var i = gc(t, e, n);
  return i > n ? n : i;
}
function nM() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function iM(t) {
  return Object.assign({}, nM(), t);
}
function rM(t, e) {
  return e.reduce(function(n, i) {
    return n[i] = t, n;
  }, {});
}
var Q8 = function(e, n) {
  return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
    placement: n.placement
  })) : e, iM(typeof e != "number" ? e : rM(e, Ed));
};
function N8(t) {
  var e, n = t.state, i = t.name, r = t.options, o = n.elements.arrow, s = n.modifiersData.popperOffsets, a = io(n.placement), l = zb(a), u = [$i, or].indexOf(a) >= 0, c = u ? "height" : "width";
  if (!(!o || !s)) {
    var d = Q8(r.padding, n), h = Xb(o), f = l === "y" ? Ti : $i, p = l === "y" ? rr : or, m = n.rects.reference[c] + n.rects.reference[l] - s[l] - n.rects.popper[c], g = s[l] - n.rects.reference[l], O = Ad(o), y = O ? l === "y" ? O.clientHeight || 0 : O.clientWidth || 0 : 0, b = m / 2 - g / 2, v = d[f], k = y - h[c] - d[p], w = y / 2 - h[c] / 2 + b, S = gc(v, w, k), $ = l;
    n.modifiersData[i] = (e = {}, e[$] = S, e.centerOffset = S - w, e);
  }
}
function I8(t) {
  var e = t.state, n = t.options, i = n.element, r = i === void 0 ? "[data-popper-arrow]" : i;
  r != null && (typeof r == "string" && (r = e.elements.popper.querySelector(r), !r) || tM(e.elements.popper, r) && (e.elements.arrow = r));
}
const L8 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: N8,
  effect: I8,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Jl(t) {
  return t.split("-")[1];
}
var V8 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function B8(t, e) {
  var n = t.x, i = t.y, r = e.devicePixelRatio || 1;
  return {
    x: Gl(n * r) / r || 0,
    y: Gl(i * r) / r || 0
  };
}
function D1(t) {
  var e, n = t.popper, i = t.popperRect, r = t.placement, o = t.variation, s = t.offsets, a = t.position, l = t.gpuAcceleration, u = t.adaptive, c = t.roundOffsets, d = t.isFixed, h = s.x, f = h === void 0 ? 0 : h, p = s.y, m = p === void 0 ? 0 : p, g = typeof c == "function" ? c({
    x: f,
    y: m
  }) : {
    x: f,
    y: m
  };
  f = g.x, m = g.y;
  var O = s.hasOwnProperty("x"), y = s.hasOwnProperty("y"), b = $i, v = Ti, k = window;
  if (u) {
    var w = Ad(n), S = "clientHeight", $ = "clientWidth";
    if (w === Fi(n) && (w = Hs(n), qo(w).position !== "static" && a === "absolute" && (S = "scrollHeight", $ = "scrollWidth")), w = w, r === Ti || (r === $i || r === or) && o === Hc) {
      v = rr;
      var C = d && w === k && k.visualViewport ? k.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        w[S]
      );
      m -= C - i.height, m *= l ? 1 : -1;
    }
    if (r === $i || (r === Ti || r === rr) && o === Hc) {
      b = or;
      var L = d && w === k && k.visualViewport ? k.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        w[$]
      );
      f -= L - i.width, f *= l ? 1 : -1;
    }
  }
  var j = Object.assign({
    position: a
  }, u && V8), P = c === !0 ? B8({
    x: f,
    y: m
  }, Fi(n)) : {
    x: f,
    y: m
  };
  if (f = P.x, m = P.y, l) {
    var A;
    return Object.assign({}, j, (A = {}, A[v] = y ? "0" : "", A[b] = O ? "0" : "", A.transform = (k.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", A));
  }
  return Object.assign({}, j, (e = {}, e[v] = y ? m + "px" : "", e[b] = O ? f + "px" : "", e.transform = "", e));
}
function Z8(t) {
  var e = t.state, n = t.options, i = n.gpuAcceleration, r = i === void 0 ? !0 : i, o = n.adaptive, s = o === void 0 ? !0 : o, a = n.roundOffsets, l = a === void 0 ? !0 : a, u = {
    placement: io(e.placement),
    variation: Jl(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: r,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, D1(Object.assign({}, u, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: s,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, D1(Object.assign({}, u, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const F8 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Z8,
  data: {}
};
var Jd = {
  passive: !0
};
function q8(t) {
  var e = t.state, n = t.instance, i = t.options, r = i.scroll, o = r === void 0 ? !0 : r, s = i.resize, a = s === void 0 ? !0 : s, l = Fi(e.elements.popper), u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return o && u.forEach(function(c) {
    c.addEventListener("scroll", n.update, Jd);
  }), a && l.addEventListener("resize", n.update, Jd), function() {
    o && u.forEach(function(c) {
      c.removeEventListener("scroll", n.update, Jd);
    }), a && l.removeEventListener("resize", n.update, Jd);
  };
}
const W8 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: q8,
  data: {}
};
var X8 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Nh(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return X8[e];
  });
}
var z8 = {
  start: "end",
  end: "start"
};
function Q1(t) {
  return t.replace(/start|end/g, function(e) {
    return z8[e];
  });
}
function jb(t) {
  var e = Fi(t), n = e.pageXOffset, i = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: i
  };
}
function Yb(t) {
  return Kl(Hs(t)).left + jb(t).scrollLeft;
}
function j8(t, e) {
  var n = Fi(t), i = Hs(t), r = n.visualViewport, o = i.clientWidth, s = i.clientHeight, a = 0, l = 0;
  if (r) {
    o = r.width, s = r.height;
    var u = eM();
    (u || !u && e === "fixed") && (a = r.offsetLeft, l = r.offsetTop);
  }
  return {
    width: o,
    height: s,
    x: a + Yb(t),
    y: l
  };
}
function Y8(t) {
  var e, n = Hs(t), i = jb(t), r = (e = t.ownerDocument) == null ? void 0 : e.body, o = Sa(n.scrollWidth, n.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), s = Sa(n.scrollHeight, n.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), a = -i.scrollLeft + Yb(t), l = -i.scrollTop;
  return qo(r || n).direction === "rtl" && (a += Sa(n.clientWidth, r ? r.clientWidth : 0) - o), {
    width: o,
    height: s,
    x: a,
    y: l
  };
}
function Hb(t) {
  var e = qo(t), n = e.overflow, i = e.overflowX, r = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + r + i);
}
function oM(t) {
  return ["html", "body", "#document"].indexOf(co(t)) >= 0 ? t.ownerDocument.body : tr(t) && Hb(t) ? t : oM(ym(t));
}
function Oc(t, e) {
  var n;
  e === void 0 && (e = []);
  var i = oM(t), r = i === ((n = t.ownerDocument) == null ? void 0 : n.body), o = Fi(i), s = r ? [o].concat(o.visualViewport || [], Hb(i) ? i : []) : i, a = e.concat(s);
  return r ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Oc(ym(s)))
  );
}
function dv(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function H8(t, e) {
  var n = Kl(t, !1, e === "fixed");
  return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n;
}
function N1(t, e, n) {
  return e === GP ? dv(j8(t, n)) : La(e) ? H8(e, n) : dv(Y8(Hs(t)));
}
function U8(t) {
  var e = Oc(ym(t)), n = ["absolute", "fixed"].indexOf(qo(t).position) >= 0, i = n && tr(t) ? Ad(t) : t;
  return La(i) ? e.filter(function(r) {
    return La(r) && tM(r, i) && co(r) !== "body";
  }) : [];
}
function G8(t, e, n, i) {
  var r = e === "clippingParents" ? U8(t) : [].concat(e), o = [].concat(r, [n]), s = o[0], a = o.reduce(function(l, u) {
    var c = N1(t, u, i);
    return l.top = Sa(c.top, l.top), l.right = Ef(c.right, l.right), l.bottom = Ef(c.bottom, l.bottom), l.left = Sa(c.left, l.left), l;
  }, N1(t, s, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function sM(t) {
  var e = t.reference, n = t.element, i = t.placement, r = i ? io(i) : null, o = i ? Jl(i) : null, s = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
  switch (r) {
    case Ti:
      l = {
        x: s,
        y: e.y - n.height
      };
      break;
    case rr:
      l = {
        x: s,
        y: e.y + e.height
      };
      break;
    case or:
      l = {
        x: e.x + e.width,
        y: a
      };
      break;
    case $i:
      l = {
        x: e.x - n.width,
        y: a
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var u = r ? zb(r) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (o) {
      case Ul:
        l[u] = l[u] - (e[c] / 2 - n[c] / 2);
        break;
      case Hc:
        l[u] = l[u] + (e[c] / 2 - n[c] / 2);
        break;
    }
  }
  return l;
}
function Uc(t, e) {
  e === void 0 && (e = {});
  var n = e, i = n.placement, r = i === void 0 ? t.placement : i, o = n.strategy, s = o === void 0 ? t.strategy : o, a = n.boundary, l = a === void 0 ? v8 : a, u = n.rootBoundary, c = u === void 0 ? GP : u, d = n.elementContext, h = d === void 0 ? Qu : d, f = n.altBoundary, p = f === void 0 ? !1 : f, m = n.padding, g = m === void 0 ? 0 : m, O = iM(typeof g != "number" ? g : rM(g, Ed)), y = h === Qu ? y8 : Qu, b = t.rects.popper, v = t.elements[p ? y : h], k = G8(La(v) ? v : v.contextElement || Hs(t.elements.popper), l, c, s), w = Kl(t.elements.reference), S = sM({
    reference: w,
    element: b,
    strategy: "absolute",
    placement: r
  }), $ = dv(Object.assign({}, b, S)), C = h === Qu ? $ : w, L = {
    top: k.top - C.top + O.top,
    bottom: C.bottom - k.bottom + O.bottom,
    left: k.left - C.left + O.left,
    right: C.right - k.right + O.right
  }, j = t.modifiersData.offset;
  if (h === Qu && j) {
    var P = j[r];
    Object.keys(L).forEach(function(A) {
      var T = [or, rr].indexOf(A) >= 0 ? 1 : -1, N = [Ti, rr].indexOf(A) >= 0 ? "y" : "x";
      L[A] += P[N] * T;
    });
  }
  return L;
}
function K8(t, e) {
  e === void 0 && (e = {});
  var n = e, i = n.placement, r = n.boundary, o = n.rootBoundary, s = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, u = l === void 0 ? KP : l, c = Jl(i), d = c ? a ? A1 : A1.filter(function(p) {
    return Jl(p) === c;
  }) : Ed, h = d.filter(function(p) {
    return u.indexOf(p) >= 0;
  });
  h.length === 0 && (h = d);
  var f = h.reduce(function(p, m) {
    return p[m] = Uc(t, {
      placement: m,
      boundary: r,
      rootBoundary: o,
      padding: s
    })[io(m)], p;
  }, {});
  return Object.keys(f).sort(function(p, m) {
    return f[p] - f[m];
  });
}
function J8(t) {
  if (io(t) === qb)
    return [];
  var e = Nh(t);
  return [Q1(t), e, Q1(e)];
}
function e7(t) {
  var e = t.state, n = t.options, i = t.name;
  if (!e.modifiersData[i]._skip) {
    for (var r = n.mainAxis, o = r === void 0 ? !0 : r, s = n.altAxis, a = s === void 0 ? !0 : s, l = n.fallbackPlacements, u = n.padding, c = n.boundary, d = n.rootBoundary, h = n.altBoundary, f = n.flipVariations, p = f === void 0 ? !0 : f, m = n.allowedAutoPlacements, g = e.options.placement, O = io(g), y = O === g, b = l || (y || !p ? [Nh(g)] : J8(g)), v = [g].concat(b).reduce(function(M, G) {
      return M.concat(io(G) === qb ? K8(e, {
        placement: G,
        boundary: c,
        rootBoundary: d,
        padding: u,
        flipVariations: p,
        allowedAutoPlacements: m
      }) : G);
    }, []), k = e.rects.reference, w = e.rects.popper, S = /* @__PURE__ */ new Map(), $ = !0, C = v[0], L = 0; L < v.length; L++) {
      var j = v[L], P = io(j), A = Jl(j) === Ul, T = [Ti, rr].indexOf(P) >= 0, N = T ? "width" : "height", Q = Uc(e, {
        placement: j,
        boundary: c,
        rootBoundary: d,
        altBoundary: h,
        padding: u
      }), Y = T ? A ? or : $i : A ? rr : Ti;
      k[N] > w[N] && (Y = Nh(Y));
      var V = Nh(Y), q = [];
      if (o && q.push(Q[P] <= 0), a && q.push(Q[Y] <= 0, Q[V] <= 0), q.every(function(M) {
        return M;
      })) {
        C = j, $ = !1;
        break;
      }
      S.set(j, q);
    }
    if ($)
      for (var B = p ? 3 : 1, pe = function(G) {
        var ce = v.find(function(F) {
          var xe = S.get(F);
          if (xe)
            return xe.slice(0, G).every(function(Be) {
              return Be;
            });
        });
        if (ce)
          return C = ce, "break";
      }, oe = B; oe > 0; oe--) {
        var te = pe(oe);
        if (te === "break")
          break;
      }
    e.placement !== C && (e.modifiersData[i]._skip = !0, e.placement = C, e.reset = !0);
  }
}
const t7 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: e7,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function I1(t, e, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: t.top - e.height - n.y,
    right: t.right - e.width + n.x,
    bottom: t.bottom - e.height + n.y,
    left: t.left - e.width - n.x
  };
}
function L1(t) {
  return [Ti, or, rr, $i].some(function(e) {
    return t[e] >= 0;
  });
}
function n7(t) {
  var e = t.state, n = t.name, i = e.rects.reference, r = e.rects.popper, o = e.modifiersData.preventOverflow, s = Uc(e, {
    elementContext: "reference"
  }), a = Uc(e, {
    altBoundary: !0
  }), l = I1(s, i), u = I1(a, r, o), c = L1(l), d = L1(u);
  e.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: u,
    isReferenceHidden: c,
    hasPopperEscaped: d
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": c,
    "data-popper-escaped": d
  });
}
const i7 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: n7
};
function r7(t, e, n) {
  var i = io(t), r = [$i, Ti].indexOf(i) >= 0 ? -1 : 1, o = typeof n == "function" ? n(Object.assign({}, e, {
    placement: t
  })) : n, s = o[0], a = o[1];
  return s = s || 0, a = (a || 0) * r, [$i, or].indexOf(i) >= 0 ? {
    x: a,
    y: s
  } : {
    x: s,
    y: a
  };
}
function o7(t) {
  var e = t.state, n = t.options, i = t.name, r = n.offset, o = r === void 0 ? [0, 0] : r, s = KP.reduce(function(c, d) {
    return c[d] = r7(d, e.rects, o), c;
  }, {}), a = s[e.placement], l = a.x, u = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += u), e.modifiersData[i] = s;
}
const s7 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: o7
};
function a7(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = sM({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}
const l7 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: a7,
  data: {}
};
function u7(t) {
  return t === "x" ? "y" : "x";
}
function c7(t) {
  var e = t.state, n = t.options, i = t.name, r = n.mainAxis, o = r === void 0 ? !0 : r, s = n.altAxis, a = s === void 0 ? !1 : s, l = n.boundary, u = n.rootBoundary, c = n.altBoundary, d = n.padding, h = n.tether, f = h === void 0 ? !0 : h, p = n.tetherOffset, m = p === void 0 ? 0 : p, g = Uc(e, {
    boundary: l,
    rootBoundary: u,
    padding: d,
    altBoundary: c
  }), O = io(e.placement), y = Jl(e.placement), b = !y, v = zb(O), k = u7(v), w = e.modifiersData.popperOffsets, S = e.rects.reference, $ = e.rects.popper, C = typeof m == "function" ? m(Object.assign({}, e.rects, {
    placement: e.placement
  })) : m, L = typeof C == "number" ? {
    mainAxis: C,
    altAxis: C
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, C), j = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, P = {
    x: 0,
    y: 0
  };
  if (w) {
    if (o) {
      var A, T = v === "y" ? Ti : $i, N = v === "y" ? rr : or, Q = v === "y" ? "height" : "width", Y = w[v], V = Y + g[T], q = Y - g[N], B = f ? -$[Q] / 2 : 0, pe = y === Ul ? S[Q] : $[Q], oe = y === Ul ? -$[Q] : -S[Q], te = e.elements.arrow, M = f && te ? Xb(te) : {
        width: 0,
        height: 0
      }, G = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : nM(), ce = G[T], F = G[N], xe = gc(0, S[Q], M[Q]), Be = b ? S[Q] / 2 - B - xe - ce - L.mainAxis : pe - xe - ce - L.mainAxis, lt = b ? -S[Q] / 2 + B + xe + F + L.mainAxis : oe + xe + F + L.mainAxis, de = e.elements.arrow && Ad(e.elements.arrow), ye = de ? v === "y" ? de.clientTop || 0 : de.clientLeft || 0 : 0, me = (A = j == null ? void 0 : j[v]) != null ? A : 0, ie = Y + Be - me - ye, I = Y + lt - me, ge = gc(f ? Ef(V, ie) : V, Y, f ? Sa(q, I) : q);
      w[v] = ge, P[v] = ge - Y;
    }
    if (a) {
      var ze, Se = v === "x" ? Ti : $i, st = v === "x" ? rr : or, D = w[k], x = k === "y" ? "height" : "width", U = D + g[Se], K = D - g[st], ke = [Ti, $i].indexOf(O) !== -1, Ve = (ze = j == null ? void 0 : j[k]) != null ? ze : 0, be = ke ? U : D - S[x] - $[x] - Ve + L.altAxis, se = ke ? D + S[x] + $[x] - Ve - L.altAxis : K, Oe = f && ke ? D8(be, D, se) : gc(f ? be : U, D, f ? se : K);
      w[k] = Oe, P[k] = Oe - D;
    }
    e.modifiersData[i] = P;
  }
}
const d7 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: c7,
  requiresIfExists: ["offset"]
};
function h7(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}
function f7(t) {
  return t === Fi(t) || !tr(t) ? jb(t) : h7(t);
}
function p7(t) {
  var e = t.getBoundingClientRect(), n = Gl(e.width) / t.offsetWidth || 1, i = Gl(e.height) / t.offsetHeight || 1;
  return n !== 1 || i !== 1;
}
function m7(t, e, n) {
  n === void 0 && (n = !1);
  var i = tr(e), r = tr(e) && p7(e), o = Hs(e), s = Kl(t, r, n), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !n) && ((co(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Hb(o)) && (a = f7(e)), tr(e) ? (l = Kl(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : o && (l.x = Yb(o))), {
    x: s.left + a.scrollLeft - l.x,
    y: s.top + a.scrollTop - l.y,
    width: s.width,
    height: s.height
  };
}
function g7(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), i = [];
  t.forEach(function(o) {
    e.set(o.name, o);
  });
  function r(o) {
    n.add(o.name);
    var s = [].concat(o.requires || [], o.requiresIfExists || []);
    s.forEach(function(a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && r(l);
      }
    }), i.push(o);
  }
  return t.forEach(function(o) {
    n.has(o.name) || r(o);
  }), i;
}
function O7(t) {
  var e = g7(t);
  return P8.reduce(function(n, i) {
    return n.concat(e.filter(function(r) {
      return r.phase === i;
    }));
  }, []);
}
function v7(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function y7(t) {
  var e = t.reduce(function(n, i) {
    var r = n[i.name];
    return n[i.name] = r ? Object.assign({}, r, i, {
      options: Object.assign({}, r.options, i.options),
      data: Object.assign({}, r.data, i.data)
    }) : i, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var V1 = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function B1() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function b7(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, i = n === void 0 ? [] : n, r = e.defaultOptions, o = r === void 0 ? V1 : r;
  return function(a, l, u) {
    u === void 0 && (u = o);
    var c = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, V1, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, d = [], h = !1, f = {
      state: c,
      setOptions: function(O) {
        var y = typeof O == "function" ? O(c.options) : O;
        m(), c.options = Object.assign({}, o, c.options, y), c.scrollParents = {
          reference: La(a) ? Oc(a) : a.contextElement ? Oc(a.contextElement) : [],
          popper: Oc(l)
        };
        var b = O7(y7([].concat(i, c.options.modifiers)));
        return c.orderedModifiers = b.filter(function(v) {
          return v.enabled;
        }), p(), f.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!h) {
          var O = c.elements, y = O.reference, b = O.popper;
          if (B1(y, b)) {
            c.rects = {
              reference: m7(y, Ad(b), c.options.strategy === "fixed"),
              popper: Xb(b)
            }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(L) {
              return c.modifiersData[L.name] = Object.assign({}, L.data);
            });
            for (var v = 0; v < c.orderedModifiers.length; v++) {
              if (c.reset === !0) {
                c.reset = !1, v = -1;
                continue;
              }
              var k = c.orderedModifiers[v], w = k.fn, S = k.options, $ = S === void 0 ? {} : S, C = k.name;
              typeof w == "function" && (c = w({
                state: c,
                options: $,
                name: C,
                instance: f
              }) || c);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: v7(function() {
        return new Promise(function(g) {
          f.forceUpdate(), g(c);
        });
      }),
      destroy: function() {
        m(), h = !0;
      }
    };
    if (!B1(a, l))
      return f;
    f.setOptions(u).then(function(g) {
      !h && u.onFirstUpdate && u.onFirstUpdate(g);
    });
    function p() {
      c.orderedModifiers.forEach(function(g) {
        var O = g.name, y = g.options, b = y === void 0 ? {} : y, v = g.effect;
        if (typeof v == "function") {
          var k = v({
            state: c,
            name: O,
            instance: f,
            options: b
          }), w = function() {
          };
          d.push(k || w);
        }
      });
    }
    function m() {
      d.forEach(function(g) {
        return g();
      }), d = [];
    }
    return f;
  };
}
var w7 = [W8, l7, F8, JP, s7, t7, d7, L8, i7], k7 = /* @__PURE__ */ b7({
  defaultModifiers: w7
}), S7 = "tippy-box", aM = "tippy-content", _7 = "tippy-backdrop", lM = "tippy-arrow", uM = "tippy-svg-arrow", ia = {
  passive: !0,
  capture: !0
}, cM = function() {
  return document.body;
};
function x7(t, e) {
  return {}.hasOwnProperty.call(t, e);
}
function xg(t, e, n) {
  if (Array.isArray(t)) {
    var i = t[e];
    return i ?? (Array.isArray(n) ? n[e] : n);
  }
  return t;
}
function Ub(t, e) {
  var n = {}.toString.call(t);
  return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
}
function dM(t, e) {
  return typeof t == "function" ? t.apply(void 0, e) : t;
}
function Z1(t, e) {
  if (e === 0)
    return t;
  var n;
  return function(i) {
    clearTimeout(n), n = setTimeout(function() {
      t(i);
    }, e);
  };
}
function C7(t, e) {
  var n = Object.assign({}, t);
  return e.forEach(function(i) {
    delete n[i];
  }), n;
}
function T7(t) {
  return t.split(/\s+/).filter(Boolean);
}
function cl(t) {
  return [].concat(t);
}
function F1(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function $7(t) {
  return t.filter(function(e, n) {
    return t.indexOf(e) === n;
  });
}
function P7(t) {
  return t.split("-")[0];
}
function Af(t) {
  return [].slice.call(t);
}
function q1(t) {
  return Object.keys(t).reduce(function(e, n) {
    return t[n] !== void 0 && (e[n] = t[n]), e;
  }, {});
}
function vc() {
  return document.createElement("div");
}
function Gc(t) {
  return ["Element", "Fragment"].some(function(e) {
    return Ub(t, e);
  });
}
function M7(t) {
  return Ub(t, "NodeList");
}
function E7(t) {
  return Ub(t, "MouseEvent");
}
function A7(t) {
  return !!(t && t._tippy && t._tippy.reference === t);
}
function R7(t) {
  return Gc(t) ? [t] : M7(t) ? Af(t) : Array.isArray(t) ? t : Af(document.querySelectorAll(t));
}
function Cg(t, e) {
  t.forEach(function(n) {
    n && (n.style.transitionDuration = e + "ms");
  });
}
function W1(t, e) {
  t.forEach(function(n) {
    n && n.setAttribute("data-state", e);
  });
}
function D7(t) {
  var e, n = cl(t), i = n[0];
  return i != null && (e = i.ownerDocument) != null && e.body ? i.ownerDocument : document;
}
function Q7(t, e) {
  var n = e.clientX, i = e.clientY;
  return t.every(function(r) {
    var o = r.popperRect, s = r.popperState, a = r.props, l = a.interactiveBorder, u = P7(s.placement), c = s.modifiersData.offset;
    if (!c)
      return !0;
    var d = u === "bottom" ? c.top.y : 0, h = u === "top" ? c.bottom.y : 0, f = u === "right" ? c.left.x : 0, p = u === "left" ? c.right.x : 0, m = o.top - i + d > l, g = i - o.bottom - h > l, O = o.left - n + f > l, y = n - o.right - p > l;
    return m || g || O || y;
  });
}
function Tg(t, e, n) {
  var i = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(r) {
    t[i](r, n);
  });
}
function X1(t, e) {
  for (var n = e; n; ) {
    var i;
    if (t.contains(n))
      return !0;
    n = n.getRootNode == null || (i = n.getRootNode()) == null ? void 0 : i.host;
  }
  return !1;
}
var Fr = {
  isTouch: !1
}, z1 = 0;
function N7() {
  Fr.isTouch || (Fr.isTouch = !0, window.performance && document.addEventListener("mousemove", hM));
}
function hM() {
  var t = performance.now();
  t - z1 < 20 && (Fr.isTouch = !1, document.removeEventListener("mousemove", hM)), z1 = t;
}
function I7() {
  var t = document.activeElement;
  if (A7(t)) {
    var e = t._tippy;
    t.blur && !e.state.isVisible && t.blur();
  }
}
function L7() {
  document.addEventListener("touchstart", N7, ia), window.addEventListener("blur", I7);
}
var V7 = typeof window < "u" && typeof document < "u", B7 = V7 ? (
  // @ts-ignore
  !!window.msCrypto
) : !1;
function il(t) {
  var e = t === "destroy" ? "n already-" : " ";
  return [t + "() was called on a" + e + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function j1(t) {
  var e = /[ \t]{2,}/g, n = /^[ \t]*/gm;
  return t.replace(e, " ").replace(n, "").trim();
}
function Z7(t) {
  return j1(`
  %ctippy.js

  %c` + j1(t) + `

  %c👷‍ This is a development-only message. It will be removed in production.
  `);
}
function fM(t) {
  return [
    Z7(t),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var Kc;
process.env.NODE_ENV !== "production" && F7();
function F7() {
  Kc = /* @__PURE__ */ new Set();
}
function Co(t, e) {
  if (t && !Kc.has(e)) {
    var n;
    Kc.add(e), (n = console).warn.apply(n, fM(e));
  }
}
function hv(t, e) {
  if (t && !Kc.has(e)) {
    var n;
    Kc.add(e), (n = console).error.apply(n, fM(e));
  }
}
function q7(t) {
  var e = !t, n = Object.prototype.toString.call(t) === "[object Object]" && !t.addEventListener;
  hv(e, ["tippy() was passed", "`" + String(t) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), hv(n, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var pM = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, W7 = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, Ni = Object.assign({
  appendTo: cM,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pM, W7), X7 = Object.keys(Ni), z7 = function(e) {
  process.env.NODE_ENV !== "production" && gM(e, []);
  var n = Object.keys(e);
  n.forEach(function(i) {
    Ni[i] = e[i];
  });
};
function mM(t) {
  var e = t.plugins || [], n = e.reduce(function(i, r) {
    var o = r.name, s = r.defaultValue;
    if (o) {
      var a;
      i[o] = t[o] !== void 0 ? t[o] : (a = Ni[o]) != null ? a : s;
    }
    return i;
  }, {});
  return Object.assign({}, t, n);
}
function j7(t, e) {
  var n = e ? Object.keys(mM(Object.assign({}, Ni, {
    plugins: e
  }))) : X7, i = n.reduce(function(r, o) {
    var s = (t.getAttribute("data-tippy-" + o) || "").trim();
    if (!s)
      return r;
    if (o === "content")
      r[o] = s;
    else
      try {
        r[o] = JSON.parse(s);
      } catch {
        r[o] = s;
      }
    return r;
  }, {});
  return i;
}
function Y1(t, e) {
  var n = Object.assign({}, e, {
    content: dM(e.content, [t])
  }, e.ignoreAttributes ? {} : j7(t, e.plugins));
  return n.aria = Object.assign({}, Ni.aria, n.aria), n.aria = {
    expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
    content: n.aria.content === "auto" ? e.interactive ? null : "describedby" : n.aria.content
  }, n;
}
function gM(t, e) {
  t === void 0 && (t = {}), e === void 0 && (e = []);
  var n = Object.keys(t);
  n.forEach(function(i) {
    var r = C7(Ni, Object.keys(pM)), o = !x7(r, i);
    o && (o = e.filter(function(s) {
      return s.name === i;
    }).length === 0), Co(o, ["`" + i + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var Y7 = function() {
  return "innerHTML";
};
function fv(t, e) {
  t[Y7()] = e;
}
function H1(t) {
  var e = vc();
  return t === !0 ? e.className = lM : (e.className = uM, Gc(t) ? e.appendChild(t) : fv(e, t)), e;
}
function U1(t, e) {
  Gc(e.content) ? (fv(t, ""), t.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? fv(t, e.content) : t.textContent = e.content);
}
function pv(t) {
  var e = t.firstElementChild, n = Af(e.children);
  return {
    box: e,
    content: n.find(function(i) {
      return i.classList.contains(aM);
    }),
    arrow: n.find(function(i) {
      return i.classList.contains(lM) || i.classList.contains(uM);
    }),
    backdrop: n.find(function(i) {
      return i.classList.contains(_7);
    })
  };
}
function OM(t) {
  var e = vc(), n = vc();
  n.className = S7, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
  var i = vc();
  i.className = aM, i.setAttribute("data-state", "hidden"), U1(i, t.props), e.appendChild(n), n.appendChild(i), r(t.props, t.props);
  function r(o, s) {
    var a = pv(e), l = a.box, u = a.content, c = a.arrow;
    s.theme ? l.setAttribute("data-theme", s.theme) : l.removeAttribute("data-theme"), typeof s.animation == "string" ? l.setAttribute("data-animation", s.animation) : l.removeAttribute("data-animation"), s.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth, s.role ? l.setAttribute("role", s.role) : l.removeAttribute("role"), (o.content !== s.content || o.allowHTML !== s.allowHTML) && U1(u, t.props), s.arrow ? c ? o.arrow !== s.arrow && (l.removeChild(c), l.appendChild(H1(s.arrow))) : l.appendChild(H1(s.arrow)) : c && l.removeChild(c);
  }
  return {
    popper: e,
    onUpdate: r
  };
}
OM.$$tippy = !0;
var H7 = 1, eh = [], $g = [];
function U7(t, e) {
  var n = Y1(t, Object.assign({}, Ni, mM(q1(e)))), i, r, o, s = !1, a = !1, l = !1, u = !1, c, d, h, f = [], p = Z1(ie, n.interactiveDebounce), m, g = H7++, O = null, y = $7(n.plugins), b = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, v = {
    // properties
    id: g,
    reference: t,
    popper: vc(),
    popperInstance: O,
    props: n,
    state: b,
    plugins: y,
    // methods
    clearDelayTimeouts: be,
    setProps: se,
    setContent: Oe,
    show: at,
    hide: $t,
    hideWithInteractivity: Qn,
    enable: ke,
    disable: Ve,
    unmount: qi,
    destroy: Mi
  };
  if (!n.render)
    return process.env.NODE_ENV !== "production" && hv(!0, "render() function has not been supplied."), v;
  var k = n.render(v), w = k.popper, S = k.onUpdate;
  w.setAttribute("data-tippy-root", ""), w.id = "tippy-" + v.id, v.popper = w, t._tippy = v, w._tippy = v;
  var $ = y.map(function(R) {
    return R.fn(v);
  }), C = t.hasAttribute("aria-expanded");
  return de(), B(), Y(), V("onCreate", [v]), n.showOnCreate && U(), w.addEventListener("mouseenter", function() {
    v.props.interactive && v.state.isVisible && v.clearDelayTimeouts();
  }), w.addEventListener("mouseleave", function() {
    v.props.interactive && v.props.trigger.indexOf("mouseenter") >= 0 && T().addEventListener("mousemove", p);
  }), v;
  function L() {
    var R = v.props.touch;
    return Array.isArray(R) ? R : [R, 0];
  }
  function j() {
    return L()[0] === "hold";
  }
  function P() {
    var R;
    return !!((R = v.props.render) != null && R.$$tippy);
  }
  function A() {
    return m || t;
  }
  function T() {
    var R = A().parentNode;
    return R ? D7(R) : document;
  }
  function N() {
    return pv(w);
  }
  function Q(R) {
    return v.state.isMounted && !v.state.isVisible || Fr.isTouch || c && c.type === "focus" ? 0 : xg(v.props.delay, R ? 0 : 1, Ni.delay);
  }
  function Y(R) {
    R === void 0 && (R = !1), w.style.pointerEvents = v.props.interactive && !R ? "" : "none", w.style.zIndex = "" + v.props.zIndex;
  }
  function V(R, le, $e) {
    if ($e === void 0 && ($e = !0), $.forEach(function(ae) {
      ae[R] && ae[R].apply(ae, le);
    }), $e) {
      var z;
      (z = v.props)[R].apply(z, le);
    }
  }
  function q() {
    var R = v.props.aria;
    if (R.content) {
      var le = "aria-" + R.content, $e = w.id, z = cl(v.props.triggerTarget || t);
      z.forEach(function(ae) {
        var Me = ae.getAttribute(le);
        if (v.state.isVisible)
          ae.setAttribute(le, Me ? Me + " " + $e : $e);
        else {
          var he = Me && Me.replace($e, "").trim();
          he ? ae.setAttribute(le, he) : ae.removeAttribute(le);
        }
      });
    }
  }
  function B() {
    if (!(C || !v.props.aria.expanded)) {
      var R = cl(v.props.triggerTarget || t);
      R.forEach(function(le) {
        v.props.interactive ? le.setAttribute("aria-expanded", v.state.isVisible && le === A() ? "true" : "false") : le.removeAttribute("aria-expanded");
      });
    }
  }
  function pe() {
    T().removeEventListener("mousemove", p), eh = eh.filter(function(R) {
      return R !== p;
    });
  }
  function oe(R) {
    if (!(Fr.isTouch && (l || R.type === "mousedown"))) {
      var le = R.composedPath && R.composedPath()[0] || R.target;
      if (!(v.props.interactive && X1(w, le))) {
        if (cl(v.props.triggerTarget || t).some(function($e) {
          return X1($e, le);
        })) {
          if (Fr.isTouch || v.state.isVisible && v.props.trigger.indexOf("click") >= 0)
            return;
        } else
          V("onClickOutside", [v, R]);
        v.props.hideOnClick === !0 && (v.clearDelayTimeouts(), v.hide(), a = !0, setTimeout(function() {
          a = !1;
        }), v.state.isMounted || ce());
      }
    }
  }
  function te() {
    l = !0;
  }
  function M() {
    l = !1;
  }
  function G() {
    var R = T();
    R.addEventListener("mousedown", oe, !0), R.addEventListener("touchend", oe, ia), R.addEventListener("touchstart", M, ia), R.addEventListener("touchmove", te, ia);
  }
  function ce() {
    var R = T();
    R.removeEventListener("mousedown", oe, !0), R.removeEventListener("touchend", oe, ia), R.removeEventListener("touchstart", M, ia), R.removeEventListener("touchmove", te, ia);
  }
  function F(R, le) {
    Be(R, function() {
      !v.state.isVisible && w.parentNode && w.parentNode.contains(w) && le();
    });
  }
  function xe(R, le) {
    Be(R, le);
  }
  function Be(R, le) {
    var $e = N().box;
    function z(ae) {
      ae.target === $e && (Tg($e, "remove", z), le());
    }
    if (R === 0)
      return le();
    Tg($e, "remove", d), Tg($e, "add", z), d = z;
  }
  function lt(R, le, $e) {
    $e === void 0 && ($e = !1);
    var z = cl(v.props.triggerTarget || t);
    z.forEach(function(ae) {
      ae.addEventListener(R, le, $e), f.push({
        node: ae,
        eventType: R,
        handler: le,
        options: $e
      });
    });
  }
  function de() {
    j() && (lt("touchstart", me, {
      passive: !0
    }), lt("touchend", I, {
      passive: !0
    })), T7(v.props.trigger).forEach(function(R) {
      if (R !== "manual")
        switch (lt(R, me), R) {
          case "mouseenter":
            lt("mouseleave", I);
            break;
          case "focus":
            lt(B7 ? "focusout" : "blur", ge);
            break;
          case "focusin":
            lt("focusout", ge);
            break;
        }
    });
  }
  function ye() {
    f.forEach(function(R) {
      var le = R.node, $e = R.eventType, z = R.handler, ae = R.options;
      le.removeEventListener($e, z, ae);
    }), f = [];
  }
  function me(R) {
    var le, $e = !1;
    if (!(!v.state.isEnabled || ze(R) || a)) {
      var z = ((le = c) == null ? void 0 : le.type) === "focus";
      c = R, m = R.currentTarget, B(), !v.state.isVisible && E7(R) && eh.forEach(function(ae) {
        return ae(R);
      }), R.type === "click" && (v.props.trigger.indexOf("mouseenter") < 0 || s) && v.props.hideOnClick !== !1 && v.state.isVisible ? $e = !0 : U(R), R.type === "click" && (s = !$e), $e && !z && K(R);
    }
  }
  function ie(R) {
    var le = R.target, $e = A().contains(le) || w.contains(le);
    if (!(R.type === "mousemove" && $e)) {
      var z = x().concat(w).map(function(ae) {
        var Me, he = ae._tippy, Re = (Me = he.popperInstance) == null ? void 0 : Me.state;
        return Re ? {
          popperRect: ae.getBoundingClientRect(),
          popperState: Re,
          props: n
        } : null;
      }).filter(Boolean);
      Q7(z, R) && (pe(), K(R));
    }
  }
  function I(R) {
    var le = ze(R) || v.props.trigger.indexOf("click") >= 0 && s;
    if (!le) {
      if (v.props.interactive) {
        v.hideWithInteractivity(R);
        return;
      }
      K(R);
    }
  }
  function ge(R) {
    v.props.trigger.indexOf("focusin") < 0 && R.target !== A() || v.props.interactive && R.relatedTarget && w.contains(R.relatedTarget) || K(R);
  }
  function ze(R) {
    return Fr.isTouch ? j() !== R.type.indexOf("touch") >= 0 : !1;
  }
  function Se() {
    st();
    var R = v.props, le = R.popperOptions, $e = R.placement, z = R.offset, ae = R.getReferenceClientRect, Me = R.moveTransition, he = P() ? pv(w).arrow : null, Re = ae ? {
      getBoundingClientRect: ae,
      contextElement: ae.contextElement || A()
    } : t, Fe = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(cr) {
        var Wi = cr.state;
        if (P()) {
          var Rr = N(), Ks = Rr.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(Ua) {
            Ua === "placement" ? Ks.setAttribute("data-placement", Wi.placement) : Wi.attributes.popper["data-popper-" + Ua] ? Ks.setAttribute("data-" + Ua, "") : Ks.removeAttribute("data-" + Ua);
          }), Wi.attributes.popper = {};
        }
      }
    }, fn = [{
      name: "offset",
      options: {
        offset: z
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !Me
      }
    }, Fe];
    P() && he && fn.push({
      name: "arrow",
      options: {
        element: he,
        padding: 3
      }
    }), fn.push.apply(fn, (le == null ? void 0 : le.modifiers) || []), v.popperInstance = k7(Re, w, Object.assign({}, le, {
      placement: $e,
      onFirstUpdate: h,
      modifiers: fn
    }));
  }
  function st() {
    v.popperInstance && (v.popperInstance.destroy(), v.popperInstance = null);
  }
  function D() {
    var R = v.props.appendTo, le, $e = A();
    v.props.interactive && R === cM || R === "parent" ? le = $e.parentNode : le = dM(R, [$e]), le.contains(w) || le.appendChild(w), v.state.isMounted = !0, Se(), process.env.NODE_ENV !== "production" && Co(v.props.interactive && R === Ni.appendTo && $e.nextElementSibling !== w, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function x() {
    return Af(w.querySelectorAll("[data-tippy-root]"));
  }
  function U(R) {
    v.clearDelayTimeouts(), R && V("onTrigger", [v, R]), G();
    var le = Q(!0), $e = L(), z = $e[0], ae = $e[1];
    Fr.isTouch && z === "hold" && ae && (le = ae), le ? i = setTimeout(function() {
      v.show();
    }, le) : v.show();
  }
  function K(R) {
    if (v.clearDelayTimeouts(), V("onUntrigger", [v, R]), !v.state.isVisible) {
      ce();
      return;
    }
    if (!(v.props.trigger.indexOf("mouseenter") >= 0 && v.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(R.type) >= 0 && s)) {
      var le = Q(!1);
      le ? r = setTimeout(function() {
        v.state.isVisible && v.hide();
      }, le) : o = requestAnimationFrame(function() {
        v.hide();
      });
    }
  }
  function ke() {
    v.state.isEnabled = !0;
  }
  function Ve() {
    v.hide(), v.state.isEnabled = !1;
  }
  function be() {
    clearTimeout(i), clearTimeout(r), cancelAnimationFrame(o);
  }
  function se(R) {
    if (process.env.NODE_ENV !== "production" && Co(v.state.isDestroyed, il("setProps")), !v.state.isDestroyed) {
      V("onBeforeUpdate", [v, R]), ye();
      var le = v.props, $e = Y1(t, Object.assign({}, le, q1(R), {
        ignoreAttributes: !0
      }));
      v.props = $e, de(), le.interactiveDebounce !== $e.interactiveDebounce && (pe(), p = Z1(ie, $e.interactiveDebounce)), le.triggerTarget && !$e.triggerTarget ? cl(le.triggerTarget).forEach(function(z) {
        z.removeAttribute("aria-expanded");
      }) : $e.triggerTarget && t.removeAttribute("aria-expanded"), B(), Y(), S && S(le, $e), v.popperInstance && (Se(), x().forEach(function(z) {
        requestAnimationFrame(z._tippy.popperInstance.forceUpdate);
      })), V("onAfterUpdate", [v, R]);
    }
  }
  function Oe(R) {
    v.setProps({
      content: R
    });
  }
  function at() {
    process.env.NODE_ENV !== "production" && Co(v.state.isDestroyed, il("show"));
    var R = v.state.isVisible, le = v.state.isDestroyed, $e = !v.state.isEnabled, z = Fr.isTouch && !v.props.touch, ae = xg(v.props.duration, 0, Ni.duration);
    if (!(R || le || $e || z) && !A().hasAttribute("disabled") && (V("onShow", [v], !1), v.props.onShow(v) !== !1)) {
      if (v.state.isVisible = !0, P() && (w.style.visibility = "visible"), Y(), G(), v.state.isMounted || (w.style.transition = "none"), P()) {
        var Me = N(), he = Me.box, Re = Me.content;
        Cg([he, Re], 0);
      }
      h = function() {
        var fn;
        if (!(!v.state.isVisible || u)) {
          if (u = !0, w.offsetHeight, w.style.transition = v.props.moveTransition, P() && v.props.animation) {
            var ti = N(), cr = ti.box, Wi = ti.content;
            Cg([cr, Wi], ae), W1([cr, Wi], "visible");
          }
          q(), B(), F1($g, v), (fn = v.popperInstance) == null || fn.forceUpdate(), V("onMount", [v]), v.props.animation && P() && xe(ae, function() {
            v.state.isShown = !0, V("onShown", [v]);
          });
        }
      }, D();
    }
  }
  function $t() {
    process.env.NODE_ENV !== "production" && Co(v.state.isDestroyed, il("hide"));
    var R = !v.state.isVisible, le = v.state.isDestroyed, $e = !v.state.isEnabled, z = xg(v.props.duration, 1, Ni.duration);
    if (!(R || le || $e) && (V("onHide", [v], !1), v.props.onHide(v) !== !1)) {
      if (v.state.isVisible = !1, v.state.isShown = !1, u = !1, s = !1, P() && (w.style.visibility = "hidden"), pe(), ce(), Y(!0), P()) {
        var ae = N(), Me = ae.box, he = ae.content;
        v.props.animation && (Cg([Me, he], z), W1([Me, he], "hidden"));
      }
      q(), B(), v.props.animation ? P() && F(z, v.unmount) : v.unmount();
    }
  }
  function Qn(R) {
    process.env.NODE_ENV !== "production" && Co(v.state.isDestroyed, il("hideWithInteractivity")), T().addEventListener("mousemove", p), F1(eh, p), p(R);
  }
  function qi() {
    process.env.NODE_ENV !== "production" && Co(v.state.isDestroyed, il("unmount")), v.state.isVisible && v.hide(), v.state.isMounted && (st(), x().forEach(function(R) {
      R._tippy.unmount();
    }), w.parentNode && w.parentNode.removeChild(w), $g = $g.filter(function(R) {
      return R !== v;
    }), v.state.isMounted = !1, V("onHidden", [v]));
  }
  function Mi() {
    process.env.NODE_ENV !== "production" && Co(v.state.isDestroyed, il("destroy")), !v.state.isDestroyed && (v.clearDelayTimeouts(), v.unmount(), ye(), delete t._tippy, v.state.isDestroyed = !0, V("onDestroy", [v]));
  }
}
function yu(t, e) {
  e === void 0 && (e = {});
  var n = Ni.plugins.concat(e.plugins || []);
  process.env.NODE_ENV !== "production" && (q7(t), gM(e, n)), L7();
  var i = Object.assign({}, e, {
    plugins: n
  }), r = R7(t);
  if (process.env.NODE_ENV !== "production") {
    var o = Gc(i.content), s = r.length > 1;
    Co(o && s, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var a = r.reduce(function(l, u) {
    var c = u && U7(u, i);
    return c && l.push(c), l;
  }, []);
  return Gc(t) ? a[0] : a;
}
yu.defaultProps = Ni;
yu.setDefaultProps = z7;
yu.currentInput = Fr;
Object.assign({}, JP, {
  effect: function(e) {
    var n = e.state, i = {
      popper: {
        position: n.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(n.elements.popper.style, i.popper), n.styles = i, n.elements.arrow && Object.assign(n.elements.arrow.style, i.arrow);
  }
});
yu.setDefaultProps({
  render: OM
});
class G7 {
  constructor({ editor: e, element: n, view: i, tippyOptions: r = {}, updateDelay: o = 250, shouldShow: s }) {
    this.preventHide = !1, this.shouldShow = ({ view: a, state: l, from: u, to: c }) => {
      const { doc: d, selection: h } = l, { empty: f } = h, p = !d.textBetween(u, c).length && Lb(l.selection), m = this.element.contains(document.activeElement);
      return !(!(a.hasFocus() || m) || f || p || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: a }) => {
      var l;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      a != null && a.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(a.relatedTarget)) || (a == null ? void 0 : a.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (a) => {
      this.blurHandler({ event: a });
    }, this.handleDebouncedUpdate = (a, l) => {
      const u = !(l != null && l.selection.eq(a.state.selection)), c = !(l != null && l.doc.eq(a.state.doc));
      !u && !c || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(a, u, c, l);
      }, this.updateDelay));
    }, this.updateHandler = (a, l, u, c) => {
      var d, h, f;
      const { state: p, composing: m } = a, { selection: g } = p;
      if (m || !l && !u)
        return;
      this.createTooltip();
      const { ranges: y } = g, b = Math.min(...y.map((w) => w.$from.pos)), v = Math.max(...y.map((w) => w.$to.pos));
      if (!((d = this.shouldShow) === null || d === void 0 ? void 0 : d.call(this, {
        editor: this.editor,
        element: this.element,
        view: a,
        state: p,
        oldState: c,
        from: b,
        to: v
      }))) {
        this.hide();
        return;
      }
      (h = this.tippy) === null || h === void 0 || h.setProps({
        getReferenceClientRect: ((f = this.tippyOptions) === null || f === void 0 ? void 0 : f.getReferenceClientRect) || (() => {
          if (HP(p.selection)) {
            let w = a.nodeDOM(b);
            if (w) {
              const S = w.dataset.nodeViewWrapper ? w : w.querySelector("[data-node-view-wrapper]");
              if (S && (w = S.firstChild), w)
                return w.getBoundingClientRect();
            }
          }
          return UP(a, b, v);
        })
      }), this.show();
    }, this.editor = e, this.element = n, this.view = i, this.updateDelay = o, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = r, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = yu(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    const { state: i } = e, r = i.selection.from !== i.selection.to;
    if (this.updateDelay > 0 && r) {
      this.handleDebouncedUpdate(e, n);
      return;
    }
    const o = !(n != null && n.selection.eq(e.state.selection)), s = !(n != null && n.doc.eq(e.state.doc));
    this.updateHandler(e, o, s, n);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const vM = (t) => new rn({
  key: typeof t.pluginKey == "string" ? new _n(t.pluginKey) : t.pluginKey,
  view: (e) => new G7({ view: e, ...t })
});
yn.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      vM({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
class K7 {
  constructor({ editor: e, element: n, view: i, tippyOptions: r = {}, shouldShow: o }) {
    this.preventHide = !1, this.shouldShow = ({ view: s, state: a }) => {
      const { selection: l } = a, { $anchor: u, empty: c } = l, d = u.depth === 1, h = u.parent.isTextblock && !u.parent.type.spec.code && !u.parent.textContent;
      return !(!s.hasFocus() || !c || !d || !h || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: s }) => {
      var a;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      s != null && s.relatedTarget && (!((a = this.element.parentNode) === null || a === void 0) && a.contains(s.relatedTarget)) || (s == null ? void 0 : s.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (s) => {
      this.blurHandler({ event: s });
    }, this.editor = e, this.element = n, this.view = i, o && (this.shouldShow = o), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = r, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = yu(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    var i, r, o;
    const { state: s } = e, { doc: a, selection: l } = s, { from: u, to: c } = l;
    if (n && n.doc.eq(a) && n.selection.eq(l))
      return;
    if (this.createTooltip(), !((i = this.shouldShow) === null || i === void 0 ? void 0 : i.call(this, {
      editor: this.editor,
      view: e,
      state: s,
      oldState: n
    }))) {
      this.hide();
      return;
    }
    (r = this.tippy) === null || r === void 0 || r.setProps({
      getReferenceClientRect: ((o = this.tippyOptions) === null || o === void 0 ? void 0 : o.getReferenceClientRect) || (() => UP(e, u, c))
    }), this.show();
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const yM = (t) => new rn({
  key: typeof t.pluginKey == "string" ? new _n(t.pluginKey) : t.pluginKey,
  view: (e) => new K7({ view: e, ...t })
});
yn.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      yM({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
const J7 = Te({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: [String, Object],
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    updateDelay: {
      type: Number,
      default: void 0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t, { slots: e }) {
    const n = re(null);
    return Et(() => {
      const { updateDelay: i, editor: r, pluginKey: o, shouldShow: s, tippyOptions: a } = t;
      r.registerPlugin(vM({
        updateDelay: i,
        editor: r,
        element: n.value,
        pluginKey: o,
        shouldShow: s,
        tippyOptions: a
      }));
    }), Zs(() => {
      const { pluginKey: i, editor: r } = t;
      r.unregisterPlugin(i);
    }), () => {
      var i;
      return ir("div", { ref: n }, (i = e.default) === null || i === void 0 ? void 0 : i.call(e));
    };
  }
});
function G1(t) {
  return Hx((e, n) => ({
    get() {
      return e(), t;
    },
    set(i) {
      t = i, requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          n();
        });
      });
    }
  }));
}
class e6 extends g8 {
  constructor(e = {}) {
    return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = G1(this.view.state), this.reactiveExtensionStorage = G1(this.extensionStorage), this.on("beforeTransaction", ({ nextState: n }) => {
      this.reactiveState.value = n, this.reactiveExtensionStorage.value = this.extensionStorage;
    }), YD(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  /**
   * Register a ProseMirror plugin.
   */
  registerPlugin(e, n) {
    const i = super.registerPlugin(e, n);
    return this.reactiveState && (this.reactiveState.value = i), i;
  }
  /**
   * Unregister a ProseMirror plugin.
   */
  unregisterPlugin(e) {
    const n = super.unregisterPlugin(e);
    return this.reactiveState && n && (this.reactiveState.value = n), n;
  }
}
const t6 = Te({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(t) {
    const e = re(), n = Ip();
    return jD(() => {
      const i = t.editor;
      i && i.options.element && e.value && nn(() => {
        if (!e.value || !i.options.element.firstChild)
          return;
        const r = E(e.value);
        e.value.append(...i.options.element.childNodes), i.contentComponent = n.ctx._, n && (i.appContext = {
          ...n.appContext,
          // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
          // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
          // @ts-expect-error forward instance's 'provides' into appContext
          provides: n.provides
        }), i.setOptions({
          element: r
        }), i.createNodeViews();
      });
    }), Zs(() => {
      const i = t.editor;
      i && (i.contentComponent = null, i.appContext = null);
    }), { rootEl: e };
  },
  render() {
    return ir("div", {
      ref: (t) => {
        this.rootEl = t;
      }
    });
  }
});
Te({
  name: "FloatingMenu",
  props: {
    pluginKey: {
      // TODO: TypeScript breaks :(
      // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
      type: null,
      default: "floatingMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t, { slots: e }) {
    const n = re(null);
    return Et(() => {
      const { pluginKey: i, editor: r, tippyOptions: o, shouldShow: s } = t;
      r.registerPlugin(yM({
        pluginKey: i,
        editor: r,
        element: n.value,
        tippyOptions: o,
        shouldShow: s
      }));
    }), Zs(() => {
      const { pluginKey: i, editor: r } = t;
      r.unregisterPlugin(i);
    }), () => {
      var i;
      return ir("div", { ref: n }, (i = e.default) === null || i === void 0 ? void 0 : i.call(e));
    };
  }
});
Te({
  name: "NodeViewContent",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  render() {
    return ir(this.as, {
      style: {
        whiteSpace: "pre-wrap"
      },
      "data-node-view-content": ""
    });
  }
});
Te({
  name: "NodeViewWrapper",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  inject: ["onDragStart", "decorationClasses"],
  render() {
    var t, e;
    return ir(this.as, {
      // @ts-ignore
      class: this.decorationClasses,
      style: {
        whiteSpace: "normal"
      },
      "data-node-view-wrapper": "",
      // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
      onDragstart: this.onDragStart
    }, (e = (t = this.$slots).default) === null || e === void 0 ? void 0 : e.call(t));
  }
});
const n6 = (t = {}) => {
  const e = vd();
  return Et(() => {
    e.value = new e6(t);
  }), Zs(() => {
    var n, i, r;
    const o = (n = e.value) === null || n === void 0 ? void 0 : n.options.element, s = o == null ? void 0 : o.cloneNode(!0);
    (i = o == null ? void 0 : o.parentNode) === null || i === void 0 || i.replaceChild(s, o), (r = e.value) === null || r === void 0 || r.destroy();
  }), e;
}, i6 = /^\s*>\s$/, r6 = mi.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["blockquote", Ht(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      Yc({
        find: i6,
        type: this.type
      })
    ];
  }
}), o6 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, s6 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, a6 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, l6 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, u6 = Zi.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t) => t.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["strong", Ht(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: t }) => t.setMark(this.name),
      toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Hl({
        find: o6,
        type: this.type
      }),
      Hl({
        find: a6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ia({
        find: s6,
        type: this.type
      }),
      Ia({
        find: l6,
        type: this.type
      })
    ];
  }
}), c6 = "listItem", K1 = "textStyle", J1 = /^\s*([-+*])\s$/, d6 = mi.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", Ht(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(c6, this.editor.getAttributes(K1)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t = Yc({
      find: J1,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Yc({
      find: J1,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(K1),
      editor: this.editor
    })), [
      t
    ];
  }
}), h6 = new RegExp("(?<!`)`([^`]+)`(?!`)"), f6 = new RegExp("(?<!`)`([^`]+)`(?!`)", "g"), p6 = Zi.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["code", Ht(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: t }) => t.setMark(this.name),
      toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      Hl({
        find: h6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ia({
        find: f6,
        type: this.type
      })
    ];
  }
}), m6 = /^```([a-z]+)?[\s\n]$/, g6 = /^~~~([a-z]+)?[\s\n]$/, O6 = mi.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (t) => {
          var e;
          const { languageClassPrefix: n } = this.options, o = [...((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((s) => s.startsWith(n)).map((s) => s.replace(n, ""))[0];
          return o || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "pre",
      Ht(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (t) => ({ commands: e }) => e.setNode(this.name, t),
      toggleCodeBlock: (t) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: t, $anchor: e } = this.editor.state.selection, n = e.pos === 1;
        return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // exit node on triple enter
      Enter: ({ editor: t }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = t, { selection: n } = e, { $from: i, empty: r } = n;
        if (!r || i.parent.type !== this.type)
          return !1;
        const o = i.parentOffset === i.parent.nodeSize - 2, s = i.parent.textContent.endsWith(`

`);
        return !o || !s ? !1 : t.chain().command(({ tr: a }) => (a.delete(i.pos - 2, i.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: t }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = t, { selection: n, doc: i } = e, { $from: r, empty: o } = n;
        if (!o || r.parent.type !== this.type || !(r.parentOffset === r.parent.nodeSize - 2))
          return !1;
        const a = r.after();
        return a === void 0 ? !1 : i.nodeAt(a) ? t.commands.command(({ tr: u }) => (u.setSelection(tt.near(i.resolve(a))), !0)) : t.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      lv({
        find: m6,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      }),
      lv({
        find: g6,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new rn({
        key: new _n("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (t, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = e.clipboardData.getData("text/plain"), i = e.clipboardData.getData("vscode-editor-data"), r = i ? JSON.parse(i) : void 0, o = r == null ? void 0 : r.mode;
            if (!n || !o)
              return !1;
            const { tr: s, schema: a } = t.state, l = a.text(n.replace(/\r\n?/g, `
`));
            return s.replaceSelectionWith(this.type.create({ language: o }, l)), s.selection.$from.parent.type !== this.type && s.setSelection(Je.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))), s.setMeta("paste", !0), t.dispatch(s), !0;
          }
        }
      })
    ];
  }
}), v6 = mi.create({
  name: "doc",
  topNode: !0,
  content: "block+"
});
function y6(t = {}) {
  return new rn({
    view(e) {
      return new b6(e, t);
    }
  });
}
class b6 {
  constructor(e, n) {
    var i;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (i = n.width) !== null && i !== void 0 ? i : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((r) => {
      let o = (s) => {
        this[r](s);
      };
      return e.dom.addEventListener(r, o), { name: r, handler: o };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
  }
  update(e, n) {
    this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, i;
    if (n) {
      let a = e.nodeBefore, l = e.nodeAfter;
      if (a || l) {
        let u = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
        if (u) {
          let c = u.getBoundingClientRect(), d = a ? c.bottom : c.top;
          a && l && (d = (d + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), i = { left: c.left, right: c.right, top: d - this.width / 2, bottom: d + this.width / 2 };
        }
      }
    }
    if (!i) {
      let a = this.editorView.coordsAtPos(this.cursorPos);
      i = { left: a.left - this.width / 2, right: a.left + this.width / 2, top: a.top, bottom: a.bottom };
    }
    let r = this.editorView.dom.offsetParent;
    this.element || (this.element = r.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let o, s;
    if (!r || r == document.body && getComputedStyle(r).position == "static")
      o = -pageXOffset, s = -pageYOffset;
    else {
      let a = r.getBoundingClientRect();
      o = a.left - r.scrollLeft, s = a.top - r.scrollTop;
    }
    this.element.style.left = i.left - o + "px", this.element.style.top = i.top - s + "px", this.element.style.width = i.right - i.left + "px", this.element.style.height = i.bottom - i.top + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), i = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), r = i && i.type.spec.disableDropCursor, o = typeof r == "function" ? r(this.editorView, n, e) : r;
    if (n && !o) {
      let s = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = F$(this.editorView.state.doc, s, this.editorView.dragging.slice);
        a != null && (s = a);
      }
      this.setCursor(s), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
  }
}
const w6 = yn.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      y6(this.options)
    ];
  }
});
class an extends tt {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let i = e.resolve(n.map(this.head));
    return an.valid(i) ? new an(i) : tt.near(i);
  }
  content() {
    return Ne.empty;
  }
  eq(e) {
    return e instanceof an && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new an(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new Gb(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !k6(e) || !S6(e))
      return !1;
    let i = n.type.spec.allowGapCursor;
    if (i != null)
      return i;
    let r = n.contentMatchAt(e.index()).defaultType;
    return r && r.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, i = !1) {
    e:
      for (; ; ) {
        if (!i && an.valid(e))
          return e;
        let r = e.pos, o = null;
        for (let s = e.depth; ; s--) {
          let a = e.node(s);
          if (n > 0 ? e.indexAfter(s) < a.childCount : e.index(s) > 0) {
            o = a.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
            break;
          } else if (s == 0)
            return null;
          r += n;
          let l = e.doc.resolve(r);
          if (an.valid(l))
            return l;
        }
        for (; ; ) {
          let s = n > 0 ? o.firstChild : o.lastChild;
          if (!s) {
            if (o.isAtom && !o.isText && !Ke.isSelectable(o)) {
              e = e.doc.resolve(r + o.nodeSize * n), i = !1;
              continue e;
            }
            break;
          }
          o = s, r += n;
          let a = e.doc.resolve(r);
          if (an.valid(a))
            return a;
        }
        return null;
      }
  }
}
an.prototype.visible = !1;
an.findFrom = an.findGapCursorFrom;
tt.jsonID("gapcursor", an);
class Gb {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new Gb(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return an.valid(n) ? new an(n) : tt.near(n);
  }
}
function k6(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e), i = t.node(e);
    if (n == 0) {
      if (i.type.spec.isolating)
        return !0;
      continue;
    }
    for (let r = i.child(n - 1); ; r = r.lastChild) {
      if (r.childCount == 0 && !r.inlineContent || r.isAtom || r.type.spec.isolating)
        return !0;
      if (r.inlineContent)
        return !1;
    }
  }
  return !0;
}
function S6(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e), i = t.node(e);
    if (n == i.childCount) {
      if (i.type.spec.isolating)
        return !0;
      continue;
    }
    for (let r = i.child(n); ; r = r.firstChild) {
      if (r.childCount == 0 && !r.inlineContent || r.isAtom || r.type.spec.isolating)
        return !0;
      if (r.inlineContent)
        return !1;
    }
  }
  return !0;
}
function _6() {
  return new rn({
    props: {
      decorations: $6,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && an.valid(n) ? new an(n) : null;
      },
      handleClick: C6,
      handleKeyDown: x6,
      handleDOMEvents: { beforeinput: T6 }
    }
  });
}
const x6 = Ab({
  ArrowLeft: th("horiz", -1),
  ArrowRight: th("horiz", 1),
  ArrowUp: th("vert", -1),
  ArrowDown: th("vert", 1)
});
function th(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(i, r, o) {
    let s = i.selection, a = e > 0 ? s.$to : s.$from, l = s.empty;
    if (s instanceof Je) {
      if (!o.endOfTextblock(n) || a.depth == 0)
        return !1;
      l = !1, a = i.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let u = an.findGapCursorFrom(a, e, l);
    return u ? (r && r(i.tr.setSelection(new an(u))), !0) : !1;
  };
}
function C6(t, e, n) {
  if (!t || !t.editable)
    return !1;
  let i = t.state.doc.resolve(e);
  if (!an.valid(i))
    return !1;
  let r = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return r && r.inside > -1 && Ke.isSelectable(t.state.doc.nodeAt(r.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new an(i))), !0);
}
function T6(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof an))
    return !1;
  let { $from: n } = t.state.selection, i = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
  if (!i)
    return !1;
  let r = we.empty;
  for (let s = i.length - 1; s >= 0; s--)
    r = we.from(i[s].createAndFill(null, r));
  let o = t.state.tr.replace(n.pos, n.pos, new Ne(r, 0, 0));
  return o.setSelection(Je.near(o.doc.resolve(n.pos + 1))), t.dispatch(o), !1;
}
function $6(t) {
  if (!(t.selection instanceof an))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Jt.create(t.doc, [Cr.widget(t.selection.head, e, { key: "gapcursor" })]);
}
const P6 = yn.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      _6()
    ];
  },
  extendNodeSchema(t) {
    var e;
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      allowGapCursor: (e = ct(Xe(t, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
    };
  }
}), M6 = mi.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["br", Ht(this.options.HTMLAttributes, t)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t, chain: e, state: n, editor: i }) => t.first([
        () => t.exitCode(),
        () => t.command(() => {
          const { selection: r, storedMarks: o } = n;
          if (r.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: s } = this.options, { splittableMarks: a } = i.extensionManager, l = o || r.$to.parentOffset && r.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: u, dispatch: c }) => {
            if (c && l && s) {
              const d = l.filter((h) => a.includes(h.type.name));
              u.ensureMarks(d);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), E6 = mi.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }));
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, Ht(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
      toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((t, e) => ({
      ...t,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((t) => lv({
      find: new RegExp(`^(#{1,${t}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t
      }
    }));
  }
});
var Rf = 200, Rn = function() {
};
Rn.prototype.append = function(e) {
  return e.length ? (e = Rn.from(e), !this.length && e || e.length < Rf && this.leafAppend(e) || this.length < Rf && e.leafPrepend(this) || this.appendInner(e)) : this;
};
Rn.prototype.prepend = function(e) {
  return e.length ? Rn.from(e).append(this) : this;
};
Rn.prototype.appendInner = function(e) {
  return new A6(this, e);
};
Rn.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? Rn.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
Rn.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
Rn.prototype.forEach = function(e, n, i) {
  n === void 0 && (n = 0), i === void 0 && (i = this.length), n <= i ? this.forEachInner(e, n, i, 0) : this.forEachInvertedInner(e, n, i, 0);
};
Rn.prototype.map = function(e, n, i) {
  n === void 0 && (n = 0), i === void 0 && (i = this.length);
  var r = [];
  return this.forEach(function(o, s) {
    return r.push(e(o, s));
  }, n, i), r;
};
Rn.from = function(e) {
  return e instanceof Rn ? e : e && e.length ? new bM(e) : Rn.empty;
};
var bM = /* @__PURE__ */ function(t) {
  function e(i) {
    t.call(this), this.values = i;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(r, o) {
    return r == 0 && o == this.length ? this : new e(this.values.slice(r, o));
  }, e.prototype.getInner = function(r) {
    return this.values[r];
  }, e.prototype.forEachInner = function(r, o, s, a) {
    for (var l = o; l < s; l++)
      if (r(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(r, o, s, a) {
    for (var l = o - 1; l >= s; l--)
      if (r(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(r) {
    if (this.length + r.length <= Rf)
      return new e(this.values.concat(r.flatten()));
  }, e.prototype.leafPrepend = function(r) {
    if (this.length + r.length <= Rf)
      return new e(r.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
}(Rn);
Rn.empty = new bM([]);
var A6 = /* @__PURE__ */ function(t) {
  function e(n, i) {
    t.call(this), this.left = n, this.right = i, this.length = n.length + i.length, this.depth = Math.max(n.depth, i.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  }, e.prototype.forEachInner = function(i, r, o, s) {
    var a = this.left.length;
    if (r < a && this.left.forEachInner(i, r, Math.min(o, a), s) === !1 || o > a && this.right.forEachInner(i, Math.max(r - a, 0), Math.min(this.length, o) - a, s + a) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(i, r, o, s) {
    var a = this.left.length;
    if (r > a && this.right.forEachInvertedInner(i, r - a, Math.max(o, a) - a, s + a) === !1 || o < a && this.left.forEachInvertedInner(i, Math.min(r, a), o, s) === !1)
      return !1;
  }, e.prototype.sliceInner = function(i, r) {
    if (i == 0 && r == this.length)
      return this;
    var o = this.left.length;
    return r <= o ? this.left.slice(i, r) : i >= o ? this.right.slice(i - o, r - o) : this.left.slice(i, o).append(this.right.slice(0, r - o));
  }, e.prototype.leafAppend = function(i) {
    var r = this.right.leafAppend(i);
    if (r)
      return new e(this.left, r);
  }, e.prototype.leafPrepend = function(i) {
    var r = this.left.leafPrepend(i);
    if (r)
      return new e(r, this.right);
  }, e.prototype.appendInner = function(i) {
    return this.left.depth >= Math.max(this.right.depth, i.depth) + 1 ? new e(this.left, new e(this.right, i)) : new e(this, i);
  }, e;
}(Rn);
const R6 = 500;
class Or {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let i = this.items.length;
    for (; ; i--)
      if (this.items.get(i - 1).selection) {
        --i;
        break;
      }
    let r, o;
    n && (r = this.remapping(i, this.items.length), o = r.maps.length);
    let s = e.tr, a, l, u = [], c = [];
    return this.items.forEach((d, h) => {
      if (!d.step) {
        r || (r = this.remapping(i, h + 1), o = r.maps.length), o--, c.push(d);
        return;
      }
      if (r) {
        c.push(new Vr(d.map));
        let f = d.step.map(r.slice(o)), p;
        f && s.maybeStep(f).doc && (p = s.mapping.maps[s.mapping.maps.length - 1], u.push(new Vr(p, void 0, void 0, u.length + c.length))), o--, p && r.appendMap(p, o);
      } else
        s.maybeStep(d.step);
      if (d.selection)
        return a = r ? d.selection.map(r.slice(o)) : d.selection, l = new Or(this.items.slice(0, i).append(c.reverse().concat(u)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: s, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, i, r) {
    let o = [], s = this.eventCount, a = this.items, l = !r && a.length ? a.get(a.length - 1) : null;
    for (let c = 0; c < e.steps.length; c++) {
      let d = e.steps[c].invert(e.docs[c]), h = new Vr(e.mapping.maps[c], d, n), f;
      (f = l && l.merge(h)) && (h = f, c ? o.pop() : a = a.slice(0, a.length - 1)), o.push(h), n && (s++, n = void 0), r || (l = h);
    }
    let u = s - i.depth;
    return u > Q6 && (a = D6(a, u), s -= u), new Or(a.append(o), s);
  }
  remapping(e, n) {
    let i = new kl();
    return this.items.forEach((r, o) => {
      let s = r.mirrorOffset != null && o - r.mirrorOffset >= e ? i.maps.length - r.mirrorOffset : void 0;
      i.appendMap(r.map, s);
    }, e, n), i;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new Or(this.items.append(e.map((n) => new Vr(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let i = [], r = Math.max(0, this.items.length - n), o = e.mapping, s = e.steps.length, a = this.eventCount;
    this.items.forEach((h) => {
      h.selection && a--;
    }, r);
    let l = n;
    this.items.forEach((h) => {
      let f = o.getMirror(--l);
      if (f == null)
        return;
      s = Math.min(s, f);
      let p = o.maps[f];
      if (h.step) {
        let m = e.steps[f].invert(e.docs[f]), g = h.selection && h.selection.map(o.slice(l + 1, f));
        g && a++, i.push(new Vr(p, m, g));
      } else
        i.push(new Vr(p));
    }, r);
    let u = [];
    for (let h = n; h < s; h++)
      u.push(new Vr(o.maps[h]));
    let c = this.items.slice(0, r).append(u).append(i), d = new Or(c, a);
    return d.emptyItemCount() > R6 && (d = d.compress(this.items.length - i.length)), d;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), i = n.maps.length, r = [], o = 0;
    return this.items.forEach((s, a) => {
      if (a >= e)
        r.push(s), s.selection && o++;
      else if (s.step) {
        let l = s.step.map(n.slice(i)), u = l && l.getMap();
        if (i--, u && n.appendMap(u, i), l) {
          let c = s.selection && s.selection.map(n.slice(i));
          c && o++;
          let d = new Vr(u.invert(), l, c), h, f = r.length - 1;
          (h = r.length && r[f].merge(d)) ? r[f] = h : r.push(d);
        }
      } else
        s.map && i--;
    }, this.items.length, 0), new Or(Rn.from(r.reverse()), o);
  }
}
Or.empty = new Or(Rn.empty, 0);
function D6(t, e) {
  let n;
  return t.forEach((i, r) => {
    if (i.selection && e-- == 0)
      return n = r, !1;
  }), t.slice(n);
}
class Vr {
  constructor(e, n, i, r) {
    this.map = e, this.step = n, this.selection = i, this.mirrorOffset = r;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new Vr(n.getMap().invert(), n, this.selection);
    }
  }
}
let rs = class {
  constructor(e, n, i, r, o) {
    this.done = e, this.undone = n, this.prevRanges = i, this.prevTime = r, this.prevComposition = o;
  }
};
const Q6 = 20;
function N6(t, e, n, i) {
  let r = n.getMeta(_a), o;
  if (r)
    return r.historyState;
  n.getMeta(V6) && (t = new rs(t.done, t.undone, null, 0, -1));
  let s = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t;
  if (s && s.getMeta(_a))
    return s.getMeta(_a).redo ? new rs(t.done.addTransform(n, void 0, i, Ih(e)), t.undone, eS(n.mapping.maps), t.prevTime, t.prevComposition) : new rs(t.done, t.undone.addTransform(n, void 0, i, Ih(e)), null, t.prevTime, t.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(s && s.getMeta("addToHistory") === !1)) {
    let a = n.getMeta("composition"), l = t.prevTime == 0 || !s && t.prevComposition != a && (t.prevTime < (n.time || 0) - i.newGroupDelay || !I6(n, t.prevRanges)), u = s ? Pg(t.prevRanges, n.mapping) : eS(n.mapping.maps);
    return new rs(t.done.addTransform(n, l ? e.selection.getBookmark() : void 0, i, Ih(e)), Or.empty, u, n.time, a ?? t.prevComposition);
  } else
    return (o = n.getMeta("rebased")) ? new rs(t.done.rebased(n, o), t.undone.rebased(n, o), Pg(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new rs(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), Pg(t.prevRanges, n.mapping), t.prevTime, t.prevComposition);
}
function I6(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let n = !1;
  return t.mapping.maps[0].forEach((i, r) => {
    for (let o = 0; o < e.length; o += 2)
      i <= e[o + 1] && r >= e[o] && (n = !0);
  }), n;
}
function eS(t) {
  let e = [];
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
    t[n].forEach((i, r, o, s) => e.push(o, s));
  return e;
}
function Pg(t, e) {
  if (!t)
    return null;
  let n = [];
  for (let i = 0; i < t.length; i += 2) {
    let r = e.map(t[i], 1), o = e.map(t[i + 1], -1);
    r <= o && n.push(r, o);
  }
  return n;
}
function L6(t, e, n) {
  let i = Ih(e), r = _a.get(e).spec.config, o = (n ? t.undone : t.done).popEvent(e, i);
  if (!o)
    return null;
  let s = o.selection.resolve(o.transform.doc), a = (n ? t.done : t.undone).addTransform(o.transform, e.selection.getBookmark(), r, i), l = new rs(n ? a : o.remaining, n ? o.remaining : a, null, 0, -1);
  return o.transform.setSelection(s).setMeta(_a, { redo: n, historyState: l });
}
let Mg = !1, tS = null;
function Ih(t) {
  let e = t.plugins;
  if (tS != e) {
    Mg = !1, tS = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        Mg = !0;
        break;
      }
  }
  return Mg;
}
const _a = new _n("history"), V6 = new _n("closeHistory");
function B6(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new rn({
    key: _a,
    state: {
      init() {
        return new rs(Or.empty, Or.empty, null, 0, -1);
      },
      apply(e, n, i) {
        return N6(n, i, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let i = n.inputType, r = i == "historyUndo" ? kM : i == "historyRedo" ? SM : null;
          return r ? (n.preventDefault(), r(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function wM(t, e) {
  return (n, i) => {
    let r = _a.getState(n);
    if (!r || (t ? r.undone : r.done).eventCount == 0)
      return !1;
    if (i) {
      let o = L6(r, n, t);
      o && i(e ? o.scrollIntoView() : o);
    }
    return !0;
  };
}
const kM = wM(!1, !0), SM = wM(!0, !0), Z6 = yn.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t, dispatch: e }) => kM(t, e),
      redo: () => ({ state: t, dispatch: e }) => SM(t, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      B6(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
}), F6 = mi.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["hr", Ht(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t, state: e }) => {
        const { selection: n } = e, { $from: i, $to: r } = n, o = t();
        return i.parentOffset === 0 ? o.insertContentAt({
          from: Math.max(i.pos - 1, 0),
          to: r.pos
        }, {
          type: this.name
        }) : HP(n) ? o.insertContentAt(r.pos, {
          type: this.name
        }) : o.insertContent({ type: this.name }), o.command(({ tr: s, dispatch: a }) => {
          var l;
          if (a) {
            const { $to: u } = s.selection, c = u.end();
            if (u.nodeAfter)
              u.nodeAfter.isTextblock ? s.setSelection(Je.create(s.doc, u.pos + 1)) : u.nodeAfter.isBlock ? s.setSelection(Ke.create(s.doc, u.pos)) : s.setSelection(Je.create(s.doc, u.pos));
            else {
              const d = (l = u.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
              d && (s.insert(c, d), s.setSelection(Je.create(s.doc, c + 1)));
            }
            s.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      O8({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), q6 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, W6 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, X6 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, z6 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, j6 = Zi.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t) => t.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["em", Ht(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t }) => t.setMark(this.name),
      toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Hl({
        find: q6,
        type: this.type
      }),
      Hl({
        find: X6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ia({
        find: W6,
        type: this.type
      }),
      Ia({
        find: z6,
        type: this.type
      })
    ];
  }
}), Y6 = mi.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", Ht(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), H6 = "listItem", nS = "textStyle", iS = /^(\d+)\.\s$/, U6 = mi.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: void 0,
        parseHTML: (t) => t.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { start: e, ...n } = t;
    return e === 1 ? ["ol", Ht(this.options.HTMLAttributes, n), 0] : ["ol", Ht(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(H6, this.editor.getAttributes(nS)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t = Yc({
      find: iS,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Yc({
      find: iS,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(nS) }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
      editor: this.editor
    })), [
      t
    ];
  }
}), G6 = mi.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["p", Ht(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: t }) => t.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), K6 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, J6 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, eG = Zi.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["s", Ht(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: t }) => t.setMark(this.name),
      toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Hl({
        find: K6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ia({
        find: J6,
        type: this.type
      })
    ];
  }
}), tG = mi.create({
  name: "text",
  group: "inline"
}), nG = yn.create({
  name: "starterKit",
  addExtensions() {
    var t, e, n, i, r, o, s, a, l, u, c, d, h, f, p, m, g, O;
    const y = [];
    return this.options.bold !== !1 && y.push(u6.configure((t = this.options) === null || t === void 0 ? void 0 : t.bold)), this.options.blockquote !== !1 && y.push(r6.configure((e = this.options) === null || e === void 0 ? void 0 : e.blockquote)), this.options.bulletList !== !1 && y.push(d6.configure((n = this.options) === null || n === void 0 ? void 0 : n.bulletList)), this.options.code !== !1 && y.push(p6.configure((i = this.options) === null || i === void 0 ? void 0 : i.code)), this.options.codeBlock !== !1 && y.push(O6.configure((r = this.options) === null || r === void 0 ? void 0 : r.codeBlock)), this.options.document !== !1 && y.push(v6.configure((o = this.options) === null || o === void 0 ? void 0 : o.document)), this.options.dropcursor !== !1 && y.push(w6.configure((s = this.options) === null || s === void 0 ? void 0 : s.dropcursor)), this.options.gapcursor !== !1 && y.push(P6.configure((a = this.options) === null || a === void 0 ? void 0 : a.gapcursor)), this.options.hardBreak !== !1 && y.push(M6.configure((l = this.options) === null || l === void 0 ? void 0 : l.hardBreak)), this.options.heading !== !1 && y.push(E6.configure((u = this.options) === null || u === void 0 ? void 0 : u.heading)), this.options.history !== !1 && y.push(Z6.configure((c = this.options) === null || c === void 0 ? void 0 : c.history)), this.options.horizontalRule !== !1 && y.push(F6.configure((d = this.options) === null || d === void 0 ? void 0 : d.horizontalRule)), this.options.italic !== !1 && y.push(j6.configure((h = this.options) === null || h === void 0 ? void 0 : h.italic)), this.options.listItem !== !1 && y.push(Y6.configure((f = this.options) === null || f === void 0 ? void 0 : f.listItem)), this.options.orderedList !== !1 && y.push(U6.configure((p = this.options) === null || p === void 0 ? void 0 : p.orderedList)), this.options.paragraph !== !1 && y.push(G6.configure((m = this.options) === null || m === void 0 ? void 0 : m.paragraph)), this.options.strike !== !1 && y.push(eG.configure((g = this.options) === null || g === void 0 ? void 0 : g.strike)), this.options.text !== !1 && y.push(tG.configure((O = this.options) === null || O === void 0 ? void 0 : O.text)), y;
  }
}), iG = Zi.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["u", Ht(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: t }) => t.setMark(this.name),
      toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), rG = Zi.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "sub" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sub", Ht(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSubscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSubscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
}), oG = Zi.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "super" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sup", Ht(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSuperscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSuperscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
}), sG = yn.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: "left"
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (t) => {
              const e = t.style.textAlign || this.options.defaultAlignment;
              return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
            },
            renderHTML: (t) => t.textAlign === this.options.defaultAlignment ? {} : { style: `text-align: ${t.textAlign}` }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (t) => ({ commands: e }) => this.options.alignments.includes(t) ? this.options.types.map((n) => e.updateAttributes(n, { textAlign: t })).every((n) => n) : !1,
      unsetTextAlign: () => ({ commands: t }) => this.options.types.map((e) => t.resetAttributes(e, "textAlign")).every((e) => e)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
}), aG = Zi.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (t) => t.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", Ht(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
        const n = Bb(t, this.type);
        return Object.entries(n).some(([, r]) => !!r) ? !0 : e.unsetMark(this.name);
      }
    };
  }
}), lG = yn.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (t) => {
              var e;
              return (e = t.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (t) => t.color ? {
              style: `color: ${t.color}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (t) => ({ chain: e }) => e().setMark("textStyle", { color: t }).run(),
      unsetColor: () => ({ chain: t }) => t().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
    };
  }
}), uG = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", cG = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", eu = (t, e) => {
  for (const n in e)
    t[n] = e[n];
  return t;
}, mv = "numeric", gv = "ascii", Ov = "alpha", yc = "asciinumeric", Ju = "alphanumeric", vv = "domain", _M = "emoji", dG = "scheme", hG = "slashscheme", Eg = "whitespace";
function fG(t, e) {
  return t in e || (e[t] = []), e[t];
}
function fa(t, e, n) {
  e[mv] && (e[yc] = !0, e[Ju] = !0), e[gv] && (e[yc] = !0, e[Ov] = !0), e[yc] && (e[Ju] = !0), e[Ov] && (e[Ju] = !0), e[Ju] && (e[vv] = !0), e[_M] && (e[vv] = !0);
  for (const i in e) {
    const r = fG(i, n);
    r.indexOf(t) < 0 && r.push(t);
  }
}
function pG(t, e) {
  const n = {};
  for (const i in e)
    e[i].indexOf(t) >= 0 && (n[i] = !0);
  return n;
}
function yi(t = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
yi.groups = {};
yi.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, n = e.j[t];
    if (n)
      return n;
    for (let i = 0; i < e.jr.length; i++) {
      const r = e.jr[i][0], o = e.jr[i][1];
      if (o && r.test(t))
        return o;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e = !1) {
    return e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, i) {
    for (let r = 0; r < t.length; r++)
      this.tt(t[r], e, n, i);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, i) {
    i = i || yi.groups;
    let r;
    return e && e.j ? r = e : (r = new yi(e), n && i && fa(e, n, i)), this.jr.push([t, r]), r;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, i) {
    let r = this;
    const o = t.length;
    if (!o)
      return r;
    for (let s = 0; s < o - 1; s++)
      r = r.tt(t[s]);
    return r.tt(t[o - 1], e, n, i);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, i) {
    i = i || yi.groups;
    const r = this;
    if (e && e.j)
      return r.j[t] = e, e;
    const o = e;
    let s, a = r.go(t);
    if (a ? (s = new yi(), eu(s.j, a.j), s.jr.push.apply(s.jr, a.jr), s.jd = a.jd, s.t = a.t) : s = new yi(), o) {
      if (i)
        if (s.t && typeof s.t == "string") {
          const l = eu(pG(s.t, i), n);
          fa(o, l, i);
        } else
          n && fa(o, n, i);
      s.t = o;
    }
    return r.j[t] = s, s;
  }
};
const ut = (t, e, n, i, r) => t.ta(e, n, i, r), on = (t, e, n, i, r) => t.tr(e, n, i, r), rS = (t, e, n, i, r) => t.ts(e, n, i, r), Ee = (t, e, n, i, r) => t.tt(e, n, i, r), So = "WORD", yv = "UWORD", xM = "ASCIINUMERICAL", CM = "ALPHANUMERICAL", Jc = "LOCALHOST", bv = "TLD", wv = "UTLD", Lh = "SCHEME", dl = "SLASH_SCHEME", Kb = "NUM", kv = "WS", Jb = "NL", bc = "OPENBRACE", wc = "CLOSEBRACE", Df = "OPENBRACKET", Qf = "CLOSEBRACKET", Nf = "OPENPAREN", If = "CLOSEPAREN", Lf = "OPENANGLEBRACKET", Vf = "CLOSEANGLEBRACKET", Bf = "FULLWIDTHLEFTPAREN", Zf = "FULLWIDTHRIGHTPAREN", Ff = "LEFTCORNERBRACKET", qf = "RIGHTCORNERBRACKET", Wf = "LEFTWHITECORNERBRACKET", Xf = "RIGHTWHITECORNERBRACKET", zf = "FULLWIDTHLESSTHAN", jf = "FULLWIDTHGREATERTHAN", Yf = "AMPERSAND", e0 = "APOSTROPHE", Hf = "ASTERISK", ss = "AT", Uf = "BACKSLASH", Gf = "BACKTICK", Kf = "CARET", cs = "COLON", t0 = "COMMA", Jf = "DOLLAR", Br = "DOT", ep = "EQUALS", n0 = "EXCLAMATION", zi = "HYPHEN", kc = "PERCENT", tp = "PIPE", np = "PLUS", ip = "POUND", Sc = "QUERY", i0 = "QUOTE", TM = "FULLWIDTHMIDDLEDOT", r0 = "SEMI", Zr = "SLASH", _c = "TILDE", rp = "UNDERSCORE", $M = "EMOJI", op = "SYM";
var PM = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD: So,
  UWORD: yv,
  ASCIINUMERICAL: xM,
  ALPHANUMERICAL: CM,
  LOCALHOST: Jc,
  TLD: bv,
  UTLD: wv,
  SCHEME: Lh,
  SLASH_SCHEME: dl,
  NUM: Kb,
  WS: kv,
  NL: Jb,
  OPENBRACE: bc,
  CLOSEBRACE: wc,
  OPENBRACKET: Df,
  CLOSEBRACKET: Qf,
  OPENPAREN: Nf,
  CLOSEPAREN: If,
  OPENANGLEBRACKET: Lf,
  CLOSEANGLEBRACKET: Vf,
  FULLWIDTHLEFTPAREN: Bf,
  FULLWIDTHRIGHTPAREN: Zf,
  LEFTCORNERBRACKET: Ff,
  RIGHTCORNERBRACKET: qf,
  LEFTWHITECORNERBRACKET: Wf,
  RIGHTWHITECORNERBRACKET: Xf,
  FULLWIDTHLESSTHAN: zf,
  FULLWIDTHGREATERTHAN: jf,
  AMPERSAND: Yf,
  APOSTROPHE: e0,
  ASTERISK: Hf,
  AT: ss,
  BACKSLASH: Uf,
  BACKTICK: Gf,
  CARET: Kf,
  COLON: cs,
  COMMA: t0,
  DOLLAR: Jf,
  DOT: Br,
  EQUALS: ep,
  EXCLAMATION: n0,
  HYPHEN: zi,
  PERCENT: kc,
  PIPE: tp,
  PLUS: np,
  POUND: ip,
  QUERY: Sc,
  QUOTE: i0,
  FULLWIDTHMIDDLEDOT: TM,
  SEMI: r0,
  SLASH: Zr,
  TILDE: _c,
  UNDERSCORE: rp,
  EMOJI: $M,
  SYM: op
});
const bo = /[a-z]/, Nu = /\p{L}/u, Ag = /\p{Emoji}/u, wo = /\d/, Rg = /\s/, oS = "\r", Dg = `
`, mG = "️", gG = "‍", Qg = "￼";
let nh = null, ih = null;
function OG(t = []) {
  const e = {};
  yi.groups = e;
  const n = new yi();
  nh == null && (nh = sS(uG)), ih == null && (ih = sS(cG)), Ee(n, "'", e0), Ee(n, "{", bc), Ee(n, "}", wc), Ee(n, "[", Df), Ee(n, "]", Qf), Ee(n, "(", Nf), Ee(n, ")", If), Ee(n, "<", Lf), Ee(n, ">", Vf), Ee(n, "（", Bf), Ee(n, "）", Zf), Ee(n, "「", Ff), Ee(n, "」", qf), Ee(n, "『", Wf), Ee(n, "』", Xf), Ee(n, "＜", zf), Ee(n, "＞", jf), Ee(n, "&", Yf), Ee(n, "*", Hf), Ee(n, "@", ss), Ee(n, "`", Gf), Ee(n, "^", Kf), Ee(n, ":", cs), Ee(n, ",", t0), Ee(n, "$", Jf), Ee(n, ".", Br), Ee(n, "=", ep), Ee(n, "!", n0), Ee(n, "-", zi), Ee(n, "%", kc), Ee(n, "|", tp), Ee(n, "+", np), Ee(n, "#", ip), Ee(n, "?", Sc), Ee(n, '"', i0), Ee(n, "/", Zr), Ee(n, ";", r0), Ee(n, "~", _c), Ee(n, "_", rp), Ee(n, "\\", Uf), Ee(n, "・", TM);
  const i = on(n, wo, Kb, {
    [mv]: !0
  });
  on(i, wo, i);
  const r = on(i, bo, xM, {
    [yc]: !0
  }), o = on(i, Nu, CM, {
    [Ju]: !0
  }), s = on(n, bo, So, {
    [gv]: !0
  });
  on(s, wo, r), on(s, bo, s), on(r, wo, r), on(r, bo, r);
  const a = on(n, Nu, yv, {
    [Ov]: !0
  });
  on(a, bo), on(a, wo, o), on(a, Nu, a), on(o, wo, o), on(o, bo), on(o, Nu, o);
  const l = Ee(n, Dg, Jb, {
    [Eg]: !0
  }), u = Ee(n, oS, kv, {
    [Eg]: !0
  }), c = on(n, Rg, kv, {
    [Eg]: !0
  });
  Ee(n, Qg, c), Ee(u, Dg, l), Ee(u, Qg, c), on(u, Rg, c), Ee(c, oS), Ee(c, Dg), on(c, Rg, c), Ee(c, Qg, c);
  const d = on(n, Ag, $M, {
    [_M]: !0
  });
  Ee(d, "#"), on(d, Ag, d), Ee(d, mG, d);
  const h = Ee(d, gG);
  Ee(h, "#"), on(h, Ag, d);
  const f = [[bo, s], [wo, r]], p = [[bo, null], [Nu, a], [wo, o]];
  for (let m = 0; m < nh.length; m++)
    es(n, nh[m], bv, So, f);
  for (let m = 0; m < ih.length; m++)
    es(n, ih[m], wv, yv, p);
  fa(bv, {
    tld: !0,
    ascii: !0
  }, e), fa(wv, {
    utld: !0,
    alpha: !0
  }, e), es(n, "file", Lh, So, f), es(n, "mailto", Lh, So, f), es(n, "http", dl, So, f), es(n, "https", dl, So, f), es(n, "ftp", dl, So, f), es(n, "ftps", dl, So, f), fa(Lh, {
    scheme: !0,
    ascii: !0
  }, e), fa(dl, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((m, g) => m[0] > g[0] ? 1 : -1);
  for (let m = 0; m < t.length; m++) {
    const g = t[m][0], y = t[m][1] ? {
      [dG]: !0
    } : {
      [hG]: !0
    };
    g.indexOf("-") >= 0 ? y[vv] = !0 : bo.test(g) ? wo.test(g) ? y[yc] = !0 : y[gv] = !0 : y[mv] = !0, rS(n, g, g, y);
  }
  return rS(n, "localhost", Jc, {
    ascii: !0
  }), n.jd = new yi(op), {
    start: n,
    tokens: eu({
      groups: e
    }, PM)
  };
}
function MM(t, e) {
  const n = vG(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), i = n.length, r = [];
  let o = 0, s = 0;
  for (; s < i; ) {
    let a = t, l = null, u = 0, c = null, d = -1, h = -1;
    for (; s < i && (l = a.go(n[s])); )
      a = l, a.accepts() ? (d = 0, h = 0, c = a) : d >= 0 && (d += n[s].length, h++), u += n[s].length, o += n[s].length, s++;
    o -= d, s -= h, u -= d, r.push({
      t: c.t,
      // token type/name
      v: e.slice(o - u, o),
      // string value
      s: o - u,
      // start index
      e: o
      // end index (excluding)
    });
  }
  return r;
}
function vG(t) {
  const e = [], n = t.length;
  let i = 0;
  for (; i < n; ) {
    let r = t.charCodeAt(i), o, s = r < 55296 || r > 56319 || i + 1 === n || (o = t.charCodeAt(i + 1)) < 56320 || o > 57343 ? t[i] : t.slice(i, i + 2);
    e.push(s), i += s.length;
  }
  return e;
}
function es(t, e, n, i, r) {
  let o;
  const s = e.length;
  for (let a = 0; a < s - 1; a++) {
    const l = e[a];
    t.j[l] ? o = t.j[l] : (o = new yi(i), o.jr = r.slice(), t.j[l] = o), t = o;
  }
  return o = new yi(n), o.jr = r.slice(), t.j[e[s - 1]] = o, o;
}
function sS(t) {
  const e = [], n = [];
  let i = 0, r = "0123456789";
  for (; i < t.length; ) {
    let o = 0;
    for (; r.indexOf(t[i + o]) >= 0; )
      o++;
    if (o > 0) {
      e.push(n.join(""));
      for (let s = parseInt(t.substring(i, i + o), 10); s > 0; s--)
        n.pop();
      i += o;
    } else
      n.push(t[i]), i++;
  }
  return e;
}
const ed = {
  defaultProtocol: "http",
  events: null,
  format: aS,
  formatHref: aS,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function o0(t, e = null) {
  let n = eu({}, ed);
  t && (n = eu(n, t instanceof o0 ? t.o : t));
  const i = n.ignoreTags, r = [];
  for (let o = 0; o < i.length; o++)
    r.push(i[o].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = r;
}
o0.prototype = {
  o: ed,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const i = e != null;
    let r = this.o[t];
    return r && (typeof r == "object" ? (r = n.t in r ? r[n.t] : ed[t], typeof r == "function" && i && (r = r(e, n))) : typeof r == "function" && i && (r = r(e, n.t, n)), r);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let i = this.o[t];
    return typeof i == "function" && e != null && (i = i(e, n.t, n)), i;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function aS(t) {
  return t;
}
function EM(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
EM.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), n = t.get("truncate", e, this), i = t.get("format", e, this);
    return n && i.length > n ? i.substring(0, n) + "…" : i;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t = ed.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, n = this.toHref(t.get("defaultProtocol")), i = t.get("formatHref", n, this), r = t.get("tagName", n, e), o = this.toFormattedString(t), s = {}, a = t.get("className", n, e), l = t.get("target", n, e), u = t.get("rel", n, e), c = t.getObj("attributes", n, e), d = t.getObj("events", n, e);
    return s.href = i, a && (s.class = a), l && (s.target = l), u && (s.rel = u), c && eu(s, c), {
      tagName: r,
      attributes: s,
      content: o,
      eventListeners: d
    };
  }
};
function bm(t, e) {
  class n extends EM {
    constructor(r, o) {
      super(r, o), this.t = t;
    }
  }
  for (const i in e)
    n.prototype[i] = e[i];
  return n.t = t, n;
}
const lS = bm("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), uS = bm("text"), yG = bm("nl"), rh = bm("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t = ed.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== Jc && t[1].t === cs;
  }
}), Xi = (t) => new yi(t);
function bG({
  groups: t
}) {
  const e = t.domain.concat([Yf, Hf, ss, Uf, Gf, Kf, Jf, ep, zi, Kb, kc, tp, np, ip, Zr, op, _c, rp]), n = [cs, t0, Br, n0, kc, Sc, i0, r0, Lf, Vf, bc, wc, Qf, Df, Nf, If, Bf, Zf, Ff, qf, Wf, Xf, zf, jf], i = [Yf, e0, Hf, Uf, Gf, Kf, Jf, ep, zi, bc, wc, kc, tp, np, ip, Sc, Zr, op, _c, rp], r = Xi(), o = Ee(r, _c);
  ut(o, i, o), ut(o, t.domain, o);
  const s = Xi(), a = Xi(), l = Xi();
  ut(r, t.domain, s), ut(r, t.scheme, a), ut(r, t.slashscheme, l), ut(s, i, o), ut(s, t.domain, s);
  const u = Ee(s, ss);
  Ee(o, ss, u), Ee(a, ss, u), Ee(l, ss, u);
  const c = Ee(o, Br);
  ut(c, i, o), ut(c, t.domain, o);
  const d = Xi();
  ut(u, t.domain, d), ut(d, t.domain, d);
  const h = Ee(d, Br);
  ut(h, t.domain, d);
  const f = Xi(lS);
  ut(h, t.tld, f), ut(h, t.utld, f), Ee(u, Jc, f);
  const p = Ee(d, zi);
  Ee(p, zi, p), ut(p, t.domain, d), ut(f, t.domain, d), Ee(f, Br, h), Ee(f, zi, p);
  const m = Ee(f, cs);
  ut(m, t.numeric, lS);
  const g = Ee(s, zi), O = Ee(s, Br);
  Ee(g, zi, g), ut(g, t.domain, s), ut(O, i, o), ut(O, t.domain, s);
  const y = Xi(rh);
  ut(O, t.tld, y), ut(O, t.utld, y), ut(y, t.domain, s), ut(y, i, o), Ee(y, Br, O), Ee(y, zi, g), Ee(y, ss, u);
  const b = Ee(y, cs), v = Xi(rh);
  ut(b, t.numeric, v);
  const k = Xi(rh), w = Xi();
  ut(k, e, k), ut(k, n, w), ut(w, e, k), ut(w, n, w), Ee(y, Zr, k), Ee(v, Zr, k);
  const S = Ee(a, cs), $ = Ee(l, cs), C = Ee($, Zr), L = Ee(C, Zr);
  ut(a, t.domain, s), Ee(a, Br, O), Ee(a, zi, g), ut(l, t.domain, s), Ee(l, Br, O), Ee(l, zi, g), ut(S, t.domain, k), Ee(S, Zr, k), Ee(S, Sc, k), ut(L, t.domain, k), ut(L, e, k), Ee(L, Zr, k);
  const j = [
    [bc, wc],
    // {}
    [Df, Qf],
    // []
    [Nf, If],
    // ()
    [Lf, Vf],
    // <>
    [Bf, Zf],
    // （）
    [Ff, qf],
    // 「」
    [Wf, Xf],
    // 『』
    [zf, jf]
    // ＜＞
  ];
  for (let P = 0; P < j.length; P++) {
    const [A, T] = j[P], N = Ee(k, A);
    Ee(w, A, N), Ee(N, T, k);
    const Q = Xi(rh);
    ut(N, e, Q);
    const Y = Xi();
    ut(N, n), ut(Q, e, Q), ut(Q, n, Y), ut(Y, e, Q), ut(Y, n, Y), Ee(Q, T, k), Ee(Y, T, k);
  }
  return Ee(r, Jc, y), Ee(r, Jb, yG), {
    start: r,
    tokens: PM
  };
}
function wG(t, e, n) {
  let i = n.length, r = 0, o = [], s = [];
  for (; r < i; ) {
    let a = t, l = null, u = null, c = 0, d = null, h = -1;
    for (; r < i && !(l = a.go(n[r].t)); )
      s.push(n[r++]);
    for (; r < i && (u = l || a.go(n[r].t)); )
      l = null, a = u, a.accepts() ? (h = 0, d = a) : h >= 0 && h++, r++, c++;
    if (h < 0)
      r -= c, r < i && (s.push(n[r]), r++);
    else {
      s.length > 0 && (o.push(Ng(uS, e, s)), s = []), r -= h, c -= h;
      const f = d.t, p = n.slice(r - c, r);
      o.push(Ng(f, e, p));
    }
  }
  return s.length > 0 && o.push(Ng(uS, e, s)), o;
}
function Ng(t, e, n) {
  const i = n[0].s, r = n[n.length - 1].e, o = e.slice(i, r);
  return new t(o, n);
}
const kG = typeof console < "u" && console && console.warn || (() => {
}), SG = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", Xt = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function _G() {
  return yi.groups = {}, Xt.scanner = null, Xt.parser = null, Xt.tokenQueue = [], Xt.pluginQueue = [], Xt.customSchemes = [], Xt.initialized = !1, Xt;
}
function cS(t, e = !1) {
  if (Xt.initialized && kG(`linkifyjs: already initialized - will not register custom scheme "${t}" ${SG}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  Xt.customSchemes.push([t, e]);
}
function xG() {
  Xt.scanner = OG(Xt.customSchemes);
  for (let t = 0; t < Xt.tokenQueue.length; t++)
    Xt.tokenQueue[t][1]({
      scanner: Xt.scanner
    });
  Xt.parser = bG(Xt.scanner.tokens);
  for (let t = 0; t < Xt.pluginQueue.length; t++)
    Xt.pluginQueue[t][1]({
      scanner: Xt.scanner,
      parser: Xt.parser
    });
  return Xt.initialized = !0, Xt;
}
function s0(t) {
  return Xt.initialized || xG(), wG(Xt.parser.start, t, MM(Xt.scanner.start, t));
}
s0.scan = MM;
function AM(t, e = null, n = null) {
  if (e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const i = new o0(n), r = s0(t), o = [];
  for (let s = 0; s < r.length; s++) {
    const a = r[s];
    a.isLink && (!e || a.t === e) && i.check(a) && o.push(a.toFormattedObject(i));
  }
  return o;
}
function CG(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function TG(t) {
  return new rn({
    key: new _n("autolink"),
    appendTransaction: (e, n, i) => {
      const r = e.some((u) => u.docChanged) && !n.doc.eq(i.doc), o = e.some((u) => u.getMeta("preventAutolink"));
      if (!r || o)
        return;
      const { tr: s } = i, a = AU(n.doc, [...e]);
      if (VU(a).forEach(({ newRange: u }) => {
        const c = DU(i.doc, u, (f) => f.isTextblock);
        let d, h;
        if (c.length > 1 ? (d = c[0], h = i.doc.textBetween(d.pos, d.pos + d.node.nodeSize, void 0, " ")) : c.length && i.doc.textBetween(u.from, u.to, " ", " ").endsWith(" ") && (d = c[0], h = i.doc.textBetween(d.pos, u.to, void 0, " ")), d && h) {
          const f = h.split(" ").filter((O) => O !== "");
          if (f.length <= 0)
            return !1;
          const p = f[f.length - 1], m = d.pos + h.lastIndexOf(p);
          if (!p)
            return !1;
          const g = s0(p).map((O) => O.toObject(t.defaultProtocol));
          if (!CG(g))
            return !1;
          g.filter((O) => O.isLink).map((O) => ({
            ...O,
            from: m + O.start + 1,
            to: m + O.end + 1
          })).filter((O) => i.schema.marks.code ? !i.doc.rangeHasMark(O.from, O.to, i.schema.marks.code) : !0).filter((O) => t.validate(O.value)).filter((O) => t.shouldAutoLink(O.value)).forEach((O) => {
            Fb(O.from, O.to, i.doc).some((y) => y.mark.type === t.type) || s.addMark(O.from, O.to, t.type.create({
              href: O.href
            }));
          });
        }
      }), !!s.steps.length)
        return s;
    }
  });
}
function $G(t) {
  return new rn({
    key: new _n("handleClickLink"),
    props: {
      handleClick: (e, n, i) => {
        var r, o;
        if (i.button !== 0 || !e.editable)
          return !1;
        let s = i.target;
        const a = [];
        for (; s.nodeName !== "DIV"; )
          a.push(s), s = s.parentNode;
        if (!a.find((h) => h.nodeName === "A"))
          return !1;
        const l = YP(e.state, t.type.name), u = i.target, c = (r = u == null ? void 0 : u.href) !== null && r !== void 0 ? r : l.href, d = (o = u == null ? void 0 : u.target) !== null && o !== void 0 ? o : l.target;
        return u && c ? (window.open(c, d), !0) : !1;
      }
    }
  });
}
function PG(t) {
  return new rn({
    key: new _n("handlePasteLink"),
    props: {
      handlePaste: (e, n, i) => {
        const { state: r } = e, { selection: o } = r, { empty: s } = o;
        if (s)
          return !1;
        let a = "";
        i.content.forEach((u) => {
          a += u.textContent;
        });
        const l = AM(a, { defaultProtocol: t.defaultProtocol }).find((u) => u.isLink && u.value === a);
        return !a || !l ? !1 : (t.editor.commands.setMark(t.type, {
          href: l.href
        }), !0);
      }
    }
  });
}
const MG = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function Iu(t, e) {
  const n = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  return e && e.forEach((i) => {
    const r = typeof i == "string" ? i : i.scheme;
    r && n.push(r);
  }), !t || t.replace(MG, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${n.join("|")}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
const EG = Zi.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        cS(t);
        return;
      }
      cS(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    _G();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t, e) => !!Iu(t, e.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => !!t
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          const e = t.getAttribute("href");
          return !e || !this.options.isAllowedUri(e, {
            defaultValidate: (n) => !!Iu(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (e) => !!Iu(e, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", Ht(this.options.HTMLAttributes, t), 0] : [
      "a",
      Ht(this.options.HTMLAttributes, { ...t, href: "" }),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: e }) => e().setMark(this.name, t).setMeta("preventAutolink", !0).run(),
      toggleLink: (t) => ({ chain: e }) => e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run(),
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Ia({
        find: (t) => {
          const e = [];
          if (t) {
            const { protocols: n, defaultProtocol: i } = this.options, r = AM(t).filter((o) => o.isLink && this.options.isAllowedUri(o.value, {
              defaultValidate: (s) => !!Iu(s, n),
              protocols: n,
              defaultProtocol: i
            }));
            r.length && r.forEach((o) => e.push({
              text: o.value,
              data: {
                href: o.href
              },
              index: o.start
            }));
          }
          return e;
        },
        type: this.type,
        getAttributes: (t) => {
          var e;
          return {
            href: (e = t.data) === null || e === void 0 ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [], { protocols: e, defaultProtocol: n } = this.options;
    return this.options.autolink && t.push(TG({
      type: this.type,
      defaultProtocol: this.options.defaultProtocol,
      validate: (i) => this.options.isAllowedUri(i, {
        defaultValidate: (r) => !!Iu(r, e),
        protocols: e,
        defaultProtocol: n
      }),
      shouldAutoLink: this.options.shouldAutoLink
    })), this.options.openOnClick === !0 && t.push($G({
      type: this.type
    })), this.options.linkOnPaste && t.push(PG({
      editor: this.editor,
      defaultProtocol: this.options.defaultProtocol,
      type: this.type
    })), t;
  }
}), AG = yn.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (t) => t.length,
      wordCounter: (t) => t.split(" ").filter((e) => e !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (t) => {
      const e = (t == null ? void 0 : t.node) || this.editor.state.doc;
      if (((t == null ? void 0 : t.mode) || this.options.mode) === "textSize") {
        const i = e.textBetween(0, e.content.size, void 0, " ");
        return this.options.textCounter(i);
      }
      return e.nodeSize;
    }, this.storage.words = (t) => {
      const e = (t == null ? void 0 : t.node) || this.editor.state.doc, n = e.textBetween(0, e.content.size, " ", " ");
      return this.options.wordCounter(n);
    };
  },
  addProseMirrorPlugins() {
    let t = !1;
    return [
      new rn({
        key: new _n("characterCount"),
        appendTransaction: (e, n, i) => {
          if (t)
            return;
          const r = this.options.limit;
          if (r == null || r === 0) {
            t = !0;
            return;
          }
          const o = this.storage.characters({ node: i.doc });
          if (o > r) {
            const s = o - r, a = 0, l = s;
            console.warn(`[CharacterCount] Initial content exceeded limit of ${r} characters. Content was automatically trimmed.`);
            const u = i.tr.deleteRange(a, l);
            return t = !0, u;
          }
          t = !0;
        },
        filterTransaction: (e, n) => {
          const i = this.options.limit;
          if (!e.docChanged || i === 0 || i === null || i === void 0)
            return !0;
          const r = this.storage.characters({ node: n.doc }), o = this.storage.characters({ node: e.doc });
          if (o <= i || r > i && o > i && o <= r)
            return !0;
          if (r > i && o > i && o > r || !e.getMeta("paste"))
            return !1;
          const a = e.selection.$head.pos, l = o - i, u = a - l, c = a;
          return e.deleteRange(u, c), !(this.storage.characters({ node: e.doc }) > i);
        }
      })
    ];
  }
});
var Sv, _v;
if (typeof WeakMap < "u") {
  let t = /* @__PURE__ */ new WeakMap();
  Sv = (e) => t.get(e), _v = (e, n) => (t.set(e, n), n);
} else {
  const t = [];
  let n = 0;
  Sv = (i) => {
    for (let r = 0; r < t.length; r += 2)
      if (t[r] == i)
        return t[r + 1];
  }, _v = (i, r) => (n == 10 && (n = 0), t[n++] = i, t[n++] = r);
}
var ln = class {
  constructor(t, e, n, i) {
    this.width = t, this.height = e, this.map = n, this.problems = i;
  }
  // Find the dimensions of the cell at the given position.
  findCell(t) {
    for (let e = 0; e < this.map.length; e++) {
      const n = this.map[e];
      if (n != t)
        continue;
      const i = e % this.width, r = e / this.width | 0;
      let o = i + 1, s = r + 1;
      for (let a = 1; o < this.width && this.map[e + a] == n; a++)
        o++;
      for (let a = 1; s < this.height && this.map[e + this.width * a] == n; a++)
        s++;
      return { left: i, top: r, right: o, bottom: s };
    }
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(t) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == t)
        return e % this.width;
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(t, e, n) {
    const { left: i, right: r, top: o, bottom: s } = this.findCell(t);
    return e == "horiz" ? (n < 0 ? i == 0 : r == this.width) ? null : this.map[o * this.width + (n < 0 ? i - 1 : r)] : (n < 0 ? o == 0 : s == this.height) ? null : this.map[i + this.width * (n < 0 ? o - 1 : s)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(t, e) {
    const {
      left: n,
      right: i,
      top: r,
      bottom: o
    } = this.findCell(t), {
      left: s,
      right: a,
      top: l,
      bottom: u
    } = this.findCell(e);
    return {
      left: Math.min(n, s),
      top: Math.min(r, l),
      right: Math.max(i, a),
      bottom: Math.max(o, u)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(t) {
    const e = [], n = {};
    for (let i = t.top; i < t.bottom; i++)
      for (let r = t.left; r < t.right; r++) {
        const o = i * this.width + r, s = this.map[o];
        n[s] || (n[s] = !0, !(r == t.left && r && this.map[o - 1] == s || i == t.top && i && this.map[o - this.width] == s) && e.push(s));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(t, e, n) {
    for (let i = 0, r = 0; ; i++) {
      const o = r + n.child(i).nodeSize;
      if (i == t) {
        let s = e + t * this.width;
        const a = (t + 1) * this.width;
        for (; s < a && this.map[s] < r; )
          s++;
        return s == a ? o - 1 : this.map[s];
      }
      r = o;
    }
  }
  // Find the table map for the given table node.
  static get(t) {
    return Sv(t) || _v(t, RG(t));
  }
};
function RG(t) {
  if (t.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + t.type.name);
  const e = DG(t), n = t.childCount, i = [];
  let r = 0, o = null;
  const s = [];
  for (let u = 0, c = e * n; u < c; u++)
    i[u] = 0;
  for (let u = 0, c = 0; u < n; u++) {
    const d = t.child(u);
    c++;
    for (let p = 0; ; p++) {
      for (; r < i.length && i[r] != 0; )
        r++;
      if (p == d.childCount)
        break;
      const m = d.child(p), { colspan: g, rowspan: O, colwidth: y } = m.attrs;
      for (let b = 0; b < O; b++) {
        if (b + u >= n) {
          (o || (o = [])).push({
            type: "overlong_rowspan",
            pos: c,
            n: O - b
          });
          break;
        }
        const v = r + b * e;
        for (let k = 0; k < g; k++) {
          i[v + k] == 0 ? i[v + k] = c : (o || (o = [])).push({
            type: "collision",
            row: u,
            pos: c,
            n: g - k
          });
          const w = y && y[k];
          if (w) {
            const S = (v + k) % e * 2, $ = s[S];
            $ == null || $ != w && s[S + 1] == 1 ? (s[S] = w, s[S + 1] = 1) : $ == w && s[S + 1]++;
          }
        }
      }
      r += g, c += m.nodeSize;
    }
    const h = (u + 1) * e;
    let f = 0;
    for (; r < h; )
      i[r++] == 0 && f++;
    f && (o || (o = [])).push({ type: "missing", row: u, n: f }), c++;
  }
  const a = new ln(e, n, i, o);
  let l = !1;
  for (let u = 0; !l && u < s.length; u += 2)
    s[u] != null && s[u + 1] < n && (l = !0);
  return l && QG(a, s, t), a;
}
function DG(t) {
  let e = -1, n = !1;
  for (let i = 0; i < t.childCount; i++) {
    const r = t.child(i);
    let o = 0;
    if (n)
      for (let s = 0; s < i; s++) {
        const a = t.child(s);
        for (let l = 0; l < a.childCount; l++) {
          const u = a.child(l);
          s + u.attrs.rowspan > i && (o += u.attrs.colspan);
        }
      }
    for (let s = 0; s < r.childCount; s++) {
      const a = r.child(s);
      o += a.attrs.colspan, a.attrs.rowspan > 1 && (n = !0);
    }
    e == -1 ? e = o : e != o && (e = Math.max(e, o));
  }
  return e;
}
function QG(t, e, n) {
  t.problems || (t.problems = []);
  const i = {};
  for (let r = 0; r < t.map.length; r++) {
    const o = t.map[r];
    if (i[o])
      continue;
    i[o] = !0;
    const s = n.nodeAt(o);
    if (!s)
      throw new RangeError(`No cell with offset ${o} found`);
    let a = null;
    const l = s.attrs;
    for (let u = 0; u < l.colspan; u++) {
      const c = (r + u) % t.width, d = e[c * 2];
      d != null && (!l.colwidth || l.colwidth[u] != d) && ((a || (a = NG(l)))[u] = d);
    }
    a && t.problems.unshift({
      type: "colwidth mismatch",
      pos: o,
      colwidth: a
    });
  }
}
function NG(t) {
  if (t.colwidth)
    return t.colwidth.slice();
  const e = [];
  for (let n = 0; n < t.colspan; n++)
    e.push(0);
  return e;
}
function Kn(t) {
  let e = t.cached.tableNodeTypes;
  if (!e) {
    e = t.cached.tableNodeTypes = {};
    for (const n in t.nodes) {
      const i = t.nodes[n], r = i.spec.tableRole;
      r && (e[r] = i);
    }
  }
  return e;
}
var ds = new _n("selectingCells");
function bu(t) {
  for (let e = t.depth - 1; e > 0; e--)
    if (t.node(e).type.spec.tableRole == "row")
      return t.node(0).resolve(t.before(e + 1));
  return null;
}
function IG(t) {
  for (let e = t.depth; e > 0; e--) {
    const n = t.node(e).type.spec.tableRole;
    if (n === "cell" || n === "header_cell")
      return t.node(e);
  }
  return null;
}
function Mr(t) {
  const e = t.selection.$head;
  for (let n = e.depth; n > 0; n--)
    if (e.node(n).type.spec.tableRole == "row")
      return !0;
  return !1;
}
function wm(t) {
  const e = t.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const n = bu(e.$head) || LG(e.$head);
  if (n)
    return n;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function LG(t) {
  for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
    const i = e.type.spec.tableRole;
    if (i == "cell" || i == "header_cell")
      return t.doc.resolve(n);
  }
  for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
    const i = e.type.spec.tableRole;
    if (i == "cell" || i == "header_cell")
      return t.doc.resolve(n - e.nodeSize);
  }
}
function xv(t) {
  return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function VG(t) {
  return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function a0(t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function RM(t, e, n) {
  const i = t.node(-1), r = ln.get(i), o = t.start(-1), s = r.nextCell(t.pos - o, e, n);
  return s == null ? null : t.node(0).resolve(o + s);
}
function Va(t, e, n = 1) {
  const i = { ...t, colspan: t.colspan - n };
  return i.colwidth && (i.colwidth = i.colwidth.slice(), i.colwidth.splice(e, n), i.colwidth.some((r) => r > 0) || (i.colwidth = null)), i;
}
function DM(t, e, n = 1) {
  const i = { ...t, colspan: t.colspan + n };
  if (i.colwidth) {
    i.colwidth = i.colwidth.slice();
    for (let r = 0; r < n; r++)
      i.colwidth.splice(e, 0, 0);
  }
  return i;
}
function BG(t, e, n) {
  const i = Kn(e.type.schema).header_cell;
  for (let r = 0; r < t.height; r++)
    if (e.nodeAt(t.map[n + r * t.width]).type != i)
      return !1;
  return !0;
}
var Ft = class _o extends tt {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, n = e) {
    const i = e.node(-1), r = ln.get(i), o = e.start(-1), s = r.rectBetween(
      e.pos - o,
      n.pos - o
    ), a = e.node(0), l = r.cellsInRect(s).filter((c) => c != n.pos - o);
    l.unshift(n.pos - o);
    const u = l.map((c) => {
      const d = i.nodeAt(c);
      if (!d)
        throw RangeError(`No cell with offset ${c} found`);
      const h = o + c + 1;
      return new j$(
        a.resolve(h),
        a.resolve(h + d.content.size)
      );
    });
    super(u[0].$from, u[0].$to, u), this.$anchorCell = e, this.$headCell = n;
  }
  map(e, n) {
    const i = e.resolve(n.map(this.$anchorCell.pos)), r = e.resolve(n.map(this.$headCell.pos));
    if (xv(i) && xv(r) && a0(i, r)) {
      const o = this.$anchorCell.node(-1) != i.node(-1);
      return o && this.isRowSelection() ? _o.rowSelection(i, r) : o && this.isColSelection() ? _o.colSelection(i, r) : new _o(i, r);
    }
    return Je.between(i, r);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), n = ln.get(e), i = this.$anchorCell.start(-1), r = n.rectBetween(
      this.$anchorCell.pos - i,
      this.$headCell.pos - i
    ), o = {}, s = [];
    for (let l = r.top; l < r.bottom; l++) {
      const u = [];
      for (let c = l * n.width + r.left, d = r.left; d < r.right; d++, c++) {
        const h = n.map[c];
        if (o[h])
          continue;
        o[h] = !0;
        const f = n.findCell(h);
        let p = e.nodeAt(h);
        if (!p)
          throw RangeError(`No cell with offset ${h} found`);
        const m = r.left - f.left, g = f.right - r.right;
        if (m > 0 || g > 0) {
          let O = p.attrs;
          if (m > 0 && (O = Va(O, 0, m)), g > 0 && (O = Va(
            O,
            O.colspan - g,
            g
          )), f.left < r.left) {
            if (p = p.type.createAndFill(O), !p)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(O)}`
              );
          } else
            p = p.type.create(O, p.content);
        }
        if (f.top < r.top || f.bottom > r.bottom) {
          const O = {
            ...p.attrs,
            rowspan: Math.min(f.bottom, r.bottom) - Math.max(f.top, r.top)
          };
          f.top < r.top ? p = p.type.createAndFill(O) : p = p.type.create(O, p.content);
        }
        u.push(p);
      }
      s.push(e.child(l).copy(we.from(u)));
    }
    const a = this.isColSelection() && this.isRowSelection() ? e : s;
    return new Ne(we.from(a), 1, 1);
  }
  replace(e, n = Ne.empty) {
    const i = e.steps.length, r = this.ranges;
    for (let s = 0; s < r.length; s++) {
      const { $from: a, $to: l } = r[s], u = e.mapping.slice(i);
      e.replace(
        u.map(a.pos),
        u.map(l.pos),
        s ? Ne.empty : n
      );
    }
    const o = tt.findFrom(
      e.doc.resolve(e.mapping.slice(i).map(this.to)),
      -1
    );
    o && e.setSelection(o);
  }
  replaceWith(e, n) {
    this.replace(e, new Ne(we.from(n), 0, 0));
  }
  forEachCell(e) {
    const n = this.$anchorCell.node(-1), i = ln.get(n), r = this.$anchorCell.start(-1), o = i.cellsInRect(
      i.rectBetween(
        this.$anchorCell.pos - r,
        this.$headCell.pos - r
      )
    );
    for (let s = 0; s < o.length; s++)
      e(n.nodeAt(o[s]), r + o[s]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
    if (Math.min(e, n) > 0)
      return !1;
    const i = e + this.$anchorCell.nodeAfter.attrs.rowspan, r = n + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(i, r) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, n = e) {
    const i = e.node(-1), r = ln.get(i), o = e.start(-1), s = r.findCell(e.pos - o), a = r.findCell(n.pos - o), l = e.node(0);
    return s.top <= a.top ? (s.top > 0 && (e = l.resolve(o + r.map[s.left])), a.bottom < r.height && (n = l.resolve(
      o + r.map[r.width * (r.height - 1) + a.right - 1]
    ))) : (a.top > 0 && (n = l.resolve(o + r.map[a.left])), s.bottom < r.height && (e = l.resolve(
      o + r.map[r.width * (r.height - 1) + s.right - 1]
    ))), new _o(e, n);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), n = ln.get(e), i = this.$anchorCell.start(-1), r = n.colCount(this.$anchorCell.pos - i), o = n.colCount(this.$headCell.pos - i);
    if (Math.min(r, o) > 0)
      return !1;
    const s = r + this.$anchorCell.nodeAfter.attrs.colspan, a = o + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(s, a) == n.width;
  }
  eq(e) {
    return e instanceof _o && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, n = e) {
    const i = e.node(-1), r = ln.get(i), o = e.start(-1), s = r.findCell(e.pos - o), a = r.findCell(n.pos - o), l = e.node(0);
    return s.left <= a.left ? (s.left > 0 && (e = l.resolve(
      o + r.map[s.top * r.width]
    )), a.right < r.width && (n = l.resolve(
      o + r.map[r.width * (a.top + 1) - 1]
    ))) : (a.left > 0 && (n = l.resolve(o + r.map[a.top * r.width])), s.right < r.width && (e = l.resolve(
      o + r.map[r.width * (s.top + 1) - 1]
    ))), new _o(e, n);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, n) {
    return new _o(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, i = n) {
    return new _o(e.resolve(n), e.resolve(i));
  }
  getBookmark() {
    return new ZG(this.$anchorCell.pos, this.$headCell.pos);
  }
};
Ft.prototype.visible = !1;
tt.jsonID("cell", Ft);
var ZG = class QM {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new QM(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), i = e.resolve(this.head);
    return n.parent.type.spec.tableRole == "row" && i.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && i.index() < i.parent.childCount && a0(n, i) ? new Ft(n, i) : tt.near(i, 1);
  }
};
function FG(t) {
  if (!(t.selection instanceof Ft))
    return null;
  const e = [];
  return t.selection.forEachCell((n, i) => {
    e.push(
      Cr.node(i, i + n.nodeSize, { class: "selectedCell" })
    );
  }), Jt.create(t.doc, e);
}
function qG({ $from: t, $to: e }) {
  if (t.pos == e.pos || t.pos < e.pos - 6)
    return !1;
  let n = t.pos, i = e.pos, r = t.depth;
  for (; r >= 0 && !(t.after(r + 1) < t.end(r)); r--, n++)
    ;
  for (let o = e.depth; o >= 0 && !(e.before(o + 1) > e.start(o)); o--, i--)
    ;
  return n == i && /row|table/.test(t.node(r).type.spec.tableRole);
}
function WG({ $from: t, $to: e }) {
  let n, i;
  for (let r = t.depth; r > 0; r--) {
    const o = t.node(r);
    if (o.type.spec.tableRole === "cell" || o.type.spec.tableRole === "header_cell") {
      n = o;
      break;
    }
  }
  for (let r = e.depth; r > 0; r--) {
    const o = e.node(r);
    if (o.type.spec.tableRole === "cell" || o.type.spec.tableRole === "header_cell") {
      i = o;
      break;
    }
  }
  return n !== i && e.parentOffset === 0;
}
function XG(t, e, n) {
  const i = (e || t).selection, r = (e || t).doc;
  let o, s;
  if (i instanceof Ke && (s = i.node.type.spec.tableRole)) {
    if (s == "cell" || s == "header_cell")
      o = Ft.create(r, i.from);
    else if (s == "row") {
      const a = r.resolve(i.from + 1);
      o = Ft.rowSelection(a, a);
    } else if (!n) {
      const a = ln.get(i.node), l = i.from + 1, u = l + a.map[a.width * a.height - 1];
      o = Ft.create(r, l + 1, u);
    }
  } else
    i instanceof Je && qG(i) ? o = Je.create(r, i.from) : i instanceof Je && WG(i) && (o = Je.create(r, i.$from.start(), i.$from.end()));
  return o && (e || (e = t.tr)).setSelection(o), e;
}
var zG = new _n("fix-tables");
function NM(t, e, n, i) {
  const r = t.childCount, o = e.childCount;
  e:
    for (let s = 0, a = 0; s < o; s++) {
      const l = e.child(s);
      for (let u = a, c = Math.min(r, s + 3); u < c; u++)
        if (t.child(u) == l) {
          a = u + 1, n += l.nodeSize;
          continue e;
        }
      i(l, n), a < r && t.child(a).sameMarkup(l) ? NM(t.child(a), l, n + 1, i) : l.nodesBetween(0, l.content.size, i, n + 1), n += l.nodeSize;
    }
}
function IM(t, e) {
  let n;
  const i = (r, o) => {
    r.type.spec.tableRole == "table" && (n = jG(t, r, o, n));
  };
  return e ? e.doc != t.doc && NM(e.doc, t.doc, 0, i) : t.doc.descendants(i), n;
}
function jG(t, e, n, i) {
  const r = ln.get(e);
  if (!r.problems)
    return i;
  i || (i = t.tr);
  const o = [];
  for (let l = 0; l < r.height; l++)
    o.push(0);
  for (let l = 0; l < r.problems.length; l++) {
    const u = r.problems[l];
    if (u.type == "collision") {
      const c = e.nodeAt(u.pos);
      if (!c)
        continue;
      const d = c.attrs;
      for (let h = 0; h < d.rowspan; h++)
        o[u.row + h] += u.n;
      i.setNodeMarkup(
        i.mapping.map(n + 1 + u.pos),
        null,
        Va(d, d.colspan - u.n, u.n)
      );
    } else if (u.type == "missing")
      o[u.row] += u.n;
    else if (u.type == "overlong_rowspan") {
      const c = e.nodeAt(u.pos);
      if (!c)
        continue;
      i.setNodeMarkup(i.mapping.map(n + 1 + u.pos), null, {
        ...c.attrs,
        rowspan: c.attrs.rowspan - u.n
      });
    } else if (u.type == "colwidth mismatch") {
      const c = e.nodeAt(u.pos);
      if (!c)
        continue;
      i.setNodeMarkup(i.mapping.map(n + 1 + u.pos), null, {
        ...c.attrs,
        colwidth: u.colwidth
      });
    }
  }
  let s, a;
  for (let l = 0; l < o.length; l++)
    o[l] && (s == null && (s = l), a = l);
  for (let l = 0, u = n + 1; l < r.height; l++) {
    const c = e.child(l), d = u + c.nodeSize, h = o[l];
    if (h > 0) {
      let f = "cell";
      c.firstChild && (f = c.firstChild.type.spec.tableRole);
      const p = [];
      for (let g = 0; g < h; g++) {
        const O = Kn(t.schema)[f].createAndFill();
        O && p.push(O);
      }
      const m = (l == 0 || s == l - 1) && a == l ? u + 1 : d - 1;
      i.insert(i.mapping.map(m), p);
    }
    u = d;
  }
  return i.setMeta(zG, { fixTables: !0 });
}
function po(t) {
  const e = t.selection, n = wm(t), i = n.node(-1), r = n.start(-1), o = ln.get(i);
  return { ...e instanceof Ft ? o.rectBetween(
    e.$anchorCell.pos - r,
    e.$headCell.pos - r
  ) : o.findCell(n.pos - r), tableStart: r, map: o, table: i };
}
function LM(t, { map: e, tableStart: n, table: i }, r) {
  let o = r > 0 ? -1 : 0;
  BG(e, i, r + o) && (o = r == 0 || r == e.width ? null : 0);
  for (let s = 0; s < e.height; s++) {
    const a = s * e.width + r;
    if (r > 0 && r < e.width && e.map[a - 1] == e.map[a]) {
      const l = e.map[a], u = i.nodeAt(l);
      t.setNodeMarkup(
        t.mapping.map(n + l),
        null,
        DM(u.attrs, r - e.colCount(l))
      ), s += u.attrs.rowspan - 1;
    } else {
      const l = o == null ? Kn(i.type.schema).cell : i.nodeAt(e.map[a + o]).type, u = e.positionAt(s, r, i);
      t.insert(t.mapping.map(n + u), l.createAndFill());
    }
  }
  return t;
}
function YG(t, e) {
  if (!Mr(t))
    return !1;
  if (e) {
    const n = po(t);
    e(LM(t.tr, n, n.left));
  }
  return !0;
}
function HG(t, e) {
  if (!Mr(t))
    return !1;
  if (e) {
    const n = po(t);
    e(LM(t.tr, n, n.right));
  }
  return !0;
}
function UG(t, { map: e, table: n, tableStart: i }, r) {
  const o = t.mapping.maps.length;
  for (let s = 0; s < e.height; ) {
    const a = s * e.width + r, l = e.map[a], u = n.nodeAt(l), c = u.attrs;
    if (r > 0 && e.map[a - 1] == l || r < e.width - 1 && e.map[a + 1] == l)
      t.setNodeMarkup(
        t.mapping.slice(o).map(i + l),
        null,
        Va(c, r - e.colCount(l))
      );
    else {
      const d = t.mapping.slice(o).map(i + l);
      t.delete(d, d + u.nodeSize);
    }
    s += c.rowspan;
  }
}
function GG(t, e) {
  if (!Mr(t))
    return !1;
  if (e) {
    const n = po(t), i = t.tr;
    if (n.left == 0 && n.right == n.map.width)
      return !1;
    for (let r = n.right - 1; UG(i, n, r), r != n.left; r--) {
      const o = n.tableStart ? i.doc.nodeAt(n.tableStart - 1) : i.doc;
      if (!o)
        throw RangeError("No table found");
      n.table = o, n.map = ln.get(o);
    }
    e(i);
  }
  return !0;
}
function KG(t, e, n) {
  var i;
  const r = Kn(e.type.schema).header_cell;
  for (let o = 0; o < t.width; o++)
    if (((i = e.nodeAt(t.map[o + n * t.width])) == null ? void 0 : i.type) != r)
      return !1;
  return !0;
}
function VM(t, { map: e, tableStart: n, table: i }, r) {
  var o;
  let s = n;
  for (let u = 0; u < r; u++)
    s += i.child(u).nodeSize;
  const a = [];
  let l = r > 0 ? -1 : 0;
  KG(e, i, r + l) && (l = r == 0 || r == e.height ? null : 0);
  for (let u = 0, c = e.width * r; u < e.width; u++, c++)
    if (r > 0 && r < e.height && e.map[c] == e.map[c - e.width]) {
      const d = e.map[c], h = i.nodeAt(d).attrs;
      t.setNodeMarkup(n + d, null, {
        ...h,
        rowspan: h.rowspan + 1
      }), u += h.colspan - 1;
    } else {
      const d = l == null ? Kn(i.type.schema).cell : (o = i.nodeAt(e.map[c + l * e.width])) == null ? void 0 : o.type, h = d == null ? void 0 : d.createAndFill();
      h && a.push(h);
    }
  return t.insert(s, Kn(i.type.schema).row.create(null, a)), t;
}
function JG(t, e) {
  if (!Mr(t))
    return !1;
  if (e) {
    const n = po(t);
    e(VM(t.tr, n, n.top));
  }
  return !0;
}
function e9(t, e) {
  if (!Mr(t))
    return !1;
  if (e) {
    const n = po(t);
    e(VM(t.tr, n, n.bottom));
  }
  return !0;
}
function t9(t, { map: e, table: n, tableStart: i }, r) {
  let o = 0;
  for (let u = 0; u < r; u++)
    o += n.child(u).nodeSize;
  const s = o + n.child(r).nodeSize, a = t.mapping.maps.length;
  t.delete(o + i, s + i);
  const l = /* @__PURE__ */ new Set();
  for (let u = 0, c = r * e.width; u < e.width; u++, c++) {
    const d = e.map[c];
    if (!l.has(d)) {
      if (l.add(d), r > 0 && d == e.map[c - e.width]) {
        const h = n.nodeAt(d).attrs;
        t.setNodeMarkup(t.mapping.slice(a).map(d + i), null, {
          ...h,
          rowspan: h.rowspan - 1
        }), u += h.colspan - 1;
      } else if (r < e.height && d == e.map[c + e.width]) {
        const h = n.nodeAt(d), f = h.attrs, p = h.type.create(
          { ...f, rowspan: h.attrs.rowspan - 1 },
          h.content
        ), m = e.positionAt(r + 1, u, n);
        t.insert(t.mapping.slice(a).map(i + m), p), u += f.colspan - 1;
      }
    }
  }
}
function n9(t, e) {
  if (!Mr(t))
    return !1;
  if (e) {
    const n = po(t), i = t.tr;
    if (n.top == 0 && n.bottom == n.map.height)
      return !1;
    for (let r = n.bottom - 1; t9(i, n, r), r != n.top; r--) {
      const o = n.tableStart ? i.doc.nodeAt(n.tableStart - 1) : i.doc;
      if (!o)
        throw RangeError("No table found");
      n.table = o, n.map = ln.get(n.table);
    }
    e(i);
  }
  return !0;
}
function dS(t) {
  const e = t.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function i9({ width: t, height: e, map: n }, i) {
  let r = i.top * t + i.left, o = r, s = (i.bottom - 1) * t + i.left, a = r + (i.right - i.left - 1);
  for (let l = i.top; l < i.bottom; l++) {
    if (i.left > 0 && n[o] == n[o - 1] || i.right < t && n[a] == n[a + 1])
      return !0;
    o += t, a += t;
  }
  for (let l = i.left; l < i.right; l++) {
    if (i.top > 0 && n[r] == n[r - t] || i.bottom < e && n[s] == n[s + t])
      return !0;
    r++, s++;
  }
  return !1;
}
function hS(t, e) {
  const n = t.selection;
  if (!(n instanceof Ft) || n.$anchorCell.pos == n.$headCell.pos)
    return !1;
  const i = po(t), { map: r } = i;
  if (i9(r, i))
    return !1;
  if (e) {
    const o = t.tr, s = {};
    let a = we.empty, l, u;
    for (let c = i.top; c < i.bottom; c++)
      for (let d = i.left; d < i.right; d++) {
        const h = r.map[c * r.width + d], f = i.table.nodeAt(h);
        if (!(s[h] || !f))
          if (s[h] = !0, l == null)
            l = h, u = f;
          else {
            dS(f) || (a = a.append(f.content));
            const p = o.mapping.map(h + i.tableStart);
            o.delete(p, p + f.nodeSize);
          }
      }
    if (l == null || u == null)
      return !0;
    if (o.setNodeMarkup(l + i.tableStart, null, {
      ...DM(
        u.attrs,
        u.attrs.colspan,
        i.right - i.left - u.attrs.colspan
      ),
      rowspan: i.bottom - i.top
    }), a.size) {
      const c = l + 1 + u.content.size, d = dS(u) ? l + 1 : c;
      o.replaceWith(d + i.tableStart, c + i.tableStart, a);
    }
    o.setSelection(
      new Ft(o.doc.resolve(l + i.tableStart))
    ), e(o);
  }
  return !0;
}
function fS(t, e) {
  const n = Kn(t.schema);
  return r9(({ node: i }) => n[i.type.spec.tableRole])(t, e);
}
function r9(t) {
  return (e, n) => {
    var i;
    const r = e.selection;
    let o, s;
    if (r instanceof Ft) {
      if (r.$anchorCell.pos != r.$headCell.pos)
        return !1;
      o = r.$anchorCell.nodeAfter, s = r.$anchorCell.pos;
    } else {
      if (o = IG(r.$from), !o)
        return !1;
      s = (i = bu(r.$from)) == null ? void 0 : i.pos;
    }
    if (o == null || s == null || o.attrs.colspan == 1 && o.attrs.rowspan == 1)
      return !1;
    if (n) {
      let a = o.attrs;
      const l = [], u = a.colwidth;
      a.rowspan > 1 && (a = { ...a, rowspan: 1 }), a.colspan > 1 && (a = { ...a, colspan: 1 });
      const c = po(e), d = e.tr;
      for (let f = 0; f < c.right - c.left; f++)
        l.push(
          u ? {
            ...a,
            colwidth: u && u[f] ? [u[f]] : null
          } : a
        );
      let h;
      for (let f = c.top; f < c.bottom; f++) {
        let p = c.map.positionAt(f, c.left, c.table);
        f == c.top && (p += o.nodeSize);
        for (let m = c.left, g = 0; m < c.right; m++, g++)
          m == c.left && f == c.top || d.insert(
            h = d.mapping.map(p + c.tableStart, 1),
            t({ node: o, row: f, col: m }).createAndFill(l[g])
          );
      }
      d.setNodeMarkup(
        s,
        t({ node: o, row: c.top, col: c.left }),
        l[0]
      ), r instanceof Ft && d.setSelection(
        new Ft(
          d.doc.resolve(r.$anchorCell.pos),
          h ? d.doc.resolve(h) : void 0
        )
      ), n(d);
    }
    return !0;
  };
}
function o9(t, e) {
  return function(n, i) {
    if (!Mr(n))
      return !1;
    const r = wm(n);
    if (r.nodeAfter.attrs[t] === e)
      return !1;
    if (i) {
      const o = n.tr;
      n.selection instanceof Ft ? n.selection.forEachCell((s, a) => {
        s.attrs[t] !== e && o.setNodeMarkup(a, null, {
          ...s.attrs,
          [t]: e
        });
      }) : o.setNodeMarkup(r.pos, null, {
        ...r.nodeAfter.attrs,
        [t]: e
      }), i(o);
    }
    return !0;
  };
}
function s9(t) {
  return function(e, n) {
    if (!Mr(e))
      return !1;
    if (n) {
      const i = Kn(e.schema), r = po(e), o = e.tr, s = r.map.cellsInRect(
        t == "column" ? {
          left: r.left,
          top: 0,
          right: r.right,
          bottom: r.map.height
        } : t == "row" ? {
          left: 0,
          top: r.top,
          right: r.map.width,
          bottom: r.bottom
        } : r
      ), a = s.map((l) => r.table.nodeAt(l));
      for (let l = 0; l < s.length; l++)
        a[l].type == i.header_cell && o.setNodeMarkup(
          r.tableStart + s[l],
          i.cell,
          a[l].attrs
        );
      if (o.steps.length == 0)
        for (let l = 0; l < s.length; l++)
          o.setNodeMarkup(
            r.tableStart + s[l],
            i.header_cell,
            a[l].attrs
          );
      n(o);
    }
    return !0;
  };
}
function pS(t, e, n) {
  const i = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == "row" ? e.map.width : 1,
    bottom: t == "column" ? e.map.height : 1
  });
  for (let r = 0; r < i.length; r++) {
    const o = e.table.nodeAt(i[r]);
    if (o && o.type !== n.header_cell)
      return !1;
  }
  return !0;
}
function td(t, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? s9(t) : function(n, i) {
    if (!Mr(n))
      return !1;
    if (i) {
      const r = Kn(n.schema), o = po(n), s = n.tr, a = pS("row", o, r), l = pS(
        "column",
        o,
        r
      ), c = (t === "column" ? a : t === "row" ? l : !1) ? 1 : 0, d = t == "column" ? {
        left: 0,
        top: c,
        right: 1,
        bottom: o.map.height
      } : t == "row" ? {
        left: c,
        top: 0,
        right: o.map.width,
        bottom: 1
      } : o, h = t == "column" ? l ? r.cell : r.header_cell : t == "row" ? a ? r.cell : r.header_cell : r.cell;
      o.map.cellsInRect(d).forEach((f) => {
        const p = f + o.tableStart, m = s.doc.nodeAt(p);
        m && s.setNodeMarkup(p, h, m.attrs);
      }), i(s);
    }
    return !0;
  };
}
td("row", {
  useDeprecatedLogic: !0
});
td("column", {
  useDeprecatedLogic: !0
});
var a9 = td("cell", {
  useDeprecatedLogic: !0
});
function l9(t, e) {
  if (e < 0) {
    const n = t.nodeBefore;
    if (n)
      return t.pos - n.nodeSize;
    for (let i = t.index(-1) - 1, r = t.before(); i >= 0; i--) {
      const o = t.node(-1).child(i), s = o.lastChild;
      if (s)
        return r - 1 - s.nodeSize;
      r -= o.nodeSize;
    }
  } else {
    if (t.index() < t.parent.childCount - 1)
      return t.pos + t.nodeAfter.nodeSize;
    const n = t.node(-1);
    for (let i = t.indexAfter(-1), r = t.after(); i < n.childCount; i++) {
      const o = n.child(i);
      if (o.childCount)
        return r + 1;
      r += o.nodeSize;
    }
  }
  return null;
}
function mS(t) {
  return function(e, n) {
    if (!Mr(e))
      return !1;
    const i = l9(wm(e), t);
    if (i == null)
      return !1;
    if (n) {
      const r = e.doc.resolve(i);
      n(
        e.tr.setSelection(Je.between(r, VG(r))).scrollIntoView()
      );
    }
    return !0;
  };
}
function u9(t, e) {
  const n = t.selection.$anchor;
  for (let i = n.depth; i > 0; i--)
    if (n.node(i).type.spec.tableRole == "table")
      return e && e(
        t.tr.delete(n.before(i), n.after(i)).scrollIntoView()
      ), !0;
  return !1;
}
function oh(t, e) {
  const n = t.selection;
  if (!(n instanceof Ft))
    return !1;
  if (e) {
    const i = t.tr, r = Kn(t.schema).cell.createAndFill().content;
    n.forEachCell((o, s) => {
      o.content.eq(r) || i.replace(
        i.mapping.map(s + 1),
        i.mapping.map(s + o.nodeSize - 1),
        new Ne(r, 0, 0)
      );
    }), i.docChanged && e(i);
  }
  return !0;
}
function c9(t) {
  if (!t.size)
    return null;
  let { content: e, openStart: n, openEnd: i } = t;
  for (; e.childCount == 1 && (n > 0 && i > 0 || e.child(0).type.spec.tableRole == "table"); )
    n--, i--, e = e.child(0).content;
  const r = e.child(0), o = r.type.spec.tableRole, s = r.type.schema, a = [];
  if (o == "row")
    for (let l = 0; l < e.childCount; l++) {
      let u = e.child(l).content;
      const c = l ? 0 : Math.max(0, n - 1), d = l < e.childCount - 1 ? 0 : Math.max(0, i - 1);
      (c || d) && (u = Cv(
        Kn(s).row,
        new Ne(u, c, d)
      ).content), a.push(u);
    }
  else if (o == "cell" || o == "header_cell")
    a.push(
      n || i ? Cv(
        Kn(s).row,
        new Ne(e, n, i)
      ).content : e
    );
  else
    return null;
  return d9(s, a);
}
function d9(t, e) {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const o = e[r];
    for (let s = o.childCount - 1; s >= 0; s--) {
      const { rowspan: a, colspan: l } = o.child(s).attrs;
      for (let u = r; u < r + a; u++)
        n[u] = (n[u] || 0) + l;
    }
  }
  let i = 0;
  for (let r = 0; r < n.length; r++)
    i = Math.max(i, n[r]);
  for (let r = 0; r < n.length; r++)
    if (r >= e.length && e.push(we.empty), n[r] < i) {
      const o = Kn(t).cell.createAndFill(), s = [];
      for (let a = n[r]; a < i; a++)
        s.push(o);
      e[r] = e[r].append(we.from(s));
    }
  return { height: e.length, width: i, rows: e };
}
function Cv(t, e) {
  const n = t.createAndFill();
  return new Sb(n).replace(0, n.content.size, e).doc;
}
function h9({ width: t, height: e, rows: n }, i, r) {
  if (t != i) {
    const o = [], s = [];
    for (let a = 0; a < n.length; a++) {
      const l = n[a], u = [];
      for (let c = o[a] || 0, d = 0; c < i; d++) {
        let h = l.child(d % l.childCount);
        c + h.attrs.colspan > i && (h = h.type.createChecked(
          Va(
            h.attrs,
            h.attrs.colspan,
            c + h.attrs.colspan - i
          ),
          h.content
        )), u.push(h), c += h.attrs.colspan;
        for (let f = 1; f < h.attrs.rowspan; f++)
          o[a + f] = (o[a + f] || 0) + h.attrs.colspan;
      }
      s.push(we.from(u));
    }
    n = s, t = i;
  }
  if (e != r) {
    const o = [];
    for (let s = 0, a = 0; s < r; s++, a++) {
      const l = [], u = n[a % e];
      for (let c = 0; c < u.childCount; c++) {
        let d = u.child(c);
        s + d.attrs.rowspan > r && (d = d.type.create(
          {
            ...d.attrs,
            rowspan: Math.max(1, r - d.attrs.rowspan)
          },
          d.content
        )), l.push(d);
      }
      o.push(we.from(l));
    }
    n = o, e = r;
  }
  return { width: t, height: e, rows: n };
}
function f9(t, e, n, i, r, o, s) {
  const a = t.doc.type.schema, l = Kn(a);
  let u, c;
  if (r > e.width)
    for (let d = 0, h = 0; d < e.height; d++) {
      const f = n.child(d);
      h += f.nodeSize;
      const p = [];
      let m;
      f.lastChild == null || f.lastChild.type == l.cell ? m = u || (u = l.cell.createAndFill()) : m = c || (c = l.header_cell.createAndFill());
      for (let g = e.width; g < r; g++)
        p.push(m);
      t.insert(t.mapping.slice(s).map(h - 1 + i), p);
    }
  if (o > e.height) {
    const d = [];
    for (let p = 0, m = (e.height - 1) * e.width; p < Math.max(e.width, r); p++) {
      const g = p >= e.width ? !1 : n.nodeAt(e.map[m + p]).type == l.header_cell;
      d.push(
        g ? c || (c = l.header_cell.createAndFill()) : u || (u = l.cell.createAndFill())
      );
    }
    const h = l.row.create(null, we.from(d)), f = [];
    for (let p = e.height; p < o; p++)
      f.push(h);
    t.insert(t.mapping.slice(s).map(i + n.nodeSize - 2), f);
  }
  return !!(u || c);
}
function gS(t, e, n, i, r, o, s, a) {
  if (s == 0 || s == e.height)
    return !1;
  let l = !1;
  for (let u = r; u < o; u++) {
    const c = s * e.width + u, d = e.map[c];
    if (e.map[c - e.width] == d) {
      l = !0;
      const h = n.nodeAt(d), { top: f, left: p } = e.findCell(d);
      t.setNodeMarkup(t.mapping.slice(a).map(d + i), null, {
        ...h.attrs,
        rowspan: s - f
      }), t.insert(
        t.mapping.slice(a).map(e.positionAt(s, p, n)),
        h.type.createAndFill({
          ...h.attrs,
          rowspan: f + h.attrs.rowspan - s
        })
      ), u += h.attrs.colspan - 1;
    }
  }
  return l;
}
function OS(t, e, n, i, r, o, s, a) {
  if (s == 0 || s == e.width)
    return !1;
  let l = !1;
  for (let u = r; u < o; u++) {
    const c = u * e.width + s, d = e.map[c];
    if (e.map[c - 1] == d) {
      l = !0;
      const h = n.nodeAt(d), f = e.colCount(d), p = t.mapping.slice(a).map(d + i);
      t.setNodeMarkup(
        p,
        null,
        Va(
          h.attrs,
          s - f,
          h.attrs.colspan - (s - f)
        )
      ), t.insert(
        p + h.nodeSize,
        h.type.createAndFill(
          Va(h.attrs, 0, s - f)
        )
      ), u += h.attrs.rowspan - 1;
    }
  }
  return l;
}
function vS(t, e, n, i, r) {
  let o = n ? t.doc.nodeAt(n - 1) : t.doc;
  if (!o)
    throw new Error("No table found");
  let s = ln.get(o);
  const { top: a, left: l } = i, u = l + r.width, c = a + r.height, d = t.tr;
  let h = 0;
  function f() {
    if (o = n ? d.doc.nodeAt(n - 1) : d.doc, !o)
      throw new Error("No table found");
    s = ln.get(o), h = d.mapping.maps.length;
  }
  f9(d, s, o, n, u, c, h) && f(), gS(d, s, o, n, l, u, a, h) && f(), gS(d, s, o, n, l, u, c, h) && f(), OS(d, s, o, n, a, c, l, h) && f(), OS(d, s, o, n, a, c, u, h) && f();
  for (let p = a; p < c; p++) {
    const m = s.positionAt(p, l, o), g = s.positionAt(p, u, o);
    d.replace(
      d.mapping.slice(h).map(m + n),
      d.mapping.slice(h).map(g + n),
      new Ne(r.rows[p - a], 0, 0)
    );
  }
  f(), d.setSelection(
    new Ft(
      d.doc.resolve(n + s.positionAt(a, l, o)),
      d.doc.resolve(n + s.positionAt(c - 1, u - 1, o))
    )
  ), e(d);
}
var p9 = Ab({
  ArrowLeft: sh("horiz", -1),
  ArrowRight: sh("horiz", 1),
  ArrowUp: sh("vert", -1),
  ArrowDown: sh("vert", 1),
  "Shift-ArrowLeft": ah("horiz", -1),
  "Shift-ArrowRight": ah("horiz", 1),
  "Shift-ArrowUp": ah("vert", -1),
  "Shift-ArrowDown": ah("vert", 1),
  Backspace: oh,
  "Mod-Backspace": oh,
  Delete: oh,
  "Mod-Delete": oh
});
function Vh(t, e, n) {
  return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function sh(t, e) {
  return (n, i, r) => {
    if (!r)
      return !1;
    const o = n.selection;
    if (o instanceof Ft)
      return Vh(
        n,
        i,
        tt.near(o.$headCell, e)
      );
    if (t != "horiz" && !o.empty)
      return !1;
    const s = BM(r, t, e);
    if (s == null)
      return !1;
    if (t == "horiz")
      return Vh(
        n,
        i,
        tt.near(n.doc.resolve(o.head + e), e)
      );
    {
      const a = n.doc.resolve(s), l = RM(a, t, e);
      let u;
      return l ? u = tt.near(l, 1) : e < 0 ? u = tt.near(n.doc.resolve(a.before(-1)), -1) : u = tt.near(n.doc.resolve(a.after(-1)), 1), Vh(n, i, u);
    }
  };
}
function ah(t, e) {
  return (n, i, r) => {
    if (!r)
      return !1;
    const o = n.selection;
    let s;
    if (o instanceof Ft)
      s = o;
    else {
      const l = BM(r, t, e);
      if (l == null)
        return !1;
      s = new Ft(n.doc.resolve(l));
    }
    const a = RM(s.$headCell, t, e);
    return a ? Vh(
      n,
      i,
      new Ft(s.$anchorCell, a)
    ) : !1;
  };
}
function m9(t, e) {
  const n = t.state.doc, i = bu(n.resolve(e));
  return i ? (t.dispatch(t.state.tr.setSelection(new Ft(i))), !0) : !1;
}
function g9(t, e, n) {
  if (!Mr(t.state))
    return !1;
  let i = c9(n);
  const r = t.state.selection;
  if (r instanceof Ft) {
    i || (i = {
      width: 1,
      height: 1,
      rows: [
        we.from(
          Cv(Kn(t.state.schema).cell, n)
        )
      ]
    });
    const o = r.$anchorCell.node(-1), s = r.$anchorCell.start(-1), a = ln.get(o).rectBetween(
      r.$anchorCell.pos - s,
      r.$headCell.pos - s
    );
    return i = h9(i, a.right - a.left, a.bottom - a.top), vS(t.state, t.dispatch, s, a, i), !0;
  } else if (i) {
    const o = wm(t.state), s = o.start(-1);
    return vS(
      t.state,
      t.dispatch,
      s,
      ln.get(o.node(-1)).findCell(o.pos - s),
      i
    ), !0;
  } else
    return !1;
}
function O9(t, e) {
  var n;
  if (e.ctrlKey || e.metaKey)
    return;
  const i = yS(t, e.target);
  let r;
  if (e.shiftKey && t.state.selection instanceof Ft)
    o(t.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && i && (r = bu(t.state.selection.$anchor)) != null && ((n = Ig(t, e)) == null ? void 0 : n.pos) != r.pos)
    o(r, e), e.preventDefault();
  else if (!i)
    return;
  function o(l, u) {
    let c = Ig(t, u);
    const d = ds.getState(t.state) == null;
    if (!c || !a0(l, c))
      if (d)
        c = l;
      else
        return;
    const h = new Ft(l, c);
    if (d || !t.state.selection.eq(h)) {
      const f = t.state.tr.setSelection(h);
      d && f.setMeta(ds, l.pos), t.dispatch(f);
    }
  }
  function s() {
    t.root.removeEventListener("mouseup", s), t.root.removeEventListener("dragstart", s), t.root.removeEventListener("mousemove", a), ds.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(ds, -1));
  }
  function a(l) {
    const u = l, c = ds.getState(t.state);
    let d;
    if (c != null)
      d = t.state.doc.resolve(c);
    else if (yS(t, u.target) != i && (d = Ig(t, e), !d))
      return s();
    d && o(d, u);
  }
  t.root.addEventListener("mouseup", s), t.root.addEventListener("dragstart", s), t.root.addEventListener("mousemove", a);
}
function BM(t, e, n) {
  if (!(t.state.selection instanceof Je))
    return null;
  const { $head: i } = t.state.selection;
  for (let r = i.depth - 1; r >= 0; r--) {
    const o = i.node(r);
    if ((n < 0 ? i.index(r) : i.indexAfter(r)) != (n < 0 ? 0 : o.childCount))
      return null;
    if (o.type.spec.tableRole == "cell" || o.type.spec.tableRole == "header_cell") {
      const a = i.before(r), l = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
      return t.endOfTextblock(l) ? a : null;
    }
  }
  return null;
}
function yS(t, e) {
  for (; e && e != t.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function Ig(t, e) {
  const n = t.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return n && n ? bu(t.state.doc.resolve(n.pos)) : null;
}
var v9 = class {
  constructor(e, n) {
    this.node = e, this.defaultCellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${n}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Tv(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, Tv(
      e,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function Tv(t, e, n, i, r, o) {
  var s;
  let a = 0, l = !0, u = e.firstChild;
  const c = t.firstChild;
  if (c) {
    for (let d = 0, h = 0; d < c.childCount; d++) {
      const { colspan: f, colwidth: p } = c.child(d).attrs;
      for (let m = 0; m < f; m++, h++) {
        const g = r == h ? o : p && p[m], O = g ? g + "px" : "";
        if (a += g || i, g || (l = !1), u)
          u.style.width != O && (u.style.width = O), u = u.nextSibling;
        else {
          const y = document.createElement("col");
          y.style.width = O, e.appendChild(y);
        }
      }
    }
    for (; u; ) {
      const d = u.nextSibling;
      (s = u.parentNode) == null || s.removeChild(u), u = d;
    }
    l ? (n.style.width = a + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = a + "px");
  }
}
var Ii = new _n(
  "tableColumnResizing"
);
function y9({
  handleWidth: t = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: n = 100,
  View: i = v9,
  lastColumnResizable: r = !0
} = {}) {
  const o = new rn({
    key: Ii,
    state: {
      init(s, a) {
        var l, u;
        const c = (u = (l = o.spec) == null ? void 0 : l.props) == null ? void 0 : u.nodeViews, d = Kn(a.schema).table.name;
        return i && c && (c[d] = (h, f) => new i(h, n, f)), new b9(-1, !1);
      },
      apply(s, a) {
        return a.apply(s);
      }
    },
    props: {
      attributes: (s) => {
        const a = Ii.getState(s);
        return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (s, a) => {
          w9(s, a, t, r);
        },
        mouseleave: (s) => {
          k9(s);
        },
        mousedown: (s, a) => {
          S9(s, a, e, n);
        }
      },
      decorations: (s) => {
        const a = Ii.getState(s);
        if (a && a.activeHandle > -1)
          return $9(s, a.activeHandle);
      },
      nodeViews: {}
    }
  });
  return o;
}
var b9 = class Bh {
  constructor(e, n) {
    this.activeHandle = e, this.dragging = n;
  }
  apply(e) {
    const n = this, i = e.getMeta(Ii);
    if (i && i.setHandle != null)
      return new Bh(i.setHandle, !1);
    if (i && i.setDragging !== void 0)
      return new Bh(n.activeHandle, i.setDragging);
    if (n.activeHandle > -1 && e.docChanged) {
      let r = e.mapping.map(n.activeHandle, -1);
      return xv(e.doc.resolve(r)) || (r = -1), new Bh(r, n.dragging);
    }
    return n;
  }
};
function w9(t, e, n, i) {
  const r = Ii.getState(t.state);
  if (r && !r.dragging) {
    const o = x9(e.target);
    let s = -1;
    if (o) {
      const { left: a, right: l } = o.getBoundingClientRect();
      e.clientX - a <= n ? s = bS(t, e, "left", n) : l - e.clientX <= n && (s = bS(t, e, "right", n));
    }
    if (s != r.activeHandle) {
      if (!i && s !== -1) {
        const a = t.state.doc.resolve(s), l = a.node(-1), u = ln.get(l), c = a.start(-1);
        if (u.colCount(a.pos - c) + a.nodeAfter.attrs.colspan - 1 == u.width - 1)
          return;
      }
      ZM(t, s);
    }
  }
}
function k9(t) {
  const e = Ii.getState(t.state);
  e && e.activeHandle > -1 && !e.dragging && ZM(t, -1);
}
function S9(t, e, n, i) {
  var r;
  const o = (r = t.dom.ownerDocument.defaultView) != null ? r : window, s = Ii.getState(t.state);
  if (!s || s.activeHandle == -1 || s.dragging)
    return !1;
  const a = t.state.doc.nodeAt(s.activeHandle), l = _9(t, s.activeHandle, a.attrs);
  t.dispatch(
    t.state.tr.setMeta(Ii, {
      setDragging: { startX: e.clientX, startWidth: l }
    })
  );
  function u(d) {
    o.removeEventListener("mouseup", u), o.removeEventListener("mousemove", c);
    const h = Ii.getState(t.state);
    h != null && h.dragging && (C9(
      t,
      h.activeHandle,
      wS(h.dragging, d, n)
    ), t.dispatch(
      t.state.tr.setMeta(Ii, { setDragging: null })
    ));
  }
  function c(d) {
    if (!d.which)
      return u(d);
    const h = Ii.getState(t.state);
    if (h && h.dragging) {
      const f = wS(h.dragging, d, n);
      kS(
        t,
        h.activeHandle,
        f,
        i
      );
    }
  }
  return kS(
    t,
    s.activeHandle,
    l,
    i
  ), o.addEventListener("mouseup", u), o.addEventListener("mousemove", c), e.preventDefault(), !0;
}
function _9(t, e, { colspan: n, colwidth: i }) {
  const r = i && i[i.length - 1];
  if (r)
    return r;
  const o = t.domAtPos(e);
  let a = o.node.childNodes[o.offset].offsetWidth, l = n;
  if (i)
    for (let u = 0; u < n; u++)
      i[u] && (a -= i[u], l--);
  return a / l;
}
function x9(t) {
  for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
    t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
  return t;
}
function bS(t, e, n, i) {
  const r = n == "right" ? -i : i, o = t.posAtCoords({
    left: e.clientX + r,
    top: e.clientY
  });
  if (!o)
    return -1;
  const { pos: s } = o, a = bu(t.state.doc.resolve(s));
  if (!a)
    return -1;
  if (n == "right")
    return a.pos;
  const l = ln.get(a.node(-1)), u = a.start(-1), c = l.map.indexOf(a.pos - u);
  return c % l.width == 0 ? -1 : u + l.map[c - 1];
}
function wS(t, e, n) {
  const i = e.clientX - t.startX;
  return Math.max(n, t.startWidth + i);
}
function ZM(t, e) {
  t.dispatch(
    t.state.tr.setMeta(Ii, { setHandle: e })
  );
}
function C9(t, e, n) {
  const i = t.state.doc.resolve(e), r = i.node(-1), o = ln.get(r), s = i.start(-1), a = o.colCount(i.pos - s) + i.nodeAfter.attrs.colspan - 1, l = t.state.tr;
  for (let u = 0; u < o.height; u++) {
    const c = u * o.width + a;
    if (u && o.map[c] == o.map[c - o.width])
      continue;
    const d = o.map[c], h = r.nodeAt(d).attrs, f = h.colspan == 1 ? 0 : a - o.colCount(d);
    if (h.colwidth && h.colwidth[f] == n)
      continue;
    const p = h.colwidth ? h.colwidth.slice() : T9(h.colspan);
    p[f] = n, l.setNodeMarkup(s + d, null, { ...h, colwidth: p });
  }
  l.docChanged && t.dispatch(l);
}
function kS(t, e, n, i) {
  const r = t.state.doc.resolve(e), o = r.node(-1), s = r.start(-1), a = ln.get(o).colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1;
  let l = t.domAtPos(r.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; )
    l = l.parentNode;
  l && Tv(
    o,
    l.firstChild,
    l,
    i,
    a,
    n
  );
}
function T9(t) {
  return Array(t).fill(0);
}
function $9(t, e) {
  var n;
  const i = [], r = t.doc.resolve(e), o = r.node(-1);
  if (!o)
    return Jt.empty;
  const s = ln.get(o), a = r.start(-1), l = s.colCount(r.pos - a) + r.nodeAfter.attrs.colspan - 1;
  for (let u = 0; u < s.height; u++) {
    const c = l + u * s.width;
    if ((l == s.width - 1 || s.map[c] != s.map[c + 1]) && (u == 0 || s.map[c] != s.map[c - s.width])) {
      const d = s.map[c], h = a + d + o.nodeAt(d).nodeSize - 1, f = document.createElement("div");
      f.className = "column-resize-handle", (n = Ii.getState(t)) != null && n.dragging && i.push(
        Cr.node(
          a + d,
          a + d + o.nodeAt(d).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), i.push(Cr.widget(h, f));
    }
  }
  return Jt.create(t.doc, i);
}
function P9({
  allowTableNodeSelection: t = !1
} = {}) {
  return new rn({
    key: ds,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, n) {
        const i = e.getMeta(ds);
        if (i != null)
          return i == -1 ? null : i;
        if (n == null || !e.docChanged)
          return n;
        const { deleted: r, pos: o } = e.mapping.mapResult(n);
        return r ? null : o;
      }
    },
    props: {
      decorations: FG,
      handleDOMEvents: {
        mousedown: O9
      },
      createSelectionBetween(e) {
        return ds.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: m9,
      handleKeyDown: p9,
      handlePaste: g9
    },
    appendTransaction(e, n, i) {
      return XG(
        i,
        IM(i, n),
        t
      );
    }
  });
}
function $v(t, e) {
  return e ? ["width", `${Math.max(e, t)}px`] : ["min-width", `${t}px`];
}
function SS(t, e, n, i, r, o) {
  var s;
  let a = 0, l = !0, u = e.firstChild;
  const c = t.firstChild;
  if (c !== null)
    for (let d = 0, h = 0; d < c.childCount; d += 1) {
      const { colspan: f, colwidth: p } = c.child(d).attrs;
      for (let m = 0; m < f; m += 1, h += 1) {
        const g = r === h ? o : p && p[m], O = g ? `${g}px` : "";
        if (a += g || i, g || (l = !1), u) {
          if (u.style.width !== O) {
            const [y, b] = $v(i, g);
            u.style.setProperty(y, b);
          }
          u = u.nextSibling;
        } else {
          const y = document.createElement("col"), [b, v] = $v(i, g);
          y.style.setProperty(b, v), e.appendChild(y);
        }
      }
    }
  for (; u; ) {
    const d = u.nextSibling;
    (s = u.parentNode) === null || s === void 0 || s.removeChild(u), u = d;
  }
  l ? (n.style.width = `${a}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${a}px`);
}
class M9 {
  constructor(e, n) {
    this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), SS(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type !== this.node.type ? !1 : (this.node = e, SS(e, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(e) {
    return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
  }
}
function E9(t, e, n, i) {
  let r = 0, o = !0;
  const s = [], a = t.firstChild;
  if (!a)
    return {};
  for (let d = 0, h = 0; d < a.childCount; d += 1) {
    const { colspan: f, colwidth: p } = a.child(d).attrs;
    for (let m = 0; m < f; m += 1, h += 1) {
      const g = n === h ? i : p && p[m];
      r += g || e, g || (o = !1);
      const [O, y] = $v(e, g);
      s.push([
        "col",
        { style: `${O}: ${y}` }
      ]);
    }
  }
  const l = o ? `${r}px` : "", u = o ? "" : `${r}px`;
  return { colgroup: ["colgroup", {}, ...s], tableWidth: l, tableMinWidth: u };
}
function _S(t, e) {
  return e ? t.createChecked(null, e) : t.createAndFill();
}
function A9(t) {
  if (t.cached.tableNodeTypes)
    return t.cached.tableNodeTypes;
  const e = {};
  return Object.keys(t.nodes).forEach((n) => {
    const i = t.nodes[n];
    i.spec.tableRole && (e[i.spec.tableRole] = i);
  }), t.cached.tableNodeTypes = e, e;
}
function R9(t, e, n, i, r) {
  const o = A9(t), s = [], a = [];
  for (let u = 0; u < n; u += 1) {
    const c = _S(o.cell, r);
    if (c && a.push(c), i) {
      const d = _S(o.header_cell, r);
      d && s.push(d);
    }
  }
  const l = [];
  for (let u = 0; u < e; u += 1)
    l.push(o.row.createChecked(null, i && u === 0 ? s : a));
  return o.table.createChecked(null, l);
}
function D9(t) {
  return t instanceof Ft;
}
const lh = ({ editor: t }) => {
  const { selection: e } = t.state;
  if (!D9(e))
    return !1;
  let n = 0;
  const i = jP(e.ranges[0].$from, (o) => o.type.name === "table");
  return i == null || i.node.descendants((o) => {
    if (o.type.name === "table")
      return !1;
    ["tableCell", "tableHeader"].includes(o.type.name) && (n += 1);
  }), n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1;
}, Q9 = mi.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: M9,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: !0,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const { colgroup: n, tableWidth: i, tableMinWidth: r } = E9(t, this.options.cellMinWidth);
    return [
      "table",
      Ht(this.options.HTMLAttributes, e, {
        style: i ? `width: ${i}` : `min-width: ${r}`
      }),
      n,
      ["tbody", 0]
    ];
  },
  addCommands() {
    return {
      insertTable: ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) => ({ tr: i, dispatch: r, editor: o }) => {
        const s = R9(o.schema, t, e, n);
        if (r) {
          const a = i.selection.from + 1;
          i.replaceSelectionWith(s).scrollIntoView().setSelection(Je.near(i.doc.resolve(a)));
        }
        return !0;
      },
      addColumnBefore: () => ({ state: t, dispatch: e }) => YG(t, e),
      addColumnAfter: () => ({ state: t, dispatch: e }) => HG(t, e),
      deleteColumn: () => ({ state: t, dispatch: e }) => GG(t, e),
      addRowBefore: () => ({ state: t, dispatch: e }) => JG(t, e),
      addRowAfter: () => ({ state: t, dispatch: e }) => e9(t, e),
      deleteRow: () => ({ state: t, dispatch: e }) => n9(t, e),
      deleteTable: () => ({ state: t, dispatch: e }) => u9(t, e),
      mergeCells: () => ({ state: t, dispatch: e }) => hS(t, e),
      splitCell: () => ({ state: t, dispatch: e }) => fS(t, e),
      toggleHeaderColumn: () => ({ state: t, dispatch: e }) => td("column")(t, e),
      toggleHeaderRow: () => ({ state: t, dispatch: e }) => td("row")(t, e),
      toggleHeaderCell: () => ({ state: t, dispatch: e }) => a9(t, e),
      mergeOrSplit: () => ({ state: t, dispatch: e }) => hS(t, e) ? !0 : fS(t, e),
      setCellAttribute: (t, e) => ({ state: n, dispatch: i }) => o9(t, e)(n, i),
      goToNextCell: () => ({ state: t, dispatch: e }) => mS(1)(t, e),
      goToPreviousCell: () => ({ state: t, dispatch: e }) => mS(-1)(t, e),
      fixTables: () => ({ state: t, dispatch: e }) => (e && IM(t), !0),
      setCellSelection: (t) => ({ tr: e, dispatch: n }) => {
        if (n) {
          const i = Ft.create(e.doc, t.anchorCell, t.headCell);
          e.setSelection(i);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: lh,
      "Mod-Backspace": lh,
      Delete: lh,
      "Mod-Delete": lh
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.options.resizable && this.editor.isEditable ? [
        y9({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      P9({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(t) {
    const e = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      tableRole: ct(Xe(t, "tableRole", e))
    };
  }
}), N9 = mi.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((i) => parseInt(i, 10)) : null;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "td" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["td", Ht(this.options.HTMLAttributes, t), 0];
  }
}), I9 = mi.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((i) => parseInt(i, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "th" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["th", Ht(this.options.HTMLAttributes, t), 0];
  }
}), L9 = mi.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [
      { tag: "tr" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["tr", Ht(this.options.HTMLAttributes, t), 0];
  }
}), V9 = yn.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something …",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new rn({
        key: new _n("placeholder"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const n = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: i } = e, r = [];
            if (!n)
              return null;
            const o = this.editor.isEmpty;
            return t.descendants((s, a) => {
              const l = i >= a && i <= a + s.nodeSize, u = !s.isLeaf && vm(s);
              if ((l || !this.options.showOnlyCurrent) && u) {
                const c = [this.options.emptyNodeClass];
                o && c.push(this.options.emptyEditorClass);
                const d = Cr.node(a, a + s.nodeSize, {
                  class: c.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: s,
                    pos: a,
                    hasAnchor: l
                  }) : this.options.placeholder
                });
                r.push(d);
              }
              return this.options.includeChildren;
            }), Jt.create(t, r);
          }
        }
      })
    ];
  }
}), B9 = ["aria-label", "disabled"], Z9 = { key: 1 }, F9 = /* @__PURE__ */ Te({
  __name: "mt-text-editor-toolbar-button",
  props: {
    editor: {
      type: Object,
      required: !0
    },
    button: {
      type: Object,
      required: !0
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const { t: n } = Lt(), i = t, r = e, o = () => {
      r("click");
    }, s = (l) => ({
      "mt-text-editor-toolbar-button": !0,
      "is-active": l.isActive && l.isActive(i.editor)
    }), a = J(() => n(i.button.label));
    return (l, u) => yt((_(), Z("button", {
      onClick: u[0] || (u[0] = (c) => o()),
      class: Ae(s(t.button)),
      "aria-label": a.value,
      disabled: t.button.disabled ? t.button.disabled(i.editor, t.disabled) : t.disabled
    }, [
      t.button.icon ? (_(), ue(mt, {
        key: 0,
        name: t.button.icon
      }, null, 8, ["name"])) : (_(), Z("span", Z9, Pe(a.value), 1))
    ], 10, B9)), [
      [E(ja), {
        disabled: !a.value,
        message: a.value,
        position: "top",
        hideDelay: 0
      }]
    ]);
  }
});
const vs = /* @__PURE__ */ je(F9, [["__scopeId", "data-v-15afc97f"]]), q9 = {
  class: "mt-text-editor-toolbar",
  role: "menu",
  tabindex: "0"
}, W9 = { class: "mt-text-editor-toolbar__buttons-left" }, X9 = { class: "mt-text-editor-toolbar__buttons-right" }, z9 = /* @__PURE__ */ Te({
  __name: "mt-text-editor-toolbar",
  props: {
    editor: {
      type: Object,
      required: !0
    },
    customButtons: {
      type: Array,
      default: () => []
    },
    excludedButtons: {
      type: Array,
      default: () => []
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["updateContextualButtons"],
  setup(t, { emit: e }) {
    const { t: n } = Lt({
      useScope: "global",
      messages: {
        en: {
          "mt-text-editor-toolbar": {
            buttons: {
              format: "Format",
              p: "Paragraph",
              h1: "Headline 1",
              h2: "Headline 2",
              h3: "Headline 3",
              h4: "Headline 4",
              h5: "Headline 5",
              h6: "Headline 6",
              bold: "Bold",
              italic: "Italic",
              underline: "Underline",
              strikethrough: "Strikethrough",
              superscript: "Superscript",
              subscript: "Subscript",
              "text-alignment": "Text Alignment",
              "align-left": "Align left",
              "align-center": "Align center",
              "align-right": "Align right",
              justify: "Justify",
              "unordered-list": "Insert Unordered List",
              "numbered-list": "Insert Ordered List",
              undo: "Undo",
              redo: "Redo"
            }
          }
        },
        de: {
          "mt-text-editor-toolbar": {
            buttons: {
              format: "Format",
              p: "Absatz",
              h1: "Überschrift 1",
              h2: "Überschrift 2",
              h3: "Überschrift 3",
              h4: "Überschrift 4",
              h5: "Überschrift 5",
              h6: "Überschrift 6",
              bold: "Fett",
              italic: "Kursiv",
              underline: "Unterstrichen",
              strikethrough: "Durchgestrichen",
              superscript: "Hochgestellt",
              subscript: "Tiefgestellt",
              "text-alignment": "Textausrichtung",
              "align-left": "Links ausrichten",
              "align-center": "Zentriert ausrichten",
              "align-right": "Rechts ausrichten",
              justify: "Blocksatz",
              "unordered-list": "Unsortierte Liste einfügen",
              "numbered-list": "Sortierte Liste einfügen",
              undo: "Rückgängig",
              redo: "Wiederholen"
            }
          }
        }
      }
    }), i = t, r = e, o = [
      {
        name: "format",
        label: "mt-text-editor-toolbar.buttons.format",
        icon: "regular-style-xs",
        position: 1e3,
        children: [
          {
            name: "p",
            label: "mt-text-editor-toolbar.buttons.p",
            action: () => i.editor.chain().focus().setParagraph().run(),
            isActive: (c) => c.isActive("paragraph")
          },
          {
            name: "h1",
            label: "mt-text-editor-toolbar.buttons.h1",
            action: () => i.editor.chain().focus().setHeading({ level: 1 }).run(),
            isActive: (c) => c.isActive("heading", { level: 1 })
          },
          {
            name: "h2",
            label: "mt-text-editor-toolbar.buttons.h2",
            action: () => i.editor.chain().focus().setHeading({ level: 2 }).run(),
            isActive: (c) => c.isActive("heading", { level: 2 })
          },
          {
            name: "h3",
            label: "mt-text-editor-toolbar.buttons.h3",
            action: () => i.editor.chain().focus().setHeading({ level: 3 }).run(),
            isActive: (c) => c.isActive("heading", { level: 3 })
          },
          {
            name: "h4",
            label: "mt-text-editor-toolbar.buttons.h4",
            action: () => i.editor.chain().focus().setHeading({ level: 4 }).run(),
            isActive: (c) => c.isActive("heading", { level: 4 })
          },
          {
            name: "h5",
            label: "mt-text-editor-toolbar.buttons.h5",
            action: () => i.editor.chain().focus().setHeading({ level: 5 }).run(),
            isActive: (c) => c.isActive("heading", { level: 5 })
          },
          {
            name: "h6",
            label: "mt-text-editor-toolbar.buttons.h6",
            action: () => i.editor.chain().focus().setHeading({ level: 6 }).run(),
            isActive: (c) => c.isActive("heading", { level: 6 })
          }
        ]
      },
      {
        name: "bold",
        label: "mt-text-editor-toolbar.buttons.bold",
        icon: "regular-bold-xs",
        action: () => i.editor.chain().focus().toggleBold().run(),
        isActive: (c) => c.isActive("bold"),
        position: 3e3
      },
      {
        name: "italic",
        label: "mt-text-editor-toolbar.buttons.italic",
        icon: "regular-italic-xs",
        action: () => i.editor.chain().focus().toggleItalic().run(),
        isActive: (c) => c.isActive("italic"),
        position: 4e3
      },
      {
        name: "underline",
        label: "mt-text-editor-toolbar.buttons.underline",
        icon: "regular-underline-xs",
        action: () => i.editor.chain().focus().toggleUnderline().run(),
        isActive: (c) => c.isActive("underline"),
        position: 5e3
      },
      {
        name: "strikethrough",
        label: "mt-text-editor-toolbar.buttons.strikethrough",
        icon: "regular-strikethrough-xs",
        action: () => i.editor.chain().focus().toggleStrike().run(),
        isActive: (c) => c.isActive("strike"),
        position: 6e3
      },
      {
        name: "superscript",
        label: "mt-text-editor-toolbar.buttons.superscript",
        icon: "regular-superscript-xs",
        action: () => i.editor.chain().focus().toggleSuperscript().run(),
        isActive: (c) => c.isActive("superscript"),
        position: 7e3
      },
      {
        name: "subscript",
        label: "mt-text-editor-toolbar.buttons.subscript",
        icon: "regular-subscript-xs",
        action: () => i.editor.chain().focus().toggleSubscript().run(),
        isActive: (c) => c.isActive("subscript"),
        position: 8e3
      },
      {
        name: "text-alignment",
        label: "mt-text-editor-toolbar.buttons.text-alignment",
        icon: "regular-align-left-xs",
        children: [
          {
            name: "align-left",
            label: "mt-text-editor-toolbar.buttons.align-left",
            action: () => i.editor.chain().focus().setTextAlign("left").run(),
            isActive: (c) => c.isActive({ textAlign: "left" })
          },
          {
            name: "align-center",
            label: "mt-text-editor-toolbar.buttons.align-center",
            action: () => i.editor.chain().focus().setTextAlign("center").run(),
            isActive: (c) => c.isActive({ textAlign: "center" })
          },
          {
            name: "align-right",
            label: "mt-text-editor-toolbar.buttons.align-right",
            action: () => i.editor.chain().focus().setTextAlign("right").run(),
            isActive: (c) => c.isActive({ textAlign: "right" })
          },
          {
            name: "justify",
            label: "mt-text-editor-toolbar.buttons.justify",
            action: () => i.editor.chain().focus().setTextAlign("justify").run(),
            isActive: (c) => c.isActive({ textAlign: "justify" })
          }
        ],
        position: 9e3
      },
      {
        name: "unordered-list",
        icon: "regular-list-unordered-xs",
        label: "mt-text-editor-toolbar.buttons.unordered-list",
        action: () => i.editor.chain().focus().toggleBulletList().run(),
        isActive: (c) => c.isActive("bulletList"),
        position: 1e4
      },
      {
        name: "numbered-list",
        icon: "regular-list-numbered-xs",
        label: "mt-text-editor-toolbar.buttons.numbered-list",
        action: () => i.editor.chain().focus().toggleOrderedList().run(),
        isActive: (c) => c.isActive("orderedList"),
        position: 11e3
      },
      {
        name: "undo",
        icon: "regular-undo-xs",
        alignment: "right",
        label: "mt-text-editor-toolbar.buttons.undo",
        action: () => i.editor.chain().focus().undo().run(),
        disabled: (c) => i.disabled ? !0 : !c.can().undo(),
        position: 1e3
      },
      {
        name: "redo",
        icon: "regular-redo-xs",
        alignment: "right",
        label: "mt-text-editor-toolbar.buttons.redo",
        action: () => i.editor.chain().focus().redo().run(),
        disabled: (c) => i.disabled ? !0 : !c.can().redo(),
        position: 2e3
      }
    ], s = J(() => [...o, ...i.customButtons].filter((c) => {
      const d = i.excludedButtons.includes(c.name), h = c.alignment === "right";
      return !d && !h;
    }).sort((c, d) => (c.position ?? Number.MAX_SAFE_INTEGER) - (d.position ?? Number.MAX_SAFE_INTEGER))), a = J(() => [...o, ...i.customButtons].filter((c) => {
      const d = i.excludedButtons.includes(c.name), h = c.alignment === "right";
      return !d && h;
    }).sort((c, d) => (c.position ?? Number.MAX_SAFE_INTEGER) - (d.position ?? Number.MAX_SAFE_INTEGER))), l = (c) => {
      c.action && c.action(i.editor);
    }, u = J(() => [...s.value, ...a.value].filter((c) => c.contextualButtons && c.contextualButtons(i.editor).length > 0).map((c) => c.contextualButtons(i.editor)).flat());
    return gt(
      u,
      (c, d) => {
        JSON.stringify(c) !== JSON.stringify(d) && r("updateContextualButtons", c);
      },
      { immediate: !0 }
    ), (c, d) => (_(), Z("div", q9, [
      X("div", W9, [
        (_(!0), Z(Qe, null, Ge(s.value, (h) => ne(c.$slots, "button_" + h.name, {
          key: h.name,
          editor: i.editor,
          disabled: t.disabled,
          button: h
        }, () => [
          h.children ? (_(), ue(Qs, {
            key: h.name
          }, {
            trigger: H(({ toggleFloatingUi: f }) => [
              fe(vs, {
                button: h,
                editor: i.editor,
                onClick: f,
                disabled: t.disabled
              }, null, 8, ["button", "editor", "onClick", "disabled"])
            ]),
            "popover-items__base": H(({ toggleFloatingUi: f }) => [
              (_(!0), Z(Qe, null, Ge(h.children, (p) => (_(), ue(Zo, {
                key: p.name,
                label: E(n)(p.label),
                icon: p.icon,
                type: p.isActive && p.isActive(i.editor) ? "active" : "default",
                onLabelClick: () => {
                  l(p), f();
                }
              }, null, 8, ["label", "icon", "type", "onLabelClick"]))), 128))
            ]),
            _: 2
          }, 1024)) : (_(), ue(vs, {
            key: 1,
            button: h,
            editor: i.editor,
            disabled: t.disabled,
            onClick: (f) => l(h)
          }, null, 8, ["button", "editor", "disabled", "onClick"]))
        ], !0)), 128))
      ]),
      ne(c.$slots, "default", {}, void 0, !0),
      X("div", X9, [
        (_(!0), Z(Qe, null, Ge(a.value, (h) => ne(c.$slots, "button_" + h.name, {
          key: h.name,
          editor: i.editor,
          disabled: t.disabled,
          button: h
        }, () => [
          h.children ? (_(), ue(Qs, {
            key: h.name
          }, {
            trigger: H(({ toggleFloatingUi: f }) => [
              fe(vs, {
                button: h,
                editor: i.editor,
                onClick: f,
                disabled: t.disabled
              }, null, 8, ["button", "editor", "onClick", "disabled"])
            ]),
            "popover-items__base": H(() => [
              (_(!0), Z(Qe, null, Ge(h.children, (f) => (_(), ue(Zo, {
                key: f.name,
                label: E(n)(f.label),
                icon: f.icon,
                type: f.isActive && f.isActive(i.editor) ? "active" : "default",
                onLabelClick: () => l(f)
              }, null, 8, ["label", "icon", "type", "onLabelClick"]))), 128))
            ]),
            _: 2
          }, 1024)) : (_(), ue(vs, {
            key: 1,
            button: h,
            editor: i.editor,
            onClick: (f) => l(h),
            disabled: t.disabled
          }, null, 8, ["button", "editor", "onClick", "disabled"]))
        ], !0)), 128))
      ])
    ]));
  }
});
const j9 = /* @__PURE__ */ je(z9, [["__scopeId", "data-v-4dd9bed0"]]), Y9 = { class: "mt-text-editor-toolbar-button-color" }, H9 = {
  name: "text-color",
  label: "mt-text-editor-toolbar-button-color.label",
  position: 2e3
}, U9 = /* @__PURE__ */ Te({
  __name: "mt-text-editor-toolbar-button-color",
  props: {
    editor: {
      type: Object,
      required: !0
    },
    button: {
      type: Object,
      required: !0
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  setup(t) {
    Lt({
      useScope: "global",
      messages: {
        en: {
          "mt-text-editor-toolbar-button-color": {
            label: "Text Color"
          }
        },
        de: {
          "mt-text-editor-toolbar-button-color": {
            label: "Textfarbe"
          }
        }
      }
    });
    const e = t, n = () => e.editor.getAttributes("textStyle").color, i = (r) => {
      e.editor.chain().focus().setColor(r).run();
    };
    return (r, o) => (_(), Z("div", Y9, [
      fe(eF, {
        class: "mt-text-editor-toolbar-button-color__colorpicker",
        compact: "",
        "model-value": n(),
        "onUpdate:modelValue": i,
        disabled: t.button.disabled ? t.button.disabled(e.editor, t.disabled) : t.disabled,
        "apply-mode": ""
      }, null, 8, ["model-value", "disabled"])
    ]));
  }
});
const G9 = /* @__PURE__ */ je(U9, [["__scopeId", "data-v-f06f87c1"]]), K9 = { class: "mt-text-editor__link-modal" }, J9 = { class: "mt-text-editor__link-modal-footer" }, eK = {
  name: "link",
  label: "mt-text-editor-toolbar-button-link.label",
  icon: "regular-link-xs",
  position: 12e3
}, tK = /* @__PURE__ */ Te({
  __name: "mt-text-editor-toolbar-button-link",
  props: {
    editor: {
      type: Object,
      required: !0
    },
    button: {
      type: Object,
      required: !0
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  setup(t) {
    const { t: e } = Lt({
      useScope: "global",
      messages: {
        en: {
          "mt-text-editor-toolbar-button-link": {
            modalTitle: "Insert/Edit Link",
            cancel: "Cancel",
            applyLink: "Apply link",
            openInNewTab: "Open in new tab",
            linkUrl: "Link URL",
            label: "Link"
          }
        },
        de: {
          "mt-text-editor-toolbar-button-link": {
            modalTitle: "Link einfügen/bearbeiten",
            cancel: "Abbrechen",
            applyLink: "Link anwenden",
            openInNewTab: "In neuem Tab öffnen",
            linkUrl: "Link URL",
            label: "Link"
          }
        }
      }
    }), n = t, i = re(!1), r = re(""), o = re(""), s = () => {
      r.value = n.editor.getAttributes("link").href ?? "", o.value = n.editor.getAttributes("link").target ?? "", i.value = !0;
    };
    return (a, l) => (_(), Z(Qe, null, [
      fe(vs, {
        button: t.button,
        editor: n.editor,
        disabled: t.disabled,
        onClick: s
      }, null, 8, ["button", "editor", "disabled"]),
      fe(f$, {
        isOpen: i.value,
        onChange: l[3] || (l[3] = (u) => i.value = u)
      }, {
        default: H(() => [
          fe(h$, {
            width: "s",
            title: E(e)("mt-text-editor-toolbar-button-link.modalTitle")
          }, {
            default: H(() => [
              X("div", K9, [
                fe(im, {
                  label: E(e)("mt-text-editor-toolbar-button-link.linkUrl"),
                  modelValue: r.value,
                  "onUpdate:modelValue": l[0] || (l[0] = (u) => r.value = u),
                  placeholder: "https://example.com",
                  required: ""
                }, null, 8, ["label", "modelValue"]),
                fe(rm, {
                  label: E(e)("mt-text-editor-toolbar-button-link.openInNewTab"),
                  checked: o.value === "_blank",
                  onChange: l[1] || (l[1] = (u) => {
                    o.value = u ? "_blank" : "";
                  }),
                  "aria-label": E(e)("mt-text-editor-toolbar-button-link.openInNewTab")
                }, null, 8, ["label", "checked", "aria-label"])
              ])
            ]),
            footer: H(() => [
              X("div", J9, [
                fe(yb, {
                  as: Sr,
                  variant: "secondary"
                }, {
                  default: H(() => [
                    He(Pe(E(e)("mt-text-editor-toolbar-button-link.cancel")), 1)
                  ]),
                  _: 1
                }),
                fe(Sr, {
                  variant: "primary",
                  onClick: l[2] || (l[2] = () => {
                    t.editor.chain().focus().extendMarkRange("link").setLink({ href: r.value, target: o.value }).run(), i.value = !1;
                  })
                }, {
                  default: H(() => [
                    He(Pe(E(e)("mt-text-editor-toolbar-button-link.applyLink")), 1)
                  ]),
                  _: 1
                })
              ])
            ]),
            _: 1
          }, 8, ["title"])
        ]),
        _: 1
      }, 8, ["isOpen"])
    ], 64));
  }
});
const nK = /* @__PURE__ */ je(tK, [["__scopeId", "data-v-f68a01fa"]]), iK = { class: "mt-text-editor__table-modal" }, rK = { class: "mt-text-editor__table-modal-footer" }, oK = {
  name: "table",
  label: "mt-text-editor-toolbar-button-table.label",
  icon: "regular-table-xs",
  disabled: (t, e) => e ? !0 : t.isActive("table"),
  position: 13e3,
  contextualButtons: (t) => t.isActive("table") ? [
    {
      name: "table-insert-row-before",
      label: "Insert row before",
      icon: "regular-insert-row-before",
      action: (e) => e.chain().focus().addRowBefore().run()
    },
    {
      name: "table-insert-row-after",
      label: "Insert row after",
      icon: "regular-insert-row-after",
      action: (e) => e.chain().focus().addRowAfter().run()
    },
    {
      name: "table-delete-row",
      label: "Delete row",
      icon: "regular-delete-row",
      action: (e) => e.chain().focus().deleteRow().run()
    },
    {
      name: "table-insert-column-before",
      label: "Insert column before",
      icon: "regular-insert-column-before",
      action: (e) => e.chain().focus().addColumnBefore().run()
    },
    {
      name: "table-insert-column-after",
      label: "Insert column after",
      icon: "regular-insert-column-after",
      action: (e) => e.chain().focus().addColumnAfter().run()
    },
    {
      name: "table-delete-column",
      label: "Delete column",
      icon: "regular-delete-column",
      action: (e) => e.chain().focus().deleteColumn().run()
    },
    {
      name: "table-remove-table",
      label: "Remove table",
      icon: "regular-times-xs",
      action: (e) => e.chain().focus().deleteTable().run()
    }
  ] : []
}, sK = /* @__PURE__ */ Te({
  __name: "mt-text-editor-toolbar-button-table",
  props: {
    editor: {
      type: Object,
      required: !0
    },
    button: {
      type: Object,
      required: !0
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  setup(t) {
    const { t: e } = Lt({
      useScope: "global",
      messages: {
        en: {
          "mt-text-editor-toolbar-button-table": {
            label: "Table",
            modalTitle: "Insert/Edit Table",
            insertTable: "Insert table",
            cancel: "Cancel",
            columns: "Columns",
            rows: "Rows",
            showHeader: "Show header",
            insertRowBefore: "Insert row before",
            insertRowAfter: "Insert row after",
            deleteRow: "Delete row",
            insertColumnBefore: "Insert column before",
            insertColumnAfter: "Insert column after",
            deleteColumn: "Delete column",
            removeTable: "Remove table"
          }
        },
        de: {
          "mt-text-editor-toolbar-button-table": {
            label: "Tabelle",
            modalTitle: "Tabelle einfügen/bearbeiten",
            insertTable: "Tabelle einfügen",
            cancel: "Abbrechen",
            columns: "Spalten",
            rows: "Zeilen",
            showHeader: "Kopfzeile anzeigen",
            insertRowBefore: "Zeile davor einfügen",
            insertRowAfter: "Zeile danach einfügen",
            deleteRow: "Zeile löschen",
            insertColumnBefore: "Spalte davor einfügen",
            insertColumnAfter: "Spalte danach einfügen",
            deleteColumn: "Spalte löschen",
            removeTable: "Tabelle entfernen"
          }
        }
      }
    }), n = t, i = re(!1), r = re(3), o = re(3), s = re(!0), a = () => {
      n.editor.isActive("table") || (r.value = 3, o.value = 3, s.value = !0, i.value = !0);
    }, l = () => {
      n.editor.chain().focus().insertTable({
        rows: o.value,
        cols: r.value,
        withHeaderRow: s.value
      }).run(), i.value = !1;
    };
    return (u, c) => (_(), Z(Qe, null, [
      fe(vs, {
        button: t.button,
        editor: n.editor,
        disabled: t.disabled,
        onClick: a
      }, null, 8, ["button", "editor", "disabled"]),
      fe(f$, {
        isOpen: i.value,
        onChange: c[3] || (c[3] = (d) => i.value = d)
      }, {
        default: H(() => [
          fe(h$, {
            title: E(e)("mt-text-editor-toolbar-button-table.modalTitle"),
            width: "s"
          }, {
            default: H(() => [
              X("div", iK, [
                fe(NO, {
                  label: E(e)("mt-text-editor-toolbar-button-table.columns"),
                  modelValue: r.value,
                  "onUpdate:modelValue": c[0] || (c[0] = (d) => r.value = d),
                  type: "number",
                  min: 1,
                  numberType: "int"
                }, null, 8, ["label", "modelValue"]),
                fe(NO, {
                  label: E(e)("mt-text-editor-toolbar-button-table.rows"),
                  modelValue: o.value,
                  "onUpdate:modelValue": c[1] || (c[1] = (d) => o.value = d),
                  type: "number",
                  min: 1,
                  numberType: "int"
                }, null, 8, ["label", "modelValue"]),
                fe(rm, {
                  label: E(e)("mt-text-editor-toolbar-button-table.showHeader"),
                  checked: s.value,
                  onChange: c[2] || (c[2] = (d) => {
                    s.value = d;
                  })
                }, null, 8, ["label", "checked"])
              ])
            ]),
            footer: H(() => [
              X("div", rK, [
                fe(yb, {
                  as: Sr,
                  variant: "secondary"
                }, {
                  default: H(() => [
                    He(Pe(E(e)("mt-text-editor-toolbar-button-table.cancel")), 1)
                  ]),
                  _: 1
                }),
                fe(Sr, {
                  variant: "primary",
                  onClick: l
                }, {
                  default: H(() => [
                    He(Pe(E(e)("mt-text-editor-toolbar-button-table.insertTable")), 1)
                  ]),
                  _: 1
                })
              ])
            ]),
            _: 1
          }, 8, ["title"])
        ]),
        _: 1
      }, 8, ["isOpen"])
    ], 64));
  }
});
const aK = /* @__PURE__ */ je(sK, [["__scopeId", "data-v-e31a079b"]]);
let Pv = [], FM = [];
(() => {
  let t = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, n = 0; e < t.length; e++)
    (e % 2 ? FM : Pv).push(n = n + t[e]);
})();
function lK(t) {
  if (t < 768)
    return !1;
  for (let e = 0, n = Pv.length; ; ) {
    let i = e + n >> 1;
    if (t < Pv[i])
      n = i;
    else if (t >= FM[i])
      e = i + 1;
    else
      return !0;
    if (e == n)
      return !1;
  }
}
function xS(t) {
  return t >= 127462 && t <= 127487;
}
const CS = 8205;
function uK(t, e, n = !0, i = !0) {
  return (n ? qM : cK)(t, e, i);
}
function qM(t, e, n) {
  if (e == t.length)
    return e;
  e && WM(t.charCodeAt(e)) && XM(t.charCodeAt(e - 1)) && e--;
  let i = Lg(t, e);
  for (e += TS(i); e < t.length; ) {
    let r = Lg(t, e);
    if (i == CS || r == CS || n && lK(r))
      e += TS(r), i = r;
    else if (xS(r)) {
      let o = 0, s = e - 2;
      for (; s >= 0 && xS(Lg(t, s)); )
        o++, s -= 2;
      if (o % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function cK(t, e, n) {
  for (; e > 0; ) {
    let i = qM(t, e - 2, n);
    if (i < e)
      return i;
    e--;
  }
  return 0;
}
function Lg(t, e) {
  let n = t.charCodeAt(e);
  if (!XM(n) || e + 1 == t.length)
    return n;
  let i = t.charCodeAt(e + 1);
  return WM(i) ? (n - 55296 << 10) + (i - 56320) + 65536 : n;
}
function WM(t) {
  return t >= 56320 && t < 57344;
}
function XM(t) {
  return t >= 55296 && t < 56320;
}
function TS(t) {
  return t < 65536 ? 1 : 2;
}
class St {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, n, i) {
    [e, n] = tu(this, e, n);
    let r = [];
    return this.decompose(
      0,
      e,
      r,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      r,
      3
      /* Open.To */
    ), this.decompose(
      n,
      this.length,
      r,
      1
      /* Open.From */
    ), Xr.from(r, this.length - (n - e) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, n = this.length) {
    [e, n] = tu(this, e, n);
    let i = [];
    return this.decompose(e, n, i, 0), Xr.from(i, n - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let n = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), r = new xc(this), o = new xc(e);
    for (let s = n, a = n; ; ) {
      if (r.next(s), o.next(s), s = 0, r.lineBreak != o.lineBreak || r.done != o.done || r.value != o.value)
        return !1;
      if (a += r.value.length, r.done || a >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new xc(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, n = this.length) {
    return new zM(this, e, n);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, n) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let r = this.line(e).from;
      i = this.iterRange(r, Math.max(r, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new jM(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? St.empty : e.length <= 32 ? new gn(e) : Xr.from(gn.split(e, []));
  }
}
class gn extends St {
  constructor(e, n = dK(e)) {
    super(), this.text = e, this.length = n;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, n, i, r) {
    for (let o = 0; ; o++) {
      let s = this.text[o], a = r + s.length;
      if ((n ? i : a) >= e)
        return new hK(r, a, i, s);
      r = a + 1, i++;
    }
  }
  decompose(e, n, i, r) {
    let o = e <= 0 && n >= this.length ? this : new gn($S(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
    if (r & 1) {
      let s = i.pop(), a = Zh(o.text, s.text.slice(), 0, o.length);
      if (a.length <= 32)
        i.push(new gn(a, s.length + o.length));
      else {
        let l = a.length >> 1;
        i.push(new gn(a.slice(0, l)), new gn(a.slice(l)));
      }
    } else
      i.push(o);
  }
  replace(e, n, i) {
    if (!(i instanceof gn))
      return super.replace(e, n, i);
    [e, n] = tu(this, e, n);
    let r = Zh(this.text, Zh(i.text, $S(this.text, 0, e)), n), o = this.length + i.length - (n - e);
    return r.length <= 32 ? new gn(r, o) : Xr.from(gn.split(r, []), o);
  }
  sliceString(e, n = this.length, i = `
`) {
    [e, n] = tu(this, e, n);
    let r = "";
    for (let o = 0, s = 0; o <= n && s < this.text.length; s++) {
      let a = this.text[s], l = o + a.length;
      o > e && s && (r += i), e < l && n > o && (r += a.slice(Math.max(0, e - o), n - o)), o = l + 1;
    }
    return r;
  }
  flatten(e) {
    for (let n of this.text)
      e.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, n) {
    let i = [], r = -1;
    for (let o of e)
      i.push(o), r += o.length + 1, i.length == 32 && (n.push(new gn(i, r)), i = [], r = -1);
    return r > -1 && n.push(new gn(i, r)), n;
  }
}
class Xr extends St {
  constructor(e, n) {
    super(), this.children = e, this.length = n, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, n, i, r) {
    for (let o = 0; ; o++) {
      let s = this.children[o], a = r + s.length, l = i + s.lines - 1;
      if ((n ? l : a) >= e)
        return s.lineInner(e, n, i, r);
      r = a + 1, i = l + 1;
    }
  }
  decompose(e, n, i, r) {
    for (let o = 0, s = 0; s <= n && o < this.children.length; o++) {
      let a = this.children[o], l = s + a.length;
      if (e <= l && n >= s) {
        let u = r & ((s <= e ? 1 : 0) | (l >= n ? 2 : 0));
        s >= e && l <= n && !u ? i.push(a) : a.decompose(e - s, n - s, i, u);
      }
      s = l + 1;
    }
  }
  replace(e, n, i) {
    if ([e, n] = tu(this, e, n), i.lines < this.lines)
      for (let r = 0, o = 0; r < this.children.length; r++) {
        let s = this.children[r], a = o + s.length;
        if (e >= o && n <= a) {
          let l = s.replace(e - o, n - o, i), u = this.lines - s.lines + l.lines;
          if (l.lines < u >> 5 - 1 && l.lines > u >> 5 + 1) {
            let c = this.children.slice();
            return c[r] = l, new Xr(c, this.length - (n - e) + i.length);
          }
          return super.replace(o, a, l);
        }
        o = a + 1;
      }
    return super.replace(e, n, i);
  }
  sliceString(e, n = this.length, i = `
`) {
    [e, n] = tu(this, e, n);
    let r = "";
    for (let o = 0, s = 0; o < this.children.length && s <= n; o++) {
      let a = this.children[o], l = s + a.length;
      s > e && o && (r += i), e < l && n > s && (r += a.sliceString(e - s, n - s, i)), s = l + 1;
    }
    return r;
  }
  flatten(e) {
    for (let n of this.children)
      n.flatten(e);
  }
  scanIdentical(e, n) {
    if (!(e instanceof Xr))
      return 0;
    let i = 0, [r, o, s, a] = n > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; r += n, o += n) {
      if (r == s || o == a)
        return i;
      let l = this.children[r], u = e.children[o];
      if (l != u)
        return i + l.scanIdentical(u, n);
      i += l.length + 1;
    }
  }
  static from(e, n = e.reduce((i, r) => i + r.length + 1, -1)) {
    let i = 0;
    for (let f of e)
      i += f.lines;
    if (i < 32) {
      let f = [];
      for (let p of e)
        p.flatten(f);
      return new gn(f, n);
    }
    let r = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), o = r << 1, s = r >> 1, a = [], l = 0, u = -1, c = [];
    function d(f) {
      let p;
      if (f.lines > o && f instanceof Xr)
        for (let m of f.children)
          d(m);
      else
        f.lines > s && (l > s || !l) ? (h(), a.push(f)) : f instanceof gn && l && (p = c[c.length - 1]) instanceof gn && f.lines + p.lines <= 32 ? (l += f.lines, u += f.length + 1, c[c.length - 1] = new gn(p.text.concat(f.text), p.length + 1 + f.length)) : (l + f.lines > r && h(), l += f.lines, u += f.length + 1, c.push(f));
    }
    function h() {
      l != 0 && (a.push(c.length == 1 ? c[0] : Xr.from(c, u)), u = -1, l = c.length = 0);
    }
    for (let f of e)
      d(f);
    return h(), a.length == 1 ? a[0] : new Xr(a, n);
  }
}
St.empty = /* @__PURE__ */ new gn([""], 0);
function dK(t) {
  let e = -1;
  for (let n of t)
    e += n.length + 1;
  return e;
}
function Zh(t, e, n = 0, i = 1e9) {
  for (let r = 0, o = 0, s = !0; o < t.length && r <= i; o++) {
    let a = t[o], l = r + a.length;
    l >= n && (l > i && (a = a.slice(0, i - r)), r < n && (a = a.slice(n - r)), s ? (e[e.length - 1] += a, s = !1) : e.push(a)), r = l + 1;
  }
  return e;
}
function $S(t, e, n) {
  return Zh(t, [""], e, n);
}
class xc {
  constructor(e, n = 1) {
    this.dir = n, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [n > 0 ? 1 : (e instanceof gn ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, r = this.nodes[i], o = this.offsets[i], s = o >> 1, a = r instanceof gn ? r.text.length : r.children.length;
      if (s == (n > 0 ? a : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        n > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((o & 1) == (n > 0 ? 0 : 1)) {
        if (this.offsets[i] += n, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (r instanceof gn) {
        let l = r.text[s + (n < 0 ? -1 : 0)];
        if (this.offsets[i] += n, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : n > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = r.children[s + (n < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[i] += n) : (n < 0 && this.offsets[i]--, this.nodes.push(l), this.offsets.push(n > 0 ? 1 : (l instanceof gn ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class zM {
  constructor(e, n, i) {
    this.value = "", this.done = !1, this.cursor = new xc(e, n > i ? -1 : 1), this.pos = n > i ? e.length : 0, this.from = Math.min(n, i), this.to = Math.max(n, i);
  }
  nextInner(e, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let i = n < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: r } = this.cursor.next(e);
    return this.pos += (r.length + e) * n, this.value = r.length <= i ? r : n < 0 ? r.slice(r.length - i) : r.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class jM {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: n, lineBreak: i, value: r } = this.inner.next(e);
    return n && this.afterBreak ? (this.value = "", this.afterBreak = !1) : n ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = r, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (St.prototype[Symbol.iterator] = function() {
  return this.iter();
}, xc.prototype[Symbol.iterator] = zM.prototype[Symbol.iterator] = jM.prototype[Symbol.iterator] = function() {
  return this;
});
class hK {
  /**
  @internal
  */
  constructor(e, n, i, r) {
    this.from = e, this.to = n, this.number = i, this.text = r;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function tu(t, e, n) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, n))];
}
function Zn(t, e, n = !0, i = !0) {
  return uK(t, e, n, i);
}
function fK(t) {
  return t >= 56320 && t < 57344;
}
function pK(t) {
  return t >= 55296 && t < 56320;
}
function bi(t, e) {
  let n = t.charCodeAt(e);
  if (!pK(n) || e + 1 == t.length)
    return n;
  let i = t.charCodeAt(e + 1);
  return fK(i) ? (n - 55296 << 10) + (i - 56320) + 65536 : n;
}
function l0(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function zr(t) {
  return t < 65536 ? 1 : 2;
}
const Mv = /\r\n?|\n/;
var Bn = /* @__PURE__ */ function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(Bn || (Bn = {}));
class ro {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2)
      e += this.sections[n];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let i = this.sections[n + 1];
      e += i < 0 ? this.sections[n] : i;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let n = 0, i = 0, r = 0; n < this.sections.length; ) {
      let o = this.sections[n++], s = this.sections[n++];
      s < 0 ? (e(i, r, o), r += o) : r += s, i += o;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, n = !1) {
    Ev(this, e, n);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let n = 0; n < this.sections.length; ) {
      let i = this.sections[n++], r = this.sections[n++];
      r < 0 ? e.push(i, r) : e.push(r, i);
    }
    return new ro(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : YM(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, n = !1) {
    return e.empty ? this : Av(this, e, n);
  }
  mapPos(e, n = -1, i = Bn.Simple) {
    let r = 0, o = 0;
    for (let s = 0; s < this.sections.length; ) {
      let a = this.sections[s++], l = this.sections[s++], u = r + a;
      if (l < 0) {
        if (u > e)
          return o + (e - r);
        o += a;
      } else {
        if (i != Bn.Simple && u >= e && (i == Bn.TrackDel && r < e && u > e || i == Bn.TrackBefore && r < e || i == Bn.TrackAfter && u > e))
          return null;
        if (u > e || u == e && n < 0 && !a)
          return e == r || n < 0 ? o : o + l;
        o += l;
      }
      r = u;
    }
    if (e > r)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${r}`);
    return o;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, n = e) {
    for (let i = 0, r = 0; i < this.sections.length && r <= n; ) {
      let o = this.sections[i++], s = this.sections[i++], a = r + o;
      if (s >= 0 && r <= n && a >= e)
        return r < e && a > n ? "cover" : !0;
      r = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 0; n < this.sections.length; ) {
      let i = this.sections[n++], r = this.sections[n++];
      e += (e ? " " : "") + i + (r >= 0 ? ":" + r : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ro(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new ro(e);
  }
}
class Cn extends ro {
  constructor(e, n) {
    super(e), this.inserted = n;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Ev(this, (n, i, r, o, s) => e = e.replace(r, r + (i - n), s), !1), e;
  }
  mapDesc(e, n = !1) {
    return Av(this, e, n, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let n = this.sections.slice(), i = [];
    for (let r = 0, o = 0; r < n.length; r += 2) {
      let s = n[r], a = n[r + 1];
      if (a >= 0) {
        n[r] = a, n[r + 1] = s;
        let l = r >> 1;
        for (; i.length < l; )
          i.push(St.empty);
        i.push(s ? e.slice(o, o + s) : St.empty);
      }
      o += s;
    }
    return new Cn(n, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : YM(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, n = !1) {
    return e.empty ? this : Av(this, e, n, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, n = !1) {
    Ev(this, e, n);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ro.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let n = [], i = [], r = [], o = new nd(this);
    e:
      for (let s = 0, a = 0; ; ) {
        let l = s == e.length ? 1e9 : e[s++];
        for (; a < l || a == l && o.len == 0; ) {
          if (o.done)
            break e;
          let c = Math.min(o.len, l - a);
          zn(r, c, -1);
          let d = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0;
          zn(n, c, d), d > 0 && ys(i, n, o.text), o.forward(c), a += c;
        }
        let u = e[s++];
        for (; a < u; ) {
          if (o.done)
            break e;
          let c = Math.min(o.len, u - a);
          zn(n, c, -1), zn(r, c, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(c), a += c;
        }
      }
    return {
      changes: new Cn(n, i),
      filtered: ro.create(r)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let i = this.sections[n], r = this.sections[n + 1];
      r < 0 ? e.push(i) : r == 0 ? e.push([i]) : e.push([i].concat(this.inserted[n >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, n, i) {
    let r = [], o = [], s = 0, a = null;
    function l(c = !1) {
      if (!c && !r.length)
        return;
      s < n && zn(r, n - s, -1);
      let d = new Cn(r, o);
      a = a ? a.compose(d.map(a)) : d, r = [], o = [], s = 0;
    }
    function u(c) {
      if (Array.isArray(c))
        for (let d of c)
          u(d);
      else if (c instanceof Cn) {
        if (c.length != n)
          throw new RangeError(`Mismatched change set length (got ${c.length}, expected ${n})`);
        l(), a = a ? a.compose(c.map(a)) : c;
      } else {
        let { from: d, to: h = d, insert: f } = c;
        if (d > h || d < 0 || h > n)
          throw new RangeError(`Invalid change range ${d} to ${h} (in doc of length ${n})`);
        let p = f ? typeof f == "string" ? St.of(f.split(i || Mv)) : f : St.empty, m = p.length;
        if (d == h && m == 0)
          return;
        d < s && l(), d > s && zn(r, d - s, -1), zn(r, h - d, m), ys(o, r, p), s = h;
      }
    }
    return u(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Cn(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [], i = [];
    for (let r = 0; r < e.length; r++) {
      let o = e[r];
      if (typeof o == "number")
        n.push(o, -1);
      else {
        if (!Array.isArray(o) || typeof o[0] != "number" || o.some((s, a) => a && typeof s != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (o.length == 1)
          n.push(o[0], 0);
        else {
          for (; i.length < r; )
            i.push(St.empty);
          i[r] = St.of(o.slice(1)), n.push(o[0], i[r].length);
        }
      }
    }
    return new Cn(n, i);
  }
  /**
  @internal
  */
  static createSet(e, n) {
    return new Cn(e, n);
  }
}
function zn(t, e, n, i = !1) {
  if (e == 0 && n <= 0)
    return;
  let r = t.length - 2;
  r >= 0 && n <= 0 && n == t[r + 1] ? t[r] += e : r >= 0 && e == 0 && t[r] == 0 ? t[r + 1] += n : i ? (t[r] += e, t[r + 1] += n) : t.push(e, n);
}
function ys(t, e, n) {
  if (n.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < t.length)
    t[t.length - 1] = t[t.length - 1].append(n);
  else {
    for (; t.length < i; )
      t.push(St.empty);
    t.push(n);
  }
}
function Ev(t, e, n) {
  let i = t.inserted;
  for (let r = 0, o = 0, s = 0; s < t.sections.length; ) {
    let a = t.sections[s++], l = t.sections[s++];
    if (l < 0)
      r += a, o += a;
    else {
      let u = r, c = o, d = St.empty;
      for (; u += a, c += l, l && i && (d = d.append(i[s - 2 >> 1])), !(n || s == t.sections.length || t.sections[s + 1] < 0); )
        a = t.sections[s++], l = t.sections[s++];
      e(r, u, o, c, d), r = u, o = c;
    }
  }
}
function Av(t, e, n, i = !1) {
  let r = [], o = i ? [] : null, s = new nd(t), a = new nd(e);
  for (let l = -1; ; ) {
    if (s.done && a.len || a.done && s.len)
      throw new Error("Mismatched change set lengths");
    if (s.ins == -1 && a.ins == -1) {
      let u = Math.min(s.len, a.len);
      zn(r, u, -1), s.forward(u), a.forward(u);
    } else if (a.ins >= 0 && (s.ins < 0 || l == s.i || s.off == 0 && (a.len < s.len || a.len == s.len && !n))) {
      let u = a.len;
      for (zn(r, a.ins, -1); u; ) {
        let c = Math.min(s.len, u);
        s.ins >= 0 && l < s.i && s.len <= c && (zn(r, 0, s.ins), o && ys(o, r, s.text), l = s.i), s.forward(c), u -= c;
      }
      a.next();
    } else if (s.ins >= 0) {
      let u = 0, c = s.len;
      for (; c; )
        if (a.ins == -1) {
          let d = Math.min(c, a.len);
          u += d, c -= d, a.forward(d);
        } else if (a.ins == 0 && a.len < c)
          c -= a.len, a.next();
        else
          break;
      zn(r, u, l < s.i ? s.ins : 0), o && l < s.i && ys(o, r, s.text), l = s.i, s.forward(s.len - c);
    } else {
      if (s.done && a.done)
        return o ? Cn.createSet(r, o) : ro.create(r);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function YM(t, e, n = !1) {
  let i = [], r = n ? [] : null, o = new nd(t), s = new nd(e);
  for (let a = !1; ; ) {
    if (o.done && s.done)
      return r ? Cn.createSet(i, r) : ro.create(i);
    if (o.ins == 0)
      zn(i, o.len, 0, a), o.next();
    else if (s.len == 0 && !s.done)
      zn(i, 0, s.ins, a), r && ys(r, i, s.text), s.next();
    else {
      if (o.done || s.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(o.len2, s.len), u = i.length;
        if (o.ins == -1) {
          let c = s.ins == -1 ? -1 : s.off ? 0 : s.ins;
          zn(i, l, c, a), r && c && ys(r, i, s.text);
        } else
          s.ins == -1 ? (zn(i, o.off ? 0 : o.len, l, a), r && ys(r, i, o.textBit(l))) : (zn(i, o.off ? 0 : o.len, s.off ? 0 : s.ins, a), r && !s.off && ys(r, i, s.text));
        a = (o.ins > l || s.ins >= 0 && s.len > l) && (a || i.length > u), o.forward2(l), s.forward(l);
      }
    }
  }
}
class nd {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, n = this.i - 2 >> 1;
    return n >= e.length ? St.empty : e[n];
  }
  textBit(e) {
    let { inserted: n } = this.set, i = this.i - 2 >> 1;
    return i >= n.length && !e ? St.empty : n[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class pa {
  constructor(e, n, i) {
    this.from = e, this.to = n, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, n = -1) {
    let i, r;
    return this.empty ? i = r = e.mapPos(this.from, n) : (i = e.mapPos(this.from, 1), r = e.mapPos(this.to, -1)), i == this.from && r == this.to ? this : new pa(i, r, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, n = e) {
    if (e <= this.anchor && n >= this.anchor)
      return ve.range(e, n);
    let i = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
    return ve.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(e, n = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return ve.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, n, i) {
    return new pa(e, n, i);
  }
}
class ve {
  constructor(e, n) {
    this.ranges = e, this.mainIndex = n;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, n = -1) {
    return e.empty ? this : ve.create(this.ranges.map((i) => i.map(e, n)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, n = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(e.ranges[i], n))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new ve([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, n = !0) {
    return ve.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, n = this.mainIndex) {
    let i = this.ranges.slice();
    return i[n] = e, ve.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new ve(e.ranges.map((n) => pa.fromJSON(n)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, n = e) {
    return new ve([ve.range(e, n)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, n = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, r = 0; r < e.length; r++) {
      let o = e[r];
      if (o.empty ? o.from <= i : o.from < i)
        return ve.normalized(e.slice(), n);
      i = o.to;
    }
    return new ve(e, n);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, n = 0, i, r) {
    return pa.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (r ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, n, i, r) {
    let o = (i ?? 16777215) << 6 | (r == null ? 7 : Math.min(6, r));
    return n < e ? pa.create(n, e, 48 | o) : pa.create(e, n, (n > e ? 8 : 0) | o);
  }
  /**
  @internal
  */
  static normalized(e, n = 0) {
    let i = e[n];
    e.sort((r, o) => r.from - o.from), n = e.indexOf(i);
    for (let r = 1; r < e.length; r++) {
      let o = e[r], s = e[r - 1];
      if (o.empty ? o.from <= s.to : o.from < s.to) {
        let a = s.from, l = Math.max(o.to, s.to);
        r <= n && n--, e.splice(--r, 2, o.anchor > o.head ? ve.range(l, a) : ve.range(a, l));
      }
    }
    return new ve(e, n);
  }
}
function HM(t, e) {
  for (let n of t.ranges)
    if (n.to > e)
      throw new RangeError("Selection points outside of document");
}
let u0 = 0;
class Ze {
  constructor(e, n, i, r, o) {
    this.combine = e, this.compareInput = n, this.compare = i, this.isStatic = r, this.id = u0++, this.default = e([]), this.extensions = typeof o == "function" ? o(this) : o;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new Ze(e.combine || ((n) => n), e.compareInput || ((n, i) => n === i), e.compare || (e.combine ? (n, i) => n === i : c0), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new Fh([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Fh(e, this, 1, n);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Fh(e, this, 2, n);
  }
  from(e, n) {
    return n || (n = (i) => i), this.compute([e], (i) => n(i.field(e)));
  }
}
function c0(t, e) {
  return t == e || t.length == e.length && t.every((n, i) => n === e[i]);
}
class Fh {
  constructor(e, n, i, r) {
    this.dependencies = e, this.facet = n, this.type = i, this.value = r, this.id = u0++;
  }
  dynamicSlot(e) {
    var n;
    let i = this.value, r = this.facet.compareInput, o = this.id, s = e[o] >> 1, a = this.type == 2, l = !1, u = !1, c = [];
    for (let d of this.dependencies)
      d == "doc" ? l = !0 : d == "selection" ? u = !0 : ((n = e[d.id]) !== null && n !== void 0 ? n : 1) & 1 || c.push(e[d.id]);
    return {
      create(d) {
        return d.values[s] = i(d), 1;
      },
      update(d, h) {
        if (l && h.docChanged || u && (h.docChanged || h.selection) || Rv(d, c)) {
          let f = i(d);
          if (a ? !PS(f, d.values[s], r) : !r(f, d.values[s]))
            return d.values[s] = f, 1;
        }
        return 0;
      },
      reconfigure: (d, h) => {
        let f, p = h.config.address[o];
        if (p != null) {
          let m = ap(h, p);
          if (this.dependencies.every((g) => g instanceof Ze ? h.facet(g) === d.facet(g) : g instanceof xn ? h.field(g, !1) == d.field(g, !1) : !0) || (a ? PS(f = i(d), m, r) : r(f = i(d), m)))
            return d.values[s] = m, 0;
        } else
          f = i(d);
        return d.values[s] = f, 1;
      }
    };
  }
}
function PS(t, e, n) {
  if (t.length != e.length)
    return !1;
  for (let i = 0; i < t.length; i++)
    if (!n(t[i], e[i]))
      return !1;
  return !0;
}
function Rv(t, e) {
  let n = !1;
  for (let i of e)
    Cc(t, i) & 1 && (n = !0);
  return n;
}
function mK(t, e, n) {
  let i = n.map((l) => t[l.id]), r = n.map((l) => l.type), o = i.filter((l) => !(l & 1)), s = t[e.id] >> 1;
  function a(l) {
    let u = [];
    for (let c = 0; c < i.length; c++) {
      let d = ap(l, i[c]);
      if (r[c] == 2)
        for (let h of d)
          u.push(h);
      else
        u.push(d);
    }
    return e.combine(u);
  }
  return {
    create(l) {
      for (let u of i)
        Cc(l, u);
      return l.values[s] = a(l), 1;
    },
    update(l, u) {
      if (!Rv(l, o))
        return 0;
      let c = a(l);
      return e.compare(c, l.values[s]) ? 0 : (l.values[s] = c, 1);
    },
    reconfigure(l, u) {
      let c = Rv(l, i), d = u.config.facets[e.id], h = u.facet(e);
      if (d && !c && c0(n, d))
        return l.values[s] = h, 0;
      let f = a(l);
      return e.compare(f, h) ? (l.values[s] = h, 0) : (l.values[s] = f, 1);
    }
  };
}
const MS = /* @__PURE__ */ Ze.define({ static: !0 });
class xn {
  constructor(e, n, i, r, o) {
    this.id = e, this.createF = n, this.updateF = i, this.compareF = r, this.spec = o, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let n = new xn(u0++, e.create, e.update, e.compare || ((i, r) => i === r), e);
    return e.provide && (n.provides = e.provide(n)), n;
  }
  create(e) {
    let n = e.facet(MS).find((i) => i.field == this);
    return ((n == null ? void 0 : n.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let n = e[this.id] >> 1;
    return {
      create: (i) => (i.values[n] = this.create(i), 1),
      update: (i, r) => {
        let o = i.values[n], s = this.updateF(o, r);
        return this.compareF(o, s) ? 0 : (i.values[n] = s, 1);
      },
      reconfigure: (i, r) => r.config.address[this.id] != null ? (i.values[n] = r.field(this), 0) : (i.values[n] = this.create(i), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, MS.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const aa = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Lu(t) {
  return (e) => new UM(e, t);
}
const Us = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Lu(aa.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Lu(aa.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Lu(aa.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Lu(aa.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Lu(aa.lowest)
};
class UM {
  constructor(e, n) {
    this.inner = e, this.prec = n;
  }
}
class nu {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new Dv(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return nu.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class Dv {
  constructor(e, n) {
    this.compartment = e, this.inner = n;
  }
}
class sp {
  constructor(e, n, i, r, o, s) {
    for (this.base = e, this.compartments = n, this.dynamicSlots = i, this.address = r, this.staticValues = o, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let n = this.address[e.id];
    return n == null ? e.default : this.staticValues[n >> 1];
  }
  static resolve(e, n, i) {
    let r = [], o = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map();
    for (let h of gK(e, n, s))
      h instanceof xn ? r.push(h) : (o[h.facet.id] || (o[h.facet.id] = [])).push(h);
    let a = /* @__PURE__ */ Object.create(null), l = [], u = [];
    for (let h of r)
      a[h.id] = u.length << 1, u.push((f) => h.slot(f));
    let c = i == null ? void 0 : i.config.facets;
    for (let h in o) {
      let f = o[h], p = f[0].facet, m = c && c[h] || [];
      if (f.every(
        (g) => g.type == 0
        /* Provider.Static */
      ))
        if (a[p.id] = l.length << 1 | 1, c0(m, f))
          l.push(i.facet(p));
        else {
          let g = p.combine(f.map((O) => O.value));
          l.push(i && p.compare(g, i.facet(p)) ? i.facet(p) : g);
        }
      else {
        for (let g of f)
          g.type == 0 ? (a[g.id] = l.length << 1 | 1, l.push(g.value)) : (a[g.id] = u.length << 1, u.push((O) => g.dynamicSlot(O)));
        a[p.id] = u.length << 1, u.push((g) => mK(g, p, f));
      }
    }
    let d = u.map((h) => h(a));
    return new sp(e, s, d, a, l, o);
  }
}
function gK(t, e, n) {
  let i = [[], [], [], [], []], r = /* @__PURE__ */ new Map();
  function o(s, a) {
    let l = r.get(s);
    if (l != null) {
      if (l <= a)
        return;
      let u = i[l].indexOf(s);
      u > -1 && i[l].splice(u, 1), s instanceof Dv && n.delete(s.compartment);
    }
    if (r.set(s, a), Array.isArray(s))
      for (let u of s)
        o(u, a);
    else if (s instanceof Dv) {
      if (n.has(s.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let u = e.get(s.compartment) || s.inner;
      n.set(s.compartment, u), o(u, a);
    } else if (s instanceof UM)
      o(s.inner, s.prec);
    else if (s instanceof xn)
      i[a].push(s), s.provides && o(s.provides, a);
    else if (s instanceof Fh)
      i[a].push(s), s.facet.extensions && o(s.facet.extensions, aa.default);
    else {
      let u = s.extension;
      if (!u)
        throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      o(u, a);
    }
  }
  return o(t, aa.default), i.reduce((s, a) => s.concat(a));
}
function Cc(t, e) {
  if (e & 1)
    return 2;
  let n = e >> 1, i = t.status[n];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  t.status[n] = 4;
  let r = t.computeSlot(t, t.config.dynamicSlots[n]);
  return t.status[n] = 2 | r;
}
function ap(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const GM = /* @__PURE__ */ Ze.define(), Qv = /* @__PURE__ */ Ze.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), KM = /* @__PURE__ */ Ze.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), JM = /* @__PURE__ */ Ze.define(), eE = /* @__PURE__ */ Ze.define(), tE = /* @__PURE__ */ Ze.define(), nE = /* @__PURE__ */ Ze.define({
  combine: (t) => t.length ? t[0] : !1
});
class Uo {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new OK();
  }
}
class OK {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Uo(this, e);
  }
}
class vK {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new ot(this, e);
  }
}
class ot {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let n = this.type.map(this.value, e);
    return n === void 0 ? void 0 : n == this.value ? this : new ot(this.type, n);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new vK(e.map || ((n) => n));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, n) {
    if (!e.length)
      return e;
    let i = [];
    for (let r of e) {
      let o = r.map(n);
      o && i.push(o);
    }
    return i;
  }
}
ot.reconfigure = /* @__PURE__ */ ot.define();
ot.appendConfig = /* @__PURE__ */ ot.define();
class Sn {
  constructor(e, n, i, r, o, s) {
    this.startState = e, this.changes = n, this.selection = i, this.effects = r, this.annotations = o, this.scrollIntoView = s, this._doc = null, this._state = null, i && HM(i, n.newLength), o.some((a) => a.type == Sn.time) || (this.annotations = o.concat(Sn.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, n, i, r, o, s) {
    return new Sn(e, n, i, r, o, s);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let n of this.annotations)
      if (n.type == e)
        return n.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let n = this.annotation(Sn.userEvent);
    return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == "."));
  }
}
Sn.time = /* @__PURE__ */ Uo.define();
Sn.userEvent = /* @__PURE__ */ Uo.define();
Sn.addToHistory = /* @__PURE__ */ Uo.define();
Sn.remote = /* @__PURE__ */ Uo.define();
function yK(t, e) {
  let n = [];
  for (let i = 0, r = 0; ; ) {
    let o, s;
    if (i < t.length && (r == e.length || e[r] >= t[i]))
      o = t[i++], s = t[i++];
    else if (r < e.length)
      o = e[r++], s = e[r++];
    else
      return n;
    !n.length || n[n.length - 1] < o ? n.push(o, s) : n[n.length - 1] < s && (n[n.length - 1] = s);
  }
}
function iE(t, e, n) {
  var i;
  let r, o, s;
  return n ? (r = e.changes, o = Cn.empty(e.changes.length), s = t.changes.compose(e.changes)) : (r = e.changes.map(t.changes), o = t.changes.mapDesc(e.changes, !0), s = t.changes.compose(r)), {
    changes: s,
    selection: e.selection ? e.selection.map(o) : (i = t.selection) === null || i === void 0 ? void 0 : i.map(r),
    effects: ot.mapEffects(t.effects, r).concat(ot.mapEffects(e.effects, o)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function Nv(t, e, n) {
  let i = e.selection, r = Cl(e.annotations);
  return e.userEvent && (r = r.concat(Sn.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Cn ? e.changes : Cn.of(e.changes || [], n, t.facet(KM)),
    selection: i && (i instanceof ve ? i : ve.single(i.anchor, i.head)),
    effects: Cl(e.effects),
    annotations: r,
    scrollIntoView: !!e.scrollIntoView
  };
}
function rE(t, e, n) {
  let i = Nv(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (n = !1);
  for (let o = 1; o < e.length; o++) {
    e[o].filter === !1 && (n = !1);
    let s = !!e[o].sequential;
    i = iE(i, Nv(t, e[o], s ? i.changes.newLength : t.doc.length), s);
  }
  let r = Sn.create(t, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return wK(n ? bK(r) : r);
}
function bK(t) {
  let e = t.startState, n = !0;
  for (let r of e.facet(JM)) {
    let o = r(t);
    if (o === !1) {
      n = !1;
      break;
    }
    Array.isArray(o) && (n = n === !0 ? o : yK(n, o));
  }
  if (n !== !0) {
    let r, o;
    if (n === !1)
      o = t.changes.invertedDesc, r = Cn.empty(e.doc.length);
    else {
      let s = t.changes.filter(n);
      r = s.changes, o = s.filtered.mapDesc(s.changes).invertedDesc;
    }
    t = Sn.create(e, r, t.selection && t.selection.map(o), ot.mapEffects(t.effects, o), t.annotations, t.scrollIntoView);
  }
  let i = e.facet(eE);
  for (let r = i.length - 1; r >= 0; r--) {
    let o = i[r](t);
    o instanceof Sn ? t = o : Array.isArray(o) && o.length == 1 && o[0] instanceof Sn ? t = o[0] : t = rE(e, Cl(o), !1);
  }
  return t;
}
function wK(t) {
  let e = t.startState, n = e.facet(tE), i = t;
  for (let r = n.length - 1; r >= 0; r--) {
    let o = n[r](t);
    o && Object.keys(o).length && (i = iE(i, Nv(e, o, t.changes.newLength), !0));
  }
  return i == t ? t : Sn.create(e, t.changes, t.selection, i.effects, i.annotations, i.scrollIntoView);
}
const kK = [];
function Cl(t) {
  return t == null ? kK : Array.isArray(t) ? t : [t];
}
var Ut = /* @__PURE__ */ function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(Ut || (Ut = {}));
const SK = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Iv;
try {
  Iv = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function _K(t) {
  if (Iv)
    return Iv.test(t);
  for (let e = 0; e < t.length; e++) {
    let n = t[e];
    if (/\w/.test(n) || n > "" && (n.toUpperCase() != n.toLowerCase() || SK.test(n)))
      return !0;
  }
  return !1;
}
function xK(t) {
  return (e) => {
    if (!/\S/.test(e))
      return Ut.Space;
    if (_K(e))
      return Ut.Word;
    for (let n = 0; n < t.length; n++)
      if (e.indexOf(t[n]) > -1)
        return Ut.Word;
    return Ut.Other;
  };
}
class ht {
  constructor(e, n, i, r, o, s) {
    this.config = e, this.doc = n, this.selection = i, this.values = r, this.status = e.statusTemplate.slice(), this.computeSlot = o, s && (s._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      Cc(this, a << 1);
    this.computeSlot = null;
  }
  field(e, n = !0) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (n)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Cc(this, i), ap(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return rE(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let n = this.config, { base: i, compartments: r } = n;
    for (let a of e.effects)
      a.is(nu.reconfigure) ? (n && (r = /* @__PURE__ */ new Map(), n.compartments.forEach((l, u) => r.set(u, l)), n = null), r.set(a.value.compartment, a.value.extension)) : a.is(ot.reconfigure) ? (n = null, i = a.value) : a.is(ot.appendConfig) && (n = null, i = Cl(i).concat(a.value));
    let o;
    n ? o = e.startState.values.slice() : (n = sp.resolve(i, r, this), o = new ht(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (l, u) => u.reconfigure(l, this), null).values);
    let s = e.startState.facet(Qv) ? e.newSelection : e.newSelection.asSingle();
    new ht(n, e.newDoc, s, o, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((n) => ({
      changes: { from: n.from, to: n.to, insert: e },
      range: ve.cursor(n.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let n = this.selection, i = e(n.ranges[0]), r = this.changes(i.changes), o = [i.range], s = Cl(i.effects);
    for (let a = 1; a < n.ranges.length; a++) {
      let l = e(n.ranges[a]), u = this.changes(l.changes), c = u.map(r);
      for (let h = 0; h < a; h++)
        o[h] = o[h].map(c);
      let d = r.mapDesc(u, !0);
      o.push(l.range.map(d)), r = r.compose(c), s = ot.mapEffects(s, c).concat(ot.mapEffects(Cl(l.effects), d));
    }
    return {
      changes: r,
      selection: ve.create(o, n.mainIndex),
      effects: s
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Cn ? e : Cn.of(e, this.doc.length, this.facet(ht.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return St.of(e.split(this.facet(ht.lineSeparator) || Mv));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, n = this.doc.length) {
    return this.doc.sliceString(e, n, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let n = this.config.address[e.id];
    return n == null ? e.default : (Cc(this, n), ap(this, n));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let n = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let r = e[i];
        r instanceof xn && this.config.address[r.id] != null && (n[i] = r.spec.toJSON(this.field(e[i]), this));
      }
    return n;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, n = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let r = [];
    if (i) {
      for (let o in i)
        if (Object.prototype.hasOwnProperty.call(e, o)) {
          let s = i[o], a = e[o];
          r.push(s.init((l) => s.spec.fromJSON(a, l)));
        }
    }
    return ht.create({
      doc: e.doc,
      selection: ve.fromJSON(e.selection),
      extensions: n.extensions ? r.concat([n.extensions]) : r
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let n = sp.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof St ? e.doc : St.of((e.doc || "").split(n.staticFacet(ht.lineSeparator) || Mv)), r = e.selection ? e.selection instanceof ve ? e.selection : ve.single(e.selection.anchor, e.selection.head) : ve.single(0);
    return HM(r, i.length), n.staticFacet(Qv) || (r = r.asSingle()), new ht(n, i, r, n.dynamicSlots.map(() => null), (o, s) => s.create(o), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(ht.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(ht.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(nE);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...n) {
    for (let i of this.facet(ht.phrases))
      if (Object.prototype.hasOwnProperty.call(i, e)) {
        e = i[e];
        break;
      }
    return n.length && (e = e.replace(/\$(\$|\d*)/g, (i, r) => {
      if (r == "$")
        return "$";
      let o = +(r || 1);
      return !o || o > n.length ? i : n[o - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, n, i = -1) {
    let r = [];
    for (let o of this.facet(GM))
      for (let s of o(this, n, i))
        Object.prototype.hasOwnProperty.call(s, e) && r.push(s[e]);
    return r;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return xK(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: n, from: i, length: r } = this.doc.lineAt(e), o = this.charCategorizer(e), s = e - i, a = e - i;
    for (; s > 0; ) {
      let l = Zn(n, s, !1);
      if (o(n.slice(l, s)) != Ut.Word)
        break;
      s = l;
    }
    for (; a < r; ) {
      let l = Zn(n, a);
      if (o(n.slice(a, l)) != Ut.Word)
        break;
      a = l;
    }
    return s == a ? null : ve.range(s + i, a + i);
  }
}
ht.allowMultipleSelections = Qv;
ht.tabSize = /* @__PURE__ */ Ze.define({
  combine: (t) => t.length ? t[0] : 4
});
ht.lineSeparator = KM;
ht.readOnly = nE;
ht.phrases = /* @__PURE__ */ Ze.define({
  compare(t, e) {
    let n = Object.keys(t), i = Object.keys(e);
    return n.length == i.length && n.every((r) => t[r] == e[r]);
  }
});
ht.languageData = GM;
ht.changeFilter = JM;
ht.transactionFilter = eE;
ht.transactionExtender = tE;
nu.reconfigure = /* @__PURE__ */ ot.define();
function Er(t, e, n = {}) {
  let i = {};
  for (let r of t)
    for (let o of Object.keys(r)) {
      let s = r[o], a = i[o];
      if (a === void 0)
        i[o] = s;
      else if (!(a === s || s === void 0))
        if (Object.hasOwnProperty.call(n, o))
          i[o] = n[o](a, s);
        else
          throw new Error("Config merge conflict for field " + o);
    }
  for (let r in e)
    i[r] === void 0 && (i[r] = e[r]);
  return i;
}
class Ba {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, n = e) {
    return Lv.create(e, n, this);
  }
}
Ba.prototype.startSide = Ba.prototype.endSide = 0;
Ba.prototype.point = !1;
Ba.prototype.mapMode = Bn.TrackDel;
let Lv = class oE {
  constructor(e, n, i) {
    this.from = e, this.to = n, this.value = i;
  }
  /**
  @internal
  */
  static create(e, n, i) {
    return new oE(e, n, i);
  }
};
function Vv(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class d0 {
  constructor(e, n, i, r) {
    this.from = e, this.to = n, this.value = i, this.maxPoint = r;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, n, i, r = 0) {
    let o = i ? this.to : this.from;
    for (let s = r, a = o.length; ; ) {
      if (s == a)
        return s;
      let l = s + a >> 1, u = o[l] - e || (i ? this.value[l].endSide : this.value[l].startSide) - n;
      if (l == s)
        return u >= 0 ? s : a;
      u >= 0 ? a = l : s = l + 1;
    }
  }
  between(e, n, i, r) {
    for (let o = this.findIndex(n, -1e9, !0), s = this.findIndex(i, 1e9, !1, o); o < s; o++)
      if (r(this.from[o] + e, this.to[o] + e, this.value[o]) === !1)
        return !1;
  }
  map(e, n) {
    let i = [], r = [], o = [], s = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let u = this.value[l], c = this.from[l] + e, d = this.to[l] + e, h, f;
      if (c == d) {
        let p = n.mapPos(c, u.startSide, u.mapMode);
        if (p == null || (h = f = p, u.startSide != u.endSide && (f = n.mapPos(c, u.endSide), f < h)))
          continue;
      } else if (h = n.mapPos(c, u.startSide), f = n.mapPos(d, u.endSide), h > f || h == f && u.startSide > 0 && u.endSide <= 0)
        continue;
      (f - h || u.endSide - u.startSide) < 0 || (s < 0 && (s = h), u.point && (a = Math.max(a, f - h)), i.push(u), r.push(h - s), o.push(f - s));
    }
    return { mapped: i.length ? new d0(r, o, i, a) : null, pos: s };
  }
}
class bt {
  constructor(e, n, i, r) {
    this.chunkPos = e, this.chunk = n, this.nextLayer = i, this.maxPoint = r;
  }
  /**
  @internal
  */
  static create(e, n, i, r) {
    return new bt(e, n, i, r);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let n of this.chunk)
      e += n.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: n = [], sort: i = !1, filterFrom: r = 0, filterTo: o = this.length } = e, s = e.filter;
    if (n.length == 0 && !s)
      return this;
    if (i && (n = n.slice().sort(Vv)), this.isEmpty)
      return n.length ? bt.of(n) : this;
    let a = new sE(this, null, -1).goto(0), l = 0, u = [], c = new Wo();
    for (; a.value || l < n.length; )
      if (l < n.length && (a.from - n[l].from || a.startSide - n[l].value.startSide) >= 0) {
        let d = n[l++];
        c.addInner(d.from, d.to, d.value) || u.push(d);
      } else
        a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == n.length || this.chunkEnd(a.chunkIndex) < n[l].from) && (!s || r > this.chunkEnd(a.chunkIndex) || o < this.chunkPos[a.chunkIndex]) && c.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!s || r > a.to || o < a.from || s(a.from, a.to, a.value)) && (c.addInner(a.from, a.to, a.value) || u.push(Lv.create(a.from, a.to, a.value))), a.next());
    return c.finishInner(this.nextLayer.isEmpty && !u.length ? bt.empty : this.nextLayer.update({ add: u, filter: s, filterFrom: r, filterTo: o }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let n = [], i = [], r = -1;
    for (let s = 0; s < this.chunk.length; s++) {
      let a = this.chunkPos[s], l = this.chunk[s], u = e.touchesRange(a, a + l.length);
      if (u === !1)
        r = Math.max(r, l.maxPoint), n.push(l), i.push(e.mapPos(a));
      else if (u === !0) {
        let { mapped: c, pos: d } = l.map(a, e);
        c && (r = Math.max(r, c.maxPoint), n.push(c), i.push(d));
      }
    }
    let o = this.nextLayer.map(e);
    return n.length == 0 ? o : new bt(i, n, o || bt.empty, r);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, n, i) {
    if (!this.isEmpty) {
      for (let r = 0; r < this.chunk.length; r++) {
        let o = this.chunkPos[r], s = this.chunk[r];
        if (n >= o && e <= o + s.length && s.between(o, e - o, n - o, i) === !1)
          return;
      }
      this.nextLayer.between(e, n, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return id.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, n = 0) {
    return id.from(e).goto(n);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, n, i, r, o = -1) {
    let s = e.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= o), a = n.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= o), l = ES(s, a, i), u = new Vu(s, l, o), c = new Vu(a, l, o);
    i.iterGaps((d, h, f) => AS(u, d, c, h, f, r)), i.empty && i.length == 0 && AS(u, 0, c, 0, 0, r);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, n, i = 0, r) {
    r == null && (r = 1e9 - 1);
    let o = e.filter((c) => !c.isEmpty && n.indexOf(c) < 0), s = n.filter((c) => !c.isEmpty && e.indexOf(c) < 0);
    if (o.length != s.length)
      return !1;
    if (!o.length)
      return !0;
    let a = ES(o, s), l = new Vu(o, a, 0).goto(i), u = new Vu(s, a, 0).goto(i);
    for (; ; ) {
      if (l.to != u.to || !Bv(l.active, u.active) || l.point && (!u.point || !l.point.eq(u.point)))
        return !1;
      if (l.to > r)
        return !0;
      l.next(), u.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, n, i, r, o = -1) {
    let s = new Vu(e, null, o).goto(n), a = n, l = s.openStart;
    for (; ; ) {
      let u = Math.min(s.to, i);
      if (s.point) {
        let c = s.activeForPoint(s.to), d = s.pointFrom < n ? c.length + 1 : s.point.startSide < 0 ? c.length : Math.min(c.length, l);
        r.point(a, u, s.point, c, d, s.pointRank), l = Math.min(s.openEnd(u), c.length);
      } else
        u > a && (r.span(a, u, s.active, l), l = s.openEnd(u));
      if (s.to > i)
        return l + (s.point && s.to > i ? 1 : 0);
      a = s.to, s.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, n = !1) {
    let i = new Wo();
    for (let r of e instanceof Lv ? [e] : n ? CK(e) : e)
      i.add(r.from, r.to, r.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return bt.empty;
    let n = e[e.length - 1];
    for (let i = e.length - 2; i >= 0; i--)
      for (let r = e[i]; r != bt.empty; r = r.nextLayer)
        n = new bt(r.chunkPos, r.chunk, n, Math.max(r.maxPoint, n.maxPoint));
    return n;
  }
}
bt.empty = /* @__PURE__ */ new bt([], [], null, -1);
function CK(t) {
  if (t.length > 1)
    for (let e = t[0], n = 1; n < t.length; n++) {
      let i = t[n];
      if (Vv(e, i) > 0)
        return t.slice().sort(Vv);
      e = i;
    }
  return t;
}
bt.empty.nextLayer = bt.empty;
class Wo {
  finishChunk(e) {
    this.chunks.push(new d0(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, n, i) {
    this.addInner(e, n, i) || (this.nextLayer || (this.nextLayer = new Wo())).add(e, n, i);
  }
  /**
  @internal
  */
  addInner(e, n, i) {
    let r = e - this.lastTo || i.startSide - this.last.endSide;
    if (r <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return r < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(n - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = n, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, n - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, n) {
    if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(e);
    let i = n.value.length - 1;
    return this.last = n.value[i], this.lastFrom = n.from[i] + e, this.lastTo = n.to[i] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(bt.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let n = bt.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, n;
  }
}
function ES(t, e, n) {
  let i = /* @__PURE__ */ new Map();
  for (let o of t)
    for (let s = 0; s < o.chunk.length; s++)
      o.chunk[s].maxPoint <= 0 && i.set(o.chunk[s], o.chunkPos[s]);
  let r = /* @__PURE__ */ new Set();
  for (let o of e)
    for (let s = 0; s < o.chunk.length; s++) {
      let a = i.get(o.chunk[s]);
      a != null && (n ? n.mapPos(a) : a) == o.chunkPos[s] && !(n != null && n.touchesRange(a, a + o.chunk[s].length)) && r.add(o.chunk[s]);
    }
  return r;
}
class sE {
  constructor(e, n, i, r = 0) {
    this.layer = e, this.skip = n, this.minPoint = i, this.rank = r;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, n = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, n, !1), this;
  }
  gotoInner(e, n, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let r = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(r) || this.layer.chunkEnd(this.chunkIndex) < e || r.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let r = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!i || this.rangeIndex < r) && this.setRangeIndex(r);
    }
    this.next();
  }
  forward(e, n) {
    (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], i = e + n.from[this.rangeIndex];
        if (this.from = i, this.to = e + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class id {
  constructor(e) {
    this.heap = e;
  }
  static from(e, n = null, i = -1) {
    let r = [];
    for (let o = 0; o < e.length; o++)
      for (let s = e[o]; !s.isEmpty; s = s.nextLayer)
        s.maxPoint >= i && r.push(new sE(s, n, i, o));
    return r.length == 1 ? r[0] : new id(r);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, n = -1e9) {
    for (let i of this.heap)
      i.goto(e, n);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Vg(this.heap, i);
    return this.next(), this;
  }
  forward(e, n) {
    for (let i of this.heap)
      i.forward(e, n);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Vg(this.heap, i);
    (this.to - e || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Vg(this.heap, 0);
    }
  }
}
function Vg(t, e) {
  for (let n = t[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= t.length)
      break;
    let r = t[i];
    if (i + 1 < t.length && r.compare(t[i + 1]) >= 0 && (r = t[i + 1], i++), n.compare(r) < 0)
      break;
    t[i] = n, t[e] = r, e = i;
  }
}
class Vu {
  constructor(e, n, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = id.from(e, n, i);
  }
  goto(e, n = -1e9) {
    return this.cursor.goto(e, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = n, this.openStart = -1, this.next(), this;
  }
  forward(e, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, n);
  }
  removeActive(e) {
    uh(this.active, e), uh(this.activeTo, e), uh(this.activeRank, e), this.minActive = RS(this.active, this.activeTo);
  }
  addActive(e) {
    let n = 0, { value: i, to: r, rank: o } = this.cursor;
    for (; n < this.activeRank.length && (o - this.activeRank[n] || r - this.activeTo[n]) > 0; )
      n++;
    ch(this.active, n, i), ch(this.activeTo, n, r), ch(this.activeRank, n, o), e && ch(e, n, this.cursor.from), this.minActive = RS(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, n = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let r = this.minActive;
      if (r > -1 && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[r] > e) {
          this.to = this.activeTo[r], this.endSide = this.active[r].endSide;
          break;
        }
        this.removeActive(r), i && uh(i, r);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let o = this.cursor.value;
          if (!o.point)
            this.addActive(i), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let r = i.length - 1; r >= 0 && i[r] < e; r--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let n = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && n.push(this.active[i]);
    return n.reverse();
  }
  openEnd(e) {
    let n = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      n++;
    return n;
  }
}
function AS(t, e, n, i, r, o) {
  t.goto(e), n.goto(i);
  let s = i + r, a = i, l = i - e;
  for (; ; ) {
    let u = t.to + l - n.to, c = u || t.endSide - n.endSide, d = c < 0 ? t.to + l : n.to, h = Math.min(d, s);
    if (t.point || n.point ? t.point && n.point && (t.point == n.point || t.point.eq(n.point)) && Bv(t.activeForPoint(t.to), n.activeForPoint(n.to)) || o.comparePoint(a, h, t.point, n.point) : h > a && !Bv(t.active, n.active) && o.compareRange(a, h, t.active, n.active), d > s)
      break;
    (u || t.openEnd != n.openEnd) && o.boundChange && o.boundChange(d), a = d, c <= 0 && t.next(), c >= 0 && n.next();
  }
}
function Bv(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] != e[n] && !t[n].eq(e[n]))
      return !1;
  return !0;
}
function uh(t, e) {
  for (let n = e, i = t.length - 1; n < i; n++)
    t[n] = t[n + 1];
  t.pop();
}
function ch(t, e, n) {
  for (let i = t.length - 1; i >= e; i--)
    t[i + 1] = t[i];
  t[e] = n;
}
function RS(t, e) {
  let n = -1, i = 1e9;
  for (let r = 0; r < e.length; r++)
    (e[r] - i || t[r].endSide - t[n].endSide) < 0 && (n = r, i = e[r]);
  return n;
}
function wu(t, e, n = t.length) {
  let i = 0;
  for (let r = 0; r < n; )
    t.charCodeAt(r) == 9 ? (i += e - i % e, r++) : (i++, r = Zn(t, r));
  return i;
}
function Zv(t, e, n, i) {
  for (let r = 0, o = 0; ; ) {
    if (o >= e)
      return r;
    if (r == t.length)
      break;
    o += t.charCodeAt(r) == 9 ? n - o % n : 1, r = Zn(t, r);
  }
  return i === !0 ? -1 : t.length;
}
const Fv = "ͼ", DS = typeof Symbol > "u" ? "__" + Fv : Symbol.for(Fv), qv = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), QS = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Ns {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, n) {
    this.rules = [];
    let { finish: i } = n || {};
    function r(s) {
      return /^@/.test(s) ? [s] : s.split(/,\s*/);
    }
    function o(s, a, l, u) {
      let c = [], d = /^@(\w+)\b/.exec(s[0]), h = d && d[1] == "keyframes";
      if (d && a == null)
        return l.push(s[0] + ";");
      for (let f in a) {
        let p = a[f];
        if (/&/.test(f))
          o(
            f.split(/,\s*/).map((m) => s.map((g) => m.replace(/&/, g))).reduce((m, g) => m.concat(g)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!d)
            throw new RangeError("The value of a property (" + f + ") should be a primitive value.");
          o(r(f), p, c, h);
        } else
          p != null && c.push(f.replace(/_.*/, "").replace(/[A-Z]/g, (m) => "-" + m.toLowerCase()) + ": " + p + ";");
      }
      (c.length || h) && l.push((i && !d && !u ? s.map(i) : s).join(", ") + " {" + c.join(" ") + "}");
    }
    for (let s in e)
      o(r(s), e[s], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = QS[DS] || 1;
    return QS[DS] = e + 1, Fv + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, n, i) {
    let r = e[qv], o = i && i.nonce;
    r ? o && r.setNonce(o) : r = new TK(e, o), r.mount(Array.isArray(n) ? n : [n], e);
  }
}
let NS = /* @__PURE__ */ new Map();
class TK {
  constructor(e, n) {
    let i = e.ownerDocument || e, r = i.defaultView;
    if (!e.head && e.adoptedStyleSheets && r.CSSStyleSheet) {
      let o = NS.get(i);
      if (o)
        return e[qv] = o;
      this.sheet = new r.CSSStyleSheet(), NS.set(i, this);
    } else
      this.styleTag = i.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
    this.modules = [], e[qv] = this;
  }
  mount(e, n) {
    let i = this.sheet, r = 0, o = 0;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], l = this.modules.indexOf(a);
      if (l < o && l > -1 && (this.modules.splice(l, 1), o--, l = -1), l == -1) {
        if (this.modules.splice(o++, 0, a), i)
          for (let u = 0; u < a.rules.length; u++)
            i.insertRule(a.rules[u], r++);
      } else {
        for (; o < l; )
          r += this.modules[o++].rules.length;
        r += a.rules.length, o++;
      }
    }
    if (i)
      n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]);
    else {
      let s = "";
      for (let l = 0; l < this.modules.length; l++)
        s += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = s;
      let a = n.head || n;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
function rd(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function Wv(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function qh(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return Wv(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function iu(t) {
  return t.nodeType == 3 ? Fa(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Tc(t, e, n, i) {
  return n ? IS(t, e, n, i, -1) || IS(t, e, n, i, 1) : !1;
}
function Za(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function lp(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
function IS(t, e, n, i, r) {
  for (; ; ) {
    if (t == n && e == i)
      return !0;
    if (e == (r < 0 ? 0 : ho(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let o = t.parentNode;
      if (!o || o.nodeType != 1)
        return !1;
      e = Za(t) + (r < 0 ? 0 : 1), t = o;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (r < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = r < 0 ? ho(t) : 0;
    } else
      return !1;
  }
}
function ho(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Rd(t, e) {
  let n = e ? t.left : t.right;
  return { left: n, right: n, top: t.top, bottom: t.bottom };
}
function $K(t) {
  let e = t.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function aE(t, e) {
  let n = e.width / t.offsetWidth, i = e.height / t.offsetHeight;
  return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(e.height - t.offsetHeight) < 1) && (i = 1), { scaleX: n, scaleY: i };
}
function PK(t, e, n, i, r, o, s, a) {
  let l = t.ownerDocument, u = l.defaultView || window;
  for (let c = t, d = !1; c && !d; )
    if (c.nodeType == 1) {
      let h, f = c == l.body, p = 1, m = 1;
      if (f)
        h = $K(u);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(c).position) && (d = !0), c.scrollHeight <= c.clientHeight && c.scrollWidth <= c.clientWidth) {
          c = c.assignedSlot || c.parentNode;
          continue;
        }
        let y = c.getBoundingClientRect();
        ({ scaleX: p, scaleY: m } = aE(c, y)), h = {
          left: y.left,
          right: y.left + c.clientWidth * p,
          top: y.top,
          bottom: y.top + c.clientHeight * m
        };
      }
      let g = 0, O = 0;
      if (r == "nearest")
        e.top < h.top ? (O = -(h.top - e.top + s), n > 0 && e.bottom > h.bottom + O && (O = e.bottom - h.bottom + O + s)) : e.bottom > h.bottom && (O = e.bottom - h.bottom + s, n < 0 && e.top - O < h.top && (O = -(h.top + O - e.top + s)));
      else {
        let y = e.bottom - e.top, b = h.bottom - h.top;
        O = (r == "center" && y <= b ? e.top + y / 2 - b / 2 : r == "start" || r == "center" && n < 0 ? e.top - s : e.bottom - b + s) - h.top;
      }
      if (i == "nearest" ? e.left < h.left ? (g = -(h.left - e.left + o), n > 0 && e.right > h.right + g && (g = e.right - h.right + g + o)) : e.right > h.right && (g = e.right - h.right + o, n < 0 && e.left < h.left + g && (g = -(h.left + g - e.left + o))) : g = (i == "center" ? e.left + (e.right - e.left) / 2 - (h.right - h.left) / 2 : i == "start" == a ? e.left - o : e.right - (h.right - h.left) + o) - h.left, g || O)
        if (f)
          u.scrollBy(g, O);
        else {
          let y = 0, b = 0;
          if (O) {
            let v = c.scrollTop;
            c.scrollTop += O / m, b = (c.scrollTop - v) * m;
          }
          if (g) {
            let v = c.scrollLeft;
            c.scrollLeft += g / p, y = (c.scrollLeft - v) * p;
          }
          e = {
            left: e.left - y,
            top: e.top - b,
            right: e.right - y,
            bottom: e.bottom - b
          }, y && Math.abs(y - g) < 1 && (i = "nearest"), b && Math.abs(b - O) < 1 && (r = "nearest");
        }
      if (f)
        break;
      c = c.assignedSlot || c.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
}
function MK(t) {
  let e = t.ownerDocument, n, i;
  for (let r = t.parentNode; r && !(r == e.body || n && i); )
    if (r.nodeType == 1)
      !i && r.scrollHeight > r.clientHeight && (i = r), !n && r.scrollWidth > r.clientWidth && (n = r), r = r.assignedSlot || r.parentNode;
    else if (r.nodeType == 11)
      r = r.host;
    else
      break;
  return { x: n, y: i };
}
class EK {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: n, focusNode: i } = e;
    this.set(n, Math.min(e.anchorOffset, n ? ho(n) : 0), i, Math.min(e.focusOffset, i ? ho(i) : 0));
  }
  set(e, n, i, r) {
    this.anchorNode = e, this.anchorOffset = n, this.focusNode = i, this.focusOffset = r;
  }
}
let rl = null;
function lE(t) {
  if (t.setActive)
    return t.setActive();
  if (rl)
    return t.focus(rl);
  let e = [];
  for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
    ;
  if (t.focus(rl == null ? {
    get preventScroll() {
      return rl = { preventScroll: !0 }, !0;
    }
  } : void 0), !rl) {
    rl = !1;
    for (let n = 0; n < e.length; ) {
      let i = e[n++], r = e[n++], o = e[n++];
      i.scrollTop != r && (i.scrollTop = r), i.scrollLeft != o && (i.scrollLeft = o);
    }
  }
}
let LS;
function Fa(t, e, n = e) {
  let i = LS || (LS = document.createRange());
  return i.setEnd(t, n), i.setStart(t, e), i;
}
function Tl(t, e, n, i) {
  let r = { key: e, code: e, keyCode: n, which: n, cancelable: !0 };
  i && ({ altKey: r.altKey, ctrlKey: r.ctrlKey, shiftKey: r.shiftKey, metaKey: r.metaKey } = i);
  let o = new KeyboardEvent("keydown", r);
  o.synthetic = !0, t.dispatchEvent(o);
  let s = new KeyboardEvent("keyup", r);
  return s.synthetic = !0, t.dispatchEvent(s), o.defaultPrevented || s.defaultPrevented;
}
function AK(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function uE(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function RK(t, e) {
  let n = e.focusNode, i = e.focusOffset;
  if (!n || e.anchorNode != n || e.anchorOffset != i)
    return !1;
  for (i = Math.min(i, ho(n)); ; )
    if (i) {
      if (n.nodeType != 1)
        return !1;
      let r = n.childNodes[i - 1];
      r.contentEditable == "false" ? i-- : (n = r, i = ho(n));
    } else {
      if (n == t)
        return !0;
      i = Za(n), n = n.parentNode;
    }
}
function cE(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
function dE(t, e) {
  for (let n = t, i = e; ; ) {
    if (n.nodeType == 3 && i > 0)
      return { node: n, offset: i };
    if (n.nodeType == 1 && i > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[i - 1], i = ho(n);
    } else if (n.parentNode && !lp(n))
      i = Za(n), n = n.parentNode;
    else
      return null;
  }
}
function hE(t, e) {
  for (let n = t, i = e; ; ) {
    if (n.nodeType == 3 && i < n.nodeValue.length)
      return { node: n, offset: i };
    if (n.nodeType == 1 && i < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[i], i = 0;
    } else if (n.parentNode && !lp(n))
      i = Za(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
class Yn {
  constructor(e, n, i = !0) {
    this.node = e, this.offset = n, this.precise = i;
  }
  static before(e, n) {
    return new Yn(e.parentNode, Za(e), n);
  }
  static after(e, n) {
    return new Yn(e.parentNode, Za(e) + 1, n);
  }
}
const h0 = [];
class It {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let n = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return n;
      n += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, n) {
    if (this.flags & 2) {
      let i = this.dom, r = null, o;
      for (let s of this.children) {
        if (s.flags & 7) {
          if (!s.dom && (o = r ? r.nextSibling : i.firstChild)) {
            let a = It.get(o);
            (!a || !a.parent && a.canReuseDOM(s)) && s.reuseDOM(o);
          }
          s.sync(e, n), s.flags &= -8;
        }
        if (o = r ? r.nextSibling : i.firstChild, n && !n.written && n.node == i && o != s.dom && (n.written = !0), s.dom.parentNode == i)
          for (; o && o != s.dom; )
            o = VS(o);
        else
          i.insertBefore(s.dom, o);
        r = s.dom;
      }
      for (o = r ? r.nextSibling : i.firstChild, o && n && n.node == i && (n.written = !0); o; )
        o = VS(o);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(e, n), i.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, n) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[n];
    else {
      let r = ho(e) == 0 ? 0 : n == 0 ? -1 : 1;
      for (; ; ) {
        let o = e.parentNode;
        if (o == this.dom)
          break;
        r == 0 && o.firstChild != o.lastChild && (e == o.firstChild ? r = -1 : r = 1), e = o;
      }
      r < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !It.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let r = 0, o = 0; ; r++) {
      let s = this.children[r];
      if (s.dom == i)
        return o;
      o += s.length + s.breakAfter;
    }
  }
  domBoundsAround(e, n, i = 0) {
    let r = -1, o = -1, s = -1, a = -1;
    for (let l = 0, u = i, c = i; l < this.children.length; l++) {
      let d = this.children[l], h = u + d.length;
      if (u < e && h > n)
        return d.domBoundsAround(e, n, u);
      if (h >= e && r == -1 && (r = l, o = u), u > n && d.dom.parentNode == this.dom) {
        s = l, a = c;
        break;
      }
      c = h, u = h + d.breakAfter;
    }
    return {
      from: o,
      to: a < 0 ? i + this.length : a,
      startDOM: (r ? this.children[r - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: s < this.children.length && s >= 0 ? this.children[s].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let n = this.parent; n; n = n.parent) {
      if (e && (n.flags |= 2), n.flags & 1)
        return;
      n.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let n = e.parent;
      if (!n)
        return e;
      e = n;
    }
  }
  replaceChildren(e, n, i = h0) {
    this.markDirty();
    for (let r = e; r < n; r++) {
      let o = this.children[r];
      o.parent == this && i.indexOf(o) < 0 && o.destroy();
    }
    i.length < 250 ? this.children.splice(e, n - e, ...i) : this.children = [].concat(this.children.slice(0, e), i, this.children.slice(n));
    for (let r = 0; r < i.length; r++)
      i[r].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new fE(this.children, e, this.children.length);
  }
  childPos(e, n = 1) {
    return this.childCursor().findPos(e, n);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, n, i, r, o, s) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
It.prototype.breakAfter = 0;
function VS(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class fE {
  constructor(e, n, i) {
    this.children = e, this.pos = n, this.i = i, this.off = 0;
  }
  findPos(e, n = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function pE(t, e, n, i, r, o, s, a, l) {
  let { children: u } = t, c = u.length ? u[e] : null, d = o.length ? o[o.length - 1] : null, h = d ? d.breakAfter : s;
  if (!(e == i && c && !s && !h && o.length < 2 && c.merge(n, r, o.length ? d : null, n == 0, a, l))) {
    if (i < u.length) {
      let f = u[i];
      f && (r < f.length || f.breakAfter && (d != null && d.breakAfter)) ? (e == i && (f = f.split(r), r = 0), !h && d && f.merge(0, r, d, !0, 0, l) ? o[o.length - 1] = f : ((r || f.children.length && !f.children[0].length) && f.merge(0, r, null, !1, 0, l), o.push(f))) : f != null && f.breakAfter && (d ? d.breakAfter = 1 : s = 1), i++;
    }
    for (c && (c.breakAfter = s, n > 0 && (!s && o.length && c.merge(n, c.length, o[0], !1, a, 0) ? c.breakAfter = o.shift().breakAfter : (n < c.length || c.children.length && c.children[c.children.length - 1].length == 0) && c.merge(n, c.length, null, !1, a, 0), e++)); e < i && o.length; )
      if (u[i - 1].become(o[o.length - 1]))
        i--, o.pop(), l = o.length ? 0 : a;
      else if (u[e].become(o[0]))
        e++, o.shift(), a = o.length ? 0 : l;
      else
        break;
    !o.length && e && i < u.length && !u[e - 1].breakAfter && u[i].merge(0, 0, u[e - 1], !1, a, l) && e--, (e < i || o.length) && t.replaceChildren(e, i, o);
  }
}
function mE(t, e, n, i, r, o) {
  let s = t.childCursor(), { i: a, off: l } = s.findPos(n, 1), { i: u, off: c } = s.findPos(e, -1), d = e - n;
  for (let h of i)
    d += h.length;
  t.length += d, pE(t, u, c, a, l, i, 0, r, o);
}
let wi = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Xv = typeof document < "u" ? document : { documentElement: { style: {} } };
const zv = /* @__PURE__ */ /Edge\/(\d+)/.exec(wi.userAgent), gE = /* @__PURE__ */ /MSIE \d/.test(wi.userAgent), jv = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(wi.userAgent), km = !!(gE || jv || zv), BS = !km && /* @__PURE__ */ /gecko\/(\d+)/i.test(wi.userAgent), Bg = !km && /* @__PURE__ */ /Chrome\/(\d+)/.exec(wi.userAgent), ZS = "webkitFontSmoothing" in Xv.documentElement.style, OE = !km && /* @__PURE__ */ /Apple Computer/.test(wi.vendor), FS = OE && (/* @__PURE__ */ /Mobile\/\w+/.test(wi.userAgent) || wi.maxTouchPoints > 2);
var qe = {
  mac: FS || /* @__PURE__ */ /Mac/.test(wi.platform),
  windows: /* @__PURE__ */ /Win/.test(wi.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(wi.platform),
  ie: km,
  ie_version: gE ? Xv.documentMode || 6 : jv ? +jv[1] : zv ? +zv[1] : 0,
  gecko: BS,
  gecko_version: BS ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(wi.userAgent) || [0, 0])[1] : 0,
  chrome: !!Bg,
  chrome_version: Bg ? +Bg[1] : 0,
  ios: FS,
  android: /* @__PURE__ */ /Android\b/.test(wi.userAgent),
  webkit: ZS,
  safari: OE,
  webkit_version: ZS ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(wi.userAgent) || [0, 0])[1] : 0,
  tabSize: Xv.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const DK = 256;
class Tr extends It {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, n) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, n, i) {
    return this.flags & 8 || i && (!(i instanceof Tr) || this.length - (n - e) + i.length > DK || i.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(n), this.markDirty(), !0);
  }
  split(e) {
    let n = new Tr(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), n.flags |= this.flags & 8, n;
  }
  localPosFromDOM(e, n) {
    return e == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Yn(this.dom, e);
  }
  domBoundsAround(e, n, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, n) {
    return QK(this.dom, e, n);
  }
}
class Xo extends It {
  constructor(e, n = [], i = 0) {
    super(), this.mark = e, this.children = n, this.length = i;
    for (let r of n)
      r.setParent(this);
  }
  setAttrs(e) {
    if (uE(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let n in this.mark.attrs)
        e.setAttribute(n, this.mark.attrs[n]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, n);
  }
  merge(e, n, i, r, o, s) {
    return i && (!(i instanceof Xo && i.mark.eq(this.mark)) || e && o <= 0 || n < this.length && s <= 0) ? !1 : (mE(this, e, n, i ? i.children.slice() : [], o - 1, s - 1), this.markDirty(), !0);
  }
  split(e) {
    let n = [], i = 0, r = -1, o = 0;
    for (let a of this.children) {
      let l = i + a.length;
      l > e && n.push(i < e ? a.split(e - i) : a), r < 0 && i >= e && (r = o), i = l, o++;
    }
    let s = this.length - e;
    return this.length = e, r > -1 && (this.children.length = r, this.markDirty()), new Xo(this.mark, n, s);
  }
  domAtPos(e) {
    return vE(this, e);
  }
  coordsAt(e, n) {
    return bE(this, e, n);
  }
}
function QK(t, e, n) {
  let i = t.nodeValue.length;
  e > i && (e = i);
  let r = e, o = e, s = 0;
  e == 0 && n < 0 || e == i && n >= 0 ? qe.chrome || qe.gecko || (e ? (r--, s = 1) : o < i && (o++, s = -1)) : n < 0 ? r-- : o < i && o++;
  let a = Fa(t, r, o).getClientRects();
  if (!a.length)
    return null;
  let l = a[(s ? s < 0 : n >= 0) ? 0 : a.length - 1];
  return qe.safari && !s && l.width == 0 && (l = Array.prototype.find.call(a, (u) => u.width) || l), s ? Rd(l, s < 0) : l || null;
}
class bs extends It {
  static create(e, n, i) {
    return new bs(e, n, i);
  }
  constructor(e, n, i) {
    super(), this.widget = e, this.length = n, this.side = i, this.prevWidget = null;
  }
  split(e) {
    let n = bs.create(this.widget, this.length - e, this.side);
    return this.length -= e, n;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, n, i, r, o, s) {
    return i && (!(i instanceof bs) || !this.widget.compare(i.widget) || e > 0 && o <= 0 || n < this.length && s <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - n), !0);
  }
  become(e) {
    return e instanceof bs && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return St.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: n } = e, i = n && n.state.doc, r = this.posAtStart;
    return i ? i.slice(r, r + this.length) : St.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Yn.before(this.dom) : Yn.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, n) {
    let i = this.widget.coordsAt(this.dom, e, n);
    if (i)
      return i;
    let r = this.dom.getClientRects(), o = null;
    if (!r.length)
      return null;
    let s = this.side ? this.side < 0 : e > 0;
    for (let a = s ? r.length - 1 : 0; o = r[a], !(e > 0 ? a == 0 : a == r.length - 1 || o.top < o.bottom); a += s ? -1 : 1)
      ;
    return Rd(o, !s);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class ru extends It {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof ru && e.side == this.side;
  }
  split() {
    return new ru(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Yn.before(this.dom) : Yn.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return St.empty;
  }
  get isHidden() {
    return !0;
  }
}
Tr.prototype.children = bs.prototype.children = ru.prototype.children = h0;
function vE(t, e) {
  let n = t.dom, { children: i } = t, r = 0;
  for (let o = 0; r < i.length; r++) {
    let s = i[r], a = o + s.length;
    if (!(a == o && s.getSide() <= 0)) {
      if (e > o && e < a && s.dom.parentNode == n)
        return s.domAtPos(e - o);
      if (e <= o)
        break;
      o = a;
    }
  }
  for (let o = r; o > 0; o--) {
    let s = i[o - 1];
    if (s.dom.parentNode == n)
      return s.domAtPos(s.length);
  }
  for (let o = r; o < i.length; o++) {
    let s = i[o];
    if (s.dom.parentNode == n)
      return s.domAtPos(0);
  }
  return new Yn(n, 0);
}
function yE(t, e, n) {
  let i, { children: r } = t;
  n > 0 && e instanceof Xo && r.length && (i = r[r.length - 1]) instanceof Xo && i.mark.eq(e.mark) ? yE(i, e.children[0], n - 1) : (r.push(e), e.setParent(t)), t.length += e.length;
}
function bE(t, e, n) {
  let i = null, r = -1, o = null, s = -1;
  function a(u, c) {
    for (let d = 0, h = 0; d < u.children.length && h <= c; d++) {
      let f = u.children[d], p = h + f.length;
      p >= c && (f.children.length ? a(f, c - h) : (!o || o.isHidden && n > 0) && (p > c || h == p && f.getSide() > 0) ? (o = f, s = c - h) : (h < c || h == p && f.getSide() < 0 && !f.isHidden) && (i = f, r = c - h)), h = p;
    }
  }
  a(t, e);
  let l = (n < 0 ? i : o) || i || o;
  return l ? l.coordsAt(Math.max(0, l == i ? r : s), n) : NK(t);
}
function NK(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let n = iu(e);
  return n[n.length - 1] || null;
}
function Yv(t, e) {
  for (let n in t)
    n == "class" && e.class ? e.class += " " + t.class : n == "style" && e.style ? e.style += ";" + t.style : e[n] = t[n];
  return e;
}
const qS = /* @__PURE__ */ Object.create(null);
function up(t, e, n) {
  if (t == e)
    return !0;
  t || (t = qS), e || (e = qS);
  let i = Object.keys(t), r = Object.keys(e);
  if (i.length - (n && i.indexOf(n) > -1 ? 1 : 0) != r.length - (n && r.indexOf(n) > -1 ? 1 : 0))
    return !1;
  for (let o of i)
    if (o != n && (r.indexOf(o) == -1 || t[o] !== e[o]))
      return !1;
  return !0;
}
function Hv(t, e, n) {
  let i = !1;
  if (e)
    for (let r in e)
      n && r in n || (i = !0, r == "style" ? t.style.cssText = "" : t.removeAttribute(r));
  if (n)
    for (let r in n)
      e && e[r] == n[r] || (i = !0, r == "style" ? t.style.cssText = n[r] : t.setAttribute(r, n[r]));
  return i;
}
function IK(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n = 0; n < t.attributes.length; n++) {
    let i = t.attributes[n];
    e[i.name] = i.value;
  }
  return e;
}
class mo {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, n) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, n, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var li = /* @__PURE__ */ function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(li || (li = {}));
class Ue extends Ba {
  constructor(e, n, i, r) {
    super(), this.startSide = e, this.endSide = n, this.widget = i, this.spec = r;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Dd(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let n = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block;
    return n += i && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new Is(e, n, n, i, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let n = !!e.block, i, r;
    if (e.isBlockGap)
      i = -5e8, r = 4e8;
    else {
      let { start: o, end: s } = wE(e, n);
      i = (o ? n ? -3e8 : -1 : 5e8) - 1, r = (s ? n ? 2e8 : 1 : -6e8) + 1;
    }
    return new Is(e, i, r, n, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Qd(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, n = !1) {
    return bt.of(e, n);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
Ue.none = bt.empty;
class Dd extends Ue {
  constructor(e) {
    let { start: n, end: i } = wE(e);
    super(n ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var n, i;
    return this == e || e instanceof Dd && this.tagName == e.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (e.class || ((i = e.attrs) === null || i === void 0 ? void 0 : i.class)) && up(this.attrs, e.attrs, "class");
  }
  range(e, n = e) {
    if (e >= n)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, n);
  }
}
Dd.prototype.point = !1;
class Qd extends Ue {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Qd && this.spec.class == e.spec.class && up(this.spec.attributes, e.spec.attributes);
  }
  range(e, n = e) {
    if (n != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, n);
  }
}
Qd.prototype.mapMode = Bn.TrackBefore;
Qd.prototype.point = !0;
class Is extends Ue {
  constructor(e, n, i, r, o, s) {
    super(n, i, o, e), this.block = r, this.isReplace = s, this.mapMode = r ? n <= 0 ? Bn.TrackBefore : Bn.TrackAfter : Bn.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? li.WidgetRange : this.startSide <= 0 ? li.WidgetBefore : li.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Is && LK(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, n = e) {
    if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, n);
  }
}
Is.prototype.point = !0;
function wE(t, e = !1) {
  let { inclusiveStart: n, inclusiveEnd: i } = t;
  return n == null && (n = t.inclusive), i == null && (i = t.inclusive), { start: n ?? e, end: i ?? e };
}
function LK(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function Wh(t, e, n, i = 0) {
  let r = n.length - 1;
  r >= 0 && n[r] + i >= t ? n[r] = Math.max(n[r], e) : n.push(t, e);
}
class bn extends It {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, n, i, r, o, s) {
    if (i) {
      if (!(i instanceof bn))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return r && this.setDeco(i ? i.attrs : null), mE(this, e, n, i ? i.children.slice() : [], o, s), !0;
  }
  split(e) {
    let n = new bn();
    if (n.breakAfter = this.breakAfter, this.length == 0)
      return n;
    let { i, off: r } = this.childPos(e);
    r && (n.append(this.children[i].split(r), 0), this.children[i].merge(r, this.children[i].length, null, !1, 0, 0), i++);
    for (let o = i; o < this.children.length; o++)
      n.append(this.children[o], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, n;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    up(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, n) {
    yE(this, e, n);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let n = e.spec.attributes, i = e.spec.class;
    n && (this.attrs = Yv(n, this.attrs || {})), i && (this.attrs = Yv({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return vE(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    var i;
    this.dom ? this.flags & 4 && (uE(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Hv(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, n);
    let r = this.dom.lastChild;
    for (; r && It.get(r) instanceof Xo; )
      r = r.lastChild;
    if (!r || !this.length || r.nodeName != "BR" && ((i = It.get(r)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!qe.ios || !this.children.some((o) => o instanceof Tr))) {
      let o = document.createElement("BR");
      o.cmIgnore = !0, this.dom.appendChild(o);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, n;
    for (let i of this.children) {
      if (!(i instanceof Tr) || /[^ -~]/.test(i.text))
        return null;
      let r = iu(i.dom);
      if (r.length != 1)
        return null;
      e += r[0].width, n = r[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: n
    } : null;
  }
  coordsAt(e, n) {
    let i = bE(this, e, n);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: r } = this.parent.view.viewState, o = i.bottom - i.top;
      if (Math.abs(o - r.lineHeight) < 2 && r.textHeight < o) {
        let s = (o - r.textHeight) / 2;
        return { top: i.top + s, bottom: i.bottom - s, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(e) {
    return e instanceof bn && this.children.length == 0 && e.children.length == 0 && up(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, n) {
    for (let i = 0, r = 0; i < e.children.length; i++) {
      let o = e.children[i], s = r + o.length;
      if (s >= n) {
        if (o instanceof bn)
          return o;
        if (s > n)
          break;
      }
      r = s + o.breakAfter;
    }
    return null;
  }
}
class Qo extends It {
  constructor(e, n, i) {
    super(), this.widget = e, this.length = n, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, n, i, r, o, s) {
    return i && (!(i instanceof Qo) || !this.widget.compare(i.widget) || e > 0 && o <= 0 || n < this.length && s <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - n), !0);
  }
  domAtPos(e) {
    return e == 0 ? Yn.before(this.dom) : Yn.after(this.dom, e == this.length);
  }
  split(e) {
    let n = this.length - e;
    this.length = e;
    let i = new Qo(this.widget, n, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return h0;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : St.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Qo && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, n) {
    let i = this.widget.coordsAt(this.dom, e, n);
    return i || (this.widget instanceof Uv ? null : Rd(this.dom.getBoundingClientRect(), this.length ? e == 0 : n <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: n, endSide: i } = this.deco;
    return n == i ? !1 : e < 0 ? n < 0 : i > 0;
  }
}
class Uv extends mo {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class $c {
  constructor(e, n, i, r) {
    this.doc = e, this.pos = n, this.end = i, this.disallowBlockEffectsFor = r, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = n;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof Qo && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new bn()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(dh(new ru(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Qo) && this.getLine();
  }
  buildText(e, n, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o, lineBreak: s, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (s) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = o, this.textOff = 0;
      }
      let r = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(n.slice(n.length - i)), this.getLine().append(dh(new Tr(this.text.slice(this.textOff, this.textOff + r)), n), i), this.atCursorPos = !0, this.textOff += r, e -= r, i = 0;
    }
  }
  span(e, n, i, r) {
    this.buildText(n - e, i, r), this.pos = n, this.openStart < 0 && (this.openStart = r);
  }
  point(e, n, i, r, o, s) {
    if (this.disallowBlockEffectsFor[s] && i instanceof Is) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = n - e;
    if (i instanceof Is)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Qo(i.widget || ou.block, a, i));
      else {
        let l = bs.create(i.widget || ou.inline, a, a ? 0 : i.startSide), u = this.atCursorPos && !l.isEditable && o <= r.length && (e < n || i.startSide > 0), c = !l.isEditable && (e < n || o > r.length || i.startSide <= 0), d = this.getLine();
        this.pendingBuffer == 2 && !u && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(r), u && (d.append(dh(new ru(1), r), o), o = r.length + Math.max(0, o - r.length)), d.append(dh(l, r), o), this.atCursorPos = c, this.pendingBuffer = c ? e < n || o > r.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = r.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = o);
  }
  static build(e, n, i, r, o) {
    let s = new $c(e, n, i, o);
    return s.openEnd = bt.spans(r, n, i, s), s.openStart < 0 && (s.openStart = s.openEnd), s.finish(s.openEnd), s;
  }
}
function dh(t, e) {
  for (let n of e)
    t = new Xo(n, [t], t.length);
  return t;
}
class ou extends mo {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
ou.inline = /* @__PURE__ */ new ou("span");
ou.block = /* @__PURE__ */ new ou("div");
var Yt = /* @__PURE__ */ function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(Yt || (Yt = {}));
const qa = Yt.LTR, f0 = Yt.RTL;
function kE(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    e.push(1 << +t[n]);
  return e;
}
const VK = /* @__PURE__ */ kE("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), BK = /* @__PURE__ */ kE("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Gv = /* @__PURE__ */ Object.create(null), Dr = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), n = /* @__PURE__ */ t.charCodeAt(1);
  Gv[e] = n, Gv[n] = -e;
}
function SE(t) {
  return t <= 247 ? VK[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? BK[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const ZK = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class ws {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? f0 : qa;
  }
  /**
  @internal
  */
  constructor(e, n, i) {
    this.from = e, this.to = n, this.level = i;
  }
  /**
  @internal
  */
  side(e, n) {
    return this.dir == n == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, n) {
    return e == (this.dir == n);
  }
  /**
  @internal
  */
  static find(e, n, i, r) {
    let o = -1;
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      if (a.from <= n && a.to >= n) {
        if (a.level == i)
          return s;
        (o < 0 || (r != 0 ? r < 0 ? a.from < n : a.to > n : e[o].level > a.level)) && (o = s);
      }
    }
    if (o < 0)
      throw new RangeError("Index out of range");
    return o;
  }
}
function _E(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++) {
    let i = t[n], r = e[n];
    if (i.from != r.from || i.to != r.to || i.direction != r.direction || !_E(i.inner, r.inner))
      return !1;
  }
  return !0;
}
const At = [];
function FK(t, e, n, i, r) {
  for (let o = 0; o <= i.length; o++) {
    let s = o ? i[o - 1].to : e, a = o < i.length ? i[o].from : n, l = o ? 256 : r;
    for (let u = s, c = l, d = l; u < a; u++) {
      let h = SE(t.charCodeAt(u));
      h == 512 ? h = c : h == 8 && d == 4 && (h = 16), At[u] = h == 4 ? 2 : h, h & 7 && (d = h), c = h;
    }
    for (let u = s, c = l, d = l; u < a; u++) {
      let h = At[u];
      if (h == 128)
        u < a - 1 && c == At[u + 1] && c & 24 ? h = At[u] = c : At[u] = 256;
      else if (h == 64) {
        let f = u + 1;
        for (; f < a && At[f] == 64; )
          f++;
        let p = u && c == 8 || f < n && At[f] == 8 ? d == 1 ? 1 : 8 : 256;
        for (let m = u; m < f; m++)
          At[m] = p;
        u = f - 1;
      } else
        h == 8 && d == 1 && (At[u] = 1);
      c = h, h & 7 && (d = h);
    }
  }
}
function qK(t, e, n, i, r) {
  let o = r == 1 ? 2 : 1;
  for (let s = 0, a = 0, l = 0; s <= i.length; s++) {
    let u = s ? i[s - 1].to : e, c = s < i.length ? i[s].from : n;
    for (let d = u, h, f, p; d < c; d++)
      if (f = Gv[h = t.charCodeAt(d)])
        if (f < 0) {
          for (let m = a - 3; m >= 0; m -= 3)
            if (Dr[m + 1] == -f) {
              let g = Dr[m + 2], O = g & 2 ? r : g & 4 ? g & 1 ? o : r : 0;
              O && (At[d] = At[Dr[m]] = O), a = m;
              break;
            }
        } else {
          if (Dr.length == 189)
            break;
          Dr[a++] = d, Dr[a++] = h, Dr[a++] = l;
        }
      else if ((p = At[d]) == 2 || p == 1) {
        let m = p == r;
        l = m ? 0 : 1;
        for (let g = a - 3; g >= 0; g -= 3) {
          let O = Dr[g + 2];
          if (O & 2)
            break;
          if (m)
            Dr[g + 2] |= 2;
          else {
            if (O & 4)
              break;
            Dr[g + 2] |= 4;
          }
        }
      }
  }
}
function WK(t, e, n, i) {
  for (let r = 0, o = i; r <= n.length; r++) {
    let s = r ? n[r - 1].to : t, a = r < n.length ? n[r].from : e;
    for (let l = s; l < a; ) {
      let u = At[l];
      if (u == 256) {
        let c = l + 1;
        for (; ; )
          if (c == a) {
            if (r == n.length)
              break;
            c = n[r++].to, a = r < n.length ? n[r].from : e;
          } else if (At[c] == 256)
            c++;
          else
            break;
        let d = o == 1, h = (c < e ? At[c] : i) == 1, f = d == h ? d ? 1 : 2 : i;
        for (let p = c, m = r, g = m ? n[m - 1].to : t; p > l; )
          p == g && (p = n[--m].from, g = m ? n[m - 1].to : t), At[--p] = f;
        l = c;
      } else
        o = u, l++;
    }
  }
}
function Kv(t, e, n, i, r, o, s) {
  let a = i % 2 ? 2 : 1;
  if (i % 2 == r % 2)
    for (let l = e, u = 0; l < n; ) {
      let c = !0, d = !1;
      if (u == o.length || l < o[u].from) {
        let m = At[l];
        m != a && (c = !1, d = m == 16);
      }
      let h = !c && a == 1 ? [] : null, f = c ? i : i + 1, p = l;
      e:
        for (; ; )
          if (u < o.length && p == o[u].from) {
            if (d)
              break e;
            let m = o[u];
            if (!c)
              for (let g = m.to, O = u + 1; ; ) {
                if (g == n)
                  break e;
                if (O < o.length && o[O].from == g)
                  g = o[O++].to;
                else {
                  if (At[g] == a)
                    break e;
                  break;
                }
              }
            if (u++, h)
              h.push(m);
            else {
              m.from > l && s.push(new ws(l, m.from, f));
              let g = m.direction == qa != !(f % 2);
              Jv(t, g ? i + 1 : i, r, m.inner, m.from, m.to, s), l = m.to;
            }
            p = m.to;
          } else {
            if (p == n || (c ? At[p] != a : At[p] == a))
              break;
            p++;
          }
      h ? Kv(t, l, p, i + 1, r, h, s) : l < p && s.push(new ws(l, p, f)), l = p;
    }
  else
    for (let l = n, u = o.length; l > e; ) {
      let c = !0, d = !1;
      if (!u || l > o[u - 1].to) {
        let m = At[l - 1];
        m != a && (c = !1, d = m == 16);
      }
      let h = !c && a == 1 ? [] : null, f = c ? i : i + 1, p = l;
      e:
        for (; ; )
          if (u && p == o[u - 1].to) {
            if (d)
              break e;
            let m = o[--u];
            if (!c)
              for (let g = m.from, O = u; ; ) {
                if (g == e)
                  break e;
                if (O && o[O - 1].to == g)
                  g = o[--O].from;
                else {
                  if (At[g - 1] == a)
                    break e;
                  break;
                }
              }
            if (h)
              h.push(m);
            else {
              m.to < l && s.push(new ws(m.to, l, f));
              let g = m.direction == qa != !(f % 2);
              Jv(t, g ? i + 1 : i, r, m.inner, m.from, m.to, s), l = m.from;
            }
            p = m.from;
          } else {
            if (p == e || (c ? At[p - 1] != a : At[p - 1] == a))
              break;
            p--;
          }
      h ? Kv(t, p, l, i + 1, r, h, s) : p < l && s.push(new ws(p, l, f)), l = p;
    }
}
function Jv(t, e, n, i, r, o, s) {
  let a = e % 2 ? 2 : 1;
  FK(t, r, o, i, a), qK(t, r, o, i, a), WK(r, o, i, a), Kv(t, r, o, e, n, i, s);
}
function XK(t, e, n) {
  if (!t)
    return [new ws(0, 0, e == f0 ? 1 : 0)];
  if (e == qa && !n.length && !ZK.test(t))
    return xE(t.length);
  if (n.length)
    for (; t.length > At.length; )
      At[At.length] = 256;
  let i = [], r = e == qa ? 0 : 1;
  return Jv(t, r, r, n, 0, t.length, i), i;
}
function xE(t) {
  return [new ws(0, t, 0)];
}
let CE = "";
function zK(t, e, n, i, r) {
  var o;
  let s = i.head - t.from, a = ws.find(e, s, (o = i.bidiLevel) !== null && o !== void 0 ? o : -1, i.assoc), l = e[a], u = l.side(r, n);
  if (s == u) {
    let h = a += r ? 1 : -1;
    if (h < 0 || h >= e.length)
      return null;
    l = e[a = h], s = l.side(!r, n), u = l.side(r, n);
  }
  let c = Zn(t.text, s, l.forward(r, n));
  (c < l.from || c > l.to) && (c = u), CE = t.text.slice(Math.min(s, c), Math.max(s, c));
  let d = a == (r ? e.length - 1 : 0) ? null : e[a + (r ? 1 : -1)];
  return d && c == u && d.level + (r ? 0 : 1) < l.level ? ve.cursor(d.side(!r, n) + t.from, d.forward(r, n) ? 1 : -1, d.level) : ve.cursor(c + t.from, l.forward(r, n) ? -1 : 1, l.level);
}
function jK(t, e, n) {
  for (let i = e; i < n; i++) {
    let r = SE(t.charCodeAt(i));
    if (r == 1)
      return qa;
    if (r == 2 || r == 4)
      return f0;
  }
  return qa;
}
const TE = /* @__PURE__ */ Ze.define(), $E = /* @__PURE__ */ Ze.define(), PE = /* @__PURE__ */ Ze.define(), ME = /* @__PURE__ */ Ze.define(), ey = /* @__PURE__ */ Ze.define(), EE = /* @__PURE__ */ Ze.define(), AE = /* @__PURE__ */ Ze.define(), p0 = /* @__PURE__ */ Ze.define(), m0 = /* @__PURE__ */ Ze.define(), RE = /* @__PURE__ */ Ze.define({
  combine: (t) => t.some((e) => e)
}), DE = /* @__PURE__ */ Ze.define({
  combine: (t) => t.some((e) => e)
}), QE = /* @__PURE__ */ Ze.define();
class $l {
  constructor(e, n = "nearest", i = "nearest", r = 5, o = 5, s = !1) {
    this.range = e, this.y = n, this.x = i, this.yMargin = r, this.xMargin = o, this.isSnapshot = s;
  }
  map(e) {
    return e.empty ? this : new $l(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new $l(ve.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const hh = /* @__PURE__ */ ot.define({ map: (t, e) => t.map(e) }), NE = /* @__PURE__ */ ot.define();
function si(t, e, n) {
  let i = t.facet(ME);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), n, void 0, void 0, e) : n ? console.error(n + ":", e) : console.error(e);
}
const Mo = /* @__PURE__ */ Ze.define({ combine: (t) => t.length ? t[0] : !0 });
let YK = 0;
const ec = /* @__PURE__ */ Ze.define();
class dn {
  constructor(e, n, i, r, o) {
    this.id = e, this.create = n, this.domEventHandlers = i, this.domEventObservers = r, this.extension = o(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, n) {
    const { eventHandlers: i, eventObservers: r, provide: o, decorations: s } = n || {};
    return new dn(YK++, e, i, r, (a) => {
      let l = [ec.of(a)];
      return s && l.push(od.of((u) => {
        let c = u.plugin(a);
        return c ? s(c) : Ue.none;
      })), o && l.push(o(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, n) {
    return dn.define((i) => new e(i), n);
  }
}
class Zg {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(n);
          } catch (i) {
            if (si(n.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (n) {
        si(e.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        si(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const IE = /* @__PURE__ */ Ze.define(), g0 = /* @__PURE__ */ Ze.define(), od = /* @__PURE__ */ Ze.define(), LE = /* @__PURE__ */ Ze.define(), O0 = /* @__PURE__ */ Ze.define(), VE = /* @__PURE__ */ Ze.define();
function WS(t, e) {
  let n = t.state.facet(VE);
  if (!n.length)
    return n;
  let i = n.map((o) => o instanceof Function ? o(t) : o), r = [];
  return bt.spans(i, e.from, e.to, {
    point() {
    },
    span(o, s, a, l) {
      let u = o - e.from, c = s - e.from, d = r;
      for (let h = a.length - 1; h >= 0; h--, l--) {
        let f = a[h].spec.bidiIsolate, p;
        if (f == null && (f = jK(e.text, u, c)), l > 0 && d.length && (p = d[d.length - 1]).to == u && p.direction == f)
          p.to = c, d = p.inner;
        else {
          let m = { from: u, to: c, direction: f, inner: [] };
          d.push(m), d = m.inner;
        }
      }
    }
  }), r;
}
const BE = /* @__PURE__ */ Ze.define();
function v0(t) {
  let e = 0, n = 0, i = 0, r = 0;
  for (let o of t.state.facet(BE)) {
    let s = o(t);
    s && (s.left != null && (e = Math.max(e, s.left)), s.right != null && (n = Math.max(n, s.right)), s.top != null && (i = Math.max(i, s.top)), s.bottom != null && (r = Math.max(r, s.bottom)));
  }
  return { left: e, right: n, top: i, bottom: r };
}
const tc = /* @__PURE__ */ Ze.define();
class nr {
  constructor(e, n, i, r) {
    this.fromA = e, this.toA = n, this.fromB = i, this.toB = r;
  }
  join(e) {
    return new nr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let n = e.length, i = this;
    for (; n > 0; n--) {
      let r = e[n - 1];
      if (!(r.fromA > i.toA)) {
        if (r.toA < i.fromA)
          break;
        i = i.join(r), e.splice(n - 1, 1);
      }
    }
    return e.splice(n, 0, i), e;
  }
  static extendWithRanges(e, n) {
    if (n.length == 0)
      return e;
    let i = [];
    for (let r = 0, o = 0, s = 0, a = 0; ; r++) {
      let l = r == e.length ? null : e[r], u = s - a, c = l ? l.fromB : 1e9;
      for (; o < n.length && n[o] < c; ) {
        let d = n[o], h = n[o + 1], f = Math.max(a, d), p = Math.min(c, h);
        if (f <= p && new nr(f + u, p + u, f, p).addToSet(i), h > c)
          break;
        o += 2;
      }
      if (!l)
        return i;
      new nr(l.fromA, l.toA, l.fromB, l.toB).addToSet(i), s = l.toA, a = l.toB;
    }
  }
}
class cp {
  constructor(e, n, i) {
    this.view = e, this.state = n, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = Cn.empty(this.startState.doc.length);
    for (let o of i)
      this.changes = this.changes.compose(o.changes);
    let r = [];
    this.changes.iterChangedRanges((o, s, a, l) => r.push(new nr(o, s, a, l))), this.changedRanges = r;
  }
  /**
  @internal
  */
  static create(e, n, i) {
    return new cp(e, n, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class XS extends It {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = Ue.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new bn()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new nr(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var n;
    let i = e.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: u, toA: c }) => c < this.minWidthFrom || u > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let r = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? r = this.domChanged.newSel.head : !tJ(e.changes, this.hasComposition) && !e.selectionSet && (r = e.state.selection.main.head));
    let o = r > -1 ? UK(this.view, e.changes, r) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: u, to: c } = this.hasComposition;
      i = new nr(u, c, e.changes.mapPos(u, -1), e.changes.mapPos(c, 1)).addToSet(i.slice());
    }
    this.hasComposition = o ? { from: o.range.fromB, to: o.range.toB } : null, (qe.ie || qe.chrome) && !o && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let s = this.decorations, a = this.updateDeco(), l = JK(s, a, e.changes);
    return i = nr.extendWithRanges(i, l), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, e.startState.doc.length, o), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, n, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, n, i);
    let { observer: r } = this.view;
    r.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let s = qe.chrome || qe.ios ? { node: r.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, s), this.flags &= -8, s && (s.written || r.selectionRange.focusNode != s.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (s) => s.flags &= -9
      /* ViewFlag.Composition */
    );
    let o = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let s of this.children)
        s instanceof Qo && s.widget instanceof Uv && o.push(s.dom);
    r.updateGaps(o);
  }
  updateChildren(e, n, i) {
    let r = i ? i.range.addToSet(e.slice()) : e, o = this.childCursor(n);
    for (let s = r.length - 1; ; s--) {
      let a = s >= 0 ? r[s] : null;
      if (!a)
        break;
      let { fromA: l, toA: u, fromB: c, toB: d } = a, h, f, p, m;
      if (i && i.range.fromB < d && i.range.toB > c) {
        let v = $c.build(this.view.state.doc, c, i.range.fromB, this.decorations, this.dynamicDecorationMap), k = $c.build(this.view.state.doc, i.range.toB, d, this.decorations, this.dynamicDecorationMap);
        f = v.breakAtStart, p = v.openStart, m = k.openEnd;
        let w = this.compositionView(i);
        k.breakAtStart ? w.breakAfter = 1 : k.content.length && w.merge(w.length, w.length, k.content[0], !1, k.openStart, 0) && (w.breakAfter = k.content[0].breakAfter, k.content.shift()), v.content.length && w.merge(0, 0, v.content[v.content.length - 1], !0, 0, v.openEnd) && v.content.pop(), h = v.content.concat(w).concat(k.content);
      } else
        ({ content: h, breakAtStart: f, openStart: p, openEnd: m } = $c.build(this.view.state.doc, c, d, this.decorations, this.dynamicDecorationMap));
      let { i: g, off: O } = o.findPos(u, 1), { i: y, off: b } = o.findPos(l, -1);
      pE(this, y, b, g, O, h, f, p, m);
    }
    i && this.fixCompositionDOM(i);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let n of e.transactions)
      for (let i of n.effects)
        i.is(NE) && (this.editContextFormatting = i.value);
  }
  compositionView(e) {
    let n = new Tr(e.text.nodeValue);
    n.flags |= 8;
    for (let { deco: r } of e.marks)
      n = new Xo(r, [n], n.length);
    let i = new bn();
    return i.append(n, 0), i;
  }
  fixCompositionDOM(e) {
    let n = (o, s) => {
      s.flags |= 8 | (s.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(s);
      let a = It.get(o);
      a && a != s && (a.dom = null), s.setDOM(o);
    }, i = this.childPos(e.range.fromB, 1), r = this.children[i.i];
    n(e.line, r);
    for (let o = e.marks.length - 1; o >= -1; o--)
      i = r.childPos(i.off, 1), r = r.children[i.i], n(o >= 0 ? e.marks[o].node : e.text, r);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, n = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, r = i == this.dom, o = !r && !(this.view.state.facet(Mo) || this.dom.tabIndex > -1) && qh(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(r || n || o))
      return;
    let s = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), u = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (qe.gecko && a.empty && !this.hasComposition && HK(l)) {
      let d = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(d, l.node.childNodes[l.offset] || null)), l = u = new Yn(d, 0), s = !0;
    }
    let c = this.view.observer.selectionRange;
    (s || !c.focusNode || (!Tc(l.node, l.offset, c.anchorNode, c.anchorOffset) || !Tc(u.node, u.offset, c.focusNode, c.focusOffset)) && !this.suppressWidgetCursorChange(c, a)) && (this.view.observer.ignore(() => {
      qe.android && qe.chrome && this.dom.contains(c.focusNode) && eJ(c.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let d = rd(this.view.root);
      if (d)
        if (a.empty) {
          if (qe.gecko) {
            let h = GK(l.node, l.offset);
            if (h && h != 3) {
              let f = (h == 1 ? dE : hE)(l.node, l.offset);
              f && (l = new Yn(f.node, f.offset));
            }
          }
          d.collapse(l.node, l.offset), a.bidiLevel != null && d.caretBidiLevel !== void 0 && (d.caretBidiLevel = a.bidiLevel);
        } else if (d.extend) {
          d.collapse(l.node, l.offset);
          try {
            d.extend(u.node, u.offset);
          } catch {
          }
        } else {
          let h = document.createRange();
          a.anchor > a.head && ([l, u] = [u, l]), h.setEnd(u.node, u.offset), h.setStart(l.node, l.offset), d.removeAllRanges(), d.addRange(h);
        }
      o && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(l, u)), this.impreciseAnchor = l.precise ? null : new Yn(c.anchorNode, c.anchorOffset), this.impreciseHead = u.precise ? null : new Yn(c.focusNode, c.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, n) {
    return this.hasComposition && n.empty && Tc(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == n.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, n = e.state.selection.main, i = rd(e.root), { anchorNode: r, anchorOffset: o } = e.observer.selectionRange;
    if (!i || !n.empty || !n.assoc || !i.modify)
      return;
    let s = bn.find(this, n.head);
    if (!s)
      return;
    let a = s.posAtStart;
    if (n.head == a || n.head == a + s.length)
      return;
    let l = this.coordsAt(n.head, -1), u = this.coordsAt(n.head, 1);
    if (!l || !u || l.bottom > u.top)
      return;
    let c = this.domAtPos(n.head + n.assoc);
    i.collapse(c.node, c.offset), i.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let d = e.observer.selectionRange;
    e.docView.posFromDOM(d.anchorNode, d.anchorOffset) != n.from && i.collapse(r, o);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let n = this.dom, i;
    if (e.node != n)
      return e;
    for (let r = e.offset; !i && r < n.childNodes.length; r++) {
      let o = It.get(n.childNodes[r]);
      o instanceof bn && (i = o.domAtPos(0));
    }
    for (let r = e.offset - 1; !i && r >= 0; r--) {
      let o = It.get(n.childNodes[r]);
      o instanceof bn && (i = o.domAtPos(o.length));
    }
    return i ? new Yn(i.node, i.offset, !0) : e;
  }
  nearest(e) {
    for (let n = e; n; ) {
      let i = It.get(n);
      if (i && i.rootView == this)
        return i;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(e, n) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, n) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: n, off: i } = this.childCursor().findPos(e, -1);
    for (; n < this.children.length - 1; ) {
      let r = this.children[n];
      if (i < r.length || r instanceof bn)
        break;
      n++, i = 0;
    }
    return this.children[n].domAtPos(i);
  }
  coordsAt(e, n) {
    let i = null, r = 0;
    for (let o = this.length, s = this.children.length - 1; s >= 0; s--) {
      let a = this.children[s], l = o - a.breakAfter, u = l - a.length;
      if (l < e)
        break;
      if (u <= e && (u < e || a.covers(-1)) && (l > e || a.covers(1)) && (!i || a instanceof bn && !(i instanceof bn && n >= 0)))
        i = a, r = u;
      else if (i && u == e && l == e && a instanceof Qo && Math.abs(n) < 2) {
        if (a.deco.startSide < 0)
          break;
        s && (i = null);
      }
      o = u;
    }
    return i ? i.coordsAt(e - r, n) : null;
  }
  coordsForChar(e) {
    let { i: n, off: i } = this.childPos(e, 1), r = this.children[n];
    if (!(r instanceof bn))
      return null;
    for (; r.children.length; ) {
      let { i: a, off: l } = r.childPos(i, 1);
      for (; ; a++) {
        if (a == r.children.length)
          return null;
        if ((r = r.children[a]).length)
          break;
      }
      i = l;
    }
    if (!(r instanceof Tr))
      return null;
    let o = Zn(r.text, i);
    if (o == i)
      return null;
    let s = Fa(r.dom, i, o).getClientRects();
    for (let a = 0; a < s.length; a++) {
      let l = s[a];
      if (a == s.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let n = [], { from: i, to: r } = e, o = this.view.contentDOM.clientWidth, s = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == Yt.LTR;
    for (let u = 0, c = 0; c < this.children.length; c++) {
      let d = this.children[c], h = u + d.length;
      if (h > r)
        break;
      if (u >= i) {
        let f = d.dom.getBoundingClientRect();
        if (n.push(f.height), s) {
          let p = d.dom.lastChild, m = p ? iu(p) : [];
          if (m.length) {
            let g = m[m.length - 1], O = l ? g.right - f.left : f.right - g.left;
            O > a && (a = O, this.minWidth = o, this.minWidthFrom = u, this.minWidthTo = h);
          }
        }
      }
      u = h + d.breakAfter;
    }
    return n;
  }
  textDirectionAt(e) {
    let { i: n } = this.childPos(e, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? Yt.RTL : Yt.LTR;
  }
  measureTextSize() {
    for (let o of this.children)
      if (o instanceof bn) {
        let s = o.measureTextSize();
        if (s)
          return s;
      }
    let e = document.createElement("div"), n, i, r;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let o = iu(e.firstChild)[0];
      n = e.getBoundingClientRect().height, i = o ? o.width / 27 : 7, r = o ? o.height : n, e.remove();
    }), { lineHeight: n, charWidth: i, textHeight: r };
  }
  childCursor(e = this.length) {
    let n = this.children.length;
    return n && (e -= this.children[--n].length), new fE(this.children, e, n);
  }
  computeBlockGapDeco() {
    let e = [], n = this.view.viewState;
    for (let i = 0, r = 0; ; r++) {
      let o = r == n.viewports.length ? null : n.viewports[r], s = o ? o.from - 1 : this.length;
      if (s > i) {
        let a = (n.lineBlockAt(s).bottom - n.lineBlockAt(i).top) / this.view.scaleY;
        e.push(Ue.replace({
          widget: new Uv(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, s));
      }
      if (!o)
        break;
      i = o.to + 1;
    }
    return Ue.set(e);
  }
  updateDeco() {
    let e = 1, n = this.view.state.facet(od).map((o) => (this.dynamicDecorationMap[e++] = typeof o == "function") ? o(this.view) : o), i = !1, r = this.view.state.facet(LE).map((o, s) => {
      let a = typeof o == "function";
      return a && (i = !0), a ? o(this.view) : o;
    });
    for (r.length && (this.dynamicDecorationMap[e++] = i, n.push(bt.join(r))), this.decorations = [
      this.editContextFormatting,
      ...n,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let u = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = u.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let u of this.view.state.facet(QE))
      try {
        if (u(this.view, e.range, e))
          return !0;
      } catch (c) {
        si(this.view.state, c, "scroll handler");
      }
    let { range: n } = e, i = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), r;
    if (!i)
      return;
    !n.empty && (r = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, r.left),
      top: Math.min(i.top, r.top),
      right: Math.max(i.right, r.right),
      bottom: Math.max(i.bottom, r.bottom)
    });
    let o = v0(this.view), s = {
      left: i.left - o.left,
      top: i.top - o.top,
      right: i.right + o.right,
      bottom: i.bottom + o.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    PK(this.view.scrollDOM, s, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == Yt.LTR);
  }
}
function HK(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
function ZE(t, e) {
  let n = t.observer.selectionRange;
  if (!n.focusNode)
    return null;
  let i = dE(n.focusNode, n.focusOffset), r = hE(n.focusNode, n.focusOffset), o = i || r;
  if (r && i && r.node != i.node) {
    let a = It.get(r.node);
    if (!a || a instanceof Tr && a.text != r.node.nodeValue)
      o = r;
    else if (t.docView.lastCompositionAfterCursor) {
      let l = It.get(i.node);
      !l || l instanceof Tr && l.text != i.node.nodeValue || (o = r);
    }
  }
  if (t.docView.lastCompositionAfterCursor = o != i, !o)
    return null;
  let s = e - o.offset;
  return { from: s, to: s + o.node.nodeValue.length, node: o.node };
}
function UK(t, e, n) {
  let i = ZE(t, n);
  if (!i)
    return null;
  let { node: r, from: o, to: s } = i, a = r.nodeValue;
  if (/[\n\r]/.test(a) || t.state.doc.sliceString(i.from, i.to) != a)
    return null;
  let l = e.invertedDesc, u = new nr(l.mapPos(o), l.mapPos(s), o, s), c = [];
  for (let d = r.parentNode; ; d = d.parentNode) {
    let h = It.get(d);
    if (h instanceof Xo)
      c.push({ node: d, deco: h.mark });
    else {
      if (h instanceof bn || d.nodeName == "DIV" && d.parentNode == t.contentDOM)
        return { range: u, text: r, marks: c, line: d };
      if (d != t.contentDOM)
        c.push({ node: d, deco: new Dd({
          inclusive: !0,
          attributes: IK(d),
          tagName: d.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function GK(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let KK = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, n) {
    Wh(e, n, this.changes);
  }
  comparePoint(e, n) {
    Wh(e, n, this.changes);
  }
  boundChange(e) {
    Wh(e, e, this.changes);
  }
};
function JK(t, e, n) {
  let i = new KK();
  return bt.compare(t, e, n, i), i.changes;
}
function eJ(t, e) {
  for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode)
    if (n.nodeType == 1 && n.contentEditable == "false")
      return !0;
  return !1;
}
function tJ(t, e) {
  let n = !1;
  return e && t.iterChangedRanges((i, r) => {
    i < e.to && r > e.from && (n = !0);
  }), n;
}
function nJ(t, e, n = 1) {
  let i = t.charCategorizer(e), r = t.doc.lineAt(e), o = e - r.from;
  if (r.length == 0)
    return ve.cursor(e);
  o == 0 ? n = 1 : o == r.length && (n = -1);
  let s = o, a = o;
  n < 0 ? s = Zn(r.text, o, !1) : a = Zn(r.text, o);
  let l = i(r.text.slice(s, a));
  for (; s > 0; ) {
    let u = Zn(r.text, s, !1);
    if (i(r.text.slice(u, s)) != l)
      break;
    s = u;
  }
  for (; a < r.length; ) {
    let u = Zn(r.text, a);
    if (i(r.text.slice(a, u)) != l)
      break;
    a = u;
  }
  return ve.range(s + r.from, a + r.from);
}
function iJ(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function rJ(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function Fg(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function zS(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function jS(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function ty(t, e, n) {
  let i, r, o, s, a = !1, l, u, c, d;
  for (let p = t.firstChild; p; p = p.nextSibling) {
    let m = iu(p);
    for (let g = 0; g < m.length; g++) {
      let O = m[g];
      r && Fg(r, O) && (O = zS(jS(O, r.bottom), r.top));
      let y = iJ(e, O), b = rJ(n, O);
      if (y == 0 && b == 0)
        return p.nodeType == 3 ? YS(p, e, n) : ty(p, e, n);
      if (!i || s > b || s == b && o > y) {
        i = p, r = O, o = y, s = b;
        let v = b ? n < O.top ? -1 : 1 : y ? e < O.left ? -1 : 1 : 0;
        a = !v || (v > 0 ? g < m.length - 1 : g > 0);
      }
      y == 0 ? n > O.bottom && (!c || c.bottom < O.bottom) ? (l = p, c = O) : n < O.top && (!d || d.top > O.top) && (u = p, d = O) : c && Fg(c, O) ? c = jS(c, O.bottom) : d && Fg(d, O) && (d = zS(d, O.top));
    }
  }
  if (c && c.bottom >= n ? (i = l, r = c) : d && d.top <= n && (i = u, r = d), !i)
    return { node: t, offset: 0 };
  let h = Math.max(r.left, Math.min(r.right, e));
  if (i.nodeType == 3)
    return YS(i, h, n);
  if (a && i.contentEditable != "false")
    return ty(i, h, n);
  let f = Array.prototype.indexOf.call(t.childNodes, i) + (e >= (r.left + r.right) / 2 ? 1 : 0);
  return { node: t, offset: f };
}
function YS(t, e, n) {
  let i = t.nodeValue.length, r = -1, o = 1e9, s = 0;
  for (let a = 0; a < i; a++) {
    let l = Fa(t, a, a + 1).getClientRects();
    for (let u = 0; u < l.length; u++) {
      let c = l[u];
      if (c.top == c.bottom)
        continue;
      s || (s = e - c.left);
      let d = (c.top > n ? c.top - n : n - c.bottom) - 1;
      if (c.left - 1 <= e && c.right + 1 >= e && d < o) {
        let h = e >= (c.left + c.right) / 2, f = h;
        if ((qe.chrome || qe.gecko) && Fa(t, a).getBoundingClientRect().left == c.right && (f = !h), d <= 0)
          return { node: t, offset: a + (f ? 1 : 0) };
        r = a + (f ? 1 : 0), o = d;
      }
    }
  }
  return { node: t, offset: r > -1 ? r : s > 0 ? t.nodeValue.length : 0 };
}
function FE(t, e, n, i = -1) {
  var r, o;
  let s = t.contentDOM.getBoundingClientRect(), a = s.top + t.viewState.paddingTop, l, { docHeight: u } = t.viewState, { x: c, y: d } = e, h = d - a;
  if (h < 0)
    return 0;
  if (h > u)
    return t.state.doc.length;
  for (let v = t.viewState.heightOracle.textHeight / 2, k = !1; l = t.elementAtHeight(h), l.type != li.Text; )
    for (; h = i > 0 ? l.bottom + v : l.top - v, !(h >= 0 && h <= u); ) {
      if (k)
        return n ? null : 0;
      k = !0, i = -i;
    }
  d = a + h;
  let f = l.from;
  if (f < t.viewport.from)
    return t.viewport.from == 0 ? 0 : n ? null : HS(t, s, l, c, d);
  if (f > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : n ? null : HS(t, s, l, c, d);
  let p = t.dom.ownerDocument, m = t.root.elementFromPoint ? t.root : p, g = m.elementFromPoint(c, d);
  g && !t.contentDOM.contains(g) && (g = null), g || (c = Math.max(s.left + 1, Math.min(s.right - 1, c)), g = m.elementFromPoint(c, d), g && !t.contentDOM.contains(g) && (g = null));
  let O, y = -1;
  if (g && ((r = t.docView.nearest(g)) === null || r === void 0 ? void 0 : r.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let v = p.caretPositionFromPoint(c, d);
      v && ({ offsetNode: O, offset: y } = v);
    } else if (p.caretRangeFromPoint) {
      let v = p.caretRangeFromPoint(c, d);
      v && ({ startContainer: O, startOffset: y } = v, (!t.contentDOM.contains(O) || qe.safari && oJ(O, y, c) || qe.chrome && sJ(O, y, c)) && (O = void 0));
    }
    O && (y = Math.min(ho(O), y));
  }
  if (!O || !t.docView.dom.contains(O)) {
    let v = bn.find(t.docView, f);
    if (!v)
      return h > l.top + l.height / 2 ? l.to : l.from;
    ({ node: O, offset: y } = ty(v.dom, c, d));
  }
  let b = t.docView.nearest(O);
  if (!b)
    return null;
  if (b.isWidget && ((o = b.dom) === null || o === void 0 ? void 0 : o.nodeType) == 1) {
    let v = b.dom.getBoundingClientRect();
    return e.y < v.top || e.y <= v.bottom && e.x <= (v.left + v.right) / 2 ? b.posAtStart : b.posAtEnd;
  } else
    return b.localPosFromDOM(O, y) + b.posAtStart;
}
function HS(t, e, n, i, r) {
  let o = Math.round((i - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) {
    let a = t.viewState.heightOracle.textHeight, l = Math.floor((r - n.top - (t.defaultLineHeight - a) * 0.5) / a);
    o += l * t.viewState.heightOracle.lineLength;
  }
  let s = t.state.sliceDoc(n.from, n.to);
  return n.from + Zv(s, o, t.state.tabSize);
}
function oJ(t, e, n) {
  let i;
  if (t.nodeType != 3 || e != (i = t.nodeValue.length))
    return !1;
  for (let r = t.nextSibling; r; r = r.nextSibling)
    if (r.nodeType != 1 || r.nodeName != "BR")
      return !1;
  return Fa(t, i - 1, i).getBoundingClientRect().left > n;
}
function sJ(t, e, n) {
  if (e != 0)
    return !1;
  for (let r = t; ; ) {
    let o = r.parentNode;
    if (!o || o.nodeType != 1 || o.firstChild != r)
      return !1;
    if (o.classList.contains("cm-line"))
      break;
    r = o;
  }
  let i = t.nodeType == 1 ? t.getBoundingClientRect() : Fa(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return n - i.left > 5;
}
function ny(t, e) {
  let n = t.lineBlockAt(e);
  if (Array.isArray(n.type)) {
    for (let i of n.type)
      if (i.to > e || i.to == e && (i.to == n.to || i.type == li.Text))
        return i;
  }
  return n;
}
function aJ(t, e, n, i) {
  let r = ny(t, e.head), o = !i || r.type != li.Text || !(t.lineWrapping || r.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > r.from ? e.head - 1 : e.head);
  if (o) {
    let s = t.dom.getBoundingClientRect(), a = t.textDirectionAt(r.from), l = t.posAtCoords({
      x: n == (a == Yt.LTR) ? s.right - 1 : s.left + 1,
      y: (o.top + o.bottom) / 2
    });
    if (l != null)
      return ve.cursor(l, n ? -1 : 1);
  }
  return ve.cursor(n ? r.to : r.from, n ? -1 : 1);
}
function US(t, e, n, i) {
  let r = t.state.doc.lineAt(e.head), o = t.bidiSpans(r), s = t.textDirectionAt(r.from);
  for (let a = e, l = null; ; ) {
    let u = zK(r, o, s, a, n), c = CE;
    if (!u) {
      if (r.number == (n ? t.state.doc.lines : 1))
        return a;
      c = `
`, r = t.state.doc.line(r.number + (n ? 1 : -1)), o = t.bidiSpans(r), u = t.visualLineSide(r, !n);
    }
    if (l) {
      if (!l(c))
        return a;
    } else {
      if (!i)
        return u;
      l = i(c);
    }
    a = u;
  }
}
function lJ(t, e, n) {
  let i = t.state.charCategorizer(e), r = i(n);
  return (o) => {
    let s = i(o);
    return r == Ut.Space && (r = s), r == s;
  };
}
function uJ(t, e, n, i) {
  let r = e.head, o = n ? 1 : -1;
  if (r == (n ? t.state.doc.length : 0))
    return ve.cursor(r, e.assoc);
  let s = e.goalColumn, a, l = t.contentDOM.getBoundingClientRect(), u = t.coordsAtPos(r, e.assoc || -1), c = t.documentTop;
  if (u)
    s == null && (s = u.left - l.left), a = o < 0 ? u.top : u.bottom;
  else {
    let f = t.viewState.lineBlockAt(r);
    s == null && (s = Math.min(l.right - l.left, t.defaultCharacterWidth * (r - f.from))), a = (o < 0 ? f.top : f.bottom) + c;
  }
  let d = l.left + s, h = i ?? t.viewState.heightOracle.textHeight >> 1;
  for (let f = 0; ; f += 10) {
    let p = a + (h + f) * o, m = FE(t, { x: d, y: p }, !1, o);
    if (p < l.top || p > l.bottom || (o < 0 ? m < r : m > r)) {
      let g = t.docView.coordsForChar(m), O = !g || p < g.top ? -1 : 1;
      return ve.cursor(m, O, void 0, s);
    }
  }
}
function Xh(t, e, n) {
  for (; ; ) {
    let i = 0;
    for (let r of t)
      r.between(e - 1, e + 1, (o, s, a) => {
        if (e > o && e < s) {
          let l = i || n || (e - o < s - e ? -1 : 1);
          e = l < 0 ? o : s, i = l;
        }
      });
    if (!i)
      return e;
  }
}
function qg(t, e, n) {
  let i = Xh(t.state.facet(O0).map((r) => r(t)), n.from, e.head > n.from ? -1 : 1);
  return i == n.from ? n : ve.cursor(i, i < n.from ? 1 : -1);
}
const nc = "￿";
class cJ {
  constructor(e, n) {
    this.points = e, this.text = "", this.lineSeparator = n.facet(ht.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += nc;
  }
  readRange(e, n) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let r = e; ; ) {
      this.findPointBefore(i, r);
      let o = this.text.length;
      this.readNode(r);
      let s = r.nextSibling;
      if (s == n)
        break;
      let a = It.get(r), l = It.get(s);
      (a && l ? a.breakAfter : (a ? a.breakAfter : lp(r)) || lp(s) && (r.nodeName != "BR" || r.cmIgnore) && this.text.length > o) && this.lineBreak(), r = s;
    }
    return this.findPointBefore(i, n), this;
  }
  readTextNode(e) {
    let n = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, n.length));
    for (let i = 0, r = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let o = -1, s = 1, a;
      if (this.lineSeparator ? (o = n.indexOf(this.lineSeparator, i), s = this.lineSeparator.length) : (a = r.exec(n)) && (o = a.index, s = a[0].length), this.append(n.slice(i, o < 0 ? n.length : o)), o < 0)
        break;
      if (this.lineBreak(), s > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= s - 1);
      i = o + s;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let n = It.get(e), i = n && n.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let r = i.iter(); !r.next().done; )
        r.lineBreak ? this.lineBreak() : this.append(r.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, n) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == n && (i.pos = this.text.length);
  }
  findPointInside(e, n) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + (dJ(e, i.node, i.offset) ? n : 0));
  }
}
function dJ(t, e, n) {
  for (; ; ) {
    if (!e || n < ho(e))
      return !1;
    if (e == t)
      return !0;
    n = Za(e) + 1, e = e.parentNode;
  }
}
class GS {
  constructor(e, n) {
    this.node = e, this.offset = n, this.pos = -1;
  }
}
class hJ {
  constructor(e, n, i, r) {
    this.typeOver = r, this.bounds = null, this.text = "", this.domChanged = n > -1;
    let { impreciseHead: o, impreciseAnchor: s } = e.docView;
    if (e.state.readOnly && n > -1)
      this.newSel = null;
    else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, i, 0))) {
      let a = o || s ? [] : mJ(e), l = new cJ(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = gJ(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = o && o.node == a.focusNode && o.offset == a.focusOffset || !Wv(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), u = s && s.node == a.anchorNode && s.offset == a.anchorOffset || !Wv(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), c = e.viewport;
      if ((qe.ios || qe.chrome) && e.state.selection.main.empty && l != u && (c.from > 0 || c.to < e.state.doc.length)) {
        let d = Math.min(l, u), h = Math.max(l, u), f = c.from - d, p = c.to - h;
        (f == 0 || f == 1 || d == 0) && (p == 0 || p == -1 || h == e.state.doc.length) && (l = 0, u = e.state.doc.length);
      }
      this.newSel = ve.single(u, l);
    }
  }
}
function qE(t, e) {
  let n, { newSel: i } = e, r = t.state.selection.main, o = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: s, to: a } = e.bounds, l = r.from, u = null;
    (o === 8 || qe.android && e.text.length < a - s) && (l = r.to, u = "end");
    let c = pJ(t.state.doc.sliceString(s, a, nc), e.text, l - s, u);
    c && (qe.chrome && o == 13 && c.toB == c.from + 2 && e.text.slice(c.from, c.toB) == nc + nc && c.toB--, n = {
      from: s + c.from,
      to: s + c.toA,
      insert: St.of(e.text.slice(c.from, c.toB).split(nc))
    });
  } else
    i && (!t.hasFocus && t.state.facet(Mo) || i.main.eq(r)) && (i = null);
  if (!n && !i)
    return !1;
  if (!n && e.typeOver && !r.empty && i && i.main.empty ? n = { from: r.from, to: r.to, insert: t.state.doc.slice(r.from, r.to) } : n && n.from >= r.from && n.to <= r.to && (n.from != r.from || n.to != r.to) && r.to - r.from - (n.to - n.from) <= 4 ? n = {
    from: r.from,
    to: r.to,
    insert: t.state.doc.slice(r.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, r.to))
  } : (qe.mac || qe.android) && n && n.from == n.to && n.from == r.head - 1 && /^\. ?$/.test(n.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (i && n.insert.length == 2 && (i = ve.single(i.main.anchor - 1, i.main.head - 1)), n = { from: r.from, to: r.to, insert: St.of([" "]) }) : qe.chrome && n && n.from == n.to && n.from == r.head && n.insert.toString() == `
 ` && t.lineWrapping && (i && (i = ve.single(i.main.anchor - 1, i.main.head - 1)), n = { from: r.from, to: r.to, insert: St.of([" "]) }), n)
    return y0(t, n, i, o);
  if (i && !i.main.eq(r)) {
    let s = !1, a = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (s = !0), a = t.inputState.lastSelectionOrigin), t.dispatch({ selection: i, scrollIntoView: s, userEvent: a }), !0;
  } else
    return !1;
}
function y0(t, e, n, i = -1) {
  if (qe.ios && t.inputState.flushIOSKey(e))
    return !0;
  let r = t.state.selection.main;
  if (qe.android && (e.to == r.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == r.from || e.from == r.from - 1 && t.state.sliceDoc(e.from, r.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && Tl(t.contentDOM, "Enter", 13) || (e.from == r.from - 1 && e.to == r.to && e.insert.length == 0 || i == 8 && e.insert.length < e.to - e.from && e.to > r.head) && Tl(t.contentDOM, "Backspace", 8) || e.from == r.from && e.to == r.to + 1 && e.insert.length == 0 && Tl(t.contentDOM, "Delete", 46)))
    return !0;
  let o = e.insert.toString();
  t.inputState.composing >= 0 && t.inputState.composing++;
  let s, a = () => s || (s = fJ(t, e, n));
  return t.state.facet(EE).some((l) => l(t, e.from, e.to, o, a)) || t.dispatch(a()), !0;
}
function fJ(t, e, n) {
  let i, r = t.state, o = r.selection.main;
  if (e.from >= o.from && e.to <= o.to && e.to - e.from >= (o.to - o.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let a = o.from < e.from ? r.sliceDoc(o.from, e.from) : "", l = o.to > e.to ? r.sliceDoc(e.to, o.to) : "";
    i = r.replaceSelection(t.state.toText(a + e.insert.sliceString(0, void 0, t.state.lineBreak) + l));
  } else {
    let a = r.changes(e), l = n && n.main.to <= a.newLength ? n.main : void 0;
    if (r.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= o.to && e.to >= o.to - 10) {
      let u = t.state.sliceDoc(e.from, e.to), c, d = n && ZE(t, n.main.head);
      if (d) {
        let p = e.insert.length - (e.to - e.from);
        c = { from: d.from, to: d.to - p };
      } else
        c = t.state.doc.lineAt(o.head);
      let h = o.to - e.to, f = o.to - o.from;
      i = r.changeByRange((p) => {
        if (p.from == o.from && p.to == o.to)
          return { changes: a, range: l || p.map(a) };
        let m = p.to - h, g = m - u.length;
        if (p.to - p.from != f || t.state.sliceDoc(g, m) != u || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        p.to >= c.from && p.from <= c.to)
          return { range: p };
        let O = r.changes({ from: g, to: m, insert: e.insert }), y = p.to - o.to;
        return {
          changes: O,
          range: l ? ve.range(Math.max(0, l.anchor + y), Math.max(0, l.head + y)) : p.map(O)
        };
      });
    } else
      i = {
        changes: a,
        selection: l && r.selection.replaceRange(l)
      };
  }
  let s = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, s += ".compose", t.inputState.compositionFirstChange && (s += ".start", t.inputState.compositionFirstChange = !1)), r.update(i, { userEvent: s, scrollIntoView: !0 });
}
function pJ(t, e, n, i) {
  let r = Math.min(t.length, e.length), o = 0;
  for (; o < r && t.charCodeAt(o) == e.charCodeAt(o); )
    o++;
  if (o == r && t.length == e.length)
    return null;
  let s = t.length, a = e.length;
  for (; s > 0 && a > 0 && t.charCodeAt(s - 1) == e.charCodeAt(a - 1); )
    s--, a--;
  if (i == "end") {
    let l = Math.max(0, o - Math.min(s, a));
    n -= s + l - o;
  }
  if (s < o && t.length < e.length) {
    let l = n <= o && n >= s ? o - n : 0;
    o -= l, a = o + (a - s), s = o;
  } else if (a < o) {
    let l = n <= o && n >= a ? o - n : 0;
    o -= l, s = o + (s - a), a = o;
  }
  return { from: o, toA: s, toB: a };
}
function mJ(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: n, anchorOffset: i, focusNode: r, focusOffset: o } = t.observer.selectionRange;
  return n && (e.push(new GS(n, i)), (r != n || o != i) && e.push(new GS(r, o))), e;
}
function gJ(t, e) {
  if (t.length == 0)
    return null;
  let n = t[0].pos, i = t.length == 2 ? t[1].pos : n;
  return n > -1 && i > -1 ? ve.single(n + e, i + e) : null;
}
class OJ {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, qe.safari && e.contentDOM.addEventListener("input", () => null), qe.gecko && RJ(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !xJ(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, n) {
    let i = this.handlers[e];
    if (i) {
      for (let r of i.observers)
        r(this.view, n);
      for (let r of i.handlers) {
        if (n.defaultPrevented)
          break;
        if (r(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let n = vJ(e), i = this.handlers, r = this.view.contentDOM;
    for (let o in n)
      if (o != "scroll") {
        let s = !n[o].handlers.length, a = i[o];
        a && s != !a.handlers.length && (r.removeEventListener(o, this.handleEvent), a = null), a || r.addEventListener(o, this.handleEvent, { passive: s });
      }
    for (let o in i)
      o != "scroll" && !n[o] && r.removeEventListener(o, this.handleEvent);
    this.handlers = n;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && XE.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), qe.android && qe.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let n;
    return qe.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = WE.find((i) => i.keyCode == e.keyCode)) && !e.ctrlKey || yJ.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let n = this.pendingIOSKey;
    return !n || n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, Tl(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : qe.safari && !qe.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function KS(t, e) {
  return (n, i) => {
    try {
      return e.call(t, i, n);
    } catch (r) {
      si(n.state, r);
    }
  };
}
function vJ(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(i) {
    return e[i] || (e[i] = { observers: [], handlers: [] });
  }
  for (let i of t) {
    let r = i.spec;
    if (r && r.domEventHandlers)
      for (let o in r.domEventHandlers) {
        let s = r.domEventHandlers[o];
        s && n(o).handlers.push(KS(i.value, s));
      }
    if (r && r.domEventObservers)
      for (let o in r.domEventObservers) {
        let s = r.domEventObservers[o];
        s && n(o).observers.push(KS(i.value, s));
      }
  }
  for (let i in $r)
    n(i).handlers.push($r[i]);
  for (let i in sr)
    n(i).observers.push(sr[i]);
  return e;
}
const WE = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], yJ = "dthko", XE = [16, 17, 18, 20, 91, 92, 224, 225], fh = 6;
function ph(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function bJ(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class wJ {
  constructor(e, n, i, r) {
    this.view = e, this.startEvent = n, this.style = i, this.mustSelect = r, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParents = MK(e.contentDOM), this.atoms = e.state.facet(O0).map((s) => s(e));
    let o = e.contentDOM.ownerDocument;
    o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = e.state.facet(ht.allowMultipleSelections) && kJ(e, n), this.dragging = _J(e, n) && YE(n) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && bJ(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let n = 0, i = 0, r = 0, o = 0, s = this.view.win.innerWidth, a = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: r, right: s } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: o, bottom: a } = this.scrollParents.y.getBoundingClientRect());
    let l = v0(this.view);
    e.clientX - l.left <= r + fh ? n = -ph(r - e.clientX) : e.clientX + l.right >= s - fh && (n = ph(e.clientX - s)), e.clientY - l.top <= o + fh ? i = -ph(o - e.clientY) : e.clientY + l.bottom >= a - fh && (i = ph(e.clientY - a)), this.setScrollSpeed(n, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, n) {
    this.scrollSpeed = { x: e, y: n }, e || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: n } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), n && this.scrollParents.y && (this.scrollParents.y.scrollTop += n, n = 0), (e || n) && this.view.win.scrollBy(e, n), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let n = null;
    for (let i = 0; i < e.ranges.length; i++) {
      let r = e.ranges[i], o = null;
      if (r.empty) {
        let s = Xh(this.atoms, r.from, 0);
        s != r.from && (o = ve.cursor(s, -1));
      } else {
        let s = Xh(this.atoms, r.from, -1), a = Xh(this.atoms, r.to, 1);
        (s != r.from || a != r.to) && (o = ve.range(r.from == r.anchor ? s : a, r.from == r.head ? s : a));
      }
      o && (n || (n = e.ranges.slice()), n[i] = o);
    }
    return n ? ve.create(n, e.mainIndex) : e;
  }
  select(e) {
    let { view: n } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !i.eq(n.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((n) => n.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function kJ(t, e) {
  let n = t.state.facet(TE);
  return n.length ? n[0](e) : qe.mac ? e.metaKey : e.ctrlKey;
}
function SJ(t, e) {
  let n = t.state.facet($E);
  return n.length ? n[0](e) : qe.mac ? !e.altKey : !e.ctrlKey;
}
function _J(t, e) {
  let { main: n } = t.state.selection;
  if (n.empty)
    return !1;
  let i = rd(t.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let r = i.getRangeAt(0).getClientRects();
  for (let o = 0; o < r.length; o++) {
    let s = r[o];
    if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function xJ(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target, i; n != t.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || (i = It.get(n)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const $r = /* @__PURE__ */ Object.create(null), sr = /* @__PURE__ */ Object.create(null), zE = qe.ie && qe.ie_version < 15 || qe.ios && qe.webkit_version < 604;
function CJ(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let n = e.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
    t.focus(), n.remove(), jE(t, n.value);
  }, 50);
}
function Sm(t, e, n) {
  for (let i of t.facet(e))
    n = i(n, t);
  return n;
}
function jE(t, e) {
  e = Sm(t.state, p0, e);
  let { state: n } = t, i, r = 1, o = n.toText(e), s = o.lines == n.selection.ranges.length;
  if (iy != null && n.selection.ranges.every((l) => l.empty) && iy == o.toString()) {
    let l = -1;
    i = n.changeByRange((u) => {
      let c = n.doc.lineAt(u.from);
      if (c.from == l)
        return { range: u };
      l = c.from;
      let d = n.toText((s ? o.line(r++).text : e) + n.lineBreak);
      return {
        changes: { from: c.from, insert: d },
        range: ve.cursor(u.from + d.length)
      };
    });
  } else
    s ? i = n.changeByRange((l) => {
      let u = o.line(r++);
      return {
        changes: { from: l.from, to: l.to, insert: u.text },
        range: ve.cursor(l.from + u.length)
      };
    }) : i = n.replaceSelection(o);
  t.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
sr.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
$r.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3), !1);
sr.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
sr.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
$r.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let n = null;
  for (let i of t.state.facet(PE))
    if (n = i(t, e), n)
      break;
  if (!n && e.button == 0 && (n = PJ(t, e)), n) {
    let i = !t.hasFocus;
    t.inputState.startMouseSelection(new wJ(t, e, n, i)), i && t.observer.ignore(() => {
      lE(t.contentDOM);
      let o = t.root.activeElement;
      o && !o.contains(t.contentDOM) && o.blur();
    });
    let r = t.inputState.mouseSelection;
    if (r)
      return r.start(e), r.dragging === !1;
  }
  return !1;
};
function JS(t, e, n, i) {
  if (i == 1)
    return ve.cursor(e, n);
  if (i == 2)
    return nJ(t.state, e, n);
  {
    let r = bn.find(t.docView, e), o = t.state.doc.lineAt(r ? r.posAtEnd : e), s = r ? r.posAtStart : o.from, a = r ? r.posAtEnd : o.to;
    return a < t.state.doc.length && a == o.to && a++, ve.range(s, a);
  }
}
let e_ = (t, e, n) => e >= n.top && e <= n.bottom && t >= n.left && t <= n.right;
function TJ(t, e, n, i) {
  let r = bn.find(t.docView, e);
  if (!r)
    return 1;
  let o = e - r.posAtStart;
  if (o == 0)
    return 1;
  if (o == r.length)
    return -1;
  let s = r.coordsAt(o, -1);
  if (s && e_(n, i, s))
    return -1;
  let a = r.coordsAt(o, 1);
  return a && e_(n, i, a) ? 1 : s && s.bottom >= i ? -1 : 1;
}
function t_(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: n, bias: TJ(t, n, e.clientX, e.clientY) };
}
const $J = qe.ie && qe.ie_version <= 11;
let n_ = null, i_ = 0, r_ = 0;
function YE(t) {
  if (!$J)
    return t.detail;
  let e = n_, n = r_;
  return n_ = t, r_ = Date.now(), i_ = !e || n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (i_ + 1) % 3 : 1;
}
function PJ(t, e) {
  let n = t_(t, e), i = YE(e), r = t.state.selection;
  return {
    update(o) {
      o.docChanged && (n.pos = o.changes.mapPos(n.pos), r = r.map(o.changes));
    },
    get(o, s, a) {
      let l = t_(t, o), u, c = JS(t, l.pos, l.bias, i);
      if (n.pos != l.pos && !s) {
        let d = JS(t, n.pos, n.bias, i), h = Math.min(d.from, c.from), f = Math.max(d.to, c.to);
        c = h < c.from ? ve.range(h, f) : ve.range(f, h);
      }
      return s ? r.replaceRange(r.main.extend(c.from, c.to)) : a && i == 1 && r.ranges.length > 1 && (u = MJ(r, l.pos)) ? u : a ? r.addRange(c) : ve.create([c]);
    }
  };
}
function MJ(t, e) {
  for (let n = 0; n < t.ranges.length; n++) {
    let { from: i, to: r } = t.ranges[n];
    if (i <= e && r >= e)
      return ve.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0));
  }
  return null;
}
$r.dragstart = (t, e) => {
  let { selection: { main: n } } = t.state;
  if (e.target.draggable) {
    let r = t.docView.nearest(e.target);
    if (r && r.isWidget) {
      let o = r.posAtStart, s = o + r.length;
      (o >= n.to || s <= n.from) && (n = ve.range(o, s));
    }
  }
  let { inputState: i } = t;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = n, e.dataTransfer && (e.dataTransfer.setData("Text", Sm(t.state, m0, t.state.sliceDoc(n.from, n.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
$r.dragend = (t) => (t.inputState.draggedContent = null, !1);
function o_(t, e, n, i) {
  if (n = Sm(t.state, p0, n), !n)
    return;
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: o } = t.inputState, s = i && o && SJ(t, e) ? { from: o.from, to: o.to } : null, a = { from: r, insert: n }, l = t.state.changes(s ? [s, a] : a);
  t.focus(), t.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(r, -1), head: l.mapPos(r, 1) },
    userEvent: s ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
$r.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let n = e.dataTransfer.files;
  if (n && n.length) {
    let i = Array(n.length), r = 0, o = () => {
      ++r == n.length && o_(t, e, i.filter((s) => s != null).join(t.state.lineBreak), !1);
    };
    for (let s = 0; s < n.length; s++) {
      let a = new FileReader();
      a.onerror = o, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (i[s] = a.result), o();
      }, a.readAsText(n[s]);
    }
    return !0;
  } else {
    let i = e.dataTransfer.getData("Text");
    if (i)
      return o_(t, e, i, !0), !0;
  }
  return !1;
};
$r.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let n = zE ? null : e.clipboardData;
  return n ? (jE(t, n.getData("text/plain") || n.getData("text/uri-list")), !0) : (CJ(t), !1);
};
function EJ(t, e) {
  let n = t.dom.parentNode;
  if (!n)
    return;
  let i = n.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), t.focus();
  }, 50);
}
function AJ(t) {
  let e = [], n = [], i = !1;
  for (let r of t.selection.ranges)
    r.empty || (e.push(t.sliceDoc(r.from, r.to)), n.push(r));
  if (!e.length) {
    let r = -1;
    for (let { from: o } of t.selection.ranges) {
      let s = t.doc.lineAt(o);
      s.number > r && (e.push(s.text), n.push({ from: s.from, to: Math.min(t.doc.length, s.to + 1) })), r = s.number;
    }
    i = !0;
  }
  return { text: Sm(t, m0, e.join(t.lineBreak)), ranges: n, linewise: i };
}
let iy = null;
$r.copy = $r.cut = (t, e) => {
  let { text: n, ranges: i, linewise: r } = AJ(t.state);
  if (!n && !r)
    return !1;
  iy = r ? n : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let o = zE ? null : e.clipboardData;
  return o ? (o.clearData(), o.setData("text/plain", n), !0) : (EJ(t, n), !1);
};
const HE = /* @__PURE__ */ Uo.define();
function UE(t, e) {
  let n = [];
  for (let i of t.facet(AE)) {
    let r = i(t, e);
    r && n.push(r);
  }
  return n ? t.update({ effects: n, annotations: HE.of(!0) }) : null;
}
function GE(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let n = UE(t.state, e);
      n ? t.dispatch(n) : t.update([]);
    }
  }, 10);
}
sr.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), GE(t);
};
sr.blur = (t) => {
  t.observer.clearSelectionRange(), GE(t);
};
sr.compositionstart = sr.compositionupdate = (t) => {
  t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0));
};
sr.compositionend = (t) => {
  t.observer.editContext || (t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, qe.chrome && qe.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50));
};
sr.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
$r.beforeinput = (t, e) => {
  var n, i;
  if (e.inputType == "insertReplacementText" && t.observer.editContext) {
    let o = (n = e.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain"), s = e.getTargetRanges();
    if (o && s.length) {
      let a = s[0], l = t.posAtDOM(a.startContainer, a.startOffset), u = t.posAtDOM(a.endContainer, a.endOffset);
      return y0(t, { from: l, to: u, insert: t.state.toText(o) }, null), !0;
    }
  }
  let r;
  if (qe.chrome && qe.android && (r = WE.find((o) => o.inputType == e.inputType)) && (t.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")) {
    let o = ((i = window.visualViewport) === null || i === void 0 ? void 0 : i.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > o + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return qe.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(), qe.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => sr.compositionend(t, e), 20), !1;
};
const s_ = /* @__PURE__ */ new Set();
function RJ(t) {
  s_.has(t) || (s_.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const a_ = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let su = !1;
function l_() {
  su = !1;
}
class DJ {
  constructor(e) {
    this.lineWrapping = e, this.doc = St.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, n) {
    let i = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((n - e - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return a_.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let n = !1;
    for (let i = 0; i < e.length; i++) {
      let r = e[i];
      r < 0 ? i++ : this.heightSamples[Math.floor(r * 10)] || (n = !0, this.heightSamples[Math.floor(r * 10)] = !0);
    }
    return n;
  }
  refresh(e, n, i, r, o, s) {
    let a = a_.indexOf(e) > -1, l = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = n, this.charWidth = i, this.textHeight = r, this.lineLength = o, l) {
      this.heightSamples = {};
      for (let u = 0; u < s.length; u++) {
        let c = s[u];
        c < 0 ? u++ : this.heightSamples[Math.floor(c * 10)] = !0;
      }
    }
    return l;
  }
}
class QJ {
  constructor(e, n) {
    this.from = e, this.heights = n, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class jr {
  /**
  @internal
  */
  constructor(e, n, i, r, o) {
    this.from = e, this.length = n, this.top = i, this.height = r, this._content = o;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? li.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Is ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new jr(this.from, this.length + e.length, this.top, this.height + e.height, n);
  }
}
var zt = /* @__PURE__ */ function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(zt || (zt = {}));
const zh = 1e-3;
class ui {
  constructor(e, n, i = 2) {
    this.length = e, this.height = n, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > zh && (su = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, n, i) {
    return ui.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, n) {
    n.push(this);
  }
  decomposeRight(e, n) {
    n.push(this);
  }
  applyChanges(e, n, i, r) {
    let o = this, s = i.doc;
    for (let a = r.length - 1; a >= 0; a--) {
      let { fromA: l, toA: u, fromB: c, toB: d } = r[a], h = o.lineAt(l, zt.ByPosNoHeight, i.setDoc(n), 0, 0), f = h.to >= u ? h : o.lineAt(u, zt.ByPosNoHeight, i, 0, 0);
      for (d += f.to - u, u = f.to; a > 0 && h.from <= r[a - 1].toA; )
        l = r[a - 1].fromA, c = r[a - 1].fromB, a--, l < h.from && (h = o.lineAt(l, zt.ByPosNoHeight, i, 0, 0));
      c += h.from - l, l = h.from;
      let p = b0.build(i.setDoc(s), e, c, d);
      o = dp(o, o.replace(l, u, p));
    }
    return o.updateHeight(i, 0);
  }
  static empty() {
    return new Di(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let n = 0, i = e.length, r = 0, o = 0;
    for (; ; )
      if (n == i)
        if (r > o * 2) {
          let a = e[n - 1];
          a.break ? e.splice(--n, 1, a.left, null, a.right) : e.splice(--n, 1, a.left, a.right), i += 1 + a.break, r -= a.size;
        } else if (o > r * 2) {
          let a = e[i];
          a.break ? e.splice(i, 1, a.left, null, a.right) : e.splice(i, 1, a.left, a.right), i += 2 + a.break, o -= a.size;
        } else
          break;
      else if (r < o) {
        let a = e[n++];
        a && (r += a.size);
      } else {
        let a = e[--i];
        a && (o += a.size);
      }
    let s = 0;
    return e[n - 1] == null ? (s = 1, n--) : e[n] == null && (s = 1, i++), new NJ(ui.of(e.slice(0, n)), s, ui.of(e.slice(i)));
  }
}
function dp(t, e) {
  return t == e ? t : (t.constructor != e.constructor && (su = !0), e);
}
ui.prototype.size = 1;
class KE extends ui {
  constructor(e, n, i) {
    super(e, n), this.deco = i;
  }
  blockAt(e, n, i, r) {
    return new jr(r, this.length, i, this.height, this.deco || 0);
  }
  lineAt(e, n, i, r, o) {
    return this.blockAt(0, i, r, o);
  }
  forEachLine(e, n, i, r, o, s) {
    e <= o + this.length && n >= o && s(this.blockAt(0, i, r, o));
  }
  updateHeight(e, n = 0, i = !1, r) {
    return r && r.from <= n && r.more && this.setHeight(r.heights[r.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Di extends KE {
  constructor(e, n) {
    super(e, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, n, i, r) {
    return new jr(r, this.length, i, this.height, this.breaks);
  }
  replace(e, n, i) {
    let r = i[0];
    return i.length == 1 && (r instanceof Di || r instanceof In && r.flags & 4) && Math.abs(this.length - r.length) < 10 ? (r instanceof In ? r = new Di(r.length, this.height) : r.height = this.height, this.outdated || (r.outdated = !1), r) : ui.of(i);
  }
  updateHeight(e, n = 0, i = !1, r) {
    return r && r.from <= n && r.more ? this.setHeight(r.heights[r.index++]) : (i || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class In extends ui {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, n) {
    let i = e.doc.lineAt(n).number, r = e.doc.lineAt(n + this.length).number, o = r - i + 1, s, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * o);
      s = l / o, this.length > o + 1 && (a = (this.height - l) / (this.length - o - 1));
    } else
      s = this.height / o;
    return { firstLine: i, lastLine: r, perLine: s, perChar: a };
  }
  blockAt(e, n, i, r) {
    let { firstLine: o, lastLine: s, perLine: a, perChar: l } = this.heightMetrics(n, r);
    if (n.lineWrapping) {
      let u = r + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length)), c = n.doc.lineAt(u), d = a + c.length * l, h = Math.max(i, e - d / 2);
      return new jr(c.from, c.length, h, d, 0);
    } else {
      let u = Math.max(0, Math.min(s - o, Math.floor((e - i) / a))), { from: c, length: d } = n.doc.line(o + u);
      return new jr(c, d, i + a * u, a, 0);
    }
  }
  lineAt(e, n, i, r, o) {
    if (n == zt.ByHeight)
      return this.blockAt(e, i, r, o);
    if (n == zt.ByPosNoHeight) {
      let { from: f, to: p } = i.doc.lineAt(e);
      return new jr(f, p - f, 0, 0, 0);
    }
    let { firstLine: s, perLine: a, perChar: l } = this.heightMetrics(i, o), u = i.doc.lineAt(e), c = a + u.length * l, d = u.number - s, h = r + a * d + l * (u.from - o - d);
    return new jr(u.from, u.length, Math.max(r, Math.min(h, r + this.height - c)), c, 0);
  }
  forEachLine(e, n, i, r, o, s) {
    e = Math.max(e, o), n = Math.min(n, o + this.length);
    let { firstLine: a, perLine: l, perChar: u } = this.heightMetrics(i, o);
    for (let c = e, d = r; c <= n; ) {
      let h = i.doc.lineAt(c);
      if (c == e) {
        let p = h.number - a;
        d += l * p + u * (e - o - p);
      }
      let f = l + u * h.length;
      s(new jr(h.from, h.length, d, f, 0)), d += f, c = h.to + 1;
    }
  }
  replace(e, n, i) {
    let r = this.length - n;
    if (r > 0) {
      let o = i[i.length - 1];
      o instanceof In ? i[i.length - 1] = new In(o.length + r) : i.push(null, new In(r - 1));
    }
    if (e > 0) {
      let o = i[0];
      o instanceof In ? i[0] = new In(e + o.length) : i.unshift(new In(e - 1), null);
    }
    return ui.of(i);
  }
  decomposeLeft(e, n) {
    n.push(new In(e - 1), null);
  }
  decomposeRight(e, n) {
    n.push(null, new In(this.length - e - 1));
  }
  updateHeight(e, n = 0, i = !1, r) {
    let o = n + this.length;
    if (r && r.from <= n + this.length && r.more) {
      let s = [], a = Math.max(n, r.from), l = -1;
      for (r.from > n && s.push(new In(r.from - n - 1).updateHeight(e, n)); a <= o && r.more; ) {
        let c = e.doc.lineAt(a).length;
        s.length && s.push(null);
        let d = r.heights[r.index++];
        l == -1 ? l = d : Math.abs(d - l) >= zh && (l = -2);
        let h = new Di(c, d);
        h.outdated = !1, s.push(h), a += c + 1;
      }
      a <= o && s.push(null, new In(o - a).updateHeight(e, a));
      let u = ui.of(s);
      return (l < 0 || Math.abs(u.height - this.height) >= zh || Math.abs(l - this.heightMetrics(e, n).perLine) >= zh) && (su = !0), dp(this, u);
    } else
      (i || this.outdated) && (this.setHeight(e.heightForGap(n, n + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class NJ extends ui {
  constructor(e, n, i) {
    super(e.length + n + i.length, e.height + i.height, n | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, n, i, r) {
    let o = i + this.left.height;
    return e < o ? this.left.blockAt(e, n, i, r) : this.right.blockAt(e, n, o, r + this.left.length + this.break);
  }
  lineAt(e, n, i, r, o) {
    let s = r + this.left.height, a = o + this.left.length + this.break, l = n == zt.ByHeight ? e < s : e < a, u = l ? this.left.lineAt(e, n, i, r, o) : this.right.lineAt(e, n, i, s, a);
    if (this.break || (l ? u.to < a : u.from > a))
      return u;
    let c = n == zt.ByPosNoHeight ? zt.ByPosNoHeight : zt.ByPos;
    return l ? u.join(this.right.lineAt(a, c, i, s, a)) : this.left.lineAt(a, c, i, r, o).join(u);
  }
  forEachLine(e, n, i, r, o, s) {
    let a = r + this.left.height, l = o + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, n, i, r, o, s), n >= l && this.right.forEachLine(e, n, i, a, l, s);
    else {
      let u = this.lineAt(l, zt.ByPos, i, r, o);
      e < u.from && this.left.forEachLine(e, u.from - 1, i, r, o, s), u.to >= e && u.from <= n && s(u), n > u.to && this.right.forEachLine(u.to + 1, n, i, a, l, s);
    }
  }
  replace(e, n, i) {
    let r = this.left.length + this.break;
    if (n < r)
      return this.balanced(this.left.replace(e, n, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - r, n - r, i));
    let o = [];
    e > 0 && this.decomposeLeft(e, o);
    let s = o.length;
    for (let a of i)
      o.push(a);
    if (e > 0 && u_(o, s - 1), n < this.length) {
      let a = o.length;
      this.decomposeRight(n, o), u_(o, a);
    }
    return ui.of(o);
  }
  decomposeLeft(e, n) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, n);
    n.push(this.left), this.break && (i++, e >= i && n.push(null)), e > i && this.right.decomposeLeft(e - i, n);
  }
  decomposeRight(e, n) {
    let i = this.left.length, r = i + this.break;
    if (e >= r)
      return this.right.decomposeRight(e - r, n);
    e < i && this.left.decomposeRight(e, n), this.break && e < r && n.push(null), n.push(this.right);
  }
  balanced(e, n) {
    return e.size > 2 * n.size || n.size > 2 * e.size ? ui.of(this.break ? [e, null, n] : [e, n]) : (this.left = dp(this.left, e), this.right = dp(this.right, n), this.setHeight(e.height + n.height), this.outdated = e.outdated || n.outdated, this.size = e.size + n.size, this.length = e.length + this.break + n.length, this);
  }
  updateHeight(e, n = 0, i = !1, r) {
    let { left: o, right: s } = this, a = n + o.length + this.break, l = null;
    return r && r.from <= n + o.length && r.more ? l = o = o.updateHeight(e, n, i, r) : o.updateHeight(e, n, i), r && r.from <= a + s.length && r.more ? l = s = s.updateHeight(e, a, i, r) : s.updateHeight(e, a, i), l ? this.balanced(o, s) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function u_(t, e) {
  let n, i;
  t[e] == null && (n = t[e - 1]) instanceof In && (i = t[e + 1]) instanceof In && t.splice(e - 1, 3, new In(n.length + 1 + i.length));
}
const IJ = 5;
class b0 {
  constructor(e, n) {
    this.pos = e, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, n) {
    if (this.lineStart > -1) {
      let i = Math.min(n, this.lineEnd), r = this.nodes[this.nodes.length - 1];
      r instanceof Di ? r.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new Di(i - this.pos, -1)), this.writtenTo = i, n > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = n;
  }
  point(e, n, i) {
    if (e < n || i.heightRelevant) {
      let r = i.widget ? i.widget.estimatedHeight : 0, o = i.widget ? i.widget.lineBreaks : 0;
      r < 0 && (r = this.oracle.lineHeight);
      let s = n - e;
      i.block ? this.addBlock(new KE(s, r, i)) : (s || o || r >= IJ) && this.addLineDeco(r, o, s);
    } else
      n > e && this.span(e, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = n, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Di(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, n) {
    let i = new In(n - e);
    return this.oracle.doc.lineAt(e).to == n && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Di)
      return e;
    let n = new Di(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(e) {
    this.enterLine();
    let n = e.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, n && n.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, n, i) {
    let r = this.ensureLine();
    r.length += i, r.collapsed += i, r.widgetHeight = Math.max(r.widgetHeight, e), r.breaks += n, this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof Di) && !this.isCovered ? this.nodes.push(new Di(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let r of this.nodes)
      r instanceof Di && r.updateHeight(this.oracle, i), i += r ? r.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, n, i, r) {
    let o = new b0(i, e);
    return bt.spans(n, i, r, o, 0), o.finish(i);
  }
}
function LJ(t, e, n) {
  let i = new VJ();
  return bt.compare(t, e, n, i, 0), i.changes;
}
class VJ {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, n, i, r) {
    (e < n || i && i.heightRelevant || r && r.heightRelevant) && Wh(e, n, this.changes, 5);
  }
}
function BJ(t, e) {
  let n = t.getBoundingClientRect(), i = t.ownerDocument, r = i.defaultView || window, o = Math.max(0, n.left), s = Math.min(r.innerWidth, n.right), a = Math.max(0, n.top), l = Math.min(r.innerHeight, n.bottom);
  for (let u = t.parentNode; u && u != i.body; )
    if (u.nodeType == 1) {
      let c = u, d = window.getComputedStyle(c);
      if ((c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && d.overflow != "visible") {
        let h = c.getBoundingClientRect();
        o = Math.max(o, h.left), s = Math.min(s, h.right), a = Math.max(a, h.top), l = Math.min(u == t.parentNode ? r.innerHeight : l, h.bottom);
      }
      u = d.position == "absolute" || d.position == "fixed" ? c.offsetParent : c.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
  return {
    left: o - n.left,
    right: Math.max(o, s) - n.left,
    top: a - (n.top + e),
    bottom: Math.max(a, l) - (n.top + e)
  };
}
function ZJ(t, e) {
  let n = t.getBoundingClientRect();
  return {
    left: 0,
    right: n.right - n.left,
    top: e,
    bottom: n.bottom - (n.top + e)
  };
}
class Wg {
  constructor(e, n, i, r) {
    this.from = e, this.to = n, this.size = i, this.displaySize = r;
  }
  static same(e, n) {
    if (e.length != n.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let r = e[i], o = n[i];
      if (r.from != o.from || r.to != o.to || r.size != o.size)
        return !1;
    }
    return !0;
  }
  draw(e, n) {
    return Ue.replace({
      widget: new FJ(this.displaySize * (n ? e.scaleY : e.scaleX), n)
    }).range(this.from, this.to);
  }
}
class FJ extends mo {
  constructor(e, n) {
    super(), this.size = e, this.vertical = n;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class c_ {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = d_, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Yt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let n = e.facet(g0).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new DJ(n), this.stateDeco = e.facet(od).filter((i) => typeof i != "function"), this.heightMap = ui.empty().applyChanges(this.stateDeco, St.empty, this.heightOracle.setDoc(e.doc), [new nr(0, 0, 0, e.doc.length)]);
    for (let i = 0; i < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); i++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Ue.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: n } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let r = i ? n.head : n.anchor;
      if (!e.some(({ from: o, to: s }) => r >= o && r <= s)) {
        let { from: o, to: s } = this.lineBlockAt(r);
        e.push(new mh(o, s));
      }
    }
    return this.viewports = e.sort((i, r) => i.from - r.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? d_ : new w0(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(ic(e, this.scaler));
    });
  }
  update(e, n = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(od).filter((c) => typeof c != "function");
    let r = e.changedRanges, o = nr.extendWithRanges(r, LJ(i, this.stateDeco, e ? e.changes : Cn.empty(this.state.doc.length))), s = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    l_(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o), (this.heightMap.height != s || su) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (n && (n.range.head < l.from || n.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, n));
    let u = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, e.flags |= this.updateForViewport(), (u || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(DE) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let n = e.contentDOM, i = window.getComputedStyle(n), r = this.heightOracle, o = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? Yt.RTL : Yt.LTR;
    let s = this.heightOracle.mustRefreshForWrapping(o), a = n.getBoundingClientRect(), l = s || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let u = 0, c = 0;
    if (a.width && a.height) {
      let { scaleX: v, scaleY: k } = aE(n, a);
      (v > 5e-3 && Math.abs(this.scaleX - v) > 5e-3 || k > 5e-3 && Math.abs(this.scaleY - k) > 5e-3) && (this.scaleX = v, this.scaleY = k, u |= 8, s = l = !0);
    }
    let d = (parseInt(i.paddingTop) || 0) * this.scaleY, h = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d || this.paddingBottom != h) && (this.paddingTop = d, this.paddingBottom = h, u |= 10), this.editorWidth != e.scrollDOM.clientWidth && (r.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, u |= 8);
    let f = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != f && (this.scrollAnchorHeight = -1, this.scrollTop = f), this.scrolledToBottom = cE(e.scrollDOM);
    let p = (this.printing ? ZJ : BJ)(n, this.paddingTop), m = p.top - this.pixelViewport.top, g = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let O = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (O != this.inView && (this.inView = O, O && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let y = a.width;
    if ((this.contentDOMWidth != y || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, u |= 8), l) {
      let v = e.docView.measureVisibleLineHeights(this.viewport);
      if (r.mustRefreshForHeights(v) && (s = !0), s || r.lineWrapping && Math.abs(y - this.contentDOMWidth) > r.charWidth) {
        let { lineHeight: k, charWidth: w, textHeight: S } = e.docView.measureTextSize();
        s = k > 0 && r.refresh(o, k, w, S, y / w, v), s && (e.docView.minWidth = 0, u |= 8);
      }
      m > 0 && g > 0 ? c = Math.max(m, g) : m < 0 && g < 0 && (c = Math.min(m, g)), l_();
      for (let k of this.viewports) {
        let w = k.from == this.viewport.from ? v : e.docView.measureVisibleLineHeights(k);
        this.heightMap = (s ? ui.empty().applyChanges(this.stateDeco, St.empty, this.heightOracle, [new nr(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(r, 0, s, new QJ(k.from, w));
      }
      su && (u |= 2);
    }
    let b = !this.viewportIsAppropriate(this.viewport, c) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return b && (u & 2 && (u |= this.updateScaler()), this.viewport = this.getViewport(c, this.scrollTarget), u |= this.updateForViewport()), (u & 2 || b) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, e)), u |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), u;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, n) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), r = this.heightMap, o = this.heightOracle, { visibleTop: s, visibleBottom: a } = this, l = new mh(r.lineAt(s - i * 1e3, zt.ByHeight, o, 0, 0).from, r.lineAt(a + (1 - i) * 1e3, zt.ByHeight, o, 0, 0).to);
    if (n) {
      let { head: u } = n.range;
      if (u < l.from || u > l.to) {
        let c = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), d = r.lineAt(u, zt.ByPos, o, 0, 0), h;
        n.y == "center" ? h = (d.top + d.bottom) / 2 - c / 2 : n.y == "start" || n.y == "nearest" && u < l.from ? h = d.top : h = d.bottom - c, l = new mh(r.lineAt(h - 1e3 / 2, zt.ByHeight, o, 0, 0).from, r.lineAt(h + c + 1e3 / 2, zt.ByHeight, o, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, n) {
    let i = n.mapPos(e.from, -1), r = n.mapPos(e.to, 1);
    return new mh(this.heightMap.lineAt(i, zt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(r, zt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: n }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: r } = this.heightMap.lineAt(e, zt.ByPos, this.heightOracle, 0, 0), { bottom: o } = this.heightMap.lineAt(n, zt.ByPos, this.heightOracle, 0, 0), { visibleTop: s, visibleBottom: a } = this;
    return (e == 0 || r <= s - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (n == this.state.doc.length || o >= a + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && r > s - 2 * 1e3 && o < a + 2 * 1e3;
  }
  mapLineGaps(e, n) {
    if (!e.length || n.empty)
      return e;
    let i = [];
    for (let r of e)
      n.touchesRange(r.from, r.to) || i.push(new Wg(n.mapPos(r.from), n.mapPos(r.to), r.size, r.displaySize));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, n) {
    let i = this.heightOracle.lineWrapping, r = i ? 1e4 : 2e3, o = r >> 1, s = r << 1;
    if (this.defaultTextDirection != Yt.LTR && !i)
      return [];
    let a = [], l = (c, d, h, f) => {
      if (d - c < o)
        return;
      let p = this.state.selection.main, m = [p.from];
      p.empty || m.push(p.to);
      for (let O of m)
        if (O > c && O < d) {
          l(c, O - 10, h, f), l(O + 10, d, h, f);
          return;
        }
      let g = WJ(e, (O) => O.from >= h.from && O.to <= h.to && Math.abs(O.from - c) < o && Math.abs(O.to - d) < o && !m.some((y) => O.from < y && O.to > y));
      if (!g) {
        if (d < h.to && n && i && n.visibleRanges.some((b) => b.from <= d && b.to >= d)) {
          let b = n.moveToLineBoundary(ve.cursor(d), !1, !0).head;
          b > c && (d = b);
        }
        let O = this.gapSize(h, c, d, f), y = i || O < 2e6 ? O : 2e6;
        g = new Wg(c, d, O, y);
      }
      a.push(g);
    }, u = (c) => {
      if (c.length < s || c.type != li.Text)
        return;
      let d = qJ(c.from, c.to, this.stateDeco);
      if (d.total < s)
        return;
      let h = this.scrollTarget ? this.scrollTarget.range.head : null, f, p;
      if (i) {
        let m = r / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, O;
        if (h != null) {
          let y = Oh(d, h), b = ((this.visibleBottom - this.visibleTop) / 2 + m) / c.height;
          g = y - b, O = y + b;
        } else
          g = (this.visibleTop - c.top - m) / c.height, O = (this.visibleBottom - c.top + m) / c.height;
        f = gh(d, g), p = gh(d, O);
      } else {
        let m = d.total * this.heightOracle.charWidth, g = r * this.heightOracle.charWidth, O = 0;
        if (m > 2e6)
          for (let w of e)
            w.from >= c.from && w.from < c.to && w.size != w.displaySize && w.from * this.heightOracle.charWidth + O < this.pixelViewport.left && (O = w.size - w.displaySize);
        let y = this.pixelViewport.left + O, b = this.pixelViewport.right + O, v, k;
        if (h != null) {
          let w = Oh(d, h), S = ((b - y) / 2 + g) / m;
          v = w - S, k = w + S;
        } else
          v = (y - g) / m, k = (b + g) / m;
        f = gh(d, v), p = gh(d, k);
      }
      f > c.from && l(c.from, f, c, d), p < c.to && l(p, c.to, c, d);
    };
    for (let c of this.viewportLines)
      Array.isArray(c.type) ? c.type.forEach(u) : u(c);
    return a;
  }
  gapSize(e, n, i, r) {
    let o = Oh(r, i) - Oh(r, n);
    return this.heightOracle.lineWrapping ? e.height * o : r.total * this.heightOracle.charWidth * o;
  }
  updateLineGaps(e) {
    Wg.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = Ue.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let n = [];
    bt.spans(e, this.viewport.from, this.viewport.to, {
      span(r, o) {
        n.push({ from: r, to: o });
      },
      point() {
      }
    }, 20);
    let i = n.length != this.visibleRanges.length || this.visibleRanges.some((r, o) => r.from != n[o].from || r.to != n[o].to);
    return this.visibleRanges = n, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e) || ic(this.heightMap.lineAt(e, zt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((n) => n.top <= e && n.bottom >= e) || ic(this.heightMap.lineAt(this.scaler.fromDOM(e), zt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let n = this.lineBlockAtHeight(e + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return ic(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class mh {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
}
function qJ(t, e, n) {
  let i = [], r = t, o = 0;
  return bt.spans(n, t, e, {
    span() {
    },
    point(s, a) {
      s > r && (i.push({ from: r, to: s }), o += s - r), r = a;
    }
  }, 20), r < e && (i.push({ from: r, to: e }), o += e - r), { total: o, ranges: i };
}
function gh({ total: t, ranges: e }, n) {
  if (n <= 0)
    return e[0].from;
  if (n >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(t * n);
  for (let r = 0; ; r++) {
    let { from: o, to: s } = e[r], a = s - o;
    if (i <= a)
      return o + i;
    i -= a;
  }
}
function Oh(t, e) {
  let n = 0;
  for (let { from: i, to: r } of t.ranges) {
    if (e <= r) {
      n += e - i;
      break;
    }
    n += r - i;
  }
  return n / t.total;
}
function WJ(t, e) {
  for (let n of t)
    if (e(n))
      return n;
}
const d_ = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1,
  eq(t) {
    return t == this;
  }
};
class w0 {
  constructor(e, n, i) {
    let r = 0, o = 0, s = 0;
    this.viewports = i.map(({ from: a, to: l }) => {
      let u = n.lineAt(a, zt.ByPos, e, 0, 0).top, c = n.lineAt(l, zt.ByPos, e, 0, 0).bottom;
      return r += c - u, { from: a, to: l, top: u, bottom: c, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - r) / (n.height - r);
    for (let a of this.viewports)
      a.domTop = s + (a.top - o) * this.scale, s = a.domBottom = a.domTop + (a.bottom - a.top), o = a.bottom;
  }
  toDOM(e) {
    for (let n = 0, i = 0, r = 0; ; n++) {
      let o = n < this.viewports.length ? this.viewports[n] : null;
      if (!o || e < o.top)
        return r + (e - i) * this.scale;
      if (e <= o.bottom)
        return o.domTop + (e - o.top);
      i = o.bottom, r = o.domBottom;
    }
  }
  fromDOM(e) {
    for (let n = 0, i = 0, r = 0; ; n++) {
      let o = n < this.viewports.length ? this.viewports[n] : null;
      if (!o || e < o.domTop)
        return i + (e - r) / this.scale;
      if (e <= o.domBottom)
        return o.top + (e - o.domTop);
      i = o.bottom, r = o.domBottom;
    }
  }
  eq(e) {
    return e instanceof w0 ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((n, i) => n.from == e.viewports[i].from && n.to == e.viewports[i].to) : !1;
  }
}
function ic(t, e) {
  if (e.scale == 1)
    return t;
  let n = e.toDOM(t.top), i = e.toDOM(t.bottom);
  return new jr(t.from, t.length, n, i - n, Array.isArray(t._content) ? t._content.map((r) => ic(r, e)) : t._content);
}
const vh = /* @__PURE__ */ Ze.define({ combine: (t) => t.join(" ") }), ry = /* @__PURE__ */ Ze.define({ combine: (t) => t.indexOf(!0) > -1 }), oy = /* @__PURE__ */ Ns.newName(), JE = /* @__PURE__ */ Ns.newName(), eA = /* @__PURE__ */ Ns.newName(), tA = { "&light": "." + JE, "&dark": "." + eA };
function sy(t, e, n) {
  return new Ns(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (r) => {
        if (r == "&")
          return t;
        if (!n || !n[r])
          throw new RangeError(`Unsupported selector: ${r}`);
        return n[r];
      }) : t + " " + i;
    }
  });
}
const XJ = /* @__PURE__ */ sy("." + oy, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, tA), zJ = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Xg = qe.ie && qe.ie_version <= 11;
class jJ {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new EK(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((n) => {
      for (let i of n)
        this.queue.push(i);
      (qe.ie && qe.ie_version <= 11 || qe.ios && e.composing) && n.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(qe.chrome && qe.chrome_version < 126) && (this.editContext = new HJ(e), e.state.facet(Mo) && (e.contentDOM.editContext = this.editContext.editContext)), Xg && (this.onCharData = (n) => {
      this.queue.push({
        target: n.target,
        type: "characterData",
        oldValue: n.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var n;
      ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, i) => n != e[i]))) {
      this.gapIntersection.disconnect();
      for (let n of e)
        this.gapIntersection.observe(n);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, r = this.selectionRange;
    if (i.state.facet(Mo) ? i.root.activeElement != this.dom : !qh(this.dom, r))
      return;
    let o = r.anchorNode && i.docView.nearest(r.anchorNode);
    if (o && o.ignoreEvent(e)) {
      n || (this.selectionChanged = !1);
      return;
    }
    (qe.ie && qe.ie_version <= 11 || qe.android && qe.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    r.focusNode && Tc(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, n = rd(e.root);
    if (!n)
      return !1;
    let i = qe.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && YJ(this.view, n) || n;
    if (!i || this.selectionRange.eq(i))
      return !1;
    let r = qh(this.dom, i);
    return r && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && RK(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(i), r && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, n) {
    this.selectionRange.set(e.node, e.offset, n.node, n.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, n = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !n && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : n || (n = this.scrollTargets.slice(0, e)), n && n.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = n)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, zJ), Xg && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Xg && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, n) {
    var i;
    if (!this.delayedAndroidKey) {
      let r = () => {
        let o = this.delayedAndroidKey;
        o && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o.force && Tl(this.dom, o.key, o.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(r);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: n,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let n = -1, i = -1, r = !1;
    for (let o of e) {
      let s = this.readMutation(o);
      s && (s.typeOver && (r = !0), n == -1 ? { from: n, to: i } = s : (n = Math.min(s.from, n), i = Math.max(s.to, i)));
    }
    return { from: n, to: i, typeOver: r };
  }
  readChange() {
    let { from: e, to: n, typeOver: i } = this.processRecords(), r = this.selectionChanged && qh(this.dom, this.selectionRange);
    if (e < 0 && !r)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let o = new hJ(this.view, e, n, i);
    return this.view.docView.domChanged = { newSel: o.newSel ? o.newSel.main : null }, o;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let n = this.readChange();
    if (!n)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, r = qE(this.view, n);
    return this.view.state == i && (n.domChanged || n.newSel && !n.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), r;
  }
  readMutation(e) {
    let n = this.view.docView.nearest(e.target);
    if (!n || n.ignoreMutation(e))
      return null;
    if (n.markDirty(e.type == "attributes"), e.type == "attributes" && (n.flags |= 4), e.type == "childList") {
      let i = h_(n, e.previousSibling || e.target.previousSibling, -1), r = h_(n, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? n.posAfter(i) : n.posAtStart,
        to: r ? n.posBefore(r) : n.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(Mo) != e.state.facet(Mo) && (e.view.contentDOM.editContext = e.state.facet(Mo) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, n, i;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let r of this.scrollTargets)
      r.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function h_(t, e, n) {
  for (; e; ) {
    let i = It.get(e);
    if (i && i.parent == t)
      return i;
    let r = e.parentNode;
    e = r != t.dom ? r : n > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function f_(t, e) {
  let n = e.startContainer, i = e.startOffset, r = e.endContainer, o = e.endOffset, s = t.docView.domAtPos(t.state.selection.main.anchor);
  return Tc(s.node, s.offset, r, o) && ([n, i, r, o] = [r, o, n, i]), { anchorNode: n, anchorOffset: i, focusNode: r, focusOffset: o };
}
function YJ(t, e) {
  if (e.getComposedRanges) {
    let r = e.getComposedRanges(t.root)[0];
    if (r)
      return f_(t, r);
  }
  let n = null;
  function i(r) {
    r.preventDefault(), r.stopImmediatePropagation(), n = r.getTargetRanges()[0];
  }
  return t.contentDOM.addEventListener("beforeinput", i, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", i, !0), n ? f_(t, n) : null;
}
class HJ {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let n = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (i) => {
      let { anchor: r } = e.state.selection.main, o = this.toEditorPos(i.updateRangeStart), s = this.toEditorPos(i.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: i.updateRangeStart, editorBase: o, drifted: !1 });
      let a = { from: o, to: s, insert: St.of(i.text.split(`
`)) };
      if (a.from == this.from && r < this.from ? a.from = r : a.to == this.to && r > this.to && (a.to = r), !(a.from == a.to && !a.insert.length)) {
        if (this.pendingContextChange = a, !e.state.readOnly) {
          let l = this.to - this.from + (a.to - a.from + a.insert.length);
          y0(e, a, ve.single(this.toEditorPos(i.selectionStart, l), this.toEditorPos(i.selectionEnd, l)));
        }
        this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state));
      }
    }, this.handlers.characterboundsupdate = (i) => {
      let r = [], o = null;
      for (let s = this.toEditorPos(i.rangeStart), a = this.toEditorPos(i.rangeEnd); s < a; s++) {
        let l = e.coordsForChar(s);
        o = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || o || new DOMRect(), r.push(o);
      }
      n.updateCharacterBounds(i.rangeStart, r);
    }, this.handlers.textformatupdate = (i) => {
      let r = [];
      for (let o of i.getTextFormats()) {
        let s = o.underlineStyle, a = o.underlineThickness;
        if (s != "None" && a != "None") {
          let l = this.toEditorPos(o.rangeStart), u = this.toEditorPos(o.rangeEnd);
          if (l < u) {
            let c = `text-decoration: underline ${s == "Dashed" ? "dashed " : s == "Squiggle" ? "wavy " : ""}${a == "Thin" ? 1 : 2}px`;
            r.push(Ue.mark({ attributes: { style: c } }).range(l, u));
          }
        }
      }
      e.dispatch({ effects: NE.of(Ue.set(r)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: i } = this.composing;
        this.composing = null, i && this.reset(e.state);
      }
    };
    for (let i in this.handlers)
      n.addEventListener(i, this.handlers[i]);
    this.measureReq = { read: (i) => {
      this.editContext.updateControlBounds(i.contentDOM.getBoundingClientRect());
      let r = rd(i.root);
      r && r.rangeCount && this.editContext.updateSelectionBounds(r.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let n = 0, i = !1, r = this.pendingContextChange;
    return e.changes.iterChanges((o, s, a, l, u) => {
      if (i)
        return;
      let c = u.length - (s - o);
      if (r && s >= r.to)
        if (r.from == o && r.to == s && r.insert.eq(u)) {
          r = this.pendingContextChange = null, n += c, this.to += c;
          return;
        } else
          r = null, this.revertPending(e.state);
      if (o += n, s += n, s <= this.from)
        this.from += c, this.to += c;
      else if (o < this.to) {
        if (o < this.from || s > this.to || this.to - this.from + u.length > 3e4) {
          i = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(o), this.toContextPos(s), u.toString()), this.to += c;
      }
      n += c;
    }), r && !i && this.revertPending(e.state), !i;
  }
  update(e) {
    let n = this.pendingContextChange;
    this.composing && (this.composing.drifted || e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || n) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: n } = e.selection.main;
    this.from = Math.max(
      0,
      n - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      n + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let n = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.from + n.insert.length), e.doc.sliceString(n.from, n.to));
  }
  setSelection(e) {
    let { main: n } = e.selection, i = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))), r = this.toContextPos(n.head);
    (this.editContext.selectionStart != i || this.editContext.selectionEnd != r) && this.editContext.updateSelection(i, r);
  }
  rangeIsValid(e) {
    let { head: n } = e.selection.main;
    return !(this.from > 0 && n - this.from < 500 || this.to < e.doc.length && this.to - n < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, n = this.to - this.from) {
    e = Math.min(e, n);
    let i = this.composing;
    return i && i.drifted ? i.editorBase + (e - i.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let n = this.composing;
    return n && n.drifted ? n.contextBase + (e - n.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class Le {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var n;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: i } = e;
    this.dispatchTransactions = e.dispatchTransactions || i && ((r) => r.forEach((o) => i(o, this))) || ((r) => this.update(r)), this.dispatch = this.dispatch.bind(this), this._root = e.root || AK(e.parent) || document, this.viewState = new c_(e.state || ht.create(e)), e.scrollTo && e.scrollTo.is(hh) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(ec).map((r) => new Zg(r));
    for (let r of this.plugins)
      r.update(this);
    this.observer = new jJ(this), this.inputState = new OJ(this), this.inputState.ensureHandlers(this.plugins), this.docView = new XS(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((n = document.fonts) === null || n === void 0) && n.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let n = e.length == 1 && e[0] instanceof Sn ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(n, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = !1, i = !1, r, o = this.state;
    for (let h of e) {
      if (h.startState != o)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      o = h.state;
    }
    if (this.destroyed) {
      this.viewState.state = o;
      return;
    }
    let s = this.hasFocus, a = 0, l = null;
    e.some((h) => h.annotation(HE)) ? (this.inputState.notifiedFocused = s, a = 1) : s != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = s, l = UE(o, s), l || (a = 1));
    let u = this.observer.delayedAndroidKey, c = null;
    if (u ? (this.observer.clearDelayedAndroidKey(), c = this.observer.readChange(), (c && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (c = null)) : this.observer.clear(), o.facet(ht.phrases) != this.state.facet(ht.phrases))
      return this.setState(o);
    r = cp.create(this, o, e), r.flags |= a;
    let d = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let h of e) {
        if (d && (d = d.map(h.changes)), h.scrollIntoView) {
          let { main: f } = h.state.selection;
          d = new $l(f.empty ? f : ve.cursor(f.head, f.head > f.anchor ? -1 : 1));
        }
        for (let f of h.effects)
          f.is(hh) && (d = f.value.clip(this.state));
      }
      this.viewState.update(r, d), this.bidiCache = hp.update(this.bidiCache, r.changes), r.empty || (this.updatePlugins(r), this.inputState.update(r)), n = this.docView.update(r), this.state.facet(tc) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some((h) => h.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (r.startState.facet(vh) != r.state.facet(vh) && (this.viewState.mustMeasureContent = !0), (n || i || d || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !r.empty)
      for (let h of this.state.facet(ey))
        try {
          h(r);
        } catch (f) {
          si(this.state, f, "update listener");
        }
    (l || c) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), c && !qE(this, c) && u.force && Tl(this.contentDOM, u.key, u.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new c_(e), this.plugins = e.facet(ec).map((i) => new Zg(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new XS(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let n = e.startState.facet(ec), i = e.state.facet(ec);
    if (n != i) {
      let r = [];
      for (let o of i) {
        let s = n.indexOf(o);
        if (s < 0)
          r.push(new Zg(o));
        else {
          let a = this.plugins[s];
          a.mustUpdate = e, r.push(a);
        }
      }
      for (let o of this.plugins)
        o.mustUpdate != e && o.destroy(this);
      this.plugins = r, this.pluginMap.clear();
    } else
      for (let r of this.plugins)
        r.mustUpdate = e;
    for (let r = 0; r < this.plugins.length; r++)
      this.plugins[r].update(this);
    n != i && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let n = e.value;
      if (n && n.docViewUpdate)
        try {
          n.docViewUpdate(this);
        } catch (i) {
          si(this.state, i, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let n = null, i = this.scrollDOM, r = i.scrollTop * this.scaleY, { scrollAnchorPos: o, scrollAnchorHeight: s } = this.viewState;
    Math.abs(r - this.viewState.scrollTop) > 1 && (s = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (s < 0)
          if (cE(i))
            o = -1, s = this.viewState.heightMap.height;
          else {
            let f = this.viewState.scrollAnchorAt(r);
            o = f.from, s = f.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let u = [];
        l & 4 || ([this.measureRequests, u] = [u, this.measureRequests]);
        let c = u.map((f) => {
          try {
            return f.read(this);
          } catch (p) {
            return si(this.state, p), p_;
          }
        }), d = cp.create(this, this.state, []), h = !1;
        d.flags |= l, n ? n.flags |= l : n = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), h = this.docView.update(d), h && this.docViewUpdate());
        for (let f = 0; f < u.length; f++)
          if (c[f] != p_)
            try {
              let p = u[f];
              p.write && p.write(c[f], this);
            } catch (p) {
              si(this.state, p);
            }
        if (h && this.docView.updateSelection(!0), !d.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, s = -1;
              continue;
            } else {
              let p = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - s;
              if (p > 1 || p < -1) {
                r = r + p, i.scrollTop = r / this.scaleY, s = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (n && !n.empty)
      for (let a of this.state.facet(ey))
        a(n);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return oy + " " + (this.state.facet(ry) ? eA : JE) + " " + this.state.facet(vh);
  }
  updateAttrs() {
    let e = m_(this, IE, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), n = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Mo) ? "true" : "false",
      class: "cm-content",
      style: `${qe.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (n["aria-readonly"] = "true"), m_(this, g0, n);
    let i = this.observer.ignore(() => {
      let r = Hv(this.contentDOM, this.contentAttrs, n), o = Hv(this.dom, this.editorAttrs, e);
      return r || o;
    });
    return this.editorAttrs = e, this.contentAttrs = n, i;
  }
  showAnnouncements(e) {
    let n = !0;
    for (let i of e)
      for (let r of i.effects)
        if (r.is(Le.announce)) {
          n && (this.announceDOM.textContent = ""), n = !1;
          let o = this.announceDOM.appendChild(document.createElement("div"));
          o.textContent = r.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(tc);
    let e = this.state.facet(Le.cspNonce);
    Ns.mount(this.root, this.styleModules.concat(XJ).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === e.key) {
            this.measureRequests[n] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let n = this.pluginMap.get(e);
    return (n === void 0 || n && n.spec != e) && this.pluginMap.set(e, n = this.plugins.find((i) => i.spec == e) || null), n && n.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, n, i) {
    return qg(this, e, US(this, e, n, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, n) {
    return qg(this, e, US(this, e, n, (i) => lJ(this, e.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, n) {
    let i = this.bidiSpans(e), r = this.textDirectionAt(e.from), o = i[n ? i.length - 1 : 0];
    return ve.cursor(o.side(n, r) + e.from, o.forward(!n, r) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, n, i = !0) {
    return aJ(this, e, n, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, n, i) {
    return qg(this, e, uJ(this, e, n, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, n = 0) {
    return this.docView.posFromDOM(e, n);
  }
  posAtCoords(e, n = !0) {
    return this.readMeasured(), FE(this, e, n);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, n = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, n);
    if (!i || i.left == i.right)
      return i;
    let r = this.state.doc.lineAt(e), o = this.bidiSpans(r), s = o[ws.find(o, e - r.from, -1, n)];
    return Rd(i, s.dir == Yt.LTR == n > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(RE) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > UJ)
      return xE(e.length);
    let n = this.textDirectionAt(e.from), i;
    for (let o of this.bidiCache)
      if (o.from == e.from && o.dir == n && (o.fresh || _E(o.isolates, i = WS(this, e))))
        return o.order;
    i || (i = WS(this, e));
    let r = XK(e.text, n, i);
    return this.bidiCache.push(new hp(e.from, e.to, n, i, !0, r)), r;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || qe.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      lE(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, n = {}) {
    return hh.of(new $l(typeof e == "number" ? ve.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: n } = this.scrollDOM, i = this.viewState.scrollAnchorAt(e);
    return hh.of(new $l(ve.cursor(i.from), "start", "start", i.top - e, n, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return dn.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return dn.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, n) {
    let i = Ns.newName(), r = [vh.of(i), tc.of(sy(`.${i}`, e))];
    return n && n.dark && r.push(ry.of(!0)), r;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Us.lowest(tc.of(sy("." + oy, e, tA)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var n;
    let i = e.querySelector(".cm-content"), r = i && It.get(i) || It.get(e);
    return ((n = r == null ? void 0 : r.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
Le.styleModule = tc;
Le.inputHandler = EE;
Le.clipboardInputFilter = p0;
Le.clipboardOutputFilter = m0;
Le.scrollHandler = QE;
Le.focusChangeEffect = AE;
Le.perLineTextDirection = RE;
Le.exceptionSink = ME;
Le.updateListener = ey;
Le.editable = Mo;
Le.mouseSelectionStyle = PE;
Le.dragMovesSelection = $E;
Le.clickAddsSelectionRange = TE;
Le.decorations = od;
Le.outerDecorations = LE;
Le.atomicRanges = O0;
Le.bidiIsolatedRanges = VE;
Le.scrollMargins = BE;
Le.darkTheme = ry;
Le.cspNonce = /* @__PURE__ */ Ze.define({ combine: (t) => t.length ? t[0] : "" });
Le.contentAttributes = g0;
Le.editorAttributes = IE;
Le.lineWrapping = /* @__PURE__ */ Le.contentAttributes.of({ class: "cm-lineWrapping" });
Le.announce = /* @__PURE__ */ ot.define();
const UJ = 4096, p_ = {};
class hp {
  constructor(e, n, i, r, o, s) {
    this.from = e, this.to = n, this.dir = i, this.isolates = r, this.fresh = o, this.order = s;
  }
  static update(e, n) {
    if (n.empty && !e.some((o) => o.fresh))
      return e;
    let i = [], r = e.length ? e[e.length - 1].dir : Yt.LTR;
    for (let o = Math.max(0, e.length - 10); o < e.length; o++) {
      let s = e[o];
      s.dir == r && !n.touchesRange(s.from, s.to) && i.push(new hp(n.mapPos(s.from, 1), n.mapPos(s.to, -1), s.dir, s.isolates, !1, s.order));
    }
    return i;
  }
}
function m_(t, e, n) {
  for (let i = t.state.facet(e), r = i.length - 1; r >= 0; r--) {
    let o = i[r], s = typeof o == "function" ? o(t) : o;
    s && Yv(s, n);
  }
  return n;
}
const GJ = qe.mac ? "mac" : qe.windows ? "win" : qe.linux ? "linux" : "key";
function KJ(t, e) {
  const n = t.split(/-(?!$)/);
  let i = n[n.length - 1];
  i == "Space" && (i = " ");
  let r, o, s, a;
  for (let l = 0; l < n.length - 1; ++l) {
    const u = n[l];
    if (/^(cmd|meta|m)$/i.test(u))
      a = !0;
    else if (/^a(lt)?$/i.test(u))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      o = !0;
    else if (/^s(hift)?$/i.test(u))
      s = !0;
    else if (/^mod$/i.test(u))
      e == "mac" ? a = !0 : o = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return r && (i = "Alt-" + i), o && (i = "Ctrl-" + i), a && (i = "Meta-" + i), s && (i = "Shift-" + i), i;
}
function yh(t, e, n) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const JJ = /* @__PURE__ */ Us.default(/* @__PURE__ */ Le.domEventHandlers({
  keydown(t, e) {
    return iA(nA(e.state), t, e, "editor");
  }
})), ku = /* @__PURE__ */ Ze.define({ enables: JJ }), g_ = /* @__PURE__ */ new WeakMap();
function nA(t) {
  let e = t.facet(ku), n = g_.get(e);
  return n || g_.set(e, n = nee(e.reduce((i, r) => i.concat(r), []))), n;
}
function eee(t, e, n) {
  return iA(nA(t.state), e, t, n);
}
let hs = null;
const tee = 4e3;
function nee(t, e = GJ) {
  let n = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), r = (s, a) => {
    let l = i[s];
    if (l == null)
      i[s] = a;
    else if (l != a)
      throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix");
  }, o = (s, a, l, u, c) => {
    var d, h;
    let f = n[s] || (n[s] = /* @__PURE__ */ Object.create(null)), p = a.split(/ (?!$)/).map((O) => KJ(O, e));
    for (let O = 1; O < p.length; O++) {
      let y = p.slice(0, O).join(" ");
      r(y, !0), f[y] || (f[y] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(b) => {
          let v = hs = { view: b, prefix: y, scope: s };
          return setTimeout(() => {
            hs == v && (hs = null);
          }, tee), !0;
        }]
      });
    }
    let m = p.join(" ");
    r(m, !1);
    let g = f[m] || (f[m] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((h = (d = f._any) === null || d === void 0 ? void 0 : d.run) === null || h === void 0 ? void 0 : h.slice()) || []
    });
    l && g.run.push(l), u && (g.preventDefault = !0), c && (g.stopPropagation = !0);
  };
  for (let s of t) {
    let a = s.scope ? s.scope.split(" ") : ["editor"];
    if (s.any)
      for (let u of a) {
        let c = n[u] || (n[u] = /* @__PURE__ */ Object.create(null));
        c._any || (c._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: d } = s;
        for (let h in c)
          c[h].run.push((f) => d(f, ay));
      }
    let l = s[e] || s.key;
    if (l)
      for (let u of a)
        o(u, l, s.run, s.preventDefault, s.stopPropagation), s.shift && o(u, "Shift-" + l, s.shift, s.preventDefault, s.stopPropagation);
  }
  return n;
}
let ay = null;
function iA(t, e, n, i) {
  ay = e;
  let r = AP(e), o = bi(r, 0), s = zr(o) == r.length && r != " ", a = "", l = !1, u = !1, c = !1;
  hs && hs.view == n && hs.scope == i && (a = hs.prefix + " ", XE.indexOf(e.keyCode) < 0 && (u = !0, hs = null));
  let d = /* @__PURE__ */ new Set(), h = (g) => {
    if (g) {
      for (let O of g.run)
        if (!d.has(O) && (d.add(O), O(n)))
          return g.stopPropagation && (c = !0), !0;
      g.preventDefault && (g.stopPropagation && (c = !0), u = !0);
    }
    return !1;
  }, f = t[i], p, m;
  return f && (h(f[a + yh(r, e, !s)]) ? l = !0 : s && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(qe.windows && e.ctrlKey && e.altKey) && (p = Fo[e.keyCode]) && p != r ? (h(f[a + yh(p, e, !0)]) || e.shiftKey && (m = zc[e.keyCode]) != r && m != p && h(f[a + yh(m, e, !1)])) && (l = !0) : s && e.shiftKey && h(f[a + yh(r, e, !0)]) && (l = !0), !l && h(f._any) && (l = !0)), u && (l = !0), l && c && e.stopPropagation(), ay = null, l;
}
class Nd {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, n, i, r, o) {
    this.className = e, this.left = n, this.top = i, this.width = r, this.height = o;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, n) {
    return n.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, n, i) {
    if (i.empty) {
      let r = e.coordsAtPos(i.head, i.assoc || 1);
      if (!r)
        return [];
      let o = rA(e);
      return [new Nd(n, r.left - o.left, r.top - o.top, null, r.bottom - r.top)];
    } else
      return iee(e, n, i);
  }
}
function rA(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == Yt.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function O_(t, e, n, i) {
  let r = t.coordsAtPos(e, n * 2);
  if (!r)
    return i;
  let o = t.dom.getBoundingClientRect(), s = (r.top + r.bottom) / 2, a = t.posAtCoords({ x: o.left + 1, y: s }), l = t.posAtCoords({ x: o.right - 1, y: s });
  return a == null || l == null ? i : { from: Math.max(i.from, Math.min(a, l)), to: Math.min(i.to, Math.max(a, l)) };
}
function iee(t, e, n) {
  if (n.to <= t.viewport.from || n.from >= t.viewport.to)
    return [];
  let i = Math.max(n.from, t.viewport.from), r = Math.min(n.to, t.viewport.to), o = t.textDirection == Yt.LTR, s = t.contentDOM, a = s.getBoundingClientRect(), l = rA(t), u = s.querySelector(".cm-line"), c = u && window.getComputedStyle(u), d = a.left + (c ? parseInt(c.paddingLeft) + Math.min(0, parseInt(c.textIndent)) : 0), h = a.right - (c ? parseInt(c.paddingRight) : 0), f = ny(t, i), p = ny(t, r), m = f.type == li.Text ? f : null, g = p.type == li.Text ? p : null;
  if (m && (t.lineWrapping || f.widgetLineBreaks) && (m = O_(t, i, 1, m)), g && (t.lineWrapping || p.widgetLineBreaks) && (g = O_(t, r, -1, g)), m && g && m.from == g.from && m.to == g.to)
    return y(b(n.from, n.to, m));
  {
    let k = m ? b(n.from, null, m) : v(f, !1), w = g ? b(null, n.to, g) : v(p, !0), S = [];
    return (m || f).to < (g || p).from - (m && g ? 1 : 0) || f.widgetLineBreaks > 1 && k.bottom + t.defaultLineHeight / 2 < w.top ? S.push(O(d, k.bottom, h, w.top)) : k.bottom < w.top && t.elementAtHeight((k.bottom + w.top) / 2).type == li.Text && (k.bottom = w.top = (k.bottom + w.top) / 2), y(k).concat(S).concat(y(w));
  }
  function O(k, w, S, $) {
    return new Nd(
      e,
      k - l.left,
      w - l.top - 0.01,
      S - k,
      $ - w + 0.01
      /* C.Epsilon */
    );
  }
  function y({ top: k, bottom: w, horizontal: S }) {
    let $ = [];
    for (let C = 0; C < S.length; C += 2)
      $.push(O(S[C], k, S[C + 1], w));
    return $;
  }
  function b(k, w, S) {
    let $ = 1e9, C = -1e9, L = [];
    function j(T, N, Q, Y, V) {
      let q = t.coordsAtPos(T, T == S.to ? -2 : 2), B = t.coordsAtPos(Q, Q == S.from ? 2 : -2);
      !q || !B || ($ = Math.min(q.top, B.top, $), C = Math.max(q.bottom, B.bottom, C), V == Yt.LTR ? L.push(o && N ? d : q.left, o && Y ? h : B.right) : L.push(!o && Y ? d : B.left, !o && N ? h : q.right));
    }
    let P = k ?? S.from, A = w ?? S.to;
    for (let T of t.visibleRanges)
      if (T.to > P && T.from < A)
        for (let N = Math.max(T.from, P), Q = Math.min(T.to, A); ; ) {
          let Y = t.state.doc.lineAt(N);
          for (let V of t.bidiSpans(Y)) {
            let q = V.from + Y.from, B = V.to + Y.from;
            if (q >= Q)
              break;
            B > N && j(Math.max(q, N), k == null && q <= P, Math.min(B, Q), w == null && B >= A, V.dir);
          }
          if (N = Y.to + 1, N >= Q)
            break;
        }
    return L.length == 0 && j(P, k == null, A, w == null, t.textDirection), { top: $, bottom: C, horizontal: L };
  }
  function v(k, w) {
    let S = a.top + (w ? k.top : k.bottom);
    return { top: S, bottom: S, horizontal: [] };
  }
}
function ree(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class oee {
  constructor(e, n) {
    this.view = e, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(jh) != e.state.facet(jh) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let n = 0, i = e.facet(jh);
    for (; n < i.length && i[n] != this.layer; )
      n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: n } = this.view;
    (e != this.scaleX || n != this.scaleY) && (this.scaleX = e, this.scaleY = n, this.dom.style.transform = `scale(${1 / e}, ${1 / n})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((n, i) => !ree(n, this.drawn[i]))) {
      let n = this.dom.firstChild, i = 0;
      for (let r of e)
        r.update && n && r.constructor && this.drawn[i].constructor && r.update(n, this.drawn[i]) ? (n = n.nextSibling, i++) : this.dom.insertBefore(r.draw(), n);
      for (; n; ) {
        let r = n.nextSibling;
        n.remove(), n = r;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const jh = /* @__PURE__ */ Ze.define();
function oA(t) {
  return [
    dn.define((e) => new oee(e, t)),
    jh.of(t)
  ];
}
const sA = !(qe.ios && qe.webkit && qe.webkit_version < 534), sd = /* @__PURE__ */ Ze.define({
  combine(t) {
    return Er(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, n) => Math.min(e, n),
      drawRangeCursor: (e, n) => e || n
    });
  }
});
function aA(t = {}) {
  return [
    sd.of(t),
    see,
    aee,
    lee,
    DE.of(!0)
  ];
}
function lA(t) {
  return t.startState.facet(sd) != t.state.facet(sd);
}
const see = /* @__PURE__ */ oA({
  above: !0,
  markers(t) {
    let { state: e } = t, n = e.facet(sd), i = [];
    for (let r of e.selection.ranges) {
      let o = r == e.selection.main;
      if (r.empty ? !o || sA : n.drawRangeCursor) {
        let s = o ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = r.empty ? r : ve.cursor(r.head, r.head > r.anchor ? -1 : 1);
        for (let l of Nd.forRange(t, s, a))
          i.push(l);
      }
    }
    return i;
  },
  update(t, e) {
    t.transactions.some((i) => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let n = lA(t);
    return n && v_(t.state, e), t.docChanged || t.selectionSet || n;
  },
  mount(t, e) {
    v_(e.state, t);
  },
  class: "cm-cursorLayer"
});
function v_(t, e) {
  e.style.animationDuration = t.facet(sd).cursorBlinkRate + "ms";
}
const aee = /* @__PURE__ */ oA({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : Nd.forRange(t, "cm-selectionBackground", e)).reduce((e, n) => e.concat(n));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || lA(t);
  },
  class: "cm-selectionLayer"
}), ly = {
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" }
  },
  ".cm-content": {
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
};
sA && (ly[".cm-line"].caretColor = ly[".cm-content"].caretColor = "transparent !important");
const lee = /* @__PURE__ */ Us.highest(/* @__PURE__ */ Le.theme(ly)), uA = /* @__PURE__ */ ot.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), rc = /* @__PURE__ */ xn.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((n, i) => i.is(uA) ? i.value : n, t);
  }
}), uee = /* @__PURE__ */ dn.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let n = t.state.field(rc);
    n == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(rc) != n || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(rc), n = e != null && t.coordsAtPos(e);
    if (!n)
      return null;
    let i = t.scrollDOM.getBoundingClientRect();
    return {
      left: n.left - i.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: n.top - i.top + t.scrollDOM.scrollTop * t.scaleY,
      height: n.bottom - n.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: n } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / n + "px", this.cursor.style.height = t.height / n + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(rc) != t && this.view.dispatch({ effects: uA.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function cee() {
  return [rc, uee];
}
function y_(t, e, n, i, r) {
  e.lastIndex = 0;
  for (let o = t.iterRange(n, i), s = n, a; !o.next().done; s += o.value.length)
    if (!o.lineBreak)
      for (; a = e.exec(o.value); )
        r(s + a.index, a);
}
function dee(t, e) {
  let n = t.visibleRanges;
  if (n.length == 1 && n[0].from == t.viewport.from && n[0].to == t.viewport.to)
    return n;
  let i = [];
  for (let { from: r, to: o } of n)
    r = Math.max(t.state.doc.lineAt(r).from, r - e), o = Math.min(t.state.doc.lineAt(o).to, o + e), i.length && i[i.length - 1].to >= r ? i[i.length - 1].to = o : i.push({ from: r, to: o });
  return i;
}
class hee {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: n, decoration: i, decorate: r, boundary: o, maxLength: s = 1e3 } = e;
    if (!n.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = n, r)
      this.addMatch = (a, l, u, c) => r(c, u, u + a[0].length, a, l);
    else if (typeof i == "function")
      this.addMatch = (a, l, u, c) => {
        let d = i(a, l, u);
        d && c(u, u + a[0].length, d);
      };
    else if (i)
      this.addMatch = (a, l, u, c) => c(u, u + a[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = o, this.maxLength = s;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let n = new Wo(), i = n.add.bind(n);
    for (let { from: r, to: o } of dee(e, this.maxLength))
      y_(e.state.doc, this.regexp, r, o, (s, a) => this.addMatch(a, e, s, i));
    return n.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, n) {
    let i = 1e9, r = -1;
    return e.docChanged && e.changes.iterChanges((o, s, a, l) => {
      l > e.view.viewport.from && a < e.view.viewport.to && (i = Math.min(a, i), r = Math.max(l, r));
    }), e.viewportChanged || r - i > 1e3 ? this.createDeco(e.view) : r > -1 ? this.updateRange(e.view, n.map(e.changes), i, r) : n;
  }
  updateRange(e, n, i, r) {
    for (let o of e.visibleRanges) {
      let s = Math.max(o.from, i), a = Math.min(o.to, r);
      if (a > s) {
        let l = e.state.doc.lineAt(s), u = l.to < a ? e.state.doc.lineAt(a) : l, c = Math.max(o.from, l.from), d = Math.min(o.to, u.to);
        if (this.boundary) {
          for (; s > l.from; s--)
            if (this.boundary.test(l.text[s - 1 - l.from])) {
              c = s;
              break;
            }
          for (; a < u.to; a++)
            if (this.boundary.test(u.text[a - u.from])) {
              d = a;
              break;
            }
        }
        let h = [], f, p = (m, g, O) => h.push(O.range(m, g));
        if (l == u)
          for (this.regexp.lastIndex = c - l.from; (f = this.regexp.exec(l.text)) && f.index < d - l.from; )
            this.addMatch(f, e, f.index + l.from, p);
        else
          y_(e.state.doc, this.regexp, c, d, (m, g) => this.addMatch(g, e, m, p));
        n = n.update({ filterFrom: c, filterTo: d, filter: (m, g) => m < c || g > d, add: h });
      }
    }
    return n;
  }
}
const uy = /x/.unicode != null ? "gu" : "g", fee = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, uy), pee = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let zg = null;
function mee() {
  var t;
  if (zg == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    zg = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return zg || !1;
}
const Yh = /* @__PURE__ */ Ze.define({
  combine(t) {
    let e = Er(t, {
      render: null,
      specialChars: fee,
      addSpecialChars: null
    });
    return (e.replaceTabs = !mee()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, uy)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, uy)), e;
  }
});
function cA(t = {}) {
  return [Yh.of(t), gee()];
}
let b_ = null;
function gee() {
  return b_ || (b_ = dn.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = Ue.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(Yh)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new hee({
        regexp: t.specialChars,
        decoration: (e, n, i) => {
          let { doc: r } = n.state, o = bi(e[0], 0);
          if (o == 9) {
            let s = r.lineAt(i), a = n.state.tabSize, l = wu(s.text, a, i - s.from);
            return Ue.replace({
              widget: new bee((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[o] || (this.decorationCache[o] = Ue.replace({ widget: new yee(t, o) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(Yh);
      t.startState.facet(Yh) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const Oee = "•";
function vee(t) {
  return t >= 32 ? Oee : t == 10 ? "␤" : String.fromCharCode(9216 + t);
}
class yee extends mo {
  constructor(e, n) {
    super(), this.options = e, this.code = n;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let n = vee(this.code), i = e.state.phrase("Control character") + " " + (pee[this.code] || "0x" + this.code.toString(16)), r = this.options.render && this.options.render(this.code, i, n);
    if (r)
      return r;
    let o = document.createElement("span");
    return o.textContent = n, o.title = i, o.setAttribute("aria-label", i), o.className = "cm-specialChar", o;
  }
  ignoreEvent() {
    return !1;
  }
}
class bee extends mo {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function wee() {
  return See;
}
const kee = /* @__PURE__ */ Ue.line({ class: "cm-activeLine" }), See = /* @__PURE__ */ dn.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, n = [];
    for (let i of t.state.selection.ranges) {
      let r = t.lineBlockAt(i.head);
      r.from > e && (n.push(kee.range(r.from)), e = r.from);
    }
    return Ue.set(n);
  }
}, {
  decorations: (t) => t.decorations
});
class _ee extends mo {
  constructor(e) {
    super(), this.content = e;
  }
  toDOM(e) {
    let n = document.createElement("span");
    return n.className = "cm-placeholder", n.style.pointerEvents = "none", n.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(e) : this.content.cloneNode(!0)), typeof this.content == "string" ? n.setAttribute("aria-label", "placeholder " + this.content) : n.setAttribute("aria-hidden", "true"), n;
  }
  coordsAt(e) {
    let n = e.firstChild ? iu(e.firstChild) : [];
    if (!n.length)
      return null;
    let i = window.getComputedStyle(e.parentNode), r = Rd(n[0], i.direction != "rtl"), o = parseInt(i.lineHeight);
    return r.bottom - r.top > o * 1.5 ? { left: r.left, right: r.right, top: r.top, bottom: r.top + o } : r;
  }
  ignoreEvent() {
    return !1;
  }
}
function xee(t) {
  return dn.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = t ? Ue.set([Ue.widget({ widget: new _ee(t), side: 1 }).range(0)]) : Ue.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Ue.none : this.placeholder;
    }
  }, { decorations: (e) => e.decorations });
}
const cy = 2e3;
function Cee(t, e, n) {
  let i = Math.min(e.line, n.line), r = Math.max(e.line, n.line), o = [];
  if (e.off > cy || n.off > cy || e.col < 0 || n.col < 0) {
    let s = Math.min(e.off, n.off), a = Math.max(e.off, n.off);
    for (let l = i; l <= r; l++) {
      let u = t.doc.line(l);
      u.length <= a && o.push(ve.range(u.from + s, u.to + a));
    }
  } else {
    let s = Math.min(e.col, n.col), a = Math.max(e.col, n.col);
    for (let l = i; l <= r; l++) {
      let u = t.doc.line(l), c = Zv(u.text, s, t.tabSize, !0);
      if (c < 0)
        o.push(ve.cursor(u.to));
      else {
        let d = Zv(u.text, a, t.tabSize);
        o.push(ve.range(u.from + c, u.from + d));
      }
    }
  }
  return o;
}
function Tee(t, e) {
  let n = t.coordsAtPos(t.viewport.from);
  return n ? Math.round(Math.abs((n.left - e) / t.defaultCharacterWidth)) : -1;
}
function w_(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = t.state.doc.lineAt(n), r = n - i.from, o = r > cy ? -1 : r == i.length ? Tee(t, e.clientX) : wu(i.text, t.state.tabSize, n - i.from);
  return { line: i.number, col: o, off: r };
}
function $ee(t, e) {
  let n = w_(t, e), i = t.state.selection;
  return n ? {
    update(r) {
      if (r.docChanged) {
        let o = r.changes.mapPos(r.startState.doc.line(n.line).from), s = r.state.doc.lineAt(o);
        n = { line: s.number, col: n.col, off: Math.min(n.off, s.length) }, i = i.map(r.changes);
      }
    },
    get(r, o, s) {
      let a = w_(t, r);
      if (!a)
        return i;
      let l = Cee(t.state, n, a);
      return l.length ? s ? ve.create(l.concat(i.ranges)) : ve.create(l) : i;
    }
  } : null;
}
function Pee(t) {
  let e = (t == null ? void 0 : t.eventFilter) || ((n) => n.altKey && n.button == 0);
  return Le.mouseSelectionStyle.of((n, i) => e(i) ? $ee(n, i) : null);
}
const Mee = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, Eee = { style: "cursor: crosshair" };
function Aee(t = {}) {
  let [e, n] = Mee[t.key || "Alt"], i = dn.fromClass(class {
    constructor(r) {
      this.view = r, this.isDown = !1;
    }
    set(r) {
      this.isDown != r && (this.isDown = r, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(r) {
        this.set(r.keyCode == e || n(r));
      },
      keyup(r) {
        (r.keyCode == e || !n(r)) && this.set(!1);
      },
      mousemove(r) {
        this.set(n(r));
      }
    }
  });
  return [
    i,
    Le.contentAttributes.of((r) => {
      var o;
      return !((o = r.plugin(i)) === null || o === void 0) && o.isDown ? Eee : null;
    })
  ];
}
const Bu = "-10000px";
class dA {
  constructor(e, n, i, r) {
    this.facet = n, this.createTooltipView = i, this.removeTooltipView = r, this.input = e.state.facet(n), this.tooltips = this.input.filter((s) => s);
    let o = null;
    this.tooltipViews = this.tooltips.map((s) => o = i(s, o));
  }
  update(e, n) {
    var i;
    let r = e.state.facet(this.facet), o = r.filter((l) => l);
    if (r === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let s = [], a = n ? [] : null;
    for (let l = 0; l < o.length; l++) {
      let u = o[l], c = -1;
      if (u) {
        for (let d = 0; d < this.tooltips.length; d++) {
          let h = this.tooltips[d];
          h && h.create == u.create && (c = d);
        }
        if (c < 0)
          s[l] = this.createTooltipView(u, l ? s[l - 1] : null), a && (a[l] = !!u.above);
        else {
          let d = s[l] = this.tooltipViews[c];
          a && (a[l] = n[c]), d.update && d.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      s.indexOf(l) < 0 && (this.removeTooltipView(l), (i = l.destroy) === null || i === void 0 || i.call(l));
    return n && (a.forEach((l, u) => n[u] = l), n.length = a.length), this.input = r, this.tooltips = o, this.tooltipViews = s, !0;
  }
}
function Ree(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const jg = /* @__PURE__ */ Ze.define({
  combine: (t) => {
    var e, n, i;
    return {
      position: qe.ios ? "absolute" : ((e = t.find((r) => r.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((n = t.find((r) => r.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
      tooltipSpace: ((i = t.find((r) => r.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || Ree
    };
  }
}), k_ = /* @__PURE__ */ new WeakMap(), k0 = /* @__PURE__ */ dn.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(jg);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new dA(t, _m, (n, i) => this.createTooltip(n, i), (n) => {
      this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
    }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
      Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let n = e || t.geometryChanged, i = t.state.facet(jg);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let r of this.manager.tooltipViews)
        r.dom.style.position = this.position;
      n = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let r of this.manager.tooltipViews)
        this.container.appendChild(r.dom);
      n = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    n && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let n = t.create(this.view), i = e ? e.dom : null;
    if (n.dom.classList.add("cm-tooltip"), t.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let r = document.createElement("div");
      r.className = "cm-tooltip-arrow", n.dom.appendChild(r);
    }
    return n.dom.style.position = this.position, n.dom.style.top = Bu, n.dom.style.left = "0px", this.container.insertBefore(n.dom, i), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;
  }
  destroy() {
    var t, e, n;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (t = i.destroy) === null || t === void 0 || t.call(i);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = 1, e = 1, n = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: o } = this.manager.tooltipViews[0];
      if (qe.gecko)
        n = o.offsetParent != this.container.ownerDocument.body;
      else if (o.style.top == Bu && o.style.left == "0px") {
        let s = o.getBoundingClientRect();
        n = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (n || this.position == "absolute")
      if (this.parent) {
        let o = this.parent.getBoundingClientRect();
        o.width && o.height && (t = o.width / this.parent.offsetWidth, e = o.height / this.parent.offsetHeight);
      } else
        ({ scaleX: t, scaleY: e } = this.view.viewState);
    let i = this.view.scrollDOM.getBoundingClientRect(), r = v0(this.view);
    return {
      visible: {
        left: i.left + r.left,
        top: i.top + r.top,
        right: i.right - r.right,
        bottom: i.bottom - r.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((o, s) => {
        let a = this.manager.tooltipViews[s];
        return a.getCoords ? a.getCoords(o.pos) : this.view.coordsAtPos(o.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: o }) => o.getBoundingClientRect()),
      space: this.view.state.facet(jg).tooltipSpace(this.view),
      scaleX: t,
      scaleY: e,
      makeAbsolute: n
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { visible: n, space: i, scaleX: r, scaleY: o } = t, s = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], u = this.manager.tooltipViews[a], { dom: c } = u, d = t.pos[a], h = t.size[a];
      if (!d || l.clip !== !1 && (d.bottom <= Math.max(n.top, i.top) || d.top >= Math.min(n.bottom, i.bottom) || d.right < Math.max(n.left, i.left) - 0.1 || d.left > Math.min(n.right, i.right) + 0.1)) {
        c.style.top = Bu;
        continue;
      }
      let f = l.arrow ? u.dom.querySelector(".cm-tooltip-arrow") : null, p = f ? 7 : 0, m = h.right - h.left, g = (e = k_.get(u)) !== null && e !== void 0 ? e : h.bottom - h.top, O = u.offset || Qee, y = this.view.textDirection == Yt.LTR, b = h.width > i.right - i.left ? y ? i.left : i.right - h.width : y ? Math.max(i.left, Math.min(d.left - (f ? 14 : 0) + O.x, i.right - m)) : Math.min(Math.max(i.left, d.left - m + (f ? 14 : 0) - O.x), i.right - m), v = this.above[a];
      !l.strictSide && (v ? d.top - g - p - O.y < i.top : d.bottom + g + p + O.y > i.bottom) && v == i.bottom - d.bottom > d.top - i.top && (v = this.above[a] = !v);
      let k = (v ? d.top - i.top : i.bottom - d.bottom) - p;
      if (k < g && u.resize !== !1) {
        if (k < this.view.defaultLineHeight) {
          c.style.top = Bu;
          continue;
        }
        k_.set(u, g), c.style.height = (g = k) / o + "px";
      } else
        c.style.height && (c.style.height = "");
      let w = v ? d.top - g - p - O.y : d.bottom + p + O.y, S = b + m;
      if (u.overlap !== !0)
        for (let $ of s)
          $.left < S && $.right > b && $.top < w + g && $.bottom > w && (w = v ? $.top - g - 2 - p : $.bottom + p + 2);
      if (this.position == "absolute" ? (c.style.top = (w - t.parent.top) / o + "px", S_(c, (b - t.parent.left) / r)) : (c.style.top = w / o + "px", S_(c, b / r)), f) {
        let $ = d.left + (y ? O.x : -O.x) - (b + 14 - 7);
        f.style.left = $ / r + "px";
      }
      u.overlap !== !0 && s.push({ left: b, top: w, right: S, bottom: w + g }), c.classList.toggle("cm-tooltip-above", v), c.classList.toggle("cm-tooltip-below", !v), u.positioned && u.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = Bu;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function S_(t, e) {
  let n = parseInt(t.style.left, 10);
  (isNaN(n) || Math.abs(e - n) > 1) && (t.style.left = e + "px");
}
const Dee = /* @__PURE__ */ Le.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), Qee = { x: 0, y: 0 }, _m = /* @__PURE__ */ Ze.define({
  enables: [k0, Dee]
}), fp = /* @__PURE__ */ Ze.define({
  combine: (t) => t.reduce((e, n) => e.concat(n), [])
});
class xm {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new xm(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new dA(e, fp, (n, i) => this.createHostedView(n, i), (n) => n.dom.remove());
  }
  createHostedView(e, n) {
    let i = e.create(this.view);
    return i.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(i.dom, n ? n.dom.nextSibling : this.dom.firstChild), this.mounted && i.mount && i.mount(this.view), i;
  }
  mount(e) {
    for (let n of this.manager.tooltipViews)
      n.mount && n.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let n of this.manager.tooltipViews)
      n.positioned && n.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let n of this.manager.tooltipViews)
      (e = n.destroy) === null || e === void 0 || e.call(n);
  }
  passProp(e) {
    let n;
    for (let i of this.manager.tooltipViews) {
      let r = i[e];
      if (r !== void 0) {
        if (n === void 0)
          n = r;
        else if (n !== r)
          return;
      }
    }
    return n;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const Nee = /* @__PURE__ */ _m.compute([fp], (t) => {
  let e = t.facet(fp);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((n) => n.pos)),
    end: Math.max(...e.map((n) => {
      var i;
      return (i = n.end) !== null && i !== void 0 ? i : n.pos;
    })),
    create: xm.create,
    above: e[0].above,
    arrow: e.some((n) => n.arrow)
  };
});
class Iee {
  constructor(e, n, i, r, o) {
    this.view = e, this.source = n, this.field = i, this.setHover = r, this.hoverTime = o, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: n } = this, i = e.docView.nearest(n.target);
    if (!i)
      return;
    let r, o = 1;
    if (i instanceof bs)
      r = i.posAtStart;
    else {
      if (r = e.posAtCoords(n), r == null)
        return;
      let a = e.coordsAtPos(r);
      if (!a || n.y < a.top || n.y > a.bottom || n.x < a.left - e.defaultCharacterWidth || n.x > a.right + e.defaultCharacterWidth)
        return;
      let l = e.bidiSpans(e.state.doc.lineAt(r)).find((c) => c.from <= r && c.to >= r), u = l && l.dir == Yt.RTL ? -1 : 1;
      o = n.x < a.left ? -u : u;
    }
    let s = this.source(e, r, o);
    if (s != null && s.then) {
      let a = this.pending = { pos: r };
      s.then((l) => {
        this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => si(e.state, l, "hover tooltip"));
    } else
      s && !(Array.isArray(s) && !s.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(s) ? s : [s]) });
  }
  get tooltip() {
    let e = this.view.plugin(k0), n = e ? e.manager.tooltips.findIndex((i) => i.create == xm.create) : -1;
    return n > -1 ? e.manager.tooltipViews[n] : null;
  }
  mousemove(e) {
    var n, i;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: r, tooltip: o } = this;
    if (r.length && o && !Lee(o.dom, e) || this.pending) {
      let { pos: s } = r[0] || this.pending, a = (i = (n = r[0]) === null || n === void 0 ? void 0 : n.end) !== null && i !== void 0 ? i : s;
      (s == a ? this.view.posAtCoords(this.lastMove) != s : !Vee(this.view, s, a, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: n } = this;
    if (n.length) {
      let { tooltip: i } = this;
      i && i.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(i.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let n = (i) => {
      e.removeEventListener("mouseleave", n), this.active.length && !this.view.dom.contains(i.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", n);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const bh = 4;
function Lee(t, e) {
  let { left: n, right: i, top: r, bottom: o } = t.getBoundingClientRect(), s;
  if (s = t.querySelector(".cm-tooltip-arrow")) {
    let a = s.getBoundingClientRect();
    r = Math.min(a.top, r), o = Math.max(a.bottom, o);
  }
  return e.clientX >= n - bh && e.clientX <= i + bh && e.clientY >= r - bh && e.clientY <= o + bh;
}
function Vee(t, e, n, i, r, o) {
  let s = t.scrollDOM.getBoundingClientRect(), a = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (s.left > i || s.right < i || s.top > r || Math.min(s.bottom, a) < r)
    return !1;
  let l = t.posAtCoords({ x: i, y: r }, !1);
  return l >= e && l <= n;
}
function Bee(t, e = {}) {
  let n = ot.define(), i = xn.define({
    create() {
      return [];
    },
    update(r, o) {
      if (r.length && (e.hideOnChange && (o.docChanged || o.selection) ? r = [] : e.hideOn && (r = r.filter((s) => !e.hideOn(o, s))), o.docChanged)) {
        let s = [];
        for (let a of r) {
          let l = o.changes.mapPos(a.pos, -1, Bn.TrackDel);
          if (l != null) {
            let u = Object.assign(/* @__PURE__ */ Object.create(null), a);
            u.pos = l, u.end != null && (u.end = o.changes.mapPos(u.end)), s.push(u);
          }
        }
        r = s;
      }
      for (let s of o.effects)
        s.is(n) && (r = s.value), s.is(Zee) && (r = []);
      return r;
    },
    provide: (r) => fp.from(r)
  });
  return {
    active: i,
    extension: [
      i,
      dn.define((r) => new Iee(
        r,
        t,
        i,
        n,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      Nee
    ]
  };
}
function hA(t, e) {
  let n = t.plugin(k0);
  if (!n)
    return null;
  let i = n.manager.tooltips.indexOf(e);
  return i < 0 ? null : n.manager.tooltipViews[i];
}
const Zee = /* @__PURE__ */ ot.define(), __ = /* @__PURE__ */ Ze.define({
  combine(t) {
    let e, n;
    for (let i of t)
      e = e || i.topContainer, n = n || i.bottomContainer;
    return { topContainer: e, bottomContainer: n };
  }
});
function ad(t, e) {
  let n = t.plugin(fA), i = n ? n.specs.indexOf(e) : -1;
  return i > -1 ? n.panels[i] : null;
}
const fA = /* @__PURE__ */ dn.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(ld), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(t));
    let e = t.state.facet(__);
    this.top = new wh(t, !0, e.topContainer), this.bottom = new wh(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
    for (let n of this.panels)
      n.dom.classList.add("cm-panel"), n.mount && n.mount();
  }
  update(t) {
    let e = t.state.facet(__);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new wh(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new wh(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let n = t.state.facet(ld);
    if (n != this.input) {
      let i = n.filter((l) => l), r = [], o = [], s = [], a = [];
      for (let l of i) {
        let u = this.specs.indexOf(l), c;
        u < 0 ? (c = l(t.view), a.push(c)) : (c = this.panels[u], c.update && c.update(t)), r.push(c), (c.top ? o : s).push(c);
      }
      this.specs = i, this.panels = r, this.top.sync(o), this.bottom.sync(s);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => Le.scrollMargins.of((e) => {
    let n = e.plugin(t);
    return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
  })
});
class wh {
  constructor(e, n, i) {
    this.view = e, this.top = n, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let n of this.panels)
      n.destroy && e.indexOf(n) < 0 && n.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; e != n.dom; )
          e = x_(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(n.dom, e);
    for (; e; )
      e = x_(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function x_(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const ld = /* @__PURE__ */ Ze.define({
  enables: fA
});
class fo extends Ba {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
fo.prototype.elementClass = "";
fo.prototype.toDOM = void 0;
fo.prototype.mapMode = Bn.TrackBefore;
fo.prototype.startSide = fo.prototype.endSide = -1;
fo.prototype.point = !0;
const Hh = /* @__PURE__ */ Ze.define(), Fee = /* @__PURE__ */ Ze.define(), qee = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => bt.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Pc = /* @__PURE__ */ Ze.define();
function pA(t) {
  return [mA(), Pc.of(Object.assign(Object.assign({}, qee), t))];
}
const dy = /* @__PURE__ */ Ze.define({
  combine: (t) => t.some((e) => e)
});
function mA(t) {
  let e = [
    Wee
  ];
  return t && t.fixed === !1 && e.push(dy.of(!0)), e;
}
const Wee = /* @__PURE__ */ dn.fromClass(class {
  constructor(t) {
    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(Pc).map((e) => new T_(t, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t.state.facet(dy), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, n = t.view.viewport, i = Math.min(e.to, n.to) - Math.max(e.from, n.from);
      this.syncGutters(i < (n.to - n.from) * 0.8);
    }
    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(dy) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && this.dom.remove();
    let n = bt.iter(this.view.state.facet(Hh), this.view.viewport.from), i = [], r = this.gutters.map((o) => new Xee(o, this.view.viewport, -this.view.documentPadding.top));
    for (let o of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(o.type)) {
        let s = !0;
        for (let a of o.type)
          if (a.type == li.Text && s) {
            hy(n, i, a.from);
            for (let l of r)
              l.line(this.view, a, i);
            s = !1;
          } else if (a.widget)
            for (let l of r)
              l.widget(this.view, a);
      } else if (o.type == li.Text) {
        hy(n, i, o.from);
        for (let s of r)
          s.line(this.view, o, i);
      } else if (o.widget)
        for (let s of r)
          s.widget(this.view, o);
    for (let o of r)
      o.finish();
    t && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t) {
    let e = t.startState.facet(Pc), n = t.state.facet(Pc), i = t.docChanged || t.heightChanged || t.viewportChanged || !bt.eq(t.startState.facet(Hh), t.state.facet(Hh), t.view.viewport.from, t.view.viewport.to);
    if (e == n)
      for (let r of this.gutters)
        r.update(t) && (i = !0);
    else {
      i = !0;
      let r = [];
      for (let o of n) {
        let s = e.indexOf(o);
        s < 0 ? r.push(new T_(this.view, o)) : (this.gutters[s].update(t), r.push(this.gutters[s]));
      }
      for (let o of this.gutters)
        o.dom.remove(), r.indexOf(o) < 0 && o.destroy();
      for (let o of r)
        this.dom.appendChild(o.dom);
      this.gutters = r;
    }
    return i;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove();
  }
}, {
  provide: (t) => Le.scrollMargins.of((e) => {
    let n = e.plugin(t);
    return !n || n.gutters.length == 0 || !n.fixed ? null : e.textDirection == Yt.LTR ? { left: n.dom.offsetWidth * e.scaleX } : { right: n.dom.offsetWidth * e.scaleX };
  })
});
function C_(t) {
  return Array.isArray(t) ? t : [t];
}
function hy(t, e, n) {
  for (; t.value && t.from <= n; )
    t.from == n && e.push(t.value), t.next();
}
class Xee {
  constructor(e, n, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = bt.iter(e.markers, n.from);
  }
  addElement(e, n, i) {
    let { gutter: r } = this, o = (n.top - this.height) / e.scaleY, s = n.height / e.scaleY;
    if (this.i == r.elements.length) {
      let a = new gA(e, s, o, i);
      r.elements.push(a), r.dom.appendChild(a.dom);
    } else
      r.elements[this.i].update(e, s, o, i);
    this.height = n.bottom, this.i++;
  }
  line(e, n, i) {
    let r = [];
    hy(this.cursor, r, n.from), i.length && (r = r.concat(i));
    let o = this.gutter.config.lineMarker(e, n, r);
    o && r.unshift(o);
    let s = this.gutter;
    r.length == 0 && !s.config.renderEmptyElements || this.addElement(e, n, r);
  }
  widget(e, n) {
    let i = this.gutter.config.widgetMarker(e, n.widget, n), r = i ? [i] : null;
    for (let o of e.state.facet(Fee)) {
      let s = o(e, n.widget, n);
      s && (r || (r = [])).push(s);
    }
    r && this.addElement(e, n, r);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let n = e.elements.pop();
      e.dom.removeChild(n.dom), n.destroy();
    }
  }
}
class T_ {
  constructor(e, n) {
    this.view = e, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in n.domEventHandlers)
      this.dom.addEventListener(i, (r) => {
        let o = r.target, s;
        if (o != this.dom && this.dom.contains(o)) {
          for (; o.parentNode != this.dom; )
            o = o.parentNode;
          let l = o.getBoundingClientRect();
          s = (l.top + l.bottom) / 2;
        } else
          s = r.clientY;
        let a = e.lineBlockAtHeight(s - e.documentTop);
        n.domEventHandlers[i](e, a, r) && r.preventDefault();
      });
    this.markers = C_(n.markers(e)), n.initialSpacer && (this.spacer = new gA(e, 0, 0, [n.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let n = this.markers;
    if (this.markers = C_(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let r = this.config.updateSpacer(this.spacer.markers[0], e);
      r != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [r]);
    }
    let i = e.view.viewport;
    return !bt.eq(this.markers, n, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class gA {
  constructor(e, n, i, r) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, n, i, r);
  }
  update(e, n, i, r) {
    this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), zee(this.markers, r) || this.setMarkers(e, r);
  }
  setMarkers(e, n) {
    let i = "cm-gutterElement", r = this.dom.firstChild;
    for (let o = 0, s = 0; ; ) {
      let a = s, l = o < n.length ? n[o++] : null, u = !1;
      if (l) {
        let c = l.elementClass;
        c && (i += " " + c);
        for (let d = s; d < this.markers.length; d++)
          if (this.markers[d].compare(l)) {
            a = d, u = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; s < a; ) {
        let c = this.markers[s++];
        if (c.toDOM) {
          c.destroy(r);
          let d = r.nextSibling;
          r.remove(), r = d;
        }
      }
      if (!l)
        break;
      l.toDOM && (u ? r = r.nextSibling : this.dom.insertBefore(l.toDOM(e), r)), u && s++;
    }
    this.dom.className = i, this.markers = n;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function zee(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].compare(e[n]))
      return !1;
  return !0;
}
const jee = /* @__PURE__ */ Ze.define(), Yee = /* @__PURE__ */ Ze.define(), Ol = /* @__PURE__ */ Ze.define({
  combine(t) {
    return Er(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, n) {
        let i = Object.assign({}, e);
        for (let r in n) {
          let o = i[r], s = n[r];
          i[r] = o ? (a, l, u) => o(a, l, u) || s(a, l, u) : s;
        }
        return i;
      }
    });
  }
});
class Yg extends fo {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Hg(t, e) {
  return t.state.facet(Ol).formatNumber(e, t.state);
}
const Hee = /* @__PURE__ */ Pc.compute([Ol], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(jee);
  },
  lineMarker(e, n, i) {
    return i.some((r) => r.toDOM) ? null : new Yg(Hg(e, e.state.doc.lineAt(n.from).number));
  },
  widgetMarker: (e, n, i) => {
    for (let r of e.state.facet(Yee)) {
      let o = r(e, n, i);
      if (o)
        return o;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(Ol) != e.state.facet(Ol),
  initialSpacer(e) {
    return new Yg(Hg(e, $_(e.state.doc.lines)));
  },
  updateSpacer(e, n) {
    let i = Hg(n.view, $_(n.view.state.doc.lines));
    return i == e.number ? e : new Yg(i);
  },
  domEventHandlers: t.facet(Ol).domEventHandlers
}));
function Uee(t = {}) {
  return [
    Ol.of(t),
    mA(),
    Hee
  ];
}
function $_(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const Gee = /* @__PURE__ */ new class extends fo {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), Kee = /* @__PURE__ */ Hh.compute(["selection"], (t) => {
  let e = [], n = -1;
  for (let i of t.selection.ranges) {
    let r = t.doc.lineAt(i.head).from;
    r > n && (n = r, e.push(Gee.range(r)));
  }
  return bt.of(e);
});
function Jee() {
  return Kee;
}
const OA = 1024;
let ete = 0;
class Gi {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
}
class dt {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = ete++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = pi.match(e)), (n) => {
      let i = e(n);
      return i === void 0 ? null : [this, i];
    };
  }
}
dt.closedBy = new dt({ deserialize: (t) => t.split(" ") });
dt.openedBy = new dt({ deserialize: (t) => t.split(" ") });
dt.group = new dt({ deserialize: (t) => t.split(" ") });
dt.isolate = new dt({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
dt.contextHash = new dt({ perNode: !0 });
dt.lookAhead = new dt({ perNode: !0 });
dt.mounted = new dt({ perNode: !0 });
class ud {
  constructor(e, n, i) {
    this.tree = e, this.overlay = n, this.parser = i;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[dt.mounted.id];
  }
}
const tte = /* @__PURE__ */ Object.create(null);
class pi {
  /**
  @internal
  */
  constructor(e, n, i, r = 0) {
    this.name = e, this.props = n, this.id = i, this.flags = r;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let n = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : tte, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), r = new pi(e.name || "", n, e.id, i);
    if (e.props) {
      for (let o of e.props)
        if (Array.isArray(o) || (o = o(r)), o) {
          if (o[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          n[o[0].id] = o[1];
        }
    }
    return r;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let n = this.prop(dt.group);
      return n ? n.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let r of i.split(" "))
        n[r] = e[i];
    return (i) => {
      for (let r = i.prop(dt.group), o = -1; o < (r ? r.length : 0); o++) {
        let s = n[o < 0 ? i.name : r[o]];
        if (s)
          return s;
      }
    };
  }
}
pi.none = new pi(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class S0 {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].id != n)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let n = [];
    for (let i of this.types) {
      let r = null;
      for (let o of e) {
        let s = o(i);
        s && (r || (r = Object.assign({}, i.props)), r[s[0].id] = s[1]);
      }
      n.push(r ? new pi(i.name, r, i.id, i.flags) : i);
    }
    return new S0(n);
  }
}
const kh = /* @__PURE__ */ new WeakMap(), P_ = /* @__PURE__ */ new WeakMap();
var Bt;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Bt || (Bt = {}));
class tn {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, n, i, r, o) {
    if (this.type = e, this.children = n, this.positions = i, this.length = r, this.props = null, o && o.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [s, a] of o)
        this.props[typeof s == "number" ? s : s.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = ud.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let n = "";
    for (let i of this.children) {
      let r = i.toString();
      r && (n && (n += ","), n += r);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new pp(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, n = 0, i = 0) {
    let r = kh.get(this) || this.topNode, o = new pp(r);
    return o.moveTo(e, n), kh.set(this, o._tree), o;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Gn(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, n = 0) {
    let i = cd(kh.get(this) || this.topNode, e, n, !1);
    return kh.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, n = 0) {
    let i = cd(P_.get(this) || this.topNode, e, n, !0);
    return P_.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, n = 0) {
    return rte(this, e, n);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: n, leave: i, from: r = 0, to: o = this.length } = e, s = e.mode || 0, a = (s & Bt.IncludeAnonymous) > 0;
    for (let l = this.cursor(s | Bt.IncludeAnonymous); ; ) {
      let u = !1;
      if (l.from <= o && l.to >= r && (!a && l.type.isAnonymous || n(l) !== !1)) {
        if (l.firstChild())
          continue;
        u = !0;
      }
      for (; u && i && (a || !l.type.isAnonymous) && i(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        u = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let n in this.props)
        e.push([+n, this.props[n]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : C0(pi.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, i, r) => new tn(this.type, n, i, r, this.propValues), e.makeTree || ((n, i, r) => new tn(pi.none, n, i, r)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return ote(e);
  }
}
tn.empty = new tn(pi.none, [], [], 0);
class _0 {
  constructor(e, n) {
    this.buffer = e, this.index = n;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _0(this.buffer, this.index);
  }
}
class Ls {
  /**
  Create a tree buffer.
  */
  constructor(e, n, i) {
    this.buffer = e, this.length = n, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return pi.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let n = 0; n < this.buffer.length; )
      e.push(this.childString(n)), n = this.buffer[n + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let n = this.buffer[e], i = this.buffer[e + 3], r = this.set.types[n], o = r.name;
    if (/\W/.test(o) && !r.isError && (o = JSON.stringify(o)), e += 4, i == e)
      return o;
    let s = [];
    for (; e < i; )
      s.push(this.childString(e)), e = this.buffer[e + 3];
    return o + "(" + s.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, n, i, r, o) {
    let { buffer: s } = this, a = -1;
    for (let l = e; l != n && !(vA(o, r, s[l + 1], s[l + 2]) && (a = l, i > 0)); l = s[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, n, i) {
    let r = this.buffer, o = new Uint16Array(n - e), s = 0;
    for (let a = e, l = 0; a < n; ) {
      o[l++] = r[a++], o[l++] = r[a++] - i;
      let u = o[l++] = r[a++] - i;
      o[l++] = r[a++] - e, s = Math.max(s, u);
    }
    return new Ls(o, s, this.set);
  }
}
function vA(t, e, n, i) {
  switch (t) {
    case -2:
      return n < e;
    case -1:
      return i >= e && n < e;
    case 0:
      return n < e && i > e;
    case 1:
      return n <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return !0;
  }
}
function cd(t, e, n, i) {
  for (var r; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e); ) {
    let s = !i && t instanceof Gn && t.index < 0 ? null : t.parent;
    if (!s)
      return t;
    t = s;
  }
  let o = i ? 0 : Bt.IgnoreOverlays;
  if (i)
    for (let s = t, a = s.parent; a; s = a, a = s.parent)
      s instanceof Gn && s.index < 0 && ((r = a.enter(e, n, o)) === null || r === void 0 ? void 0 : r.from) != s.from && (t = a);
  for (; ; ) {
    let s = t.enter(e, n, o);
    if (!s)
      return t;
    t = s;
  }
}
class yA {
  cursor(e = 0) {
    return new pp(this, e);
  }
  getChild(e, n = null, i = null) {
    let r = M_(this, e, n, i);
    return r.length ? r[0] : null;
  }
  getChildren(e, n = null, i = null) {
    return M_(this, e, n, i);
  }
  resolve(e, n = 0) {
    return cd(this, e, n, !1);
  }
  resolveInner(e, n = 0) {
    return cd(this, e, n, !0);
  }
  matchContext(e) {
    return fy(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let n = this.childBefore(e), i = this;
    for (; n; ) {
      let r = n.lastChild;
      if (!r || r.to != n.to)
        break;
      r.type.isError && r.from == r.to ? (i = n, n = r.prevSibling) : n = r;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Gn extends yA {
  constructor(e, n, i, r) {
    super(), this._tree = e, this.from = n, this.index = i, this._parent = r;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, n, i, r, o = 0) {
    for (let s = this; ; ) {
      for (let { children: a, positions: l } = s._tree, u = n > 0 ? a.length : -1; e != u; e += n) {
        let c = a[e], d = l[e] + s.from;
        if (vA(r, i, d, d + c.length)) {
          if (c instanceof Ls) {
            if (o & Bt.ExcludeBuffers)
              continue;
            let h = c.findChild(0, c.buffer.length, n, i - d, r);
            if (h > -1)
              return new Gr(new nte(s, c, e, d), null, h);
          } else if (o & Bt.IncludeAnonymous || !c.type.isAnonymous || x0(c)) {
            let h;
            if (!(o & Bt.IgnoreMounts) && (h = ud.get(c)) && !h.overlay)
              return new Gn(h.tree, d, e, s);
            let f = new Gn(c, d, e, s);
            return o & Bt.IncludeAnonymous || !f.type.isAnonymous ? f : f.nextChild(n < 0 ? c.children.length - 1 : 0, n, i, r);
          }
        }
      }
      if (o & Bt.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? e = s.index + n : e = n < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, i = 0) {
    let r;
    if (!(i & Bt.IgnoreOverlays) && (r = ud.get(this._tree)) && r.overlay) {
      let o = e - this.from;
      for (let { from: s, to: a } of r.overlay)
        if ((n > 0 ? s <= o : s < o) && (n < 0 ? a >= o : a > o))
          return new Gn(r.tree, r.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, n, i);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function M_(t, e, n, i) {
  let r = t.cursor(), o = [];
  if (!r.firstChild())
    return o;
  if (n != null) {
    for (let s = !1; !s; )
      if (s = r.type.is(n), !r.nextSibling())
        return o;
  }
  for (; ; ) {
    if (i != null && r.type.is(i))
      return o;
    if (r.type.is(e) && o.push(r.node), !r.nextSibling())
      return i == null ? o : [];
  }
}
function fy(t, e, n = e.length - 1) {
  for (let i = t; n >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (e[n] && e[n] != i.name)
        return !1;
      n--;
    }
  }
  return !0;
}
class nte {
  constructor(e, n, i, r) {
    this.parent = e, this.buffer = n, this.index = i, this.start = r;
  }
}
class Gr extends yA {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, n, i) {
    super(), this.context = e, this._parent = n, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  child(e, n, i) {
    let { buffer: r } = this.context, o = r.findChild(this.index + 4, r.buffer[this.index + 3], e, n - this.context.start, i);
    return o < 0 ? null : new Gr(this.context, this, o);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, i = 0) {
    if (i & Bt.ExcludeBuffers)
      return null;
    let { buffer: r } = this.context, o = r.findChild(this.index + 4, r.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
    return o < 0 ? null : new Gr(this.context, this, o);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, n = e.buffer[this.index + 3];
    return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Gr(this.context, this._parent, n) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new Gr(this.context, this._parent, e.findChild(
      n,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], n = [], { buffer: i } = this.context, r = this.index + 4, o = i.buffer[this.index + 3];
    if (o > r) {
      let s = i.buffer[this.index + 1];
      e.push(i.slice(r, o, s)), n.push(0);
    }
    return new tn(this.type, e, n, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function bA(t) {
  if (!t.length)
    return null;
  let e = 0, n = t[0];
  for (let o = 1; o < t.length; o++) {
    let s = t[o];
    (s.from > n.from || s.to < n.to) && (n = s, e = o);
  }
  let i = n instanceof Gn && n.index < 0 ? null : n.parent, r = t.slice();
  return i ? r[e] = i : r.splice(e, 1), new ite(r, n);
}
class ite {
  constructor(e, n) {
    this.heads = e, this.node = n;
  }
  get next() {
    return bA(this.heads);
  }
}
function rte(t, e, n) {
  let i = t.resolveInner(e, n), r = null;
  for (let o = i instanceof Gn ? i : i.context.parent; o; o = o.parent)
    if (o.index < 0) {
      let s = o.parent;
      (r || (r = [i])).push(s.resolve(e, n)), o = s;
    } else {
      let s = ud.get(o.tree);
      if (s && s.overlay && s.overlay[0].from <= e && s.overlay[s.overlay.length - 1].to >= e) {
        let a = new Gn(s.tree, s.overlay[0].from + o.from, -1, o);
        (r || (r = [i])).push(cd(a, e, n, !1));
      }
    }
  return r ? bA(r) : i;
}
class pp {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, n = 0) {
    if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Gn)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, n) {
    this.index = e;
    let { start: i, buffer: r } = this.buffer;
    return this.type = n || r.set.types[r.buffer[e]], this.from = i + r.buffer[e + 1], this.to = i + r.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Gn ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, n, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, i, this.mode));
    let { buffer: r } = this.buffer, o = r.findChild(this.index + 4, r.buffer[this.index + 3], e, n - this.buffer.start, i);
    return o < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(o));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, n, i = this.mode) {
    return this.buffer ? i & Bt.ExcludeBuffers ? !1 : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Bt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Bt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: n } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let r = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != r)
        return this.yieldBuf(n.findChild(
          r,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let r = n.buffer[this.index + 3];
      if (r < (i < 0 ? n.buffer.length : n.buffer[this.stack[i] + 3]))
        return this.yieldBuf(r);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let n, i, { buffer: r } = this;
    if (r) {
      if (e > 0) {
        if (this.index < r.buffer.buffer.length)
          return !1;
      } else
        for (let o = 0; o < this.index; o++)
          if (r.buffer.buffer[o + 3] < this.index)
            return !1;
      ({ index: n, parent: i } = r);
    } else
      ({ index: n, _parent: i } = this._tree);
    for (; i; { index: n, _parent: i } = i)
      if (n > -1)
        for (let o = n + e, s = e < 0 ? -1 : i._tree.children.length; o != s; o += e) {
          let a = i._tree.children[o];
          if (this.mode & Bt.IncludeAnonymous || a instanceof Ls || !a.type.isAnonymous || x0(a))
            return !1;
        }
    return !0;
  }
  move(e, n) {
    if (n && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, n); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, n = null, i = 0;
    if (e && e.context == this.buffer)
      e:
        for (let r = this.index, o = this.stack.length; o >= 0; ) {
          for (let s = e; s; s = s._parent)
            if (s.index == r) {
              if (r == this.index)
                return s;
              n = s, i = o + 1;
              break e;
            }
          r = this.stack[--o];
        }
    for (let r = i; r < this.stack.length; r++)
      n = new Gr(this.buffer, n, this.stack[r]);
    return this.bufferNode = new Gr(this.buffer, n, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, n) {
    for (let i = 0; ; ) {
      let r = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (r = !0);
      }
      for (; ; ) {
        if (r && n && n(this), r = this.type.isAnonymous, !i)
          return;
        if (this.nextSibling())
          break;
        this.parent(), i--, r = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return fy(this.node.parent, e);
    let { buffer: n } = this.buffer, { types: i } = n.set;
    for (let r = e.length - 1, o = this.stack.length - 1; r >= 0; o--) {
      if (o < 0)
        return fy(this._tree, e, r);
      let s = i[n.buffer[this.stack[o]]];
      if (!s.isAnonymous) {
        if (e[r] && e[r] != s.name)
          return !1;
        r--;
      }
    }
    return !0;
  }
}
function x0(t) {
  return t.children.some((e) => e instanceof Ls || !e.type.isAnonymous || x0(e));
}
function ote(t) {
  var e;
  let { buffer: n, nodeSet: i, maxBufferLength: r = OA, reused: o = [], minRepeatType: s = i.types.length } = t, a = Array.isArray(n) ? new _0(n, n.length) : n, l = i.types, u = 0, c = 0;
  function d(k, w, S, $, C, L) {
    let { id: j, start: P, end: A, size: T } = a, N = c, Q = u;
    for (; T < 0; )
      if (a.next(), T == -1) {
        let pe = o[j];
        S.push(pe), $.push(P - k);
        return;
      } else if (T == -3) {
        u = j;
        return;
      } else if (T == -4) {
        c = j;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${T}`);
    let Y = l[j], V, q, B = P - k;
    if (A - P <= r && (q = g(a.pos - w, C))) {
      let pe = new Uint16Array(q.size - q.skip), oe = a.pos - q.size, te = pe.length;
      for (; a.pos > oe; )
        te = O(q.start, pe, te);
      V = new Ls(pe, A - q.start, i), B = q.start - k;
    } else {
      let pe = a.pos - T;
      a.next();
      let oe = [], te = [], M = j >= s ? j : -1, G = 0, ce = A;
      for (; a.pos > pe; )
        M >= 0 && a.id == M && a.size >= 0 ? (a.end <= ce - r && (p(oe, te, P, G, a.end, ce, M, N, Q), G = oe.length, ce = a.end), a.next()) : L > 2500 ? h(P, pe, oe, te) : d(P, pe, oe, te, M, L + 1);
      if (M >= 0 && G > 0 && G < oe.length && p(oe, te, P, G, P, ce, M, N, Q), oe.reverse(), te.reverse(), M > -1 && G > 0) {
        let F = f(Y, Q);
        V = C0(Y, oe, te, 0, oe.length, 0, A - P, F, F);
      } else
        V = m(Y, oe, te, A - P, N - A, Q);
    }
    S.push(V), $.push(B);
  }
  function h(k, w, S, $) {
    let C = [], L = 0, j = -1;
    for (; a.pos > w; ) {
      let { id: P, start: A, end: T, size: N } = a;
      if (N > 4)
        a.next();
      else {
        if (j > -1 && A < j)
          break;
        j < 0 && (j = T - r), C.push(P, A, T), L++, a.next();
      }
    }
    if (L) {
      let P = new Uint16Array(L * 4), A = C[C.length - 2];
      for (let T = C.length - 3, N = 0; T >= 0; T -= 3)
        P[N++] = C[T], P[N++] = C[T + 1] - A, P[N++] = C[T + 2] - A, P[N++] = N;
      S.push(new Ls(P, C[2] - A, i)), $.push(A - k);
    }
  }
  function f(k, w) {
    return (S, $, C) => {
      let L = 0, j = S.length - 1, P, A;
      if (j >= 0 && (P = S[j]) instanceof tn) {
        if (!j && P.type == k && P.length == C)
          return P;
        (A = P.prop(dt.lookAhead)) && (L = $[j] + P.length + A);
      }
      return m(k, S, $, C, L, w);
    };
  }
  function p(k, w, S, $, C, L, j, P, A) {
    let T = [], N = [];
    for (; k.length > $; )
      T.push(k.pop()), N.push(w.pop() + S - C);
    k.push(m(i.types[j], T, N, L - C, P - L, A)), w.push(C - S);
  }
  function m(k, w, S, $, C, L, j) {
    if (L) {
      let P = [dt.contextHash, L];
      j = j ? [P].concat(j) : [P];
    }
    if (C > 25) {
      let P = [dt.lookAhead, C];
      j = j ? [P].concat(j) : [P];
    }
    return new tn(k, w, S, $, j);
  }
  function g(k, w) {
    let S = a.fork(), $ = 0, C = 0, L = 0, j = S.end - r, P = { size: 0, start: 0, skip: 0 };
    e:
      for (let A = S.pos - k; S.pos > A; ) {
        let T = S.size;
        if (S.id == w && T >= 0) {
          P.size = $, P.start = C, P.skip = L, L += 4, $ += 4, S.next();
          continue;
        }
        let N = S.pos - T;
        if (T < 0 || N < A || S.start < j)
          break;
        let Q = S.id >= s ? 4 : 0, Y = S.start;
        for (S.next(); S.pos > N; ) {
          if (S.size < 0)
            if (S.size == -3)
              Q += 4;
            else
              break e;
          else
            S.id >= s && (Q += 4);
          S.next();
        }
        C = Y, $ += T, L += Q;
      }
    return (w < 0 || $ == k) && (P.size = $, P.start = C, P.skip = L), P.size > 4 ? P : void 0;
  }
  function O(k, w, S) {
    let { id: $, start: C, end: L, size: j } = a;
    if (a.next(), j >= 0 && $ < s) {
      let P = S;
      if (j > 4) {
        let A = a.pos - (j - 4);
        for (; a.pos > A; )
          S = O(k, w, S);
      }
      w[--S] = P, w[--S] = L - k, w[--S] = C - k, w[--S] = $;
    } else
      j == -3 ? u = $ : j == -4 && (c = $);
    return S;
  }
  let y = [], b = [];
  for (; a.pos > 0; )
    d(t.start || 0, t.bufferStart || 0, y, b, -1, 0);
  let v = (e = t.length) !== null && e !== void 0 ? e : y.length ? b[0] + y[0].length : 0;
  return new tn(l[t.topID], y.reverse(), b.reverse(), v);
}
const E_ = /* @__PURE__ */ new WeakMap();
function Uh(t, e) {
  if (!t.isAnonymous || e instanceof Ls || e.type != t)
    return 1;
  let n = E_.get(e);
  if (n == null) {
    n = 1;
    for (let i of e.children) {
      if (i.type != t || !(i instanceof tn)) {
        n = 1;
        break;
      }
      n += Uh(t, i);
    }
    E_.set(e, n);
  }
  return n;
}
function C0(t, e, n, i, r, o, s, a, l) {
  let u = 0;
  for (let p = i; p < r; p++)
    u += Uh(t, e[p]);
  let c = Math.ceil(
    u * 1.5 / 8
    /* Balance.BranchFactor */
  ), d = [], h = [];
  function f(p, m, g, O, y) {
    for (let b = g; b < O; ) {
      let v = b, k = m[b], w = Uh(t, p[b]);
      for (b++; b < O; b++) {
        let S = Uh(t, p[b]);
        if (w + S >= c)
          break;
        w += S;
      }
      if (b == v + 1) {
        if (w > c) {
          let S = p[v];
          f(S.children, S.positions, 0, S.children.length, m[v] + y);
          continue;
        }
        d.push(p[v]);
      } else {
        let S = m[b - 1] + p[b - 1].length - k;
        d.push(C0(t, p, m, v, b, k, S, null, l));
      }
      h.push(k + y - o);
    }
  }
  return f(e, n, i, r, 0), (a || l)(d, h, s);
}
class wA {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, n, i) {
    let r = this.map.get(e);
    r || this.map.set(e, r = /* @__PURE__ */ new Map()), r.set(n, i);
  }
  getBuffer(e, n) {
    let i = this.map.get(e);
    return i && i.get(n);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, n) {
    e instanceof Gr ? this.setBuffer(e.context.buffer, e.index, n) : e instanceof Gn && this.map.set(e.tree, n);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof Gr ? this.getBuffer(e.context.buffer, e.index) : e instanceof Gn ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, n) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, n) : this.map.set(e.tree, n);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class No {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, n, i, r, o = !1, s = !1) {
    this.from = e, this.to = n, this.tree = i, this.offset = r, this.open = (o ? 1 : 0) | (s ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, n = [], i = !1) {
    let r = [new No(0, e.length, e, 0, !1, i)];
    for (let o of n)
      o.to > e.length && r.push(o);
    return r;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, n, i = 128) {
    if (!n.length)
      return e;
    let r = [], o = 1, s = e.length ? e[0] : null;
    for (let a = 0, l = 0, u = 0; ; a++) {
      let c = a < n.length ? n[a] : null, d = c ? c.fromA : 1e9;
      if (d - l >= i)
        for (; s && s.from < d; ) {
          let h = s;
          if (l >= h.from || d <= h.to || u) {
            let f = Math.max(h.from, l) - u, p = Math.min(h.to, d) - u;
            h = f >= p ? null : new No(f, p, h.tree, h.offset + u, a > 0, !!c);
          }
          if (h && r.push(h), s.to > d)
            break;
          s = o < e.length ? e[o++] : null;
        }
      if (!c)
        break;
      l = c.toA, u = c.toA - c.toB;
    }
    return r;
  }
}
class kA {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, n, i) {
    return typeof e == "string" && (e = new ste(e)), i = i ? i.length ? i.map((r) => new Gi(r.from, r.to)) : [new Gi(0, 0)] : [new Gi(0, e.length)], this.createParse(e, n || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, n, i) {
    let r = this.startParse(e, n, i);
    for (; ; ) {
      let o = r.advance();
      if (o)
        return o;
    }
  }
}
class ste {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, n) {
    return this.string.slice(e, n);
  }
}
function ate(t) {
  return (e, n, i, r) => new ute(e, t, n, i, r);
}
class A_ {
  constructor(e, n, i, r, o) {
    this.parser = e, this.parse = n, this.overlay = i, this.target = r, this.from = o;
  }
}
function R_(t) {
  if (!t.length || t.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t));
}
class lte {
  constructor(e, n, i, r, o, s, a) {
    this.parser = e, this.predicate = n, this.mounts = i, this.index = r, this.start = o, this.target = s, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const py = new dt({ perNode: !0 });
class ute {
  constructor(e, n, i, r, o) {
    this.nest = n, this.input = i, this.fragments = r, this.ranges = o, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let r of this.inner)
          r.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new tn(i.type, i.children, i.positions, i.length, i.propValues.concat([[py, this.stoppedAt]]))), i;
    }
    let e = this.inner[this.innerDone], n = e.parse.advance();
    if (n) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      i[dt.mounted.id] = new ud(n, e.overlay, e.parser), e.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let n = this.innerDone; n < this.inner.length; n++)
      this.inner[n].from < e && (e = Math.min(e, this.inner[n].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let n = this.innerDone; n < this.inner.length; n++)
        this.inner[n].parse.stopAt(e);
  }
  startInner() {
    let e = new hte(this.fragments), n = null, i = null, r = new pp(new Gn(this.baseTree, this.ranges[0].from, 0, null), Bt.IncludeAnonymous | Bt.IgnoreMounts);
    e:
      for (let o, s; ; ) {
        let a = !0, l;
        if (this.stoppedAt != null && r.from >= this.stoppedAt)
          a = !1;
        else if (e.hasNode(r)) {
          if (n) {
            let u = n.mounts.find((c) => c.frag.from <= r.from && c.frag.to >= r.to && c.mount.overlay);
            if (u)
              for (let c of u.mount.overlay) {
                let d = c.from + u.pos, h = c.to + u.pos;
                d >= r.from && h <= r.to && !n.ranges.some((f) => f.from < h && f.to > d) && n.ranges.push({ from: d, to: h });
              }
          }
          a = !1;
        } else if (i && (s = cte(i.ranges, r.from, r.to)))
          a = s != 2;
        else if (!r.type.isAnonymous && (o = this.nest(r, this.input)) && (r.from < r.to || !o.overlay)) {
          r.tree || dte(r);
          let u = e.findMounts(r.from, o.parser);
          if (typeof o.overlay == "function")
            n = new lte(o.parser, o.overlay, u, this.inner.length, r.from, r.tree, n);
          else {
            let c = N_(this.ranges, o.overlay || (r.from < r.to ? [new Gi(r.from, r.to)] : []));
            c.length && R_(c), (c.length || !o.overlay) && this.inner.push(new A_(o.parser, c.length ? o.parser.startParse(this.input, I_(u, c), c) : o.parser.startParse(""), o.overlay ? o.overlay.map((d) => new Gi(d.from - r.from, d.to - r.from)) : null, r.tree, c.length ? c[0].from : r.from)), o.overlay ? c.length && (i = { ranges: c, depth: 0, prev: i }) : a = !1;
          }
        } else if (n && (l = n.predicate(r)) && (l === !0 && (l = new Gi(r.from, r.to)), l.from < l.to)) {
          let u = n.ranges.length - 1;
          u >= 0 && n.ranges[u].to == l.from ? n.ranges[u] = { from: n.ranges[u].from, to: l.to } : n.ranges.push(l);
        }
        if (a && r.firstChild())
          n && n.depth++, i && i.depth++;
        else
          for (; !r.nextSibling(); ) {
            if (!r.parent())
              break e;
            if (n && !--n.depth) {
              let u = N_(this.ranges, n.ranges);
              u.length && (R_(u), this.inner.splice(n.index, 0, new A_(n.parser, n.parser.startParse(this.input, I_(n.mounts, u), u), n.ranges.map((c) => new Gi(c.from - n.start, c.to - n.start)), n.target, u[0].from))), n = n.prev;
            }
            i && !--i.depth && (i = i.prev);
          }
      }
  }
}
function cte(t, e, n) {
  for (let i of t) {
    if (i.from >= n)
      break;
    if (i.to > e)
      return i.from <= e && i.to >= n ? 2 : 1;
  }
  return 0;
}
function D_(t, e, n, i, r, o) {
  if (e < n) {
    let s = t.buffer[e + 1];
    i.push(t.slice(e, n, s)), r.push(s - o);
  }
}
function dte(t) {
  let { node: e } = t, n = [], i = e.context.buffer;
  do
    n.push(t.index), t.parent();
  while (!t.tree);
  let r = t.tree, o = r.children.indexOf(i), s = r.children[o], a = s.buffer, l = [o];
  function u(c, d, h, f, p, m) {
    let g = n[m], O = [], y = [];
    D_(s, c, g, O, y, f);
    let b = a[g + 1], v = a[g + 2];
    l.push(O.length);
    let k = m ? u(g + 4, a[g + 3], s.set.types[a[g]], b, v - b, m - 1) : e.toTree();
    return O.push(k), y.push(b - f), D_(s, a[g + 3], d, O, y, f), new tn(h, O, y, p);
  }
  r.children[o] = u(0, a.length, pi.none, 0, s.length, n.length - 1);
  for (let c of l) {
    let d = t.tree.children[c], h = t.tree.positions[c];
    t.yield(new Gn(d, h + t.from, c, t._tree));
  }
}
class Q_ {
  constructor(e, n) {
    this.offset = n, this.done = !1, this.cursor = e.cursor(Bt.IncludeAnonymous | Bt.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: n } = this, i = e - this.offset;
    for (; !this.done && n.from < i; )
      n.to >= e && n.enter(i, 1, Bt.IgnoreOverlays | Bt.ExcludeBuffers) || n.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let n = this.cursor.tree; ; ) {
        if (n == e.tree)
          return !0;
        if (n.children.length && n.positions[0] == 0 && n.children[0] instanceof tn)
          n = n.children[0];
        else
          break;
      }
    return !1;
  }
}
let hte = class {
  constructor(e) {
    var n;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let i = this.curFrag = e[0];
      this.curTo = (n = i.tree.prop(py)) !== null && n !== void 0 ? n : i.to, this.inner = new Q_(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let n = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = n.tree.prop(py)) !== null && e !== void 0 ? e : n.to, this.inner = new Q_(n.tree, -n.offset);
    }
  }
  findMounts(e, n) {
    var i;
    let r = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let o = this.inner.cursor.node; o; o = o.parent) {
        let s = (i = o.tree) === null || i === void 0 ? void 0 : i.prop(dt.mounted);
        if (s && s.parser == n)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= o.to)
              break;
            l.tree == this.curFrag.tree && r.push({
              frag: l,
              pos: o.from - l.offset,
              mount: s
            });
          }
      }
    }
    return r;
  }
};
function N_(t, e) {
  let n = null, i = e;
  for (let r = 1, o = 0; r < t.length; r++) {
    let s = t[r - 1].to, a = t[r].from;
    for (; o < i.length; o++) {
      let l = i[o];
      if (l.from >= a)
        break;
      l.to <= s || (n || (i = n = e.slice()), l.from < s ? (n[o] = new Gi(l.from, s), l.to > a && n.splice(o + 1, 0, new Gi(a, l.to))) : l.to > a ? n[o--] = new Gi(a, l.to) : n.splice(o--, 1));
    }
  }
  return i;
}
function fte(t, e, n, i) {
  let r = 0, o = 0, s = !1, a = !1, l = -1e9, u = [];
  for (; ; ) {
    let c = r == t.length ? 1e9 : s ? t[r].to : t[r].from, d = o == e.length ? 1e9 : a ? e[o].to : e[o].from;
    if (s != a) {
      let h = Math.max(l, n), f = Math.min(c, d, i);
      h < f && u.push(new Gi(h, f));
    }
    if (l = Math.min(c, d), l == 1e9)
      break;
    c == l && (s ? (s = !1, r++) : s = !0), d == l && (a ? (a = !1, o++) : a = !0);
  }
  return u;
}
function I_(t, e) {
  let n = [];
  for (let { pos: i, mount: r, frag: o } of t) {
    let s = i + (r.overlay ? r.overlay[0].from : 0), a = s + r.tree.length, l = Math.max(o.from, s), u = Math.min(o.to, a);
    if (r.overlay) {
      let c = r.overlay.map((h) => new Gi(h.from + i, h.to + i)), d = fte(e, c, l, u);
      for (let h = 0, f = l; ; h++) {
        let p = h == d.length, m = p ? u : d[h].from;
        if (m > f && n.push(new No(f, m, r.tree, -s, o.from >= f || o.openStart, o.to <= m || o.openEnd)), p)
          break;
        f = d[h].to;
      }
    } else
      n.push(new No(l, u, r.tree, -s, o.from >= s || o.openStart, o.to <= a || o.openEnd));
  }
  return n;
}
let pte = 0;
class Hi {
  /**
  @internal
  */
  constructor(e, n, i, r) {
    this.name = e, this.set = n, this.base = i, this.modified = r, this.id = pte++;
  }
  toString() {
    let { name: e } = this;
    for (let n of this.modified)
      n.name && (e = `${n.name}(${e})`);
    return e;
  }
  static define(e, n) {
    let i = typeof e == "string" ? e : "?";
    if (e instanceof Hi && (n = e), n != null && n.base)
      throw new Error("Can not derive from a modified tag");
    let r = new Hi(i, [], null, []);
    if (r.set.push(r), n)
      for (let o of n.set)
        r.set.push(o);
    return r;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let n = new mp(e);
    return (i) => i.modified.indexOf(n) > -1 ? i : mp.get(i.base || i, i.modified.concat(n).sort((r, o) => r.id - o.id));
  }
}
let mte = 0;
class mp {
  constructor(e) {
    this.name = e, this.instances = [], this.id = mte++;
  }
  static get(e, n) {
    if (!n.length)
      return e;
    let i = n[0].instances.find((a) => a.base == e && gte(n, a.modified));
    if (i)
      return i;
    let r = [], o = new Hi(e.name, r, e, n);
    for (let a of n)
      a.instances.push(o);
    let s = Ote(n);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of s)
          r.push(mp.get(a, l));
    return o;
  }
}
function gte(t, e) {
  return t.length == e.length && t.every((n, i) => n == e[i]);
}
function Ote(t) {
  let e = [[]];
  for (let n = 0; n < t.length; n++)
    for (let i = 0, r = e.length; i < r; i++)
      e.push(e[i].concat(t[n]));
  return e.sort((n, i) => i.length - n.length);
}
function Cm(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let i = t[n];
    Array.isArray(i) || (i = [i]);
    for (let r of n.split(" "))
      if (r) {
        let o = [], s = 2, a = r;
        for (let d = 0; ; ) {
          if (a == "..." && d > 0 && d + 3 == r.length) {
            s = 1;
            break;
          }
          let h = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!h)
            throw new RangeError("Invalid path: " + r);
          if (o.push(h[0] == "*" ? "" : h[0][0] == '"' ? JSON.parse(h[0]) : h[0]), d += h[0].length, d == r.length)
            break;
          let f = r[d++];
          if (d == r.length && f == "!") {
            s = 0;
            break;
          }
          if (f != "/")
            throw new RangeError("Invalid path: " + r);
          a = r.slice(d);
        }
        let l = o.length - 1, u = o[l];
        if (!u)
          throw new RangeError("Invalid path: " + r);
        let c = new gp(i, s, l > 0 ? o.slice(0, l) : null);
        e[u] = c.sort(e[u]);
      }
  }
  return SA.add(e);
}
const SA = new dt();
class gp {
  constructor(e, n, i, r) {
    this.tags = e, this.mode = n, this.context = i, this.next = r;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
gp.empty = new gp([], 2, null);
function _A(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let o of t)
    if (!Array.isArray(o.tag))
      n[o.tag.id] = o.class;
    else
      for (let s of o.tag)
        n[s.id] = o.class;
  let { scope: i, all: r = null } = e || {};
  return {
    style: (o) => {
      let s = r;
      for (let a of o)
        for (let l of a.set) {
          let u = n[l.id];
          if (u) {
            s = s ? s + " " + u : u;
            break;
          }
        }
      return s;
    },
    scope: i
  };
}
function vte(t, e) {
  let n = null;
  for (let i of t) {
    let r = i.style(e);
    r && (n = n ? n + " " + r : r);
  }
  return n;
}
function yte(t, e, n, i = 0, r = t.length) {
  let o = new bte(i, Array.isArray(e) ? e : [e], n);
  o.highlightRange(t.cursor(), i, r, "", o.highlighters), o.flush(r);
}
class bte {
  constructor(e, n, i) {
    this.at = e, this.highlighters = n, this.span = i, this.class = "";
  }
  startSpan(e, n) {
    n != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = n);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, n, i, r, o) {
    let { type: s, from: a, to: l } = e;
    if (a >= i || l <= n)
      return;
    s.isTop && (o = this.highlighters.filter((f) => !f.scope || f.scope(s)));
    let u = r, c = wte(e) || gp.empty, d = vte(o, c.tags);
    if (d && (u && (u += " "), u += d, c.mode == 1 && (r += (r ? " " : "") + d)), this.startSpan(Math.max(n, a), u), c.opaque)
      return;
    let h = e.tree && e.tree.prop(dt.mounted);
    if (h && h.overlay) {
      let f = e.node.enter(h.overlay[0].from + a, 1), p = this.highlighters.filter((g) => !g.scope || g.scope(h.tree.type)), m = e.firstChild();
      for (let g = 0, O = a; ; g++) {
        let y = g < h.overlay.length ? h.overlay[g] : null, b = y ? y.from + a : l, v = Math.max(n, O), k = Math.min(i, b);
        if (v < k && m)
          for (; e.from < k && (this.highlightRange(e, v, k, r, o), this.startSpan(Math.min(k, e.to), u), !(e.to >= b || !e.nextSibling())); )
            ;
        if (!y || b > i)
          break;
        O = y.to + a, O > n && (this.highlightRange(f.cursor(), Math.max(n, y.from + a), Math.min(i, O), "", p), this.startSpan(Math.min(i, O), u));
      }
      m && e.parent();
    } else if (e.firstChild()) {
      h && (r = "");
      do
        if (!(e.to <= n)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, n, i, r, o), this.startSpan(Math.min(i, e.to), u);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function wte(t) {
  let e = t.type.prop(SA);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const Ie = Hi.define, Sh = Ie(), as = Ie(), L_ = Ie(as), V_ = Ie(as), ls = Ie(), _h = Ie(ls), Ug = Ie(ls), Ir = Ie(), ta = Ie(Ir), Qr = Ie(), Nr = Ie(), my = Ie(), Zu = Ie(my), xh = Ie(), ee = {
  /**
  A comment.
  */
  comment: Sh,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: Ie(Sh),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: Ie(Sh),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: Ie(Sh),
  /**
  Any kind of identifier.
  */
  name: as,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: Ie(as),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: L_,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: Ie(L_),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: V_,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: Ie(V_),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: Ie(as),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: Ie(as),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: Ie(as),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: Ie(as),
  /**
  A literal value.
  */
  literal: ls,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: _h,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: Ie(_h),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: Ie(_h),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: Ie(_h),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Ug,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: Ie(Ug),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: Ie(Ug),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: Ie(ls),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: Ie(ls),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: Ie(ls),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: Ie(ls),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: Ie(ls),
  /**
  A language keyword.
  */
  keyword: Qr,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: Ie(Qr),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: Ie(Qr),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: Ie(Qr),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: Ie(Qr),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: Ie(Qr),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: Ie(Qr),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: Ie(Qr),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: Ie(Qr),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: Ie(Qr),
  /**
  An operator.
  */
  operator: Nr,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: Ie(Nr),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: Ie(Nr),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: Ie(Nr),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: Ie(Nr),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: Ie(Nr),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: Ie(Nr),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: Ie(Nr),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: Ie(Nr),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: Ie(Nr),
  /**
  Program or markup punctuation.
  */
  punctuation: my,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: Ie(my),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Zu,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: Ie(Zu),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: Ie(Zu),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: Ie(Zu),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: Ie(Zu),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Ir,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: ta,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: Ie(ta),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: Ie(ta),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: Ie(ta),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: Ie(ta),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: Ie(ta),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: Ie(ta),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: Ie(Ir),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: Ie(Ir),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: Ie(Ir),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: Ie(Ir),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: Ie(Ir),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: Ie(Ir),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: Ie(Ir),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: Ie(Ir),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: Ie(),
  /**
  Deleted text.
  */
  deleted: Ie(),
  /**
  Changed text.
  */
  changed: Ie(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: Ie(),
  /**
  Metadata or meta-instruction.
  */
  meta: xh,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: Ie(xh),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: Ie(xh),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: Ie(xh),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Hi.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Hi.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Hi.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Hi.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Hi.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Hi.defineModifier("special")
};
for (let t in ee) {
  let e = ee[t];
  e instanceof Hi && (e.name = t);
}
_A([
  { tag: ee.link, class: "tok-link" },
  { tag: ee.heading, class: "tok-heading" },
  { tag: ee.emphasis, class: "tok-emphasis" },
  { tag: ee.strong, class: "tok-strong" },
  { tag: ee.keyword, class: "tok-keyword" },
  { tag: ee.atom, class: "tok-atom" },
  { tag: ee.bool, class: "tok-bool" },
  { tag: ee.url, class: "tok-url" },
  { tag: ee.labelName, class: "tok-labelName" },
  { tag: ee.inserted, class: "tok-inserted" },
  { tag: ee.deleted, class: "tok-deleted" },
  { tag: ee.literal, class: "tok-literal" },
  { tag: ee.string, class: "tok-string" },
  { tag: ee.number, class: "tok-number" },
  { tag: [ee.regexp, ee.escape, ee.special(ee.string)], class: "tok-string2" },
  { tag: ee.variableName, class: "tok-variableName" },
  { tag: ee.local(ee.variableName), class: "tok-variableName tok-local" },
  { tag: ee.definition(ee.variableName), class: "tok-variableName tok-definition" },
  { tag: ee.special(ee.variableName), class: "tok-variableName2" },
  { tag: ee.definition(ee.propertyName), class: "tok-propertyName tok-definition" },
  { tag: ee.typeName, class: "tok-typeName" },
  { tag: ee.namespace, class: "tok-namespace" },
  { tag: ee.className, class: "tok-className" },
  { tag: ee.macroName, class: "tok-macroName" },
  { tag: ee.propertyName, class: "tok-propertyName" },
  { tag: ee.operator, class: "tok-operator" },
  { tag: ee.comment, class: "tok-comment" },
  { tag: ee.meta, class: "tok-meta" },
  { tag: ee.invalid, class: "tok-invalid" },
  { tag: ee.punctuation, class: "tok-punctuation" }
]);
var Gg;
const vl = /* @__PURE__ */ new dt();
function xA(t) {
  return Ze.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const T0 = /* @__PURE__ */ new dt();
class yr {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, n, i = [], r = "") {
    this.data = e, this.name = r, ht.prototype.hasOwnProperty("tree") || Object.defineProperty(ht.prototype, "tree", { get() {
      return hn(this);
    } }), this.parser = n, this.extension = [
      Vs.of(this),
      ht.languageData.of((o, s, a) => {
        let l = B_(o, s, a), u = l.type.prop(vl);
        if (!u)
          return [];
        let c = o.facet(u), d = l.type.prop(T0);
        if (d) {
          let h = l.resolve(s - l.from, a);
          for (let f of d)
            if (f.test(h, o)) {
              let p = o.facet(f.facet);
              return f.type == "replace" ? p : p.concat(c);
            }
        }
        return c;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, n, i = -1) {
    return B_(e, n, i).type.prop(vl) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let n = e.facet(Vs);
    if ((n == null ? void 0 : n.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!n || !n.allowsNesting)
      return [];
    let i = [], r = (o, s) => {
      if (o.prop(vl) == this.data) {
        i.push({ from: s, to: s + o.length });
        return;
      }
      let a = o.prop(dt.mounted);
      if (a) {
        if (a.tree.prop(vl) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              i.push({ from: l.from + s, to: l.to + s });
          else
            i.push({ from: s, to: s + o.length });
          return;
        } else if (a.overlay) {
          let l = i.length;
          if (r(a.tree, a.overlay[0].from + s), i.length > l)
            return;
        }
      }
      for (let l = 0; l < o.children.length; l++) {
        let u = o.children[l];
        u instanceof tn && r(u, o.positions[l] + s);
      }
    };
    return r(hn(e), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
yr.setState = /* @__PURE__ */ ot.define();
function B_(t, e, n) {
  let i = t.facet(Vs), r = hn(t).topNode;
  if (!i || i.allowsNesting)
    for (let o = r; o; o = o.enter(e, n, Bt.ExcludeBuffers))
      o.type.isTop && (r = o);
  return r;
}
class au extends yr {
  constructor(e, n, i) {
    super(e, n, [], i), this.parser = n;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let n = xA(e.languageData);
    return new au(n, e.parser.configure({
      props: [vl.add((i) => i.isTop ? n : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, n) {
    return new au(this.data, this.parser.configure(e), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function hn(t) {
  let e = t.field(yr.state, !1);
  return e ? e.tree : tn.empty;
}
class kte {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, n) {
    let i = this.cursorPos - this.string.length;
    return e < i || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - i, n - i);
  }
}
let Fu = null;
class Op {
  constructor(e, n, i = [], r, o, s, a, l) {
    this.parser = e, this.state = n, this.fragments = i, this.tree = r, this.treeLen = o, this.viewport = s, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, n, i) {
    return new Op(e, n, [], tn.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new kte(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, n) {
    return n != null && n >= this.state.doc.length && (n = void 0), this.tree != tn.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let r = Date.now() + e;
        e = () => Date.now() > r;
      }
      for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
        let r = this.parse.advance();
        if (r)
          if (this.fragments = this.withoutTempSkipped(No.addTree(r, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = r, this.parse = null, this.treeLen < (n ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, n;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(n = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = n, this.fragments = this.withoutTempSkipped(No.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let n = Fu;
    Fu = this;
    try {
      return e();
    } finally {
      Fu = n;
    }
  }
  withoutTempSkipped(e) {
    for (let n; n = this.tempSkipped.pop(); )
      e = Z_(e, n.from, n.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, n) {
    let { fragments: i, tree: r, treeLen: o, viewport: s, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((u, c, d, h) => l.push({ fromA: u, toA: c, fromB: d, toB: h })), i = No.applyChanges(i, l), r = tn.empty, o = 0, s = { from: e.mapPos(s.from, -1), to: e.mapPos(s.to, 1) }, this.skipped.length) {
        a = [];
        for (let u of this.skipped) {
          let c = e.mapPos(u.from, 1), d = e.mapPos(u.to, -1);
          c < d && a.push({ from: c, to: d });
        }
      }
    }
    return new Op(this.parser, n, i, r, o, s, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let n = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: r, to: o } = this.skipped[i];
      r < e.to && o > e.from && (this.fragments = Z_(this.fragments, r, o), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, n) {
    this.skipped.push({ from: e, to: n });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends kA {
      createParse(n, i, r) {
        let o = r[0].from, s = r[r.length - 1].to;
        return {
          parsedPos: o,
          advance() {
            let l = Fu;
            if (l) {
              for (let u of r)
                l.tempSkipped.push(u);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = s, new tn(pi.none, [], [], s - o);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Fu;
  }
}
function Z_(t, e, n) {
  return No.applyChanges(t, [{ fromA: e, toA: n, fromB: e, toB: n }]);
}
class lu {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let n = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, i) || n.takeTree(), new lu(n);
  }
  static init(e) {
    let n = Math.min(3e3, e.doc.length), i = Op.create(e.facet(Vs).parser, e, { from: 0, to: n });
    return i.work(20, n) || i.takeTree(), new lu(i);
  }
}
yr.state = /* @__PURE__ */ xn.define({
  create: lu.init,
  update(t, e) {
    for (let n of e.effects)
      if (n.is(yr.setState))
        return n.value;
    return e.startState.facet(Vs) != e.state.facet(Vs) ? lu.init(e.state) : t.apply(e);
  }
});
let CA = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (CA = (t) => {
  let e = -1, n = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 500 - 100
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e);
});
const Kg = typeof navigator < "u" && (!((Gg = navigator.scheduling) === null || Gg === void 0) && Gg.isInputPending) ? () => navigator.scheduling.isInputPending() : null, Ste = /* @__PURE__ */ dn.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let n = this.view.state.field(yr.state).context;
    (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, n = e.field(yr.state);
    (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = CA(this.work));
  }
  work(e) {
    this.working = null;
    let n = Date.now();
    if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: r } } = this.view, o = i.field(yr.state);
    if (o.tree == o.context.tree && o.context.isDone(
      r + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let s = Date.now() + Math.min(this.chunkBudget, 100, e && !Kg ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = o.context.treeLen < r && i.doc.length > r + 1e3, l = o.context.work(() => Kg && Kg() || Date.now() > s, r + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - n, (l || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({ effects: yr.setState.of(new lu(o.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(o.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((n) => si(this.view.state, n)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Vs = /* @__PURE__ */ Ze.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    yr.state,
    Ste,
    Le.contentAttributes.compute([t], (e) => {
      let n = e.facet(t);
      return n && n.name ? { "data-language": n.name } : {};
    })
  ]
});
class $0 {
  /**
  Create a language support object.
  */
  constructor(e, n = []) {
    this.language = e, this.support = n, this.extension = [e, n];
  }
}
const _te = /* @__PURE__ */ Ze.define(), Id = /* @__PURE__ */ Ze.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function vp(t) {
  let e = t.facet(Id);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function dd(t, e) {
  let n = "", i = t.tabSize, r = t.facet(Id)[0];
  if (r == "	") {
    for (; e >= i; )
      n += "	", e -= i;
    r = " ";
  }
  for (let o = 0; o < e; o++)
    n += r;
  return n;
}
function P0(t, e) {
  t instanceof ht && (t = new Tm(t));
  for (let i of t.state.facet(_te)) {
    let r = i(t, e);
    if (r !== void 0)
      return r;
  }
  let n = hn(t.state);
  return n.length >= e ? xte(t, n, e) : null;
}
class Tm {
  /**
  Create an indent context.
  */
  constructor(e, n = {}) {
    this.state = e, this.options = n, this.unit = vp(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, n = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: r, simulateDoubleBreak: o } = this.options;
    return r != null && r >= i.from && r <= i.to ? o && r == e ? { text: "", from: e } : (n < 0 ? r < e : r <= e) ? { text: i.text.slice(r - i.from), from: r } : { text: i.text.slice(0, r - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, n = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: r } = this.lineAt(e, n);
    return i.slice(e - r, Math.min(i.length, e + 100 - r));
  }
  /**
  Find the column for the given position.
  */
  column(e, n = 1) {
    let { text: i, from: r } = this.lineAt(e, n), o = this.countColumn(i, e - r), s = this.options.overrideIndentation ? this.options.overrideIndentation(r) : -1;
    return s > -1 && (o += s - this.countColumn(i, i.search(/\S|$/))), o;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, n = e.length) {
    return wu(e, this.state.tabSize, n);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, n = 1) {
    let { text: i, from: r } = this.lineAt(e, n), o = this.options.overrideIndentation;
    if (o) {
      let s = o(r);
      if (s > -1)
        return s;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const $m = /* @__PURE__ */ new dt();
function xte(t, e, n) {
  let i = e.resolveStack(n), r = i.node.enterUnfinishedNodesBefore(n);
  if (r != i.node) {
    let o = [];
    for (let s = r; s != i.node; s = s.parent)
      o.push(s);
    for (let s = o.length - 1; s >= 0; s--)
      i = { node: o[s], next: i };
  }
  return TA(i, t, n);
}
function TA(t, e, n) {
  for (let i = t; i; i = i.next) {
    let r = Tte(i.node);
    if (r)
      return r(M0.create(e, n, i));
  }
  return 0;
}
function Cte(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function Tte(t) {
  let e = t.type.prop($m);
  if (e)
    return e;
  let n = t.firstChild, i;
  if (n && (i = n.type.prop(dt.closedBy))) {
    let r = t.lastChild, o = r && i.indexOf(r.name) > -1;
    return (s) => $A(s, !0, 1, void 0, o && !Cte(s) ? r.from : void 0);
  }
  return t.parent == null ? $te : null;
}
function $te() {
  return 0;
}
class M0 extends Tm {
  constructor(e, n, i) {
    super(e.state, e.options), this.base = e, this.pos = n, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, n, i) {
    return new M0(e, n, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let n = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let i = e.resolve(n.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (Pte(i, e))
        break;
      n = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(n.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return TA(this.context.next, this.base, this.pos);
  }
}
function Pte(t, e) {
  for (let n = e; n; n = n.parent)
    if (t == n)
      return !0;
  return !1;
}
function Mte(t) {
  let e = t.node, n = e.childAfter(e.from), i = e.lastChild;
  if (!n)
    return null;
  let r = t.options.simulateBreak, o = t.state.doc.lineAt(n.from), s = r == null || r <= o.from ? o.to : Math.min(o.to, r);
  for (let a = n.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == i)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= s)
        return null;
      let u = /^ */.exec(o.text.slice(n.to - o.from))[0].length;
      return { from: n.from, to: n.to + u };
    }
    a = l.to;
  }
}
function Ete({ closing: t, align: e = !0, units: n = 1 }) {
  return (i) => $A(i, e, n, t);
}
function $A(t, e, n, i, r) {
  let o = t.textAfter, s = o.match(/^\s*/)[0].length, a = i && o.slice(s, s + i.length) == i || r == t.pos + s, l = e ? Mte(t) : null;
  return l ? a ? t.column(l.from) : t.column(l.to) : t.baseIndent + (a ? 0 : t.unit * n);
}
const Ate = (t) => t.baseIndent;
function Gh({ except: t, units: e = 1 } = {}) {
  return (n) => {
    let i = t && t.test(n.textAfter);
    return n.baseIndent + (i ? 0 : e * n.unit);
  };
}
const Rte = 200;
function Dte() {
  return ht.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let n = t.newDoc, { head: i } = t.newSelection.main, r = n.lineAt(i);
    if (i > r.from + Rte)
      return t;
    let o = n.sliceString(r.from, i);
    if (!e.some((u) => u.test(o)))
      return t;
    let { state: s } = t, a = -1, l = [];
    for (let { head: u } of s.selection.ranges) {
      let c = s.doc.lineAt(u);
      if (c.from == a)
        continue;
      a = c.from;
      let d = P0(s, c.from);
      if (d == null)
        continue;
      let h = /^\s*/.exec(c.text)[0], f = dd(s, d);
      h != f && l.push({ from: c.from, to: c.from + h.length, insert: f });
    }
    return l.length ? [t, { changes: l, sequential: !0 }] : t;
  });
}
const Qte = /* @__PURE__ */ Ze.define(), Pm = /* @__PURE__ */ new dt();
function PA(t) {
  let e = t.firstChild, n = t.lastChild;
  return e && e.to < n.from ? { from: e.to, to: n.type.isError ? t.to : n.from } : null;
}
function Nte(t, e, n) {
  let i = hn(t);
  if (i.length < n)
    return null;
  let r = i.resolveStack(n, 1), o = null;
  for (let s = r; s; s = s.next) {
    let a = s.node;
    if (a.to <= n || a.from > n)
      continue;
    if (o && a.from < e)
      break;
    let l = a.type.prop(Pm);
    if (l && (a.to < i.length - 50 || i.length == t.doc.length || !Ite(a))) {
      let u = l(a, t);
      u && u.from <= n && u.from >= e && u.to > n && (o = u);
    }
  }
  return o;
}
function Ite(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function yp(t, e, n) {
  for (let i of t.facet(Qte)) {
    let r = i(t, e, n);
    if (r)
      return r;
  }
  return Nte(t, e, n);
}
function MA(t, e) {
  let n = e.mapPos(t.from, 1), i = e.mapPos(t.to, -1);
  return n >= i ? void 0 : { from: n, to: i };
}
const Mm = /* @__PURE__ */ ot.define({ map: MA }), Ld = /* @__PURE__ */ ot.define({ map: MA });
function EA(t) {
  let e = [];
  for (let { head: n } of t.state.selection.ranges)
    e.some((i) => i.from <= n && i.to >= n) || e.push(t.lineBlockAt(n));
  return e;
}
const Wa = /* @__PURE__ */ xn.define({
  create() {
    return Ue.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let n of e.effects)
      if (n.is(Mm) && !Lte(t, n.value.from, n.value.to)) {
        let { preparePlaceholder: i } = e.state.facet(E0), r = i ? Ue.replace({ widget: new Xte(i(e.state, n.value)) }) : F_;
        t = t.update({ add: [r.range(n.value.from, n.value.to)] });
      } else
        n.is(Ld) && (t = t.update({
          filter: (i, r) => n.value.from != i || n.value.to != r,
          filterFrom: n.value.from,
          filterTo: n.value.to
        }));
    if (e.selection) {
      let n = !1, { head: i } = e.selection.main;
      t.between(i, i, (r, o) => {
        r < i && o > i && (n = !0);
      }), n && (t = t.update({
        filterFrom: i,
        filterTo: i,
        filter: (r, o) => o <= i || r >= i
      }));
    }
    return t;
  },
  provide: (t) => Le.decorations.from(t),
  toJSON(t, e) {
    let n = [];
    return t.between(0, e.doc.length, (i, r) => {
      n.push(i, r);
    }), n;
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let n = 0; n < t.length; ) {
      let i = t[n++], r = t[n++];
      if (typeof i != "number" || typeof r != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(F_.range(i, r));
    }
    return Ue.set(e, !0);
  }
});
function bp(t, e, n) {
  var i;
  let r = null;
  return (i = t.field(Wa, !1)) === null || i === void 0 || i.between(e, n, (o, s) => {
    (!r || r.from > o) && (r = { from: o, to: s });
  }), r;
}
function Lte(t, e, n) {
  let i = !1;
  return t.between(e, e, (r, o) => {
    r == e && o == n && (i = !0);
  }), i;
}
function AA(t, e) {
  return t.field(Wa, !1) ? e : e.concat(ot.appendConfig.of(DA()));
}
const Vte = (t) => {
  for (let e of EA(t)) {
    let n = yp(t.state, e.from, e.to);
    if (n)
      return t.dispatch({ effects: AA(t.state, [Mm.of(n), RA(t, n)]) }), !0;
  }
  return !1;
}, Bte = (t) => {
  if (!t.state.field(Wa, !1))
    return !1;
  let e = [];
  for (let n of EA(t)) {
    let i = bp(t.state, n.from, n.to);
    i && e.push(Ld.of(i), RA(t, i, !1));
  }
  return e.length && t.dispatch({ effects: e }), e.length > 0;
};
function RA(t, e, n = !0) {
  let i = t.state.doc.lineAt(e.from).number, r = t.state.doc.lineAt(e.to).number;
  return Le.announce.of(`${t.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${i} ${t.state.phrase("to")} ${r}.`);
}
const Zte = (t) => {
  let { state: e } = t, n = [];
  for (let i = 0; i < e.doc.length; ) {
    let r = t.lineBlockAt(i), o = yp(e, r.from, r.to);
    o && n.push(Mm.of(o)), i = (o ? t.lineBlockAt(o.to) : r).to + 1;
  }
  return n.length && t.dispatch({ effects: AA(t.state, n) }), !!n.length;
}, Fte = (t) => {
  let e = t.state.field(Wa, !1);
  if (!e || !e.size)
    return !1;
  let n = [];
  return e.between(0, t.state.doc.length, (i, r) => {
    n.push(Ld.of({ from: i, to: r }));
  }), t.dispatch({ effects: n }), !0;
}, qte = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: Vte },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: Bte },
  { key: "Ctrl-Alt-[", run: Zte },
  { key: "Ctrl-Alt-]", run: Fte }
], Wte = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, E0 = /* @__PURE__ */ Ze.define({
  combine(t) {
    return Er(t, Wte);
  }
});
function DA(t) {
  let e = [Wa, Yte];
  return t && e.push(E0.of(t)), e;
}
function QA(t, e) {
  let { state: n } = t, i = n.facet(E0), r = (s) => {
    let a = t.lineBlockAt(t.posAtDOM(s.target)), l = bp(t.state, a.from, a.to);
    l && t.dispatch({ effects: Ld.of(l) }), s.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(t, r, e);
  let o = document.createElement("span");
  return o.textContent = i.placeholderText, o.setAttribute("aria-label", n.phrase("folded code")), o.title = n.phrase("unfold"), o.className = "cm-foldPlaceholder", o.onclick = r, o;
}
const F_ = /* @__PURE__ */ Ue.replace({ widget: /* @__PURE__ */ new class extends mo {
  toDOM(t) {
    return QA(t, null);
  }
}() });
class Xte extends mo {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return QA(e, this.value);
  }
}
const zte = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Jg extends fo {
  constructor(e, n) {
    super(), this.config = e, this.open = n;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let n = document.createElement("span");
    return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), n;
  }
}
function jte(t = {}) {
  let e = Object.assign(Object.assign({}, zte), t), n = new Jg(e, !0), i = new Jg(e, !1), r = dn.fromClass(class {
    constructor(s) {
      this.from = s.viewport.from, this.markers = this.buildMarkers(s);
    }
    update(s) {
      (s.docChanged || s.viewportChanged || s.startState.facet(Vs) != s.state.facet(Vs) || s.startState.field(Wa, !1) != s.state.field(Wa, !1) || hn(s.startState) != hn(s.state) || e.foldingChanged(s)) && (this.markers = this.buildMarkers(s.view));
    }
    buildMarkers(s) {
      let a = new Wo();
      for (let l of s.viewportLineBlocks) {
        let u = bp(s.state, l.from, l.to) ? i : yp(s.state, l.from, l.to) ? n : null;
        u && a.add(l.from, l.from, u);
      }
      return a.finish();
    }
  }), { domEventHandlers: o } = e;
  return [
    r,
    pA({
      class: "cm-foldGutter",
      markers(s) {
        var a;
        return ((a = s.plugin(r)) === null || a === void 0 ? void 0 : a.markers) || bt.empty;
      },
      initialSpacer() {
        return new Jg(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, o), { click: (s, a, l) => {
        if (o.click && o.click(s, a, l))
          return !0;
        let u = bp(s.state, a.from, a.to);
        if (u)
          return s.dispatch({ effects: Ld.of(u) }), !0;
        let c = yp(s.state, a.from, a.to);
        return c ? (s.dispatch({ effects: Mm.of(c) }), !0) : !1;
      } })
    }),
    DA()
  ];
}
const Yte = /* @__PURE__ */ Le.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Em {
  constructor(e, n) {
    this.specs = e;
    let i;
    function r(a) {
      let l = Ns.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const o = typeof n.all == "string" ? n.all : n.all ? r(n.all) : void 0, s = n.scope;
    this.scope = s instanceof yr ? (a) => a.prop(vl) == s.data : s ? (a) => a == s : void 0, this.style = _A(e.map((a) => ({
      tag: a.tag,
      class: a.class || r(Object.assign({}, a, { tag: null }))
    })), {
      all: o
    }).style, this.module = i ? new Ns(i) : null, this.themeType = n.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, n) {
    return new Em(e, n || {});
  }
}
const gy = /* @__PURE__ */ Ze.define(), NA = /* @__PURE__ */ Ze.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function eO(t) {
  let e = t.facet(gy);
  return e.length ? e : t.facet(NA);
}
function IA(t, e) {
  let n = [Ute], i;
  return t instanceof Em && (t.module && n.push(Le.styleModule.of(t.module)), i = t.themeType), e != null && e.fallback ? n.push(NA.of(t)) : i ? n.push(gy.computeN([Le.darkTheme], (r) => r.facet(Le.darkTheme) == (i == "dark") ? [t] : [])) : n.push(gy.of(t)), n;
}
class Hte {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = hn(e.state), this.decorations = this.buildDeco(e, eO(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let n = hn(e.state), i = eO(e.state), r = i != eO(e.startState), { viewport: o } = e.view, s = e.changes.mapPos(this.decoratedTo, 1);
    n.length < o.to && !r && n.type == this.tree.type && s >= o.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = s) : (n != this.tree || e.viewportChanged || r) && (this.tree = n, this.decorations = this.buildDeco(e.view, i), this.decoratedTo = o.to);
  }
  buildDeco(e, n) {
    if (!n || !this.tree.length)
      return Ue.none;
    let i = new Wo();
    for (let { from: r, to: o } of e.visibleRanges)
      yte(this.tree, n, (s, a, l) => {
        i.add(s, a, this.markCache[l] || (this.markCache[l] = Ue.mark({ class: l })));
      }, r, o);
    return i.finish();
  }
}
const Ute = /* @__PURE__ */ Us.high(/* @__PURE__ */ dn.fromClass(Hte, {
  decorations: (t) => t.decorations
})), LA = /* @__PURE__ */ Em.define([
  {
    tag: ee.meta,
    color: "#404740"
  },
  {
    tag: ee.link,
    textDecoration: "underline"
  },
  {
    tag: ee.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: ee.emphasis,
    fontStyle: "italic"
  },
  {
    tag: ee.strong,
    fontWeight: "bold"
  },
  {
    tag: ee.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: ee.keyword,
    color: "#708"
  },
  {
    tag: [ee.atom, ee.bool, ee.url, ee.contentSeparator, ee.labelName],
    color: "#219"
  },
  {
    tag: [ee.literal, ee.inserted],
    color: "#164"
  },
  {
    tag: [ee.string, ee.deleted],
    color: "#a11"
  },
  {
    tag: [ee.regexp, ee.escape, /* @__PURE__ */ ee.special(ee.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ ee.definition(ee.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ ee.local(ee.variableName),
    color: "#30a"
  },
  {
    tag: [ee.typeName, ee.namespace],
    color: "#085"
  },
  {
    tag: ee.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ ee.special(ee.variableName), ee.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ ee.definition(ee.propertyName),
    color: "#00c"
  },
  {
    tag: ee.comment,
    color: "#940"
  },
  {
    tag: ee.invalid,
    color: "#f00"
  }
]), Gte = /* @__PURE__ */ Le.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), VA = 1e4, BA = "()[]{}", ZA = /* @__PURE__ */ Ze.define({
  combine(t) {
    return Er(t, {
      afterCursor: !0,
      brackets: BA,
      maxScanDistance: VA,
      renderMatch: ene
    });
  }
}), Kte = /* @__PURE__ */ Ue.mark({ class: "cm-matchingBracket" }), Jte = /* @__PURE__ */ Ue.mark({ class: "cm-nonmatchingBracket" });
function ene(t) {
  let e = [], n = t.matched ? Kte : Jte;
  return e.push(n.range(t.start.from, t.start.to)), t.end && e.push(n.range(t.end.from, t.end.to)), e;
}
const tne = /* @__PURE__ */ xn.define({
  create() {
    return Ue.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let n = [], i = e.state.facet(ZA);
    for (let r of e.state.selection.ranges) {
      if (!r.empty)
        continue;
      let o = Kr(e.state, r.head, -1, i) || r.head > 0 && Kr(e.state, r.head - 1, 1, i) || i.afterCursor && (Kr(e.state, r.head, 1, i) || r.head < e.state.doc.length && Kr(e.state, r.head + 1, -1, i));
      o && (n = n.concat(i.renderMatch(o, e.state)));
    }
    return Ue.set(n, !0);
  },
  provide: (t) => Le.decorations.from(t)
}), nne = [
  tne,
  Gte
];
function ine(t = {}) {
  return [ZA.of(t), nne];
}
const FA = /* @__PURE__ */ new dt();
function Oy(t, e, n) {
  let i = t.prop(e < 0 ? dt.openedBy : dt.closedBy);
  if (i)
    return i;
  if (t.name.length == 1) {
    let r = n.indexOf(t.name);
    if (r > -1 && r % 2 == (e < 0 ? 1 : 0))
      return [n[r + e]];
  }
  return null;
}
function vy(t) {
  let e = t.type.prop(FA);
  return e ? e(t.node) : t;
}
function Kr(t, e, n, i = {}) {
  let r = i.maxScanDistance || VA, o = i.brackets || BA, s = hn(t), a = s.resolveInner(e, n);
  for (let l = a; l; l = l.parent) {
    let u = Oy(l.type, n, o);
    if (u && l.from < l.to) {
      let c = vy(l);
      if (c && (n > 0 ? e >= c.from && e < c.to : e > c.from && e <= c.to))
        return rne(t, e, n, l, c, u, o);
    }
  }
  return one(t, e, n, s, a.type, r, o);
}
function rne(t, e, n, i, r, o, s) {
  let a = i.parent, l = { from: r.from, to: r.to }, u = 0, c = a == null ? void 0 : a.cursor();
  if (c && (n < 0 ? c.childBefore(i.from) : c.childAfter(i.to)))
    do
      if (n < 0 ? c.to <= i.from : c.from >= i.to) {
        if (u == 0 && o.indexOf(c.type.name) > -1 && c.from < c.to) {
          let d = vy(c);
          return { start: l, end: d ? { from: d.from, to: d.to } : void 0, matched: !0 };
        } else if (Oy(c.type, n, s))
          u++;
        else if (Oy(c.type, -n, s)) {
          if (u == 0) {
            let d = vy(c);
            return {
              start: l,
              end: d && d.from < d.to ? { from: d.from, to: d.to } : void 0,
              matched: !1
            };
          }
          u--;
        }
      }
    while (n < 0 ? c.prevSibling() : c.nextSibling());
  return { start: l, matched: !1 };
}
function one(t, e, n, i, r, o, s) {
  let a = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), l = s.indexOf(a);
  if (l < 0 || l % 2 == 0 != n > 0)
    return null;
  let u = { from: n < 0 ? e - 1 : e, to: n > 0 ? e + 1 : e }, c = t.doc.iterRange(e, n > 0 ? t.doc.length : 0), d = 0;
  for (let h = 0; !c.next().done && h <= o; ) {
    let f = c.value;
    n < 0 && (h += f.length);
    let p = e + h * n;
    for (let m = n > 0 ? 0 : f.length - 1, g = n > 0 ? f.length : -1; m != g; m += n) {
      let O = s.indexOf(f[m]);
      if (!(O < 0 || i.resolveInner(p + m, 1).type != r))
        if (O % 2 == 0 == n > 0)
          d++;
        else {
          if (d == 1)
            return { start: u, end: { from: p + m, to: p + m + 1 }, matched: O >> 1 == l >> 1 };
          d--;
        }
    }
    n > 0 && (h += f.length);
  }
  return c.done ? { start: u, matched: !1 } : null;
}
const sne = /* @__PURE__ */ Object.create(null), q_ = [pi.none], W_ = [], X_ = /* @__PURE__ */ Object.create(null), ane = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  ane[t] = /* @__PURE__ */ lne(sne, e);
function tO(t, e) {
  W_.indexOf(t) > -1 || (W_.push(t), console.warn(e));
}
function lne(t, e) {
  let n = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let u of a.split(".")) {
      let c = t[u] || ee[u];
      c ? typeof c == "function" ? l.length ? l = l.map(c) : tO(u, `Modifier ${u} used at start of tag`) : l.length ? tO(u, `Tag ${u} used as modifier`) : l = Array.isArray(c) ? c : [c] : tO(u, `Unknown highlighting tag ${u}`);
    }
    for (let u of l)
      n.push(u);
  }
  if (!n.length)
    return 0;
  let i = e.replace(/ /g, "_"), r = i + " " + n.map((a) => a.id), o = X_[r];
  if (o)
    return o.id;
  let s = X_[r] = pi.define({
    id: q_.length,
    name: i,
    props: [Cm({ [i]: n })]
  });
  return q_.push(s), s.id;
}
Yt.RTL, Yt.LTR;
const une = (t) => {
  let { state: e } = t, n = e.doc.lineAt(e.selection.main.from), i = R0(t.state, n.from);
  return i.line ? cne(t) : i.block ? hne(t) : !1;
};
function A0(t, e) {
  return ({ state: n, dispatch: i }) => {
    if (n.readOnly)
      return !1;
    let r = t(e, n);
    return r ? (i(n.update(r)), !0) : !1;
  };
}
const cne = /* @__PURE__ */ A0(
  mne,
  0
  /* CommentOption.Toggle */
), dne = /* @__PURE__ */ A0(
  qA,
  0
  /* CommentOption.Toggle */
), hne = /* @__PURE__ */ A0(
  (t, e) => qA(t, e, pne(e)),
  0
  /* CommentOption.Toggle */
);
function R0(t, e) {
  let n = t.languageDataAt("commentTokens", e);
  return n.length ? n[0] : {};
}
const qu = 50;
function fne(t, { open: e, close: n }, i, r) {
  let o = t.sliceDoc(i - qu, i), s = t.sliceDoc(r, r + qu), a = /\s*$/.exec(o)[0].length, l = /^\s*/.exec(s)[0].length, u = o.length - a;
  if (o.slice(u - e.length, u) == e && s.slice(l, l + n.length) == n)
    return {
      open: { pos: i - a, margin: a && 1 },
      close: { pos: r + l, margin: l && 1 }
    };
  let c, d;
  r - i <= 2 * qu ? c = d = t.sliceDoc(i, r) : (c = t.sliceDoc(i, i + qu), d = t.sliceDoc(r - qu, r));
  let h = /^\s*/.exec(c)[0].length, f = /\s*$/.exec(d)[0].length, p = d.length - f - n.length;
  return c.slice(h, h + e.length) == e && d.slice(p, p + n.length) == n ? {
    open: {
      pos: i + h + e.length,
      margin: /\s/.test(c.charAt(h + e.length)) ? 1 : 0
    },
    close: {
      pos: r - f - n.length,
      margin: /\s/.test(d.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function pne(t) {
  let e = [];
  for (let n of t.selection.ranges) {
    let i = t.doc.lineAt(n.from), r = n.to <= i.to ? i : t.doc.lineAt(n.to);
    r.from > i.from && r.from == n.to && (r = n.to == i.to + 1 ? i : t.doc.lineAt(n.to - 1));
    let o = e.length - 1;
    o >= 0 && e[o].to > i.from ? e[o].to = r.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: r.to });
  }
  return e;
}
function qA(t, e, n = e.selection.ranges) {
  let i = n.map((o) => R0(e, o.from).block);
  if (!i.every((o) => o))
    return null;
  let r = n.map((o, s) => fne(e, i[s], o.from, o.to));
  if (t != 2 && !r.every((o) => o))
    return { changes: e.changes(n.map((o, s) => r[s] ? [] : [{ from: o.from, insert: i[s].open + " " }, { from: o.to, insert: " " + i[s].close }])) };
  if (t != 1 && r.some((o) => o)) {
    let o = [];
    for (let s = 0, a; s < r.length; s++)
      if (a = r[s]) {
        let l = i[s], { open: u, close: c } = a;
        o.push({ from: u.pos - l.open.length, to: u.pos + u.margin }, { from: c.pos - c.margin, to: c.pos + l.close.length });
      }
    return { changes: o };
  }
  return null;
}
function mne(t, e, n = e.selection.ranges) {
  let i = [], r = -1;
  for (let { from: o, to: s } of n) {
    let a = i.length, l = 1e9, u = R0(e, o).line;
    if (u) {
      for (let c = o; c <= s; ) {
        let d = e.doc.lineAt(c);
        if (d.from > r && (o == s || s > d.from)) {
          r = d.from;
          let h = /^\s*/.exec(d.text)[0].length, f = h == d.length, p = d.text.slice(h, h + u.length) == u ? h : -1;
          h < d.text.length && h < l && (l = h), i.push({ line: d, comment: p, token: u, indent: h, empty: f, single: !1 });
        }
        c = d.to + 1;
      }
      if (l < 1e9)
        for (let c = a; c < i.length; c++)
          i[c].indent < i[c].line.text.length && (i[c].indent = l);
      i.length == a + 1 && (i[a].single = !0);
    }
  }
  if (t != 2 && i.some((o) => o.comment < 0 && (!o.empty || o.single))) {
    let o = [];
    for (let { line: a, token: l, indent: u, empty: c, single: d } of i)
      (d || !c) && o.push({ from: a.from + u, insert: l + " " });
    let s = e.changes(o);
    return { changes: s, selection: e.selection.map(s, 1) };
  } else if (t != 1 && i.some((o) => o.comment >= 0)) {
    let o = [];
    for (let { line: s, comment: a, token: l } of i)
      if (a >= 0) {
        let u = s.from + a, c = u + l.length;
        s.text[c - s.from] == " " && c++, o.push({ from: u, to: c });
      }
    return { changes: o };
  }
  return null;
}
const yy = /* @__PURE__ */ Uo.define(), gne = /* @__PURE__ */ Uo.define(), One = /* @__PURE__ */ Ze.define(), WA = /* @__PURE__ */ Ze.define({
  combine(t) {
    return Er(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, n) => n
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, n) => (i, r) => e(i, r) || n(i, r)
    });
  }
}), XA = /* @__PURE__ */ xn.define({
  create() {
    return Jr.empty;
  },
  update(t, e) {
    let n = e.state.facet(WA), i = e.annotation(yy);
    if (i) {
      let l = Si.fromTransaction(e, i.selection), u = i.side, c = u == 0 ? t.undone : t.done;
      return l ? c = wp(c, c.length, n.minDepth, l) : c = HA(c, e.startState.selection), new Jr(u == 0 ? i.rest : c, u == 0 ? c : i.rest);
    }
    let r = e.annotation(gne);
    if ((r == "full" || r == "before") && (t = t.isolate()), e.annotation(Sn.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let o = Si.fromTransaction(e), s = e.annotation(Sn.time), a = e.annotation(Sn.userEvent);
    return o ? t = t.addChanges(o, s, a, n, e) : e.selection && (t = t.addSelection(e.startState.selection, s, a, n.newGroupDelay)), (r == "full" || r == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new Jr(t.done.map(Si.fromJSON), t.undone.map(Si.fromJSON));
  }
});
function zA(t = {}) {
  return [
    XA,
    WA.of(t),
    Le.domEventHandlers({
      beforeinput(e, n) {
        let i = e.inputType == "historyUndo" ? jA : e.inputType == "historyRedo" ? by : null;
        return i ? (e.preventDefault(), i(n)) : !1;
      }
    })
  ];
}
function Am(t, e) {
  return function({ state: n, dispatch: i }) {
    if (!e && n.readOnly)
      return !1;
    let r = n.field(XA, !1);
    if (!r)
      return !1;
    let o = r.pop(t, n, e);
    return o ? (i(o), !0) : !1;
  };
}
const jA = /* @__PURE__ */ Am(0, !1), by = /* @__PURE__ */ Am(1, !1), vne = /* @__PURE__ */ Am(0, !0), yne = /* @__PURE__ */ Am(1, !0);
class Si {
  constructor(e, n, i, r, o) {
    this.changes = e, this.effects = n, this.mapped = i, this.startSelection = r, this.selectionsAfter = o;
  }
  setSelAfter(e) {
    return new Si(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, n, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((r) => r.toJSON())
    };
  }
  static fromJSON(e) {
    return new Si(e.changes && Cn.fromJSON(e.changes), [], e.mapped && ro.fromJSON(e.mapped), e.startSelection && ve.fromJSON(e.startSelection), e.selectionsAfter.map(ve.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, n) {
    let i = Ki;
    for (let r of e.startState.facet(One)) {
      let o = r(e);
      o.length && (i = i.concat(o));
    }
    return !i.length && e.changes.empty ? null : new Si(e.changes.invert(e.startState.doc), i, void 0, n || e.startState.selection, Ki);
  }
  static selection(e) {
    return new Si(void 0, Ki, void 0, void 0, e);
  }
}
function wp(t, e, n, i) {
  let r = e + 1 > n + 20 ? e - n - 1 : 0, o = t.slice(r, e);
  return o.push(i), o;
}
function bne(t, e) {
  let n = [], i = !1;
  return t.iterChangedRanges((r, o) => n.push(r, o)), e.iterChangedRanges((r, o, s, a) => {
    for (let l = 0; l < n.length; ) {
      let u = n[l++], c = n[l++];
      a >= u && s <= c && (i = !0);
    }
  }), i;
}
function wne(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((n, i) => n.empty != e.ranges[i].empty).length === 0;
}
function YA(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const Ki = [], kne = 200;
function HA(t, e) {
  if (t.length) {
    let n = t[t.length - 1], i = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - kne));
    return i.length && i[i.length - 1].eq(e) ? t : (i.push(e), wp(t, t.length - 1, 1e9, n.setSelAfter(i)));
  } else
    return [Si.selection([e])];
}
function Sne(t) {
  let e = t[t.length - 1], n = t.slice();
  return n[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), n;
}
function nO(t, e) {
  if (!t.length)
    return t;
  let n = t.length, i = Ki;
  for (; n; ) {
    let r = _ne(t[n - 1], e, i);
    if (r.changes && !r.changes.empty || r.effects.length) {
      let o = t.slice(0, n);
      return o[n - 1] = r, o;
    } else
      e = r.mapped, n--, i = r.selectionsAfter;
  }
  return i.length ? [Si.selection(i)] : Ki;
}
function _ne(t, e, n) {
  let i = YA(t.selectionsAfter.length ? t.selectionsAfter.map((a) => a.map(e)) : Ki, n);
  if (!t.changes)
    return Si.selection(i);
  let r = t.changes.map(e), o = e.mapDesc(t.changes, !0), s = t.mapped ? t.mapped.composeDesc(o) : o;
  return new Si(r, ot.mapEffects(t.effects, e), s, t.startSelection.map(o), i);
}
const xne = /^(input\.type|delete)($|\.)/;
class Jr {
  constructor(e, n, i = 0, r = void 0) {
    this.done = e, this.undone = n, this.prevTime = i, this.prevUserEvent = r;
  }
  isolate() {
    return this.prevTime ? new Jr(this.done, this.undone) : this;
  }
  addChanges(e, n, i, r, o) {
    let s = this.done, a = s[s.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!i || xne.test(i)) && (!a.selectionsAfter.length && n - this.prevTime < r.newGroupDelay && r.joinToEvent(o, bne(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? s = wp(s, s.length - 1, r.minDepth, new Si(e.changes.compose(a.changes), YA(ot.mapEffects(e.effects, a.changes), a.effects), a.mapped, a.startSelection, Ki)) : s = wp(s, s.length, r.minDepth, e), new Jr(s, Ki, n, i);
  }
  addSelection(e, n, i, r) {
    let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Ki;
    return o.length > 0 && n - this.prevTime < r && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && wne(o[o.length - 1], e) ? this : new Jr(HA(this.done, e), this.undone, n, i);
  }
  addMapping(e) {
    return new Jr(nO(this.done, e), nO(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, n, i) {
    let r = e == 0 ? this.done : this.undone;
    if (r.length == 0)
      return null;
    let o = r[r.length - 1], s = o.selectionsAfter[0] || n.selection;
    if (i && o.selectionsAfter.length)
      return n.update({
        selection: o.selectionsAfter[o.selectionsAfter.length - 1],
        annotations: yy.of({ side: e, rest: Sne(r), selection: s }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (o.changes) {
      let a = r.length == 1 ? Ki : r.slice(0, r.length - 1);
      return o.mapped && (a = nO(a, o.mapped)), n.update({
        changes: o.changes,
        selection: o.startSelection,
        effects: o.effects,
        annotations: yy.of({ side: e, rest: a, selection: s }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Jr.empty = /* @__PURE__ */ new Jr(Ki, Ki);
const UA = [
  { key: "Mod-z", run: jA, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: by, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: by, preventDefault: !0 },
  { key: "Mod-u", run: vne, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: yne, preventDefault: !0 }
];
function Su(t, e) {
  return ve.create(t.ranges.map(e), t.mainIndex);
}
function go(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Ar({ state: t, dispatch: e }, n) {
  let i = Su(t.selection, n);
  return i.eq(t.selection, !0) ? !1 : (e(go(t, i)), !0);
}
function Rm(t, e) {
  return ve.cursor(e ? t.to : t.from);
}
function GA(t, e) {
  return Ar(t, (n) => n.empty ? t.moveByChar(n, e) : Rm(n, e));
}
function ei(t) {
  return t.textDirectionAt(t.state.selection.main.head) == Yt.LTR;
}
const KA = (t) => GA(t, !ei(t)), JA = (t) => GA(t, ei(t));
function eR(t, e) {
  return Ar(t, (n) => n.empty ? t.moveByGroup(n, e) : Rm(n, e));
}
const Cne = (t) => eR(t, !ei(t)), Tne = (t) => eR(t, ei(t));
function $ne(t, e, n) {
  if (e.type.prop(n))
    return !0;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Dm(t, e, n) {
  let i = hn(t).resolveInner(e.head), r = n ? dt.closedBy : dt.openedBy;
  for (let l = e.head; ; ) {
    let u = n ? i.childAfter(l) : i.childBefore(l);
    if (!u)
      break;
    $ne(t, u, r) ? i = u : l = n ? u.to : u.from;
  }
  let o = i.type.prop(r), s, a;
  return o && (s = n ? Kr(t, i.from, 1) : Kr(t, i.to, -1)) && s.matched ? a = n ? s.end.to : s.end.from : a = n ? i.to : i.from, ve.cursor(a, n ? -1 : 1);
}
const Pne = (t) => Ar(t, (e) => Dm(t.state, e, !ei(t))), Mne = (t) => Ar(t, (e) => Dm(t.state, e, ei(t)));
function tR(t, e) {
  return Ar(t, (n) => {
    if (!n.empty)
      return Rm(n, e);
    let i = t.moveVertically(n, e);
    return i.head != n.head ? i : t.moveToLineBoundary(n, e);
  });
}
const nR = (t) => tR(t, !1), iR = (t) => tR(t, !0);
function rR(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, n = 0, i = 0, r;
  if (e) {
    for (let o of t.state.facet(Le.scrollMargins)) {
      let s = o(t);
      s != null && s.top && (n = Math.max(s == null ? void 0 : s.top, n)), s != null && s.bottom && (i = Math.max(s == null ? void 0 : s.bottom, i));
    }
    r = t.scrollDOM.clientHeight - n - i;
  } else
    r = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: n,
    marginBottom: i,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, r - 5)
  };
}
function oR(t, e) {
  let n = rR(t), { state: i } = t, r = Su(i.selection, (s) => s.empty ? t.moveVertically(s, e, n.height) : Rm(s, e));
  if (r.eq(i.selection))
    return !1;
  let o;
  if (n.selfScroll) {
    let s = t.coordsAtPos(i.selection.main.head), a = t.scrollDOM.getBoundingClientRect(), l = a.top + n.marginTop, u = a.bottom - n.marginBottom;
    s && s.top > l && s.bottom < u && (o = Le.scrollIntoView(r.main.head, { y: "start", yMargin: s.top - l }));
  }
  return t.dispatch(go(i, r), { effects: o }), !0;
}
const z_ = (t) => oR(t, !1), wy = (t) => oR(t, !0);
function Gs(t, e, n) {
  let i = t.lineBlockAt(e.head), r = t.moveToLineBoundary(e, n);
  if (r.head == e.head && r.head != (n ? i.to : i.from) && (r = t.moveToLineBoundary(e, n, !1)), !n && r.head == i.from && i.length) {
    let o = /^\s*/.exec(t.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    o && e.head != i.from + o && (r = ve.cursor(i.from + o));
  }
  return r;
}
const Ene = (t) => Ar(t, (e) => Gs(t, e, !0)), Ane = (t) => Ar(t, (e) => Gs(t, e, !1)), Rne = (t) => Ar(t, (e) => Gs(t, e, !ei(t))), Dne = (t) => Ar(t, (e) => Gs(t, e, ei(t))), Qne = (t) => Ar(t, (e) => ve.cursor(t.lineBlockAt(e.head).from, 1)), Nne = (t) => Ar(t, (e) => ve.cursor(t.lineBlockAt(e.head).to, -1));
function Ine(t, e, n) {
  let i = !1, r = Su(t.selection, (o) => {
    let s = Kr(t, o.head, -1) || Kr(t, o.head, 1) || o.head > 0 && Kr(t, o.head - 1, 1) || o.head < t.doc.length && Kr(t, o.head + 1, -1);
    if (!s || !s.end)
      return o;
    i = !0;
    let a = s.start.from == o.head ? s.end.to : s.end.from;
    return n ? ve.range(o.anchor, a) : ve.cursor(a);
  });
  return i ? (e(go(t, r)), !0) : !1;
}
const Lne = ({ state: t, dispatch: e }) => Ine(t, e, !1);
function lr(t, e) {
  let n = Su(t.state.selection, (i) => {
    let r = e(i);
    return ve.range(i.anchor, r.head, r.goalColumn, r.bidiLevel || void 0);
  });
  return n.eq(t.state.selection) ? !1 : (t.dispatch(go(t.state, n)), !0);
}
function sR(t, e) {
  return lr(t, (n) => t.moveByChar(n, e));
}
const aR = (t) => sR(t, !ei(t)), lR = (t) => sR(t, ei(t));
function uR(t, e) {
  return lr(t, (n) => t.moveByGroup(n, e));
}
const Vne = (t) => uR(t, !ei(t)), Bne = (t) => uR(t, ei(t)), Zne = (t) => lr(t, (e) => Dm(t.state, e, !ei(t))), Fne = (t) => lr(t, (e) => Dm(t.state, e, ei(t)));
function cR(t, e) {
  return lr(t, (n) => t.moveVertically(n, e));
}
const dR = (t) => cR(t, !1), hR = (t) => cR(t, !0);
function fR(t, e) {
  return lr(t, (n) => t.moveVertically(n, e, rR(t).height));
}
const j_ = (t) => fR(t, !1), Y_ = (t) => fR(t, !0), qne = (t) => lr(t, (e) => Gs(t, e, !0)), Wne = (t) => lr(t, (e) => Gs(t, e, !1)), Xne = (t) => lr(t, (e) => Gs(t, e, !ei(t))), zne = (t) => lr(t, (e) => Gs(t, e, ei(t))), jne = (t) => lr(t, (e) => ve.cursor(t.lineBlockAt(e.head).from)), Yne = (t) => lr(t, (e) => ve.cursor(t.lineBlockAt(e.head).to)), H_ = ({ state: t, dispatch: e }) => (e(go(t, { anchor: 0 })), !0), U_ = ({ state: t, dispatch: e }) => (e(go(t, { anchor: t.doc.length })), !0), G_ = ({ state: t, dispatch: e }) => (e(go(t, { anchor: t.selection.main.anchor, head: 0 })), !0), K_ = ({ state: t, dispatch: e }) => (e(go(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), Hne = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), Une = ({ state: t, dispatch: e }) => {
  let n = Qm(t).map(({ from: i, to: r }) => ve.range(i, Math.min(r + 1, t.doc.length)));
  return e(t.update({ selection: ve.create(n), userEvent: "select" })), !0;
}, Gne = ({ state: t, dispatch: e }) => {
  let n = Su(t.selection, (i) => {
    let r = hn(t), o = r.resolveStack(i.from, 1);
    if (i.empty) {
      let s = r.resolveStack(i.from, -1);
      s.node.from >= o.node.from && s.node.to <= o.node.to && (o = s);
    }
    for (let s = o; s; s = s.next) {
      let { node: a } = s;
      if ((a.from < i.from && a.to >= i.to || a.to > i.to && a.from <= i.from) && s.next)
        return ve.range(a.to, a.from);
    }
    return i;
  });
  return n.eq(t.selection) ? !1 : (e(go(t, n)), !0);
}, Kne = ({ state: t, dispatch: e }) => {
  let n = t.selection, i = null;
  return n.ranges.length > 1 ? i = ve.create([n.main]) : n.main.empty || (i = ve.create([ve.cursor(n.main.head)])), i ? (e(go(t, i)), !0) : !1;
};
function Vd(t, e) {
  if (t.state.readOnly)
    return !1;
  let n = "delete.selection", { state: i } = t, r = i.changeByRange((o) => {
    let { from: s, to: a } = o;
    if (s == a) {
      let l = e(o);
      l < s ? (n = "delete.backward", l = Ch(t, l, !1)) : l > s && (n = "delete.forward", l = Ch(t, l, !0)), s = Math.min(s, l), a = Math.max(a, l);
    } else
      s = Ch(t, s, !1), a = Ch(t, a, !0);
    return s == a ? { range: o } : { changes: { from: s, to: a }, range: ve.cursor(s, s < o.head ? -1 : 1) };
  });
  return r.changes.empty ? !1 : (t.dispatch(i.update(r, {
    scrollIntoView: !0,
    userEvent: n,
    effects: n == "delete.selection" ? Le.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function Ch(t, e, n) {
  if (t instanceof Le)
    for (let i of t.state.facet(Le.atomicRanges).map((r) => r(t)))
      i.between(e, e, (r, o) => {
        r < e && o > e && (e = n ? o : r);
      });
  return e;
}
const pR = (t, e, n) => Vd(t, (i) => {
  let r = i.from, { state: o } = t, s = o.doc.lineAt(r), a, l;
  if (n && !e && r > s.from && r < s.from + 200 && !/[^ \t]/.test(a = s.text.slice(0, r - s.from))) {
    if (a[a.length - 1] == "	")
      return r - 1;
    let u = wu(a, o.tabSize), c = u % vp(o) || vp(o);
    for (let d = 0; d < c && a[a.length - 1 - d] == " "; d++)
      r--;
    l = r;
  } else
    l = Zn(s.text, r - s.from, e, e) + s.from, l == r && s.number != (e ? o.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(l - s.from, r - s.from)) && (l = Zn(s.text, l - s.from, !1, !1) + s.from);
  return l;
}), ky = (t) => pR(t, !1, !0), mR = (t) => pR(t, !0, !1), gR = (t, e) => Vd(t, (n) => {
  let i = n.head, { state: r } = t, o = r.doc.lineAt(i), s = r.charCategorizer(i);
  for (let a = null; ; ) {
    if (i == (e ? o.to : o.from)) {
      i == n.head && o.number != (e ? r.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let l = Zn(o.text, i - o.from, e) + o.from, u = o.text.slice(Math.min(i, l) - o.from, Math.max(i, l) - o.from), c = s(u);
    if (a != null && c != a)
      break;
    (u != " " || i != n.head) && (a = c), i = l;
  }
  return i;
}), OR = (t) => gR(t, !1), Jne = (t) => gR(t, !0), eie = (t) => Vd(t, (e) => {
  let n = t.lineBlockAt(e.head).to;
  return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
}), tie = (t) => Vd(t, (e) => {
  let n = t.moveToLineBoundary(e, !1).head;
  return e.head > n ? n : Math.max(0, e.head - 1);
}), nie = (t) => Vd(t, (e) => {
  let n = t.moveToLineBoundary(e, !0).head;
  return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
}), iie = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = t.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: St.of(["", ""]) },
    range: ve.cursor(i.from)
  }));
  return e(t.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
}, rie = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = t.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == t.doc.length)
      return { range: i };
    let r = i.from, o = t.doc.lineAt(r), s = r == o.from ? r - 1 : Zn(o.text, r - o.from, !1) + o.from, a = r == o.to ? r + 1 : Zn(o.text, r - o.from, !0) + o.from;
    return {
      changes: { from: s, to: a, insert: t.doc.slice(r, a).append(t.doc.slice(s, r)) },
      range: ve.cursor(a)
    };
  });
  return n.changes.empty ? !1 : (e(t.update(n, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Qm(t) {
  let e = [], n = -1;
  for (let i of t.selection.ranges) {
    let r = t.doc.lineAt(i.from), o = t.doc.lineAt(i.to);
    if (!i.empty && i.to == o.from && (o = t.doc.lineAt(i.to - 1)), n >= r.number) {
      let s = e[e.length - 1];
      s.to = o.to, s.ranges.push(i);
    } else
      e.push({ from: r.from, to: o.to, ranges: [i] });
    n = o.number + 1;
  }
  return e;
}
function vR(t, e, n) {
  if (t.readOnly)
    return !1;
  let i = [], r = [];
  for (let o of Qm(t)) {
    if (n ? o.to == t.doc.length : o.from == 0)
      continue;
    let s = t.doc.lineAt(n ? o.to + 1 : o.from - 1), a = s.length + 1;
    if (n) {
      i.push({ from: o.to, to: s.to }, { from: o.from, insert: s.text + t.lineBreak });
      for (let l of o.ranges)
        r.push(ve.range(Math.min(t.doc.length, l.anchor + a), Math.min(t.doc.length, l.head + a)));
    } else {
      i.push({ from: s.from, to: o.from }, { from: o.to, insert: t.lineBreak + s.text });
      for (let l of o.ranges)
        r.push(ve.range(l.anchor - a, l.head - a));
    }
  }
  return i.length ? (e(t.update({
    changes: i,
    scrollIntoView: !0,
    selection: ve.create(r, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const oie = ({ state: t, dispatch: e }) => vR(t, e, !1), sie = ({ state: t, dispatch: e }) => vR(t, e, !0);
function yR(t, e, n) {
  if (t.readOnly)
    return !1;
  let i = [];
  for (let r of Qm(t))
    n ? i.push({ from: r.from, insert: t.doc.slice(r.from, r.to) + t.lineBreak }) : i.push({ from: r.to, insert: t.lineBreak + t.doc.slice(r.from, r.to) });
  return e(t.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const aie = ({ state: t, dispatch: e }) => yR(t, e, !1), lie = ({ state: t, dispatch: e }) => yR(t, e, !0), uie = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, n = e.changes(Qm(e).map(({ from: r, to: o }) => (r > 0 ? r-- : o < e.doc.length && o++, { from: r, to: o }))), i = Su(e.selection, (r) => {
    let o;
    if (t.lineWrapping) {
      let s = t.lineBlockAt(r.head), a = t.coordsAtPos(r.head, r.assoc || 1);
      a && (o = s.bottom + t.documentTop - a.bottom + t.defaultLineHeight / 2);
    }
    return t.moveVertically(r, !0, o);
  }).map(n);
  return t.dispatch({ changes: n, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function cie(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let n = hn(t).resolveInner(e), i = n.childBefore(e), r = n.childAfter(e), o;
  return i && r && i.to <= e && r.from >= e && (o = i.type.prop(dt.closedBy)) && o.indexOf(r.name) > -1 && t.doc.lineAt(i.to).from == t.doc.lineAt(r.from).from && !/\S/.test(t.sliceDoc(i.to, r.from)) ? { from: i.to, to: r.from } : null;
}
const J_ = /* @__PURE__ */ bR(!1), die = /* @__PURE__ */ bR(!0);
function bR(t) {
  return ({ state: e, dispatch: n }) => {
    if (e.readOnly)
      return !1;
    let i = e.changeByRange((r) => {
      let { from: o, to: s } = r, a = e.doc.lineAt(o), l = !t && o == s && cie(e, o);
      t && (o = s = (s <= a.to ? a : e.doc.lineAt(s)).to);
      let u = new Tm(e, { simulateBreak: o, simulateDoubleBreak: !!l }), c = P0(u, o);
      for (c == null && (c = wu(/^\s*/.exec(e.doc.lineAt(o).text)[0], e.tabSize)); s < a.to && /\s/.test(a.text[s - a.from]); )
        s++;
      l ? { from: o, to: s } = l : o > a.from && o < a.from + 100 && !/\S/.test(a.text.slice(0, o)) && (o = a.from);
      let d = ["", dd(e, c)];
      return l && d.push(dd(e, u.lineIndent(a.from, -1))), {
        changes: { from: o, to: s, insert: St.of(d) },
        range: ve.cursor(o + 1 + d[1].length)
      };
    });
    return n(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function D0(t, e) {
  let n = -1;
  return t.changeByRange((i) => {
    let r = [];
    for (let s = i.from; s <= i.to; ) {
      let a = t.doc.lineAt(s);
      a.number > n && (i.empty || i.to > a.from) && (e(a, r, i), n = a.number), s = a.to + 1;
    }
    let o = t.changes(r);
    return {
      changes: r,
      range: ve.range(o.mapPos(i.anchor, 1), o.mapPos(i.head, 1))
    };
  });
}
const hie = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = /* @__PURE__ */ Object.create(null), i = new Tm(t, { overrideIndentation: (o) => {
    let s = n[o];
    return s ?? -1;
  } }), r = D0(t, (o, s, a) => {
    let l = P0(i, o.from);
    if (l == null)
      return;
    /\S/.test(o.text) || (l = 0);
    let u = /^\s*/.exec(o.text)[0], c = dd(t, l);
    (u != c || a.from < o.from + u.length) && (n[o.from] = l, s.push({ from: o.from, to: o.from + u.length, insert: c }));
  });
  return r.changes.empty || e(t.update(r, { userEvent: "indent" })), !0;
}, wR = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(D0(t, (n, i) => {
  i.push({ from: n.from, insert: t.facet(Id) });
}), { userEvent: "input.indent" })), !0), kR = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(D0(t, (n, i) => {
  let r = /^\s*/.exec(n.text)[0];
  if (!r)
    return;
  let o = wu(r, t.tabSize), s = 0, a = dd(t, Math.max(0, o - vp(t)));
  for (; s < r.length && s < a.length && r.charCodeAt(s) == a.charCodeAt(s); )
    s++;
  i.push({ from: n.from + s, to: n.from + r.length, insert: a.slice(s) });
}), { userEvent: "delete.dedent" })), !0), fie = (t) => (t.setTabFocusMode(), !0), pie = [
  { key: "Ctrl-b", run: KA, shift: aR, preventDefault: !0 },
  { key: "Ctrl-f", run: JA, shift: lR },
  { key: "Ctrl-p", run: nR, shift: dR },
  { key: "Ctrl-n", run: iR, shift: hR },
  { key: "Ctrl-a", run: Qne, shift: jne },
  { key: "Ctrl-e", run: Nne, shift: Yne },
  { key: "Ctrl-d", run: mR },
  { key: "Ctrl-h", run: ky },
  { key: "Ctrl-k", run: eie },
  { key: "Ctrl-Alt-h", run: OR },
  { key: "Ctrl-o", run: iie },
  { key: "Ctrl-t", run: rie },
  { key: "Ctrl-v", run: wy }
], mie = /* @__PURE__ */ [
  { key: "ArrowLeft", run: KA, shift: aR, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: Cne, shift: Vne, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: Rne, shift: Xne, preventDefault: !0 },
  { key: "ArrowRight", run: JA, shift: lR, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: Tne, shift: Bne, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: Dne, shift: zne, preventDefault: !0 },
  { key: "ArrowUp", run: nR, shift: dR, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: H_, shift: G_ },
  { mac: "Ctrl-ArrowUp", run: z_, shift: j_ },
  { key: "ArrowDown", run: iR, shift: hR, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: U_, shift: K_ },
  { mac: "Ctrl-ArrowDown", run: wy, shift: Y_ },
  { key: "PageUp", run: z_, shift: j_ },
  { key: "PageDown", run: wy, shift: Y_ },
  { key: "Home", run: Ane, shift: Wne, preventDefault: !0 },
  { key: "Mod-Home", run: H_, shift: G_ },
  { key: "End", run: Ene, shift: qne, preventDefault: !0 },
  { key: "Mod-End", run: U_, shift: K_ },
  { key: "Enter", run: J_, shift: J_ },
  { key: "Mod-a", run: Hne },
  { key: "Backspace", run: ky, shift: ky },
  { key: "Delete", run: mR },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: OR },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Jne },
  { mac: "Mod-Backspace", run: tie },
  { mac: "Mod-Delete", run: nie }
].concat(/* @__PURE__ */ pie.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), SR = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: Pne, shift: Zne },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: Mne, shift: Fne },
  { key: "Alt-ArrowUp", run: oie },
  { key: "Shift-Alt-ArrowUp", run: aie },
  { key: "Alt-ArrowDown", run: sie },
  { key: "Shift-Alt-ArrowDown", run: lie },
  { key: "Escape", run: Kne },
  { key: "Mod-Enter", run: die },
  { key: "Alt-l", mac: "Ctrl-l", run: Une },
  { key: "Mod-i", run: Gne, preventDefault: !0 },
  { key: "Mod-[", run: kR },
  { key: "Mod-]", run: wR },
  { key: "Mod-Alt-\\", run: hie },
  { key: "Shift-Mod-k", run: uie },
  { key: "Shift-Mod-\\", run: Lne },
  { key: "Mod-/", run: une },
  { key: "Alt-A", run: dne },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: fie }
].concat(mie), gie = { key: "Tab", run: wR, shift: kR };
function Vt() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var i in n)
      if (Object.prototype.hasOwnProperty.call(n, i)) {
        var r = n[i];
        typeof r == "string" ? t.setAttribute(i, r) : r != null && (t[i] = r);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    _R(t, arguments[e]);
  return t;
}
function _R(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      t.appendChild(e);
    else if (Array.isArray(e))
      for (var n = 0; n < e.length; n++)
        _R(t, e[n]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
class ex {
  constructor(e, n, i) {
    this.from = e, this.to = n, this.diagnostic = i;
  }
}
class la {
  constructor(e, n, i) {
    this.diagnostics = e, this.panel = n, this.selected = i;
  }
  static init(e, n, i) {
    let r = e, o = i.facet(eo).markerFilter;
    o && (r = o(r, i));
    let s = e.slice().sort((d, h) => d.from - h.from || d.to - h.to), a = new Wo(), l = [], u = 0;
    for (let d = 0; ; ) {
      let h = d == s.length ? null : s[d];
      if (!h && !l.length)
        break;
      let f, p;
      for (l.length ? (f = u, p = l.reduce((g, O) => Math.min(g, O.to), h && h.from > f ? h.from : 1e8)) : (f = h.from, p = h.to, l.push(h), d++); d < s.length; ) {
        let g = s[d];
        if (g.from == f && (g.to > g.from || g.to == f))
          l.push(g), d++, p = Math.min(g.to, p);
        else {
          p = Math.min(g.from, p);
          break;
        }
      }
      let m = AR(l);
      if (l.some((g) => g.from == g.to || g.from == g.to - 1 && i.doc.lineAt(g.from).to == g.from))
        a.add(f, f, Ue.widget({
          widget: new Cie(m),
          diagnostics: l.slice()
        }));
      else {
        let g = l.reduce((O, y) => y.markClass ? O + " " + y.markClass : O, "");
        a.add(f, p, Ue.mark({
          class: "cm-lintRange cm-lintRange-" + m + g,
          diagnostics: l.slice(),
          inclusiveEnd: l.some((O) => O.to > p)
        }));
      }
      u = p;
      for (let g = 0; g < l.length; g++)
        l[g].to <= u && l.splice(g--, 1);
    }
    let c = a.finish();
    return new la(c, n, uu(c));
  }
}
function uu(t, e = null, n = 0) {
  let i = null;
  return t.between(n, 1e9, (r, o, { spec: s }) => {
    if (!(e && s.diagnostics.indexOf(e) < 0))
      if (!i)
        i = new ex(r, o, e || s.diagnostics[0]);
      else {
        if (s.diagnostics.indexOf(i.diagnostic) < 0)
          return !1;
        i = new ex(i.from, o, i.diagnostic);
      }
  }), i;
}
function xR(t, e) {
  let n = e.pos, i = e.end || n, r = t.state.facet(eo).hideOn(t, n, i);
  if (r != null)
    return r;
  let o = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((s) => s.is(Nm)) || t.changes.touchesRange(o.from, Math.max(o.to, i)));
}
function CR(t, e) {
  return t.field(_i, !1) ? e : e.concat(ot.appendConfig.of(QR));
}
function Oie(t, e) {
  return {
    effects: CR(t, [Nm.of(e)])
  };
}
const Nm = /* @__PURE__ */ ot.define(), Q0 = /* @__PURE__ */ ot.define(), TR = /* @__PURE__ */ ot.define(), _i = /* @__PURE__ */ xn.define({
  create() {
    return new la(Ue.none, null, null);
  },
  update(t, e) {
    if (e.docChanged && t.diagnostics.size) {
      let n = t.diagnostics.map(e.changes), i = null, r = t.panel;
      if (t.selected) {
        let o = e.changes.mapPos(t.selected.from, 1);
        i = uu(n, t.selected.diagnostic, o) || uu(n, null, o);
      }
      !n.size && r && e.state.facet(eo).autoPanel && (r = null), t = new la(n, r, i);
    }
    for (let n of e.effects)
      if (n.is(Nm)) {
        let i = e.state.facet(eo).autoPanel ? n.value.length ? hd.open : null : t.panel;
        t = la.init(n.value, i, e.state);
      } else
        n.is(Q0) ? t = new la(t.diagnostics, n.value ? hd.open : null, t.selected) : n.is(TR) && (t = new la(t.diagnostics, t.panel, n.value));
    return t;
  },
  provide: (t) => [
    ld.from(t, (e) => e.panel),
    Le.decorations.from(t, (e) => e.diagnostics)
  ]
});
function vie(t) {
  let e = t.field(_i, !1);
  return e ? e.diagnostics.size : 0;
}
const yie = /* @__PURE__ */ Ue.mark({ class: "cm-lintRange cm-lintRange-active" });
function bie(t, e, n) {
  let { diagnostics: i } = t.state.field(_i), r, o = -1, s = -1;
  i.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (l, u, { spec: c }) => {
    if (e >= l && e <= u && (l == u || (e > l || n > 0) && (e < u || n < 0)))
      return r = c.diagnostics, o = l, s = u, !1;
  });
  let a = t.state.facet(eo).tooltipFilter;
  return r && a && (r = a(r, t.state)), r ? {
    pos: o,
    end: s,
    above: t.state.doc.lineAt(o).to < s,
    create() {
      return { dom: $R(t, r) };
    }
  } : null;
}
function $R(t, e) {
  return Vt("ul", { class: "cm-tooltip-lint" }, e.map((n) => ER(t, n, !1)));
}
const wie = (t) => {
  let e = t.state.field(_i, !1);
  (!e || !e.panel) && t.dispatch({ effects: CR(t.state, [Q0.of(!0)]) });
  let n = ad(t, hd.open);
  return n && n.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, tx = (t) => {
  let e = t.state.field(_i, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: Q0.of(!1) }), !0);
}, kie = (t) => {
  let e = t.state.field(_i, !1);
  if (!e)
    return !1;
  let n = t.state.selection.main, i = e.diagnostics.iter(n.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == n.from && i.to == n.to) ? !1 : (t.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, Sie = [
  { key: "Mod-Shift-m", run: wie, preventDefault: !0 },
  { key: "F8", run: kie }
], PR = /* @__PURE__ */ dn.fromClass(class {
  constructor(t) {
    this.view = t, this.timeout = -1, this.set = !0;
    let { delay: e } = t.state.facet(eo);
    this.lintTime = Date.now() + e, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, e);
  }
  run() {
    clearTimeout(this.timeout);
    let t = Date.now();
    if (t < this.lintTime - 10)
      this.timeout = setTimeout(this.run, this.lintTime - t);
    else {
      this.set = !1;
      let { state: e } = this.view, { sources: n } = e.facet(eo);
      n.length && _ie(n.map((i) => Promise.resolve(i(this.view))), (i) => {
        this.view.state.doc == e.doc && this.view.dispatch(Oie(this.view.state, i.reduce((r, o) => r.concat(o))));
      }, (i) => {
        si(this.view.state, i);
      });
    }
  }
  update(t) {
    let e = t.state.facet(eo);
    (t.docChanged || e != t.startState.facet(eo) || e.needsRefresh && e.needsRefresh(t)) && (this.lintTime = Date.now() + e.delay, this.set || (this.set = !0, this.timeout = setTimeout(this.run, e.delay)));
  }
  force() {
    this.set && (this.lintTime = Date.now(), this.run());
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
function _ie(t, e, n) {
  let i = [], r = -1;
  for (let o of t)
    o.then((s) => {
      i.push(s), clearTimeout(r), i.length == t.length ? e(i) : r = setTimeout(() => e(i), 200);
    }, n);
}
const eo = /* @__PURE__ */ Ze.define({
  combine(t) {
    return Object.assign({ sources: t.map((e) => e.source).filter((e) => e != null) }, Er(t.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, n) => e ? n ? (i) => e(i) || n(i) : e : n
    }));
  }
});
function xie(t, e = {}) {
  return [
    eo.of({ source: t, config: e }),
    PR,
    QR
  ];
}
function nx(t) {
  let e = t.plugin(PR);
  e && e.force();
}
function MR(t) {
  let e = [];
  if (t)
    e:
      for (let { name: n } of t) {
        for (let i = 0; i < n.length; i++) {
          let r = n[i];
          if (/[a-zA-Z]/.test(r) && !e.some((o) => o.toLowerCase() == r.toLowerCase())) {
            e.push(r);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function ER(t, e, n) {
  var i;
  let r = n ? MR(e.actions) : [];
  return Vt("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Vt("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(t) : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((o, s) => {
    let a = !1, l = (h) => {
      if (h.preventDefault(), a)
        return;
      a = !0;
      let f = uu(t.state.field(_i).diagnostics, e);
      f && o.apply(t, f.from, f.to);
    }, { name: u } = o, c = r[s] ? u.indexOf(r[s]) : -1, d = c < 0 ? u : [
      u.slice(0, c),
      Vt("u", u.slice(c, c + 1)),
      u.slice(c + 1)
    ];
    return Vt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${u}${c < 0 ? "" : ` (access key "${r[s]})"`}.`
    }, d);
  }), e.source && Vt("div", { class: "cm-diagnosticSource" }, e.source));
}
class Cie extends mo {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return Vt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class ix {
  constructor(e, n) {
    this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = ER(e, n, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class hd {
  constructor(e) {
    this.view = e, this.items = [];
    let n = (r) => {
      if (r.keyCode == 27)
        tx(this.view), this.view.focus();
      else if (r.keyCode == 38 || r.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (r.keyCode == 40 || r.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (r.keyCode == 36)
        this.moveSelection(0);
      else if (r.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (r.keyCode == 13)
        this.view.focus();
      else if (r.keyCode >= 65 && r.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: o } = this.items[this.selectedIndex], s = MR(o.actions);
        for (let a = 0; a < s.length; a++)
          if (s[a].toUpperCase().charCodeAt(0) == r.keyCode) {
            let l = uu(this.view.state.field(_i).diagnostics, o);
            l && o.actions[a].apply(e, l.from, l.to);
          }
      } else
        return;
      r.preventDefault();
    }, i = (r) => {
      for (let o = 0; o < this.items.length; o++)
        this.items[o].dom.contains(r.target) && this.moveSelection(o);
    };
    this.list = Vt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: n,
      onclick: i
    }), this.dom = Vt("div", { class: "cm-panel-lint" }, this.list, Vt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => tx(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(_i).selected;
    if (!e)
      return -1;
    for (let n = 0; n < this.items.length; n++)
      if (this.items[n].diagnostic == e.diagnostic)
        return n;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: n } = this.view.state.field(_i), i = 0, r = !1, o = null, s = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (a, l, { spec: u }) => {
      for (let c of u.diagnostics) {
        if (s.has(c))
          continue;
        s.add(c);
        let d = -1, h;
        for (let f = i; f < this.items.length; f++)
          if (this.items[f].diagnostic == c) {
            d = f;
            break;
          }
        d < 0 ? (h = new ix(this.view, c), this.items.splice(i, 0, h), r = !0) : (h = this.items[d], d > i && (this.items.splice(i, d - i), r = !0)), n && h.diagnostic == n.diagnostic ? h.dom.hasAttribute("aria-selected") || (h.dom.setAttribute("aria-selected", "true"), o = h) : h.dom.hasAttribute("aria-selected") && h.dom.removeAttribute("aria-selected"), i++;
      }
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      r = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new ix(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), r = !0), o ? (this.list.setAttribute("aria-activedescendant", o.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: o.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: a, panel: l }) => {
        let u = l.height / this.list.offsetHeight;
        a.top < l.top ? this.list.scrollTop -= (l.top - a.top) / u : a.bottom > l.bottom && (this.list.scrollTop += (a.bottom - l.bottom) / u);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), r && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function n() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          n();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      n();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let n = this.view.state.field(_i), i = uu(n.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: TR.of(i)
    });
  }
  static open(e) {
    return new hd(e);
  }
}
function Kh(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function Th(t) {
  return Kh(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const Tie = /* @__PURE__ */ Le.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Th("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Th("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Th("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Th("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function $ie(t) {
  return t == "error" ? 4 : t == "warning" ? 3 : t == "info" ? 2 : 1;
}
function AR(t) {
  let e = "hint", n = 1;
  for (let i of t) {
    let r = $ie(i.severity);
    r > n && (n = r, e = i.severity);
  }
  return e;
}
class RR extends fo {
  constructor(e) {
    super(), this.diagnostics = e, this.severity = AR(e);
  }
  toDOM(e) {
    let n = document.createElement("div");
    n.className = "cm-lint-marker cm-lint-marker-" + this.severity;
    let i = this.diagnostics, r = e.state.facet(Im).tooltipFilter;
    return r && (i = r(i, e.state)), i.length && (n.onmouseover = () => Mie(e, n, i)), n;
  }
}
function Pie(t, e) {
  let n = (i) => {
    let r = e.getBoundingClientRect();
    if (!(i.clientX > r.left - 10 && i.clientX < r.right + 10 && i.clientY > r.top - 10 && i.clientY < r.bottom + 10)) {
      for (let o = i.target; o; o = o.parentNode)
        if (o.nodeType == 1 && o.classList.contains("cm-tooltip-lint"))
          return;
      window.removeEventListener("mousemove", n), t.state.field(DR) && t.dispatch({ effects: N0.of(null) });
    }
  };
  window.addEventListener("mousemove", n);
}
function Mie(t, e, n) {
  function i() {
    let s = t.elementAtHeight(e.getBoundingClientRect().top + 5 - t.documentTop);
    t.coordsAtPos(s.from) && t.dispatch({ effects: N0.of({
      pos: s.from,
      above: !1,
      clip: !1,
      create() {
        return {
          dom: $R(t, n),
          getCoords: () => e.getBoundingClientRect()
        };
      }
    }) }), e.onmouseout = e.onmousemove = null, Pie(t, e);
  }
  let { hoverTime: r } = t.state.facet(Im), o = setTimeout(i, r);
  e.onmouseout = () => {
    clearTimeout(o), e.onmouseout = e.onmousemove = null;
  }, e.onmousemove = () => {
    clearTimeout(o), o = setTimeout(i, r);
  };
}
function Eie(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r of e) {
    let o = t.lineAt(r.from);
    (n[o.from] || (n[o.from] = [])).push(r);
  }
  let i = [];
  for (let r in n)
    i.push(new RR(n[r]).range(+r));
  return bt.of(i, !0);
}
const Aie = /* @__PURE__ */ pA({
  class: "cm-gutter-lint",
  markers: (t) => t.state.field(Sy),
  widgetMarker: (t, e, n) => {
    let i = [];
    return t.state.field(Sy).between(n.from, n.to, (r, o, s) => {
      r > n.from && r < n.to && i.push(...s.diagnostics);
    }), i.length ? new RR(i) : null;
  }
}), Sy = /* @__PURE__ */ xn.define({
  create() {
    return bt.empty;
  },
  update(t, e) {
    t = t.map(e.changes);
    let n = e.state.facet(Im).markerFilter;
    for (let i of e.effects)
      if (i.is(Nm)) {
        let r = i.value;
        n && (r = n(r || [], e.state)), t = Eie(e.state.doc, r.slice(0));
      }
    return t;
  }
}), N0 = /* @__PURE__ */ ot.define(), DR = /* @__PURE__ */ xn.define({
  create() {
    return null;
  },
  update(t, e) {
    return t && e.docChanged && (t = xR(e, t) ? null : Object.assign(Object.assign({}, t), { pos: e.changes.mapPos(t.pos) })), e.effects.reduce((n, i) => i.is(N0) ? i.value : n, t);
  },
  provide: (t) => _m.from(t)
}), Rie = /* @__PURE__ */ Le.baseTheme({
  ".cm-gutter-lint": {
    width: "1.4em",
    "& .cm-gutterElement": {
      padding: ".2em"
    }
  },
  ".cm-lint-marker": {
    width: "1em",
    height: "1em"
  },
  ".cm-lint-marker-info": {
    content: /* @__PURE__ */ Kh('<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>')
  },
  ".cm-lint-marker-warning": {
    content: /* @__PURE__ */ Kh('<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>')
  },
  ".cm-lint-marker-error": {
    content: /* @__PURE__ */ Kh('<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>')
  }
}), QR = [
  _i,
  /* @__PURE__ */ Le.decorations.compute([_i], (t) => {
    let { selected: e, panel: n } = t.field(_i);
    return !e || !n || e.from == e.to ? Ue.none : Ue.set([
      yie.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ Bee(bie, { hideOn: xR }),
  Tie
], Im = /* @__PURE__ */ Ze.define({
  combine(t) {
    return Er(t, {
      hoverTime: 300,
      markerFilter: null,
      tooltipFilter: null
    });
  }
});
function Die(t = {}) {
  return [Im.of(t), Sy, Aie, Rie, DR];
}
const rx = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class cu {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, n, i = 0, r = e.length, o, s) {
    this.test = s, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, r), this.bufferStart = i, this.normalize = o ? (a) => o(rx(a)) : rx, this.query = this.normalize(n);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return bi(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let n = l0(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += zr(e);
      let r = this.normalize(n);
      if (r.length)
        for (let o = 0, s = i; ; o++) {
          let a = r.charCodeAt(o), l = this.match(a, s, this.bufferPos + this.bufferStart);
          if (o == r.length - 1) {
            if (l)
              return this.value = l, this;
            break;
          }
          s == i && o < n.length && n.charCodeAt(o) == a && s++;
        }
    }
  }
  match(e, n, i) {
    let r = null;
    for (let o = 0; o < this.matches.length; o += 2) {
      let s = this.matches[o], a = !1;
      this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? r = { from: this.matches[o + 1], to: i } : (this.matches[o]++, a = !0)), a || (this.matches.splice(o, 2), o -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? r = { from: n, to: i } : this.matches.push(1, n)), r && this.test && !this.test(r.from, r.to, this.buffer, this.bufferStart) && (r = null), r;
  }
}
typeof Symbol < "u" && (cu.prototype[Symbol.iterator] = function() {
  return this;
});
const NR = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, I0 = "gm" + (/x/.unicode == null ? "" : "u");
class IR {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, n, i, r = 0, o = e.length) {
    if (this.text = e, this.to = o, this.curLine = "", this.done = !1, this.value = NR, /\\[sWDnr]|\n|\r|\[\^/.test(n))
      return new LR(e, n, i, r, o);
    this.re = new RegExp(n, I0 + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = e.iter();
    let s = e.lineAt(r);
    this.curLineStart = s.from, this.matchPos = kp(e, r), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let i = this.curLineStart + n.index, r = i + n[0].length;
        if (this.matchPos = kp(this.text, r + (i == r ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < r || i > this.value.to) && (!this.test || this.test(i, r, n)))
          return this.value = { from: i, to: r, match: n }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const iO = /* @__PURE__ */ new WeakMap();
class Pl {
  constructor(e, n) {
    this.from = e, this.text = n;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, n, i) {
    let r = iO.get(e);
    if (!r || r.from >= i || r.to <= n) {
      let a = new Pl(n, e.sliceString(n, i));
      return iO.set(e, a), a;
    }
    if (r.from == n && r.to == i)
      return r;
    let { text: o, from: s } = r;
    return s > n && (o = e.sliceString(n, s) + o, s = n), r.to < i && (o += e.sliceString(r.to, i)), iO.set(e, new Pl(s, o)), new Pl(n, o.slice(n - s, i - s));
  }
}
class LR {
  constructor(e, n, i, r, o) {
    this.text = e, this.to = o, this.done = !1, this.value = NR, this.matchPos = kp(e, r), this.re = new RegExp(n, I0 + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = Pl.get(e, r, this.chunkEnd(
      r + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
      if (n && !n[0] && n.index == e && (this.re.lastIndex = e + 1, n = this.re.exec(this.flat.text)), n) {
        let i = this.flat.from + n.index, r = i + n[0].length;
        if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, r, n)))
          return this.value = { from: i, to: r, match: n }, this.matchPos = kp(this.text, r + (i == r ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Pl.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (IR.prototype[Symbol.iterator] = LR.prototype[Symbol.iterator] = function() {
  return this;
});
function Qie(t) {
  try {
    return new RegExp(t, I0), !0;
  } catch {
    return !1;
  }
}
function kp(t, e) {
  if (e >= t.length)
    return e;
  let n = t.lineAt(e), i;
  for (; e < n.to && (i = n.text.charCodeAt(e - n.from)) >= 56320 && i < 57344; )
    e++;
  return e;
}
function _y(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), n = Vt("input", { class: "cm-textfield", name: "line", value: e }), i = Vt("form", {
    class: "cm-gotoLine",
    onkeydown: (o) => {
      o.keyCode == 27 ? (o.preventDefault(), t.dispatch({ effects: Sp.of(!1) }), t.focus()) : o.keyCode == 13 && (o.preventDefault(), r());
    },
    onsubmit: (o) => {
      o.preventDefault(), r();
    }
  }, Vt("label", t.state.phrase("Go to line"), ": ", n), " ", Vt("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")));
  function r() {
    let o = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!o)
      return;
    let { state: s } = t, a = s.doc.lineAt(s.selection.main.head), [, l, u, c, d] = o, h = c ? +c.slice(1) : 0, f = u ? +u : a.number;
    if (u && d) {
      let g = f / 100;
      l && (g = g * (l == "-" ? -1 : 1) + a.number / s.doc.lines), f = Math.round(s.doc.lines * g);
    } else
      u && l && (f = f * (l == "-" ? -1 : 1) + a.number);
    let p = s.doc.line(Math.max(1, Math.min(s.doc.lines, f))), m = ve.cursor(p.from + Math.max(0, Math.min(h, p.length)));
    t.dispatch({
      effects: [Sp.of(!1), Le.scrollIntoView(m.from, { y: "center" })],
      selection: m
    }), t.focus();
  }
  return { dom: i };
}
const Sp = /* @__PURE__ */ ot.define(), ox = /* @__PURE__ */ xn.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let n of e.effects)
      n.is(Sp) && (t = n.value);
    return t;
  },
  provide: (t) => ld.from(t, (e) => e ? _y : null)
}), Nie = (t) => {
  let e = ad(t, _y);
  if (!e) {
    let n = [Sp.of(!0)];
    t.state.field(ox, !1) == null && n.push(ot.appendConfig.of([ox, Iie])), t.dispatch({ effects: n }), e = ad(t, _y);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, Iie = /* @__PURE__ */ Le.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), Lie = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, VR = /* @__PURE__ */ Ze.define({
  combine(t) {
    return Er(t, Lie, {
      highlightWordAroundCursor: (e, n) => e || n,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function Vie(t) {
  let e = [Wie, qie];
  return t && e.push(VR.of(t)), e;
}
const Bie = /* @__PURE__ */ Ue.mark({ class: "cm-selectionMatch" }), Zie = /* @__PURE__ */ Ue.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function sx(t, e, n, i) {
  return (n == 0 || t(e.sliceDoc(n - 1, n)) != Ut.Word) && (i == e.doc.length || t(e.sliceDoc(i, i + 1)) != Ut.Word);
}
function Fie(t, e, n, i) {
  return t(e.sliceDoc(n, n + 1)) == Ut.Word && t(e.sliceDoc(i - 1, i)) == Ut.Word;
}
const qie = /* @__PURE__ */ dn.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(VR), { state: n } = t, i = n.selection;
    if (i.ranges.length > 1)
      return Ue.none;
    let r = i.main, o, s = null;
    if (r.empty) {
      if (!e.highlightWordAroundCursor)
        return Ue.none;
      let l = n.wordAt(r.head);
      if (!l)
        return Ue.none;
      s = n.charCategorizer(r.head), o = n.sliceDoc(l.from, l.to);
    } else {
      let l = r.to - r.from;
      if (l < e.minSelectionLength || l > 200)
        return Ue.none;
      if (e.wholeWords) {
        if (o = n.sliceDoc(r.from, r.to), s = n.charCategorizer(r.head), !(sx(s, n, r.from, r.to) && Fie(s, n, r.from, r.to)))
          return Ue.none;
      } else if (o = n.sliceDoc(r.from, r.to), !o)
        return Ue.none;
    }
    let a = [];
    for (let l of t.visibleRanges) {
      let u = new cu(n.doc, o, l.from, l.to);
      for (; !u.next().done; ) {
        let { from: c, to: d } = u.value;
        if ((!s || sx(s, n, c, d)) && (r.empty && c <= r.from && d >= r.to ? a.push(Zie.range(c, d)) : (c >= r.to || d <= r.from) && a.push(Bie.range(c, d)), a.length > e.maxMatches))
          return Ue.none;
      }
    }
    return Ue.set(a);
  }
}, {
  decorations: (t) => t.decorations
}), Wie = /* @__PURE__ */ Le.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), Xie = ({ state: t, dispatch: e }) => {
  let { selection: n } = t, i = ve.create(n.ranges.map((r) => t.wordAt(r.head) || ve.cursor(r.head)), n.mainIndex);
  return i.eq(n) ? !1 : (e(t.update({ selection: i })), !0);
};
function zie(t, e) {
  let { main: n, ranges: i } = t.selection, r = t.wordAt(n.head), o = r && r.from == n.from && r.to == n.to;
  for (let s = !1, a = new cu(t.doc, e, i[i.length - 1].to); ; )
    if (a.next(), a.done) {
      if (s)
        return null;
      a = new cu(t.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), s = !0;
    } else {
      if (s && i.some((l) => l.from == a.value.from))
        continue;
      if (o) {
        let l = t.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const jie = ({ state: t, dispatch: e }) => {
  let { ranges: n } = t.selection;
  if (n.some((o) => o.from === o.to))
    return Xie({ state: t, dispatch: e });
  let i = t.sliceDoc(n[0].from, n[0].to);
  if (t.selection.ranges.some((o) => t.sliceDoc(o.from, o.to) != i))
    return !1;
  let r = zie(t, i);
  return r ? (e(t.update({
    selection: t.selection.addRange(ve.range(r.from, r.to), !1),
    effects: Le.scrollIntoView(r.to)
  })), !0) : !1;
}, _u = /* @__PURE__ */ Ze.define({
  combine(t) {
    return Er(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new ore(e),
      scrollToMatch: (e) => Le.scrollIntoView(e)
    });
  }
});
class BR {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Qie(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new Gie(this) : new Hie(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, n = 0, i) {
    let r = e.doc ? e : ht.create({ doc: e });
    return i == null && (i = r.doc.length), this.regexp ? fl(this, r, n, i) : hl(this, r, n, i);
  }
}
class ZR {
  constructor(e) {
    this.spec = e;
  }
}
function hl(t, e, n, i) {
  return new cu(e.doc, t.unquoted, n, i, t.caseSensitive ? void 0 : (r) => r.toLowerCase(), t.wholeWord ? Yie(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function Yie(t, e) {
  return (n, i, r, o) => ((o > n || o + r.length < i) && (o = Math.max(0, n - 2), r = t.sliceString(o, Math.min(t.length, i + 2))), (e(_p(r, n - o)) != Ut.Word || e(xp(r, n - o)) != Ut.Word) && (e(xp(r, i - o)) != Ut.Word || e(_p(r, i - o)) != Ut.Word));
}
class Hie extends ZR {
  constructor(e) {
    super(e);
  }
  nextMatch(e, n, i) {
    let r = hl(this.spec, e, i, e.doc.length).nextOverlapping();
    if (r.done) {
      let o = Math.min(e.doc.length, n + this.spec.unquoted.length);
      r = hl(this.spec, e, 0, o).nextOverlapping();
    }
    return r.done || r.value.from == n && r.value.to == i ? null : r.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, n, i) {
    for (let r = i; ; ) {
      let o = Math.max(n, r - 1e4 - this.spec.unquoted.length), s = hl(this.spec, e, o, r), a = null;
      for (; !s.nextOverlapping().done; )
        a = s.value;
      if (a)
        return a;
      if (o == n)
        return null;
      r -= 1e4;
    }
  }
  prevMatch(e, n, i) {
    let r = this.prevMatchInRange(e, 0, n);
    return r || (r = this.prevMatchInRange(e, Math.max(0, i - this.spec.unquoted.length), e.doc.length)), r && (r.from != n || r.to != i) ? r : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, n) {
    let i = hl(this.spec, e, 0, e.doc.length), r = [];
    for (; !i.next().done; ) {
      if (r.length >= n)
        return null;
      r.push(i.value);
    }
    return r;
  }
  highlight(e, n, i, r) {
    let o = hl(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length));
    for (; !o.next().done; )
      r(o.value.from, o.value.to);
  }
}
function fl(t, e, n, i) {
  return new IR(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? Uie(e.charCategorizer(e.selection.main.head)) : void 0
  }, n, i);
}
function _p(t, e) {
  return t.slice(Zn(t, e, !1), e);
}
function xp(t, e) {
  return t.slice(e, Zn(t, e));
}
function Uie(t) {
  return (e, n, i) => !i[0].length || (t(_p(i.input, i.index)) != Ut.Word || t(xp(i.input, i.index)) != Ut.Word) && (t(xp(i.input, i.index + i[0].length)) != Ut.Word || t(_p(i.input, i.index + i[0].length)) != Ut.Word);
}
class Gie extends ZR {
  nextMatch(e, n, i) {
    let r = fl(this.spec, e, i, e.doc.length).next();
    return r.done && (r = fl(this.spec, e, 0, n).next()), r.done ? null : r.value;
  }
  prevMatchInRange(e, n, i) {
    for (let r = 1; ; r++) {
      let o = Math.max(
        n,
        i - r * 1e4
        /* FindPrev.ChunkSize */
      ), s = fl(this.spec, e, o, i), a = null;
      for (; !s.next().done; )
        a = s.value;
      if (a && (o == n || a.from > o + 10))
        return a;
      if (o == n)
        return null;
    }
  }
  prevMatch(e, n, i) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (n, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : n);
  }
  matchAll(e, n) {
    let i = fl(this.spec, e, 0, e.doc.length), r = [];
    for (; !i.next().done; ) {
      if (r.length >= n)
        return null;
      r.push(i.value);
    }
    return r;
  }
  highlight(e, n, i, r) {
    let o = fl(this.spec, e, Math.max(
      0,
      n - 250
      /* RegExp.HighlightMargin */
    ), Math.min(i + 250, e.doc.length));
    for (; !o.next().done; )
      r(o.value.from, o.value.to);
  }
}
const fd = /* @__PURE__ */ ot.define(), L0 = /* @__PURE__ */ ot.define(), Ms = /* @__PURE__ */ xn.define({
  create(t) {
    return new rO(xy(t).create(), null);
  },
  update(t, e) {
    for (let n of e.effects)
      n.is(fd) ? t = new rO(n.value.create(), t.panel) : n.is(L0) && (t = new rO(t.query, n.value ? V0 : null));
    return t;
  },
  provide: (t) => ld.from(t, (e) => e.panel)
});
class rO {
  constructor(e, n) {
    this.query = e, this.panel = n;
  }
}
const Kie = /* @__PURE__ */ Ue.mark({ class: "cm-searchMatch" }), Jie = /* @__PURE__ */ Ue.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), ere = /* @__PURE__ */ dn.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(Ms));
  }
  update(t) {
    let e = t.state.field(Ms);
    (e != t.startState.field(Ms) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return Ue.none;
    let { view: n } = this, i = new Wo();
    for (let r = 0, o = n.visibleRanges, s = o.length; r < s; r++) {
      let { from: a, to: l } = o[r];
      for (; r < s - 1 && l > o[r + 1].from - 2 * 250; )
        l = o[++r].to;
      t.highlight(n.state, a, l, (u, c) => {
        let d = n.state.selection.ranges.some((h) => h.from == u && h.to == c);
        i.add(u, c, d ? Jie : Kie);
      });
    }
    return i.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function Bd(t) {
  return (e) => {
    let n = e.state.field(Ms, !1);
    return n && n.query.spec.valid ? t(e, n) : WR(e);
  };
}
const Cp = /* @__PURE__ */ Bd((t, { query: e }) => {
  let { to: n } = t.state.selection.main, i = e.nextMatch(t.state, n, n);
  if (!i)
    return !1;
  let r = ve.single(i.from, i.to), o = t.state.facet(_u);
  return t.dispatch({
    selection: r,
    effects: [B0(t, i), o.scrollToMatch(r.main, t)],
    userEvent: "select.search"
  }), qR(t), !0;
}), Tp = /* @__PURE__ */ Bd((t, { query: e }) => {
  let { state: n } = t, { from: i } = n.selection.main, r = e.prevMatch(n, i, i);
  if (!r)
    return !1;
  let o = ve.single(r.from, r.to), s = t.state.facet(_u);
  return t.dispatch({
    selection: o,
    effects: [B0(t, r), s.scrollToMatch(o.main, t)],
    userEvent: "select.search"
  }), qR(t), !0;
}), tre = /* @__PURE__ */ Bd((t, { query: e }) => {
  let n = e.matchAll(t.state, 1e3);
  return !n || !n.length ? !1 : (t.dispatch({
    selection: ve.create(n.map((i) => ve.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), nre = ({ state: t, dispatch: e }) => {
  let n = t.selection;
  if (n.ranges.length > 1 || n.main.empty)
    return !1;
  let { from: i, to: r } = n.main, o = [], s = 0;
  for (let a = new cu(t.doc, t.sliceDoc(i, r)); !a.next().done; ) {
    if (o.length > 1e3)
      return !1;
    a.value.from == i && (s = o.length), o.push(ve.range(a.value.from, a.value.to));
  }
  return e(t.update({
    selection: ve.create(o, s),
    userEvent: "select.search.matches"
  })), !0;
}, ax = /* @__PURE__ */ Bd((t, { query: e }) => {
  let { state: n } = t, { from: i, to: r } = n.selection.main;
  if (n.readOnly)
    return !1;
  let o = e.nextMatch(n, i, i);
  if (!o)
    return !1;
  let s = o, a = [], l, u, c = [];
  if (s.from == i && s.to == r && (u = n.toText(e.getReplacement(s)), a.push({ from: s.from, to: s.to, insert: u }), s = e.nextMatch(n, s.from, s.to), c.push(Le.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(i).number) + "."))), s) {
    let d = a.length == 0 || a[0].from >= o.to ? 0 : o.to - o.from - u.length;
    l = ve.single(s.from - d, s.to - d), c.push(B0(t, s)), c.push(n.facet(_u).scrollToMatch(l.main, t));
  }
  return t.dispatch({
    changes: a,
    selection: l,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), ire = /* @__PURE__ */ Bd((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let n = e.matchAll(t.state, 1e9).map((r) => {
    let { from: o, to: s } = r;
    return { from: o, to: s, insert: e.getReplacement(r) };
  });
  if (!n.length)
    return !1;
  let i = t.state.phrase("replaced $ matches", n.length) + ".";
  return t.dispatch({
    changes: n,
    effects: Le.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function V0(t) {
  return t.state.facet(_u).createPanel(t);
}
function xy(t, e) {
  var n, i, r, o, s;
  let a = t.selection.main, l = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let u = t.facet(_u);
  return new BR({
    search: ((n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : u.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (i = e == null ? void 0 : e.caseSensitive) !== null && i !== void 0 ? i : u.caseSensitive,
    literal: (r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : u.literal,
    regexp: (o = e == null ? void 0 : e.regexp) !== null && o !== void 0 ? o : u.regexp,
    wholeWord: (s = e == null ? void 0 : e.wholeWord) !== null && s !== void 0 ? s : u.wholeWord
  });
}
function FR(t) {
  let e = ad(t, V0);
  return e && e.dom.querySelector("[main-field]");
}
function qR(t) {
  let e = FR(t);
  e && e == t.root.activeElement && e.select();
}
const WR = (t) => {
  let e = t.state.field(Ms, !1);
  if (e && e.panel) {
    let n = FR(t);
    if (n && n != t.root.activeElement) {
      let i = xy(t.state, e.query.spec);
      i.valid && t.dispatch({ effects: fd.of(i) }), n.focus(), n.select();
    }
  } else
    t.dispatch({ effects: [
      L0.of(!0),
      e ? fd.of(xy(t.state, e.query.spec)) : ot.appendConfig.of(are)
    ] });
  return !0;
}, XR = (t) => {
  let e = t.state.field(Ms, !1);
  if (!e || !e.panel)
    return !1;
  let n = ad(t, V0);
  return n && n.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: L0.of(!1) }), !0;
}, rre = [
  { key: "Mod-f", run: WR, scope: "editor search-panel" },
  { key: "F3", run: Cp, shift: Tp, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Cp, shift: Tp, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: XR, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: nre },
  { key: "Mod-Alt-g", run: Nie },
  { key: "Mod-d", run: jie, preventDefault: !0 }
];
class ore {
  constructor(e) {
    this.view = e;
    let n = this.query = e.state.field(Ms).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Vt("input", {
      value: n.search,
      placeholder: Ei(e, "Find"),
      "aria-label": Ei(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Vt("input", {
      value: n.replace,
      placeholder: Ei(e, "Replace"),
      "aria-label": Ei(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Vt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: n.caseSensitive,
      onchange: this.commit
    }), this.reField = Vt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: n.regexp,
      onchange: this.commit
    }), this.wordField = Vt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: n.wholeWord,
      onchange: this.commit
    });
    function i(r, o, s) {
      return Vt("button", { class: "cm-button", name: r, onclick: o, type: "button" }, s);
    }
    this.dom = Vt("div", { onkeydown: (r) => this.keydown(r), class: "cm-search" }, [
      this.searchField,
      i("next", () => Cp(e), [Ei(e, "next")]),
      i("prev", () => Tp(e), [Ei(e, "previous")]),
      i("select", () => tre(e), [Ei(e, "all")]),
      Vt("label", null, [this.caseField, Ei(e, "match case")]),
      Vt("label", null, [this.reField, Ei(e, "regexp")]),
      Vt("label", null, [this.wordField, Ei(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Vt("br"),
        this.replaceField,
        i("replace", () => ax(e), [Ei(e, "replace")]),
        i("replaceAll", () => ire(e), [Ei(e, "replace all")])
      ],
      Vt("button", {
        name: "close",
        onclick: () => XR(e),
        "aria-label": Ei(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new BR({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: fd.of(e) }));
  }
  keydown(e) {
    eee(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Tp : Cp)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), ax(this.view));
  }
  update(e) {
    for (let n of e.transactions)
      for (let i of n.effects)
        i.is(fd) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(_u).top;
  }
}
function Ei(t, e) {
  return t.state.phrase(e);
}
const $h = 30, Ph = /[\s\.,:;?!]/;
function B0(t, { from: e, to: n }) {
  let i = t.state.doc.lineAt(e), r = t.state.doc.lineAt(n).to, o = Math.max(i.from, e - $h), s = Math.min(r, n + $h), a = t.state.sliceDoc(o, s);
  if (o != i.from) {
    for (let l = 0; l < $h; l++)
      if (!Ph.test(a[l + 1]) && Ph.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (s != r) {
    for (let l = a.length - 1; l > a.length - $h; l--)
      if (!Ph.test(a[l - 1]) && Ph.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return Le.announce.of(`${t.state.phrase("current match")}. ${a} ${t.state.phrase("on line")} ${i.number}.`);
}
const sre = /* @__PURE__ */ Le.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), are = [
  Ms,
  /* @__PURE__ */ Us.low(ere),
  sre
];
class zR {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, n, i, r) {
    this.state = e, this.pos = n, this.explicit = i, this.view = r, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let n = hn(this.state).resolveInner(this.pos, -1);
    for (; n && e.indexOf(n.name) < 0; )
      n = n.parent;
    return n ? {
      from: n.from,
      to: this.pos,
      text: this.state.sliceDoc(n.from, this.pos),
      type: n.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let n = this.state.doc.lineAt(this.pos), i = Math.max(n.from, this.pos - 250), r = n.text.slice(i - n.from, this.pos - n.from), o = r.search(YR(e, !1));
    return o < 0 ? null : { from: i + o, to: this.pos, text: r.slice(o) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, n, i) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(n), i && i.onDocChange && (this.abortOnDocChange = !0));
  }
}
function lx(t) {
  let e = Object.keys(t).join(""), n = /\w/.test(e);
  return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function lre(t) {
  let e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  for (let { label: r } of t) {
    e[r[0]] = !0;
    for (let o = 1; o < r.length; o++)
      n[r[o]] = !0;
  }
  let i = lx(e) + lx(n) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function jR(t) {
  let e = t.map((r) => typeof r == "string" ? { label: r } : r), [n, i] = e.every((r) => /^\w+$/.test(r.label)) ? [/\w*$/, /\w+$/] : lre(e);
  return (r) => {
    let o = r.matchBefore(i);
    return o || r.explicit ? { from: o ? o.from : r.pos, options: e, validFor: n } : null;
  };
}
function ure(t, e) {
  return (n) => {
    for (let i = hn(n.state).resolveInner(n.pos, -1); i; i = i.parent) {
      if (t.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return e(n);
  };
}
class ux {
  constructor(e, n, i, r) {
    this.completion = e, this.source = n, this.match = i, this.score = r;
  }
}
function xa(t) {
  return t.selection.main.from;
}
function YR(t, e) {
  var n;
  let { source: i } = t, r = e && i[0] != "^", o = i[i.length - 1] != "$";
  return !r && !o ? t : new RegExp(`${r ? "^" : ""}(?:${i})${o ? "$" : ""}`, (n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? "i" : "");
}
const Z0 = /* @__PURE__ */ Uo.define();
function cre(t, e, n, i) {
  let { main: r } = t.selection, o = n - r.from, s = i - r.from;
  return Object.assign(Object.assign({}, t.changeByRange((a) => {
    if (a != r && n != i && t.sliceDoc(a.from + o, a.from + s) != t.sliceDoc(n, i))
      return { range: a };
    let l = t.toText(e);
    return {
      changes: { from: a.from + o, to: i == r.from ? a.to : a.from + s, insert: l },
      range: ve.cursor(a.from + o + l.length)
    };
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const cx = /* @__PURE__ */ new WeakMap();
function dre(t) {
  if (!Array.isArray(t))
    return t;
  let e = cx.get(t);
  return e || cx.set(t, e = jR(t)), e;
}
const $p = /* @__PURE__ */ ot.define(), pd = /* @__PURE__ */ ot.define();
class hre {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let n = 0; n < e.length; ) {
      let i = bi(e, n), r = zr(i);
      this.chars.push(i);
      let o = e.slice(n, n + r), s = o.toUpperCase();
      this.folded.push(bi(s == o ? o.toLowerCase() : s, 0)), n += r;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, n) {
    return this.score = e, this.matched = n, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: n, folded: i, any: r, precise: o, byWord: s } = this;
    if (n.length == 1) {
      let y = bi(e, 0), b = zr(y), v = b == e.length ? 0 : -100;
      if (y != n[0])
        if (y == i[0])
          v += -200;
        else
          return null;
      return this.ret(v, [0, b]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = n.length, u = 0;
    if (a < 0) {
      for (let y = 0, b = Math.min(e.length, 200); y < b && u < l; ) {
        let v = bi(e, y);
        (v == n[u] || v == i[u]) && (r[u++] = y), y += zr(v);
      }
      if (u < l)
        return null;
    }
    let c = 0, d = 0, h = !1, f = 0, p = -1, m = -1, g = /[a-z]/.test(e), O = !0;
    for (let y = 0, b = Math.min(e.length, 200), v = 0; y < b && d < l; ) {
      let k = bi(e, y);
      a < 0 && (c < l && k == n[c] && (o[c++] = y), f < l && (k == n[f] || k == i[f] ? (f == 0 && (p = y), m = y + 1, f++) : f = 0));
      let w, S = k < 255 ? k >= 48 && k <= 57 || k >= 97 && k <= 122 ? 2 : k >= 65 && k <= 90 ? 1 : 0 : (w = l0(k)) != w.toLowerCase() ? 1 : w != w.toUpperCase() ? 2 : 0;
      (!y || S == 1 && g || v == 0 && S != 0) && (n[d] == k || i[d] == k && (h = !0) ? s[d++] = y : s.length && (O = !1)), v = S, y += zr(k);
    }
    return d == l && s[0] == 0 && O ? this.result(-100 + (h ? -200 : 0), s, e) : f == l && p == 0 ? this.ret(-200 - e.length + (m == e.length ? 0 : -100), [0, m]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : f == l ? this.ret(-200 + -700 - e.length, [p, m]) : d == l ? this.result(-100 + (h ? -200 : 0) + -700 + (O ? 0 : -1100), s, e) : n.length == 2 ? null : this.result((r[0] ? -700 : 0) + -200 + -1100, r, e);
  }
  result(e, n, i) {
    let r = [], o = 0;
    for (let s of n) {
      let a = s + (this.astral ? zr(bi(i, s)) : 1);
      o && r[o - 1] == s ? r[o - 1] = a : (r[o++] = s, r[o++] = a);
    }
    return this.ret(e - i.length, r);
  }
}
class fre {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let n = e.slice(0, this.pattern.length), i = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
    return i == null ? null : (this.matched = [0, n.length], this.score = i + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const En = /* @__PURE__ */ Ze.define({
  combine(t) {
    return Er(t, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: pre,
      filterStrict: !1,
      compareCompletions: (e, n) => e.label.localeCompare(n.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, n) => e && n,
      closeOnBlur: (e, n) => e && n,
      icons: (e, n) => e && n,
      tooltipClass: (e, n) => (i) => dx(e(i), n(i)),
      optionClass: (e, n) => (i) => dx(e(i), n(i)),
      addToOptions: (e, n) => e.concat(n),
      filterStrict: (e, n) => e || n
    });
  }
});
function dx(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function pre(t, e, n, i, r, o) {
  let s = t.textDirection == Yt.RTL, a = s, l = !1, u = "top", c, d, h = e.left - r.left, f = r.right - e.right, p = i.right - i.left, m = i.bottom - i.top;
  if (a && h < Math.min(p, f) ? a = !1 : !a && f < Math.min(p, h) && (a = !0), p <= (a ? h : f))
    c = Math.max(r.top, Math.min(n.top, r.bottom - m)) - e.top, d = Math.min(400, a ? h : f);
  else {
    l = !0, d = Math.min(
      400,
      (s ? e.right : r.right - e.left) - 30
      /* Info.Margin */
    );
    let y = r.bottom - e.bottom;
    y >= m || y > e.top ? c = n.bottom - e.top : (u = "bottom", c = e.bottom - n.top);
  }
  let g = (e.bottom - e.top) / o.offsetHeight, O = (e.right - e.left) / o.offsetWidth;
  return {
    style: `${u}: ${c / g}px; max-width: ${d / O}px`,
    class: "cm-completionInfo-" + (l ? s ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function mre(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(n) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), n.type && i.classList.add(...n.type.split(/\s+/g).map((r) => "cm-completionIcon-" + r)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(n, i, r, o) {
      let s = document.createElement("span");
      s.className = "cm-completionLabel";
      let a = n.displayLabel || n.label, l = 0;
      for (let u = 0; u < o.length; ) {
        let c = o[u++], d = o[u++];
        c > l && s.appendChild(document.createTextNode(a.slice(l, c)));
        let h = s.appendChild(document.createElement("span"));
        h.appendChild(document.createTextNode(a.slice(c, d))), h.className = "cm-completionMatchedText", l = d;
      }
      return l < a.length && s.appendChild(document.createTextNode(a.slice(l))), s;
    },
    position: 50
  }, {
    render(n) {
      if (!n.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = n.detail, i;
    },
    position: 80
  }), e.sort((n, i) => n.position - i.position).map((n) => n.render);
}
function oO(t, e, n) {
  if (t <= n)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let r = Math.floor(e / n);
    return { from: r * n, to: (r + 1) * n };
  }
  let i = Math.floor((t - e) / n);
  return { from: t - (i + 1) * n, to: t - i * n };
}
class gre {
  constructor(e, n, i) {
    this.view = e, this.stateField = n, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let r = e.state.field(n), { options: o, selected: s } = r.open, a = e.state.facet(En);
    this.optionContent = mre(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = oO(o.length, s, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: u } = e.state.field(n).open;
      for (let c = l.target, d; c && c != this.dom; c = c.parentNode)
        if (c.nodeName == "LI" && (d = /-(\d+)$/.exec(c.id)) && +d[1] < u.length) {
          this.applyCompletion(e, u[+d[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let u = e.state.field(this.stateField, !1);
      u && u.tooltip && e.state.facet(En).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: pd.of(null) });
    }), this.showOptions(o, r.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, n) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, n, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var n;
    let i = e.state.field(this.stateField), r = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), i != r) {
      let { options: o, selected: s, disabled: a } = i.open;
      (!r.open || r.open.options != o) && (this.range = oO(o.length, s, e.state.facet(En).maxRenderedOptions), this.showOptions(o, i.id)), this.updateSel(), a != ((n = r.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let n = this.tooltipClass(e);
    if (n != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of n.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = n;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), n = e.open;
    if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = oO(n.options.length, n.selected, this.view.state.facet(En).maxRenderedOptions), this.showOptions(n.options, e.id)), this.updateSelectedOption(n.selected)) {
      this.destroyInfo();
      let { completion: i } = n.options[n.selected], { info: r } = i;
      if (!r)
        return;
      let o = typeof r == "string" ? document.createTextNode(r) : r(i);
      if (!o)
        return;
      "then" in o ? o.then((s) => {
        s && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(s, i);
      }).catch((s) => si(this.view.state, s, "completion info")) : this.addInfoPane(o, i);
    }
  }
  addInfoPane(e, n) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      i.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: r, destroy: o } = e;
      i.appendChild(r), this.infoDestroy = o || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let n = null;
    for (let i = this.list.firstChild, r = this.range.from; i; i = i.nextSibling, r++)
      i.nodeName != "LI" || !i.id ? r-- : r == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), n = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return n && vre(this.list, n), n;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let n = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), r = e.getBoundingClientRect(), o = this.space;
    if (!o) {
      let s = this.dom.ownerDocument.defaultView || window;
      o = { left: 0, top: 0, right: s.innerWidth, bottom: s.innerHeight };
    }
    return r.top > Math.min(o.bottom, n.bottom) - 10 || r.bottom < Math.max(o.top, n.top) + 10 ? null : this.view.state.facet(En).positionInfo(this.view, n, r, i, o, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, n, i) {
    const r = document.createElement("ul");
    r.id = n, r.setAttribute("role", "listbox"), r.setAttribute("aria-expanded", "true"), r.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let o = null;
    for (let s = i.from; s < i.to; s++) {
      let { completion: a, match: l } = e[s], { section: u } = a;
      if (u) {
        let h = typeof u == "string" ? u : u.name;
        if (h != o && (s > i.from || i.from == 0))
          if (o = h, typeof u != "string" && u.header)
            r.appendChild(u.header(u));
          else {
            let f = r.appendChild(document.createElement("completion-section"));
            f.textContent = h;
          }
      }
      const c = r.appendChild(document.createElement("li"));
      c.id = n + "-" + s, c.setAttribute("role", "option");
      let d = this.optionClass(a);
      d && (c.className = d);
      for (let h of this.optionContent) {
        let f = h(a, this.view.state, this.view, l);
        f && c.appendChild(f);
      }
    }
    return i.from && r.classList.add("cm-completionListIncompleteTop"), i.to < e.length && r.classList.add("cm-completionListIncompleteBottom"), r;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function Ore(t, e) {
  return (n) => new gre(n, t, e);
}
function vre(t, e) {
  let n = t.getBoundingClientRect(), i = e.getBoundingClientRect(), r = n.height / t.offsetHeight;
  i.top < n.top ? t.scrollTop -= (n.top - i.top) / r : i.bottom > n.bottom && (t.scrollTop += (i.bottom - n.bottom) / r);
}
function hx(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function yre(t, e) {
  let n = [], i = null, r = (u) => {
    n.push(u);
    let { section: c } = u.completion;
    if (c) {
      i || (i = []);
      let d = typeof c == "string" ? c : c.name;
      i.some((h) => h.name == d) || i.push(typeof c == "string" ? { name: d } : c);
    }
  }, o = e.facet(En);
  for (let u of t)
    if (u.hasResult()) {
      let c = u.result.getMatch;
      if (u.result.filter === !1)
        for (let d of u.result.options)
          r(new ux(d, u.source, c ? c(d) : [], 1e9 - n.length));
      else {
        let d = e.sliceDoc(u.from, u.to), h, f = o.filterStrict ? new fre(d) : new hre(d);
        for (let p of u.result.options)
          if (h = f.match(p.label)) {
            let m = p.displayLabel ? c ? c(p, h.matched) : [] : h.matched;
            r(new ux(p, u.source, m, h.score + (p.boost || 0)));
          }
      }
    }
  if (i) {
    let u = /* @__PURE__ */ Object.create(null), c = 0, d = (h, f) => {
      var p, m;
      return ((p = h.rank) !== null && p !== void 0 ? p : 1e9) - ((m = f.rank) !== null && m !== void 0 ? m : 1e9) || (h.name < f.name ? -1 : 1);
    };
    for (let h of i.sort(d))
      c -= 1e5, u[h.name] = c;
    for (let h of n) {
      let { section: f } = h.completion;
      f && (h.score += u[typeof f == "string" ? f : f.name]);
    }
  }
  let s = [], a = null, l = o.compareCompletions;
  for (let u of n.sort((c, d) => d.score - c.score || l(c.completion, d.completion))) {
    let c = u.completion;
    !a || a.label != c.label || a.detail != c.detail || a.type != null && c.type != null && a.type != c.type || a.apply != c.apply || a.boost != c.boost ? s.push(u) : hx(u.completion) > hx(a) && (s[s.length - 1] = u), a = u.completion;
  }
  return s;
}
class yl {
  constructor(e, n, i, r, o, s) {
    this.options = e, this.attrs = n, this.tooltip = i, this.timestamp = r, this.selected = o, this.disabled = s;
  }
  setSelected(e, n) {
    return e == this.selected || e >= this.options.length ? this : new yl(this.options, fx(n, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, n, i, r, o, s) {
    if (r && !s && e.some((u) => u.isPending))
      return r.setDisabled();
    let a = yre(e, n);
    if (!a.length)
      return r && e.some((u) => u.isPending) ? r.setDisabled() : null;
    let l = n.facet(En).selectOnOpen ? 0 : -1;
    if (r && r.selected != l && r.selected != -1) {
      let u = r.options[r.selected].completion;
      for (let c = 0; c < a.length; c++)
        if (a[c].completion == u) {
          l = c;
          break;
        }
    }
    return new yl(a, fx(i, l), {
      pos: e.reduce((u, c) => c.hasResult() ? Math.min(u, c.from) : u, 1e8),
      create: xre,
      above: o.aboveCursor
    }, r ? r.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new yl(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new yl(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class Pp {
  constructor(e, n, i) {
    this.active = e, this.id = n, this.open = i;
  }
  static start() {
    return new Pp(Sre, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: n } = e, i = n.facet(En), o = (i.override || n.languageDataAt("autocomplete", xa(n)).map(dre)).map((l) => (this.active.find((c) => c.source == l) || new Ji(
      l,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, i));
    o.length == this.active.length && o.every((l, u) => l == this.active[u]) && (o = this.active);
    let s = this.open, a = e.effects.some((l) => l.is(F0));
    s && e.docChanged && (s = s.map(e.changes)), e.selection || o.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !bre(o, this.active) || a ? s = yl.build(o, n, this.id, s, i, a) : s && s.disabled && !o.some((l) => l.isPending) && (s = null), !s && o.every((l) => !l.isPending) && o.some((l) => l.hasResult()) && (o = o.map((l) => l.hasResult() ? new Ji(
      l.source,
      0
      /* State.Inactive */
    ) : l));
    for (let l of e.effects)
      l.is(UR) && (s = s && s.setSelected(l.value, this.id));
    return o == this.active && s == this.open ? this : new Pp(o, this.id, s);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? wre : kre;
  }
}
function bre(t, e) {
  if (t == e)
    return !0;
  for (let n = 0, i = 0; ; ) {
    for (; n < t.length && !t[n].hasResult(); )
      n++;
    for (; i < e.length && !e[i].hasResult(); )
      i++;
    let r = n == t.length, o = i == e.length;
    if (r || o)
      return r == o;
    if (t[n++].result != e[i++].result)
      return !1;
  }
}
const wre = {
  "aria-autocomplete": "list"
}, kre = {};
function fx(t, e) {
  let n = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (n["aria-activedescendant"] = t + "-" + e), n;
}
const Sre = [];
function HR(t, e) {
  if (t.isUserEvent("input.complete")) {
    let i = t.annotation(Z0);
    if (i && e.activateOnCompletion(i))
      return 12;
  }
  let n = t.isUserEvent("input.type");
  return n && e.activateOnTyping ? 5 : n ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
}
class Ji {
  constructor(e, n, i = !1) {
    this.source = e, this.state = n, this.explicit = i;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, n) {
    let i = HR(e, n), r = this;
    (i & 8 || i & 16 && this.touches(e)) && (r = new Ji(
      r.source,
      0
      /* State.Inactive */
    )), i & 4 && r.state == 0 && (r = new Ji(
      this.source,
      1
      /* State.Pending */
    )), r = r.updateFor(e, i);
    for (let o of e.effects)
      if (o.is($p))
        r = new Ji(r.source, 1, o.value);
      else if (o.is(pd))
        r = new Ji(
          r.source,
          0
          /* State.Inactive */
        );
      else if (o.is(F0))
        for (let s of o.value)
          s.source == r.source && (r = s);
    return r;
  }
  updateFor(e, n) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(xa(e.state));
  }
}
class Ml extends Ji {
  constructor(e, n, i, r, o, s) {
    super(e, 3, n), this.limit = i, this.result = r, this.from = o, this.to = s;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, n) {
    var i;
    if (!(n & 3))
      return this.map(e.changes);
    let r = this.result;
    r.map && !e.changes.empty && (r = r.map(r, e.changes));
    let o = e.changes.mapPos(this.from), s = e.changes.mapPos(this.to, 1), a = xa(e.state);
    if (a > s || !r || n & 2 && (xa(e.startState) == this.from || a < this.limit))
      return new Ji(
        this.source,
        n & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = e.changes.mapPos(this.limit);
    return _re(r.validFor, e.state, o, s) ? new Ml(this.source, this.explicit, l, r, o, s) : r.update && (r = r.update(r, o, s, new zR(e.state, a, !1))) ? new Ml(this.source, this.explicit, l, r, r.from, (i = r.to) !== null && i !== void 0 ? i : xa(e.state)) : new Ji(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Ml(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new Ji(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function _re(t, e, n, i) {
  if (!t)
    return !1;
  let r = e.sliceDoc(n, i);
  return typeof t == "function" ? t(r, n, i, e) : YR(t, !0).test(r);
}
const F0 = /* @__PURE__ */ ot.define({
  map(t, e) {
    return t.map((n) => n.map(e));
  }
}), UR = /* @__PURE__ */ ot.define(), ki = /* @__PURE__ */ xn.define({
  create() {
    return Pp.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    _m.from(t, (e) => e.tooltip),
    Le.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function q0(t, e) {
  const n = e.completion.apply || e.completion.label;
  let i = t.state.field(ki).active.find((r) => r.source == e.source);
  return i instanceof Ml ? (typeof n == "string" ? t.dispatch(Object.assign(Object.assign({}, cre(t.state, n, i.from, i.to)), { annotations: Z0.of(e.completion) })) : n(t, e.completion, i.from, i.to), !0) : !1;
}
const xre = /* @__PURE__ */ Ore(ki, q0);
function Mh(t, e = "option") {
  return (n) => {
    let i = n.state.field(ki, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < n.state.facet(En).interactionDelay)
      return !1;
    let r = 1, o;
    e == "page" && (o = hA(n, i.open.tooltip)) && (r = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1));
    let { length: s } = i.open.options, a = i.open.selected > -1 ? i.open.selected + r * (t ? 1 : -1) : t ? 0 : s - 1;
    return a < 0 ? a = e == "page" ? 0 : s - 1 : a >= s && (a = e == "page" ? s - 1 : 0), n.dispatch({ effects: UR.of(a) }), !0;
  };
}
const Cre = (t) => {
  let e = t.state.field(ki, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(En).interactionDelay ? !1 : q0(t, e.open.options[e.open.selected]);
}, px = (t) => t.state.field(ki, !1) ? (t.dispatch({ effects: $p.of(!0) }), !0) : !1, Tre = (t) => {
  let e = t.state.field(ki, !1);
  return !e || !e.active.some(
    (n) => n.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: pd.of(null) }), !0);
};
class $re {
  constructor(e, n) {
    this.active = e, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const Pre = 50, Mre = 1e3, Ere = /* @__PURE__ */ dn.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(ki).active)
      e.isPending && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(ki), n = t.state.facet(En);
    if (!t.selectionSet && !t.docChanged && t.startState.field(ki) == e)
      return;
    let i = t.transactions.some((o) => {
      let s = HR(o, n);
      return s & 8 || (o.selection || o.docChanged) && !(s & 3);
    });
    for (let o = 0; o < this.running.length; o++) {
      let s = this.running[o];
      if (i || s.context.abortOnDocChange && t.docChanged || s.updates.length + t.transactions.length > Pre && Date.now() - s.time > Mre) {
        for (let a of s.context.abortListeners)
          try {
            a();
          } catch (l) {
            si(this.view.state, l);
          }
        s.context.abortListeners = null, this.running.splice(o--, 1);
      } else
        s.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((o) => o.effects.some((s) => s.is($p))) && (this.pendingStart = !0);
    let r = this.pendingStart ? 50 : n.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((o) => o.isPending && !this.running.some((s) => s.active.source == o.source)) ? setTimeout(() => this.startUpdate(), r) : -1, this.composing != 0)
      for (let o of t.transactions)
        o.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && o.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(ki);
    for (let n of e.active)
      n.isPending && !this.running.some((i) => i.active.source == n.source) && this.startQuery(n);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(En).updateSyncTime));
  }
  startQuery(t) {
    let { state: e } = this.view, n = xa(e), i = new zR(e, n, t.explicit, this.view), r = new $re(t, i);
    this.running.push(r), Promise.resolve(t.source(i)).then((o) => {
      r.context.aborted || (r.done = o || null, this.scheduleAccept());
    }, (o) => {
      this.view.dispatch({ effects: pd.of(null) }), si(this.view.state, o);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(En).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], n = this.view.state.facet(En), i = this.view.state.field(ki);
    for (let r = 0; r < this.running.length; r++) {
      let o = this.running[r];
      if (o.done === void 0)
        continue;
      if (this.running.splice(r--, 1), o.done) {
        let a = xa(o.updates.length ? o.updates[0].startState : this.view.state), l = Math.min(a, o.done.from + (o.active.explicit ? 0 : 1)), u = new Ml(o.active.source, o.active.explicit, l, o.done, o.done.from, (t = o.done.to) !== null && t !== void 0 ? t : a);
        for (let c of o.updates)
          u = u.update(c, n);
        if (u.hasResult()) {
          e.push(u);
          continue;
        }
      }
      let s = i.active.find((a) => a.source == o.active.source);
      if (s && s.isPending)
        if (o.done == null) {
          let a = new Ji(
            o.active.source,
            0
            /* State.Inactive */
          );
          for (let l of o.updates)
            a = a.update(l, n);
          a.isPending || e.push(a);
        } else
          this.startQuery(s);
    }
    (e.length || i.open && i.open.disabled) && this.view.dispatch({ effects: F0.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(ki, !1);
      if (e && e.tooltip && this.view.state.facet(En).closeOnBlur) {
        let n = e.open && hA(this.view, e.open.tooltip);
        (!n || !n.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: pd.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: $p.of(!1) }), 20), this.composing = 0;
    }
  }
}), Are = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), Rre = /* @__PURE__ */ Us.highest(/* @__PURE__ */ Le.domEventHandlers({
  keydown(t, e) {
    let n = e.state.field(ki, !1);
    if (!n || !n.open || n.open.disabled || n.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(Are && t.altKey) || t.metaKey)
      return !1;
    let i = n.open.options[n.open.selected], r = n.active.find((s) => s.source == i.source), o = i.completion.commitCharacters || r.result.commitCharacters;
    return o && o.indexOf(t.key) > -1 && q0(e, i), !1;
  }
})), GR = /* @__PURE__ */ Le.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class Dre {
  constructor(e, n, i, r) {
    this.field = e, this.line = n, this.from = i, this.to = r;
  }
}
class W0 {
  constructor(e, n, i) {
    this.field = e, this.from = n, this.to = i;
  }
  map(e) {
    let n = e.mapPos(this.from, -1, Bn.TrackDel), i = e.mapPos(this.to, 1, Bn.TrackDel);
    return n == null || i == null ? null : new W0(this.field, n, i);
  }
}
class X0 {
  constructor(e, n) {
    this.lines = e, this.fieldPositions = n;
  }
  instantiate(e, n) {
    let i = [], r = [n], o = e.doc.lineAt(n), s = /^\s*/.exec(o.text)[0];
    for (let l of this.lines) {
      if (i.length) {
        let u = s, c = /^\t*/.exec(l)[0].length;
        for (let d = 0; d < c; d++)
          u += e.facet(Id);
        r.push(n + u.length - c), l = u + l.slice(c);
      }
      i.push(l), n += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new W0(l.field, r[l.line] + l.from, r[l.line] + l.to));
    return { text: i, ranges: a };
  }
  static parse(e) {
    let n = [], i = [], r = [], o;
    for (let s of e.split(/\r\n?|\n/)) {
      for (; o = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(s); ) {
        let a = o[1] ? +o[1] : null, l = o[2] || o[3] || "", u = -1, c = l.replace(/\\[{}]/g, (d) => d[1]);
        for (let d = 0; d < n.length; d++)
          (a != null ? n[d].seq == a : c && n[d].name == c) && (u = d);
        if (u < 0) {
          let d = 0;
          for (; d < n.length && (a == null || n[d].seq != null && n[d].seq < a); )
            d++;
          n.splice(d, 0, { seq: a, name: c }), u = d;
          for (let h of r)
            h.field >= u && h.field++;
        }
        r.push(new Dre(u, i.length, o.index, o.index + c.length)), s = s.slice(0, o.index) + l + s.slice(o.index + o[0].length);
      }
      s = s.replace(/\\([{}])/g, (a, l, u) => {
        for (let c of r)
          c.line == i.length && c.from > u && (c.from--, c.to--);
        return l;
      }), i.push(s);
    }
    return new X0(i, r);
  }
}
let Qre = /* @__PURE__ */ Ue.widget({ widget: /* @__PURE__ */ new class extends mo {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return !1;
  }
}() }), Nre = /* @__PURE__ */ Ue.mark({ class: "cm-snippetField" });
class xu {
  constructor(e, n) {
    this.ranges = e, this.active = n, this.deco = Ue.set(e.map((i) => (i.from == i.to ? Qre : Nre).range(i.from, i.to)));
  }
  map(e) {
    let n = [];
    for (let i of this.ranges) {
      let r = i.map(e);
      if (!r)
        return null;
      n.push(r);
    }
    return new xu(n, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((n) => this.ranges.some((i) => i.field == this.active && i.from <= n.from && i.to >= n.to));
  }
}
const Zd = /* @__PURE__ */ ot.define({
  map(t, e) {
    return t && t.map(e);
  }
}), Ire = /* @__PURE__ */ ot.define(), md = /* @__PURE__ */ xn.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let n of e.effects) {
      if (n.is(Zd))
        return n.value;
      if (n.is(Ire) && t)
        return new xu(t.ranges, n.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => Le.decorations.from(t, (e) => e ? e.deco : Ue.none)
});
function z0(t, e) {
  return ve.create(t.filter((n) => n.field == e).map((n) => ve.range(n.from, n.to)));
}
function Lre(t) {
  let e = X0.parse(t);
  return (n, i, r, o) => {
    let { text: s, ranges: a } = e.instantiate(n.state, r), l = {
      changes: { from: r, to: o, insert: St.of(s) },
      scrollIntoView: !0,
      annotations: i ? [Z0.of(i), Sn.userEvent.of("input.complete")] : void 0
    };
    if (a.length && (l.selection = z0(a, 0)), a.some((u) => u.field > 0)) {
      let u = new xu(a, 0), c = l.effects = [Zd.of(u)];
      n.state.field(md, !1) === void 0 && c.push(ot.appendConfig.of([md, qre, Wre, GR]));
    }
    n.dispatch(n.state.update(l));
  };
}
function KR(t) {
  return ({ state: e, dispatch: n }) => {
    let i = e.field(md, !1);
    if (!i || t < 0 && i.active == 0)
      return !1;
    let r = i.active + t, o = t > 0 && !i.ranges.some((s) => s.field == r + t);
    return n(e.update({
      selection: z0(i.ranges, r),
      effects: Zd.of(o ? null : new xu(i.ranges, r)),
      scrollIntoView: !0
    })), !0;
  };
}
const Vre = ({ state: t, dispatch: e }) => t.field(md, !1) ? (e(t.update({ effects: Zd.of(null) })), !0) : !1, Bre = /* @__PURE__ */ KR(1), Zre = /* @__PURE__ */ KR(-1), Fre = [
  { key: "Tab", run: Bre, shift: Zre },
  { key: "Escape", run: Vre }
], mx = /* @__PURE__ */ Ze.define({
  combine(t) {
    return t.length ? t[0] : Fre;
  }
}), qre = /* @__PURE__ */ Us.highest(/* @__PURE__ */ ku.compute([mx], (t) => t.facet(mx)));
function Oi(t, e) {
  return Object.assign(Object.assign({}, e), { apply: Lre(t) });
}
const Wre = /* @__PURE__ */ Le.domEventHandlers({
  mousedown(t, e) {
    let n = e.state.field(md, !1), i;
    if (!n || (i = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return !1;
    let r = n.ranges.find((o) => o.from <= i && o.to >= i);
    return !r || r.field == n.active ? !1 : (e.dispatch({
      selection: z0(n.ranges, r.field),
      effects: Zd.of(n.ranges.some((o) => o.field > r.field) ? new xu(n.ranges, r.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), gd = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, ma = /* @__PURE__ */ ot.define({
  map(t, e) {
    let n = e.mapPos(t, -1, Bn.TrackAfter);
    return n ?? void 0;
  }
}), j0 = /* @__PURE__ */ new class extends Ba {
}();
j0.startSide = 1;
j0.endSide = -1;
const JR = /* @__PURE__ */ xn.define({
  create() {
    return bt.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let n = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (i) => i >= n.from && i <= n.to });
    }
    for (let n of e.effects)
      n.is(ma) && (t = t.update({ add: [j0.range(n.value, n.value + 1)] }));
    return t;
  }
});
function Xre() {
  return [jre, JR];
}
const sO = "()[]{}<>";
function eD(t) {
  for (let e = 0; e < sO.length; e += 2)
    if (sO.charCodeAt(e) == t)
      return sO.charAt(e + 1);
  return l0(t < 128 ? t : t + 1);
}
function tD(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || gd;
}
const zre = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), jre = /* @__PURE__ */ Le.inputHandler.of((t, e, n, i) => {
  if ((zre ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let r = t.state.selection.main;
  if (i.length > 2 || i.length == 2 && zr(bi(i, 0)) == 1 || e != r.from || n != r.to)
    return !1;
  let o = Ure(t.state, i);
  return o ? (t.dispatch(o), !0) : !1;
}), Yre = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let i = tD(t, t.selection.main.head).brackets || gd.brackets, r = null, o = t.changeByRange((s) => {
    if (s.empty) {
      let a = Gre(t.doc, s.head);
      for (let l of i)
        if (l == a && Lm(t.doc, s.head) == eD(bi(l, 0)))
          return {
            changes: { from: s.head - l.length, to: s.head + l.length },
            range: ve.cursor(s.head - l.length)
          };
    }
    return { range: r = s };
  });
  return r || e(t.update(o, { scrollIntoView: !0, userEvent: "delete.backward" })), !r;
}, Hre = [
  { key: "Backspace", run: Yre }
];
function Ure(t, e) {
  let n = tD(t, t.selection.main.head), i = n.brackets || gd.brackets;
  for (let r of i) {
    let o = eD(bi(r, 0));
    if (e == r)
      return o == r ? eoe(t, r, i.indexOf(r + r + r) > -1, n) : Kre(t, r, o, n.before || gd.before);
    if (e == o && nD(t, t.selection.main.from))
      return Jre(t, r, o);
  }
  return null;
}
function nD(t, e) {
  let n = !1;
  return t.field(JR).between(0, t.doc.length, (i) => {
    i == e && (n = !0);
  }), n;
}
function Lm(t, e) {
  let n = t.sliceString(e, e + 2);
  return n.slice(0, zr(bi(n, 0)));
}
function Gre(t, e) {
  let n = t.sliceString(e - 2, e);
  return zr(bi(n, 0)) == n.length ? n : n.slice(1);
}
function Kre(t, e, n, i) {
  let r = null, o = t.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: e, from: s.from }, { insert: n, from: s.to }],
        effects: ma.of(s.to + e.length),
        range: ve.range(s.anchor + e.length, s.head + e.length)
      };
    let a = Lm(t.doc, s.head);
    return !a || /\s/.test(a) || i.indexOf(a) > -1 ? {
      changes: { insert: e + n, from: s.head },
      effects: ma.of(s.head + e.length),
      range: ve.cursor(s.head + e.length)
    } : { range: r = s };
  });
  return r ? null : t.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Jre(t, e, n) {
  let i = null, r = t.changeByRange((o) => o.empty && Lm(t.doc, o.head) == n ? {
    changes: { from: o.head, to: o.head + n.length, insert: n },
    range: ve.cursor(o.head + n.length)
  } : i = { range: o });
  return i ? null : t.update(r, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function eoe(t, e, n, i) {
  let r = i.stringPrefixes || gd.stringPrefixes, o = null, s = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: ma.of(a.to + e.length),
        range: ve.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, u = Lm(t.doc, l), c;
    if (u == e) {
      if (gx(t, l))
        return {
          changes: { insert: e + e, from: l },
          effects: ma.of(l + e.length),
          range: ve.cursor(l + e.length)
        };
      if (nD(t, l)) {
        let h = n && t.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + h.length, insert: h },
          range: ve.cursor(l + h.length)
        };
      }
    } else {
      if (n && t.sliceDoc(l - 2 * e.length, l) == e + e && (c = Ox(t, l - 2 * e.length, r)) > -1 && gx(t, c))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: ma.of(l + e.length),
          range: ve.cursor(l + e.length)
        };
      if (t.charCategorizer(l)(u) != Ut.Word && Ox(t, l, r) > -1 && !toe(t, l, e, r))
        return {
          changes: { insert: e + e, from: l },
          effects: ma.of(l + e.length),
          range: ve.cursor(l + e.length)
        };
    }
    return { range: o = a };
  });
  return o ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function gx(t, e) {
  let n = hn(t).resolveInner(e + 1);
  return n.parent && n.from == e;
}
function toe(t, e, n, i) {
  let r = hn(t).resolveInner(e, -1), o = i.reduce((s, a) => Math.max(s, a.length), 0);
  for (let s = 0; s < 5; s++) {
    let a = t.sliceDoc(r.from, Math.min(r.to, r.from + n.length + o)), l = a.indexOf(n);
    if (!l || l > -1 && i.indexOf(a.slice(0, l)) > -1) {
      let c = r.firstChild;
      for (; c && c.from == r.from && c.to - c.from > n.length + l; ) {
        if (t.sliceDoc(c.to - n.length, c.to) == n)
          return !1;
        c = c.firstChild;
      }
      return !0;
    }
    let u = r.to == e && r.parent;
    if (!u)
      break;
    r = u;
  }
  return !1;
}
function Ox(t, e, n) {
  let i = t.charCategorizer(e);
  if (i(t.sliceDoc(e - 1, e)) != Ut.Word)
    return e;
  for (let r of n) {
    let o = e - r.length;
    if (t.sliceDoc(o, e) == r && i(t.sliceDoc(o - 1, o)) != Ut.Word)
      return o;
  }
  return -1;
}
function noe(t = {}) {
  return [
    Rre,
    ki,
    En.of(t),
    Ere,
    ioe,
    GR
  ];
}
const iD = [
  { key: "Ctrl-Space", run: px },
  { mac: "Alt-`", run: px },
  { key: "Escape", run: Tre },
  { key: "ArrowDown", run: /* @__PURE__ */ Mh(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Mh(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Mh(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Mh(!1, "page") },
  { key: "Enter", run: Cre }
], ioe = /* @__PURE__ */ Us.highest(/* @__PURE__ */ ku.computeN([En], (t) => t.facet(En).defaultKeymap ? [iD] : [])), roe = /* @__PURE__ */ (() => [
  Uee(),
  Jee(),
  cA(),
  zA(),
  jte(),
  aA(),
  cee(),
  ht.allowMultipleSelections.of(!0),
  Dte(),
  IA(LA, { fallback: !0 }),
  ine(),
  Xre(),
  noe(),
  Pee(),
  Aee(),
  wee(),
  Vie(),
  ku.of([
    ...Hre,
    ...SR,
    ...rre,
    ...UA,
    ...qte,
    ...iD,
    ...Sie
  ])
])(), ooe = /* @__PURE__ */ (() => [
  cA(),
  zA(),
  aA(),
  IA(LA, { fallback: !0 }),
  ku.of([
    ...SR,
    ...UA
  ])
])();
/**
 * vue-codemirror6
 *
 * @description CodeMirror6 Component for vue2 and vue3.
 * @author Logue <logue@hotmail.co.jp>
 * @copyright 2022-2024 By Masashi Yoshikawa All rights reserved.
 * @license MIT
 * @version 1.3.8
 * @see {@link https://github.com/logue/vue-codemirror6}
 */
const soe = (t) => t ? Object.entries(t).reduce((e, [n, i]) => (n = n.charAt(0).toUpperCase() + n.slice(1), n = `on${n}`, { ...e, [n]: i }), {}) : {};
function vx(t, e = {}, n) {
  const { props: i, domProps: r, on: o, ...s } = e, a = o ? soe(o) : {};
  return ir(
    t,
    { ...s, ...i, ...r, ...a },
    n
  );
}
const aoe = (t) => typeof t == "function" ? t() : t;
var loe = Te({
  /** Component Name */
  name: "CodeMirror",
  /** Model Definition */
  model: {
    prop: "modelValue",
    event: "update:modelValue"
  },
  /** Props Definition */
  props: {
    /** Model value */
    modelValue: {
      type: String,
      default: ""
    },
    /**
     * Theme
     *
     * @see {@link https://codemirror.net/docs/ref/#view.EditorView^theme}
     */
    theme: {
      type: Object,
      default: () => ({})
    },
    /** Dark Mode */
    dark: {
      type: Boolean,
      default: !1
    },
    /**
     * Use Basic Setup
     *
     * @see {@link https://codemirror.net/docs/ref/#codemirror.basicSetup}
     */
    basic: {
      type: Boolean,
      default: !1
    },
    /**
     * Use Minimal Setup (The basic setting has priority.)
     *
     * @see {@link https://codemirror.net/docs/ref/#codemirror.minimalSetup}
     */
    minimal: {
      type: Boolean,
      default: !1
    },
    /**
     * Placeholder
     *
     * @see {@link https://codemirror.net/docs/ref/#view.placeholder}
     */
    placeholder: {
      type: String,
      default: void 0
    },
    /**
     * Line wrapping
     *
     * An extension that enables line wrapping in the editor (by setting CSS white-space to pre-wrap in the content).
     *
     * @see {@link https://codemirror.net/docs/ref/#view.EditorView%5ElineWrapping}
     */
    wrap: {
      type: Boolean,
      default: !1
    },
    /**
     * Allow tab key indent.
     *
     * @see {@link https://codemirror.net/examples/tab/}
     */
    tab: {
      type: Boolean,
      default: !1
    },
    /**
     * Tab character
     */
    indentUnit: {
      type: String,
      default: void 0
    },
    /**
     * Allow Multiple Selection.
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^allowMultipleSelections}
     */
    allowMultipleSelections: {
      type: Boolean,
      default: !1
    },
    /**
     * Tab size
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^tabSize}
     */
    tabSize: {
      type: Number,
      default: void 0
    },
    /**
     * Set line break (separetor) char.
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^lineSeparator}
     */
    lineSeparator: {
      type: String,
      default: void 0
    },
    /**
     * Readonly
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^readOnly}
     */
    readonly: {
      type: Boolean,
      default: !1
    },
    /**
     * Disable input.
     *
     * This is the reversed value of the CodeMirror editable.
     * Similar to `readonly`, but setting this value to true disables dragging.
     *
     * @see {@link https://codemirror.net/docs/ref/#view.EditorView^editable}
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * Additional Extension
     *
     * @see {@link https://codemirror.net/docs/ref/#state.Extension}
     */
    extensions: {
      type: Array,
      default: () => []
    },
    /**
     * Language Phreses
     *
     * @see {@link https://codemirror.net/examples/translate/}
     */
    phrases: {
      type: Object,
      default: () => {
      }
    },
    /**
     * CodeMirror Language
     *
     * @see {@link https://codemirror.net/docs/ref/#language}
     */
    lang: {
      type: Object,
      default: () => {
      }
    },
    /**
     * CodeMirror Linter
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.linter}
     */
    linter: {
      type: Function,
      default: void 0
    },
    /**
     * Linter Config
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.linter^config}
     */
    linterConfig: {
      type: Object,
      default: () => ({})
    },
    /**
     * Forces any linters configured to run when the editor is idle to run right away.
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.forceLinting}
     */
    forceLinting: {
      type: Boolean,
      default: !1
    },
    /**
     * Show Linter Gutter
     *
     * An area to 🔴 the lines with errors will be displayed.
     * This feature is not enabled if `linter` is not specified.
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.lintGutter}
     */
    gutter: {
      type: Boolean,
      default: !1
    },
    /**
     * Gutter Config
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.lintGutter^config}
     */
    gutterConfig: {
      type: Object,
      default: () => {
      }
    },
    /**
     * Using tag
     */
    tag: {
      type: String,
      default: "div"
    }
  },
  /** Emits */
  emits: {
    /** Model Update */
    "update:modelValue": (t = "") => !0,
    /** CodeMirror ViewUpdate */
    update: (t) => !0,
    /** CodeMirror onReady */
    ready: (t) => !0,
    /** CodeMirror onFocus */
    focus: (t) => !0,
    /** State Changed */
    change: (t) => !0,
    /** CodeMirror onDestroy */
    destroy: () => !0
  },
  /**
   * Setup
   *
   * @param props  - Props
   * @param context - Context
   */
  setup(t, e) {
    const n = re(), i = re(t.modelValue), r = vd(new Le()), o = J({
      get: () => r.value.hasFocus,
      set: (A) => {
        A && r.value.focus();
      }
    }), s = J({
      get: () => r.value.state.selection,
      set: (A) => r.value.dispatch({ selection: A })
    }), a = J({
      get: () => r.value.state.selection.main.head,
      set: (A) => r.value.dispatch({ selection: { anchor: A } })
    }), l = J(
      {
        get: () => r.value.state.toJSON(),
        set: (A) => r.value.setState(ht.fromJSON(A))
      }
    ), u = re(0), c = re(0), d = J(() => {
      const A = new nu(), T = new nu();
      if (t.basic && t.minimal)
        throw "[Vue CodeMirror] Both basic and minimal cannot be specified.";
      return [
        // Toggle basic setup
        t.basic && !t.minimal ? roe : void 0,
        // Toggle minimal setup
        t.minimal && !t.basic ? ooe : void 0,
        // ViewUpdate event listener
        Le.updateListener.of((N) => {
          var Q;
          e.emit("focus", r.value.hasFocus), u.value = (Q = r.value.state.doc) == null ? void 0 : Q.length, !(N.changes.empty || !N.docChanged) && (t.linter && (t.forceLinting && nx(r.value), c.value = t.linter(r.value).length), e.emit("update", N));
        }),
        // Toggle light/dark mode.
        Le.theme(t.theme, { dark: t.dark }),
        // Toggle line wrapping
        t.wrap ? Le.lineWrapping : void 0,
        // Indent with tab
        t.tab ? ku.of([gie]) : void 0,
        // Tab character
        t.indentUnit ? Id.of(t.indentUnit) : void 0,
        // Allow Multiple Selections
        ht.allowMultipleSelections.of(t.allowMultipleSelections),
        // Indent tab size
        t.tabSize ? T.of(ht.tabSize.of(t.tabSize)) : void 0,
        // locale settings
        t.phrases ? ht.phrases.of(t.phrases) : void 0,
        // Readonly option
        ht.readOnly.of(t.readonly),
        // Editable option
        Le.editable.of(!t.disabled),
        // Set Line break char
        t.lineSeparator ? ht.lineSeparator.of(t.lineSeparator) : void 0,
        // Lang
        t.lang ? A.of(t.lang) : void 0,
        // Append Linter settings
        t.linter ? xie(t.linter, t.linterConfig) : void 0,
        // Show 🔴 to error line when linter enabled.
        t.linter && t.gutter ? Die(t.gutterConfig) : void 0,
        // Placeholder
        t.placeholder ? xee(t.placeholder) : void 0,
        // Append Extensions
        ...t.extensions
      ].filter((N) => !!N);
    });
    gt(
      d,
      (A) => {
        var T;
        (T = r.value) == null || T.dispatch({
          effects: ot.reconfigure.of(A)
        });
      },
      { immediate: !0 }
    ), gt(
      () => t.modelValue,
      async (A) => {
        if (r.value.composing || // IME fix
        r.value.state.doc.toJSON().join(t.lineSeparator ?? `
`) === A)
          return;
        const T = !r.value.state.selection.ranges.every(
          (N) => N.anchor < A.length && N.head < A.length
        );
        r.value.dispatch({
          changes: { from: 0, to: r.value.state.doc.length, insert: A },
          selection: T ? { anchor: 0, head: 0 } : r.value.state.selection,
          scrollIntoView: !0
        });
      },
      { immediate: !0 }
    ), Et(async () => {
      let A = i.value;
      n.value && (n.value.childNodes[0] && (i.value !== "" && console.warn(
        "[CodeMirror.vue] The <code-mirror> tag contains child elements that overwrite the `v-model` values."
      ), A = n.value.childNodes[0].innerText.trim()), r.value = new Le({
        parent: n.value,
        state: ht.create({ doc: A, extensions: d.value }),
        dispatch: (T) => {
          r.value.update([T]), !(T.changes.empty || !T.docChanged) && (e.emit("update:modelValue", T.state.doc.toString() ?? ""), e.emit("change", T.state));
        }
      }), await nn(), e.emit("ready", {
        view: r.value,
        state: r.value.state,
        container: n.value
      }));
    }), to(() => {
      r.value.destroy(), e.emit("destroy");
    });
    const h = () => {
      !t.linter || !r.value || (t.forceLinting && nx(r.value), c.value = vie(r.value.state));
    }, f = () => {
      var A, T;
      (A = r.value) == null || A.dispatch({
        effects: ot.reconfigure.of([])
      }), (T = r.value) == null || T.dispatch({
        effects: ot.appendConfig.of(d.value)
      });
    }, p = (A, T) => r.value.state.sliceDoc(A, T), m = (A) => r.value.state.doc.line(A + 1).text, g = () => r.value.state.doc.lines, O = () => r.value.state.selection.main.head, y = () => {
      let A;
      return (A = r.value.state.selection.ranges) !== null && A !== void 0 ? A : [];
    }, b = () => {
      let A;
      return (A = r.value.state.sliceDoc(
        r.value.state.selection.main.from,
        r.value.state.selection.main.to
      )) !== null && A !== void 0 ? A : "";
    }, v = () => {
      const A = r.value.state;
      return A ? A.selection.ranges.map(
        (T) => A.sliceDoc(T.from, T.to)
      ) : [];
    }, k = () => r.value.state.selection.ranges.some(
      (A) => !A.empty
    ), w = (A, T, N) => r.value.dispatch({
      changes: { from: T, to: N, insert: A }
    }), S = (A) => r.value.dispatch(r.value.state.replaceSelection(A)), $ = (A) => r.value.dispatch({ selection: { anchor: A } }), C = (A, T) => r.value.dispatch({ selection: { anchor: A, head: T } }), L = (A, T) => r.value.dispatch({
      selection: ve.create(A, T)
    }), j = (A) => r.value.dispatch({
      selection: ve.create(
        s.value.ranges.map((T) => T.extend(A(T)))
      )
    }), P = {
      editor: n,
      view: r,
      cursor: a,
      selection: s,
      focus: o,
      length: u,
      json: l,
      diagnosticCount: c,
      dom: r.value.contentDOM,
      lint: h,
      forceReconfigure: f,
      // Bellow is CodeMirror5's function
      getRange: p,
      getLine: m,
      lineCount: g,
      getCursor: O,
      listSelections: y,
      getSelection: b,
      getSelections: v,
      somethingSelected: k,
      replaceRange: w,
      replaceSelection: S,
      setCursor: $,
      setSelection: C,
      setSelections: L,
      extendSelectionsBy: j
    };
    return e.expose(P), P;
  },
  render() {
    return vx(
      this.$props.tag,
      {
        ref: "editor",
        class: "vue-codemirror"
      },
      this.$slots.default ? (
        // Hide original content
        vx(
          "aside",
          { style: "display: none;", "aria-hidden": "true" },
          aoe(this.$slots.default)
        )
      ) : void 0
    );
  }
});
class Mp {
  /**
  @internal
  */
  constructor(e, n, i, r, o, s, a, l, u, c = 0, d) {
    this.p = e, this.stack = n, this.state = i, this.reducePos = r, this.pos = o, this.score = s, this.buffer = a, this.bufferBase = l, this.curContext = u, this.lookAhead = c, this.parent = d;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, n, i = 0) {
    let r = e.parser.context;
    return new Mp(e, [], n, i, i, 0, [], 0, r ? new yx(r, r.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var n;
    let i = e >> 19, r = e & 65535, { parser: o } = this.p, s = this.reducePos < this.pos - 25;
    s && this.setLookAhead(this.pos);
    let a = o.dynamicPrecedence(r);
    if (a && (this.score += a), i == 0) {
      this.pushState(o.getGoto(this.state, r, !0), this.reducePos), r < o.minRepeatTerm && this.storeNode(r, this.reducePos, this.reducePos, s ? 8 : 4, !0), this.reduceContext(r, this.reducePos);
      return;
    }
    let l = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0), u = l ? this.stack[l - 2] : this.p.ranges[0].from, c = this.reducePos - u;
    c >= 2e3 && !(!((n = this.p.parser.nodeSet.types[r]) === null || n === void 0) && n.isAnonymous) && (u == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = u, this.p.lastBigReductionSize = c));
    let d = l ? this.stack[l - 1] : 0, h = this.bufferBase + this.buffer.length - d;
    if (r < o.minRepeatTerm || e & 131072) {
      let f = o.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(r, u, f, h + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[l];
    else {
      let f = this.stack[l - 3];
      this.state = o.getGoto(f, r, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(r, u);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, n, i, r = 4, o = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let s = this, a = this.buffer.length;
      if (a == 0 && s.parent && (a = s.bufferBase - s.parent.bufferBase, s = s.parent), a > 0 && s.buffer[a - 4] == 0 && s.buffer[a - 1] > -1) {
        if (n == i)
          return;
        if (s.buffer[a - 2] >= n) {
          s.buffer[a - 2] = i;
          return;
        }
      }
    }
    if (!o || this.pos == i)
      this.buffer.push(e, n, i, r);
    else {
      let s = this.buffer.length;
      if (s > 0 && this.buffer[s - 4] != 0) {
        let a = !1;
        for (let l = s; l > 0 && this.buffer[l - 2] > i; l -= 4)
          if (this.buffer[l - 1] >= 0) {
            a = !0;
            break;
          }
        if (a)
          for (; s > 0 && this.buffer[s - 2] > i; )
            this.buffer[s] = this.buffer[s - 4], this.buffer[s + 1] = this.buffer[s - 3], this.buffer[s + 2] = this.buffer[s - 2], this.buffer[s + 3] = this.buffer[s - 1], s -= 4, r > 4 && (r -= 4);
      }
      this.buffer[s] = e, this.buffer[s + 1] = n, this.buffer[s + 2] = i, this.buffer[s + 3] = r;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, n, i, r) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = r, this.shiftContext(n, i), n <= this.p.parser.maxNode && this.buffer.push(n, i, r, 4);
    else {
      let o = e, { parser: s } = this.p;
      (r > this.pos || n <= s.maxNode) && (this.pos = r, s.stateFlag(
        o,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = r)), this.pushState(o, i), this.shiftContext(n, i), n <= s.maxNode && this.buffer.push(n, i, r, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, n, i, r) {
    e & 65536 ? this.reduce(e) : this.shift(e, n, i, r);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, n) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
    let r = this.pos;
    this.reducePos = this.pos = r + e.length, this.pushState(n, r), this.buffer.push(
      i,
      r,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, n = e.buffer.length;
    for (; n > 0 && e.buffer[n - 2] > e.reducePos; )
      n -= 4;
    let i = e.buffer.slice(n), r = e.bufferBase + n;
    for (; e && r == e.bufferBase; )
      e = e.parent;
    return new Mp(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, r, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, n) {
    let i = e <= this.p.parser.maxNode;
    i && this.storeNode(e, this.pos, n, 4), this.storeNode(0, this.pos, n, i ? 8 : 4), this.pos = this.reducePos = n, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let n = new uoe(this); ; ) {
      let i = this.p.parser.stateSlot(
        n.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(n.state, e);
      if (i == 0)
        return !1;
      if (!(i & 65536))
        return !0;
      n.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 8 || this.stack.length >= 120) {
      let r = [];
      for (let o = 0, s; o < n.length; o += 2)
        (s = n[o + 1]) != this.state && this.p.parser.hasAction(s, e) && r.push(n[o], s);
      if (this.stack.length < 120)
        for (let o = 0; r.length < 8 && o < n.length; o += 2) {
          let s = n[o + 1];
          r.some((a, l) => l & 1 && a == s) || r.push(n[o], s);
        }
      n = r;
    }
    let i = [];
    for (let r = 0; r < n.length && i.length < 4; r += 2) {
      let o = n[r + 1];
      if (o == this.state)
        continue;
      let s = this.split();
      s.pushState(o, this.pos), s.storeNode(0, s.pos, s.pos, 4, !0), s.shiftContext(n[r], this.pos), s.reducePos = this.pos, s.score -= 200, i.push(s);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, n = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(n & 65536))
      return !1;
    if (!e.validAction(this.state, n)) {
      let i = n >> 19, r = n & 65535, o = this.stack.length - i * 3;
      if (o < 0 || e.getGoto(this.stack[o], r, !1) < 0) {
        let s = this.findForcedReduction();
        if (s == null)
          return !1;
        n = s;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(n), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, n = [], i = (r, o) => {
      if (!n.includes(r))
        return n.push(r), e.allActions(r, (s) => {
          if (!(s & 393216))
            if (s & 65536) {
              let a = (s >> 19) - o;
              if (a > 1) {
                let l = s & 65535, u = this.stack.length - a * 3;
                if (u >= 0 && e.getGoto(this.stack[u], l, !1) >= 0)
                  return a << 19 | 65536 | l;
              }
            } else {
              let a = i(s, o + 1);
              if (a != null)
                return a;
            }
        });
    };
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let n = 0; n < this.stack.length; n += 3)
      if (this.stack[n] != e.stack[n])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  reduceContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let n = new yx(this.curContext.tracker, e);
      n.hash != this.curContext.hash && this.emitContext(), this.curContext = n;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class yx {
  constructor(e, n) {
    this.tracker = e, this.context = n, this.hash = e.strict ? e.hash(n) : 0;
  }
}
class uoe {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let n = e & 65535, i = e >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let r = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);
    this.state = r;
  }
}
class Ep {
  constructor(e, n, i) {
    this.stack = e, this.pos = n, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, n = e.bufferBase + e.buffer.length) {
    return new Ep(e, n, n - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Ep(this.stack, this.pos, this.index);
  }
}
function oc(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let n = null;
  for (let i = 0, r = 0; i < t.length; ) {
    let o = 0;
    for (; ; ) {
      let s = t.charCodeAt(i++), a = !1;
      if (s == 126) {
        o = 65535;
        break;
      }
      s >= 92 && s--, s >= 34 && s--;
      let l = s - 32;
      if (l >= 46 && (l -= 46, a = !0), o += l, a)
        break;
      o *= 46;
    }
    n ? n[r++] = o : n = new e(o);
  }
  return n;
}
class Jh {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const bx = new Jh();
class coe {
  /**
  @internal
  */
  constructor(e, n) {
    this.input = e, this.ranges = n, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = bx, this.rangeIndex = 0, this.pos = this.chunkPos = n[0].from, this.range = n[0], this.end = n[n.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, n) {
    let i = this.range, r = this.rangeIndex, o = this.pos + e;
    for (; o < i.from; ) {
      if (!r)
        return null;
      let s = this.ranges[--r];
      o -= i.from - s.to, i = s;
    }
    for (; n < 0 ? o > i.to : o >= i.to; ) {
      if (r == this.ranges.length - 1)
        return null;
      let s = this.ranges[++r];
      o += s.from - i.to, i = s;
    }
    return o;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let n of this.ranges)
      if (n.to > e)
        return Math.max(e, n.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let n = this.chunkOff + e, i, r;
    if (n >= 0 && n < this.chunk.length)
      i = this.pos + e, r = this.chunk.charCodeAt(n);
    else {
      let o = this.resolveOffset(e, 1);
      if (o == null)
        return -1;
      if (i = o, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        r = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let s = this.rangeIndex, a = this.range;
        for (; a.to <= i; )
          a = this.ranges[++s];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - i)), r = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), r;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, n = 0) {
    let i = n ? this.resolveOffset(n, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, n) {
    this.token.value = e, this.token.end = n;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: n } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = n, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), n = this.pos + e.length;
      this.chunk = n > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, n) {
    if (n ? (this.token = n, n.start = e, n.lookAhead = e + 1, n.value = n.extended = -1) : this.token = bx, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, n) {
    if (e >= this.chunkPos && n <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, n - this.chunkPos);
    if (e >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, n - this.chunk2Pos);
    if (e >= this.range.from && n <= this.range.to)
      return this.input.read(e, n);
    let i = "";
    for (let r of this.ranges) {
      if (r.from >= n)
        break;
      r.to > e && (i += this.input.read(Math.max(r.from, e), Math.min(r.to, n)));
    }
    return i;
  }
}
class El {
  constructor(e, n) {
    this.data = e, this.id = n;
  }
  token(e, n) {
    let { parser: i } = n.p;
    rD(this.data, e, n, this.id, i.data, i.tokenPrecTable);
  }
}
El.prototype.contextual = El.prototype.fallback = El.prototype.extend = !1;
class Ap {
  constructor(e, n, i) {
    this.precTable = n, this.elseToken = i, this.data = typeof e == "string" ? oc(e) : e;
  }
  token(e, n) {
    let i = e.pos, r = 0;
    for (; ; ) {
      let o = e.next < 0, s = e.resolveOffset(1, 1);
      if (rD(this.data, e, n, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (o || r++, s == null)
        break;
      e.reset(s, e.token);
    }
    r && (e.reset(i, e.token), e.acceptToken(this.elseToken, r));
  }
}
Ap.prototype.contextual = El.prototype.fallback = El.prototype.extend = !1;
class ur {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, n = {}) {
    this.token = e, this.contextual = !!n.contextual, this.fallback = !!n.fallback, this.extend = !!n.extend;
  }
}
function rD(t, e, n, i, r, o) {
  let s = 0, a = 1 << i, { dialect: l } = n.p.parser;
  e:
    for (; a & t[s]; ) {
      let u = t[s + 1];
      for (let f = s + 3; f < u; f += 2)
        if ((t[f + 1] & a) > 0) {
          let p = t[f];
          if (l.allows(p) && (e.token.value == -1 || e.token.value == p || doe(p, e.token.value, r, o))) {
            e.acceptToken(p);
            break;
          }
        }
      let c = e.next, d = 0, h = t[s + 2];
      if (e.next < 0 && h > d && t[u + h * 3 - 3] == 65535) {
        s = t[u + h * 3 - 1];
        continue e;
      }
      for (; d < h; ) {
        let f = d + h >> 1, p = u + f + (f << 1), m = t[p], g = t[p + 1] || 65536;
        if (c < m)
          h = f;
        else if (c >= g)
          d = f + 1;
        else {
          s = t[p + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function wx(t, e, n) {
  for (let i = e, r; (r = t[i]) != 65535; i++)
    if (r == n)
      return i - e;
  return -1;
}
function doe(t, e, n, i) {
  let r = wx(n, i, e);
  return r < 0 || wx(n, i, t) < r;
}
const Ai = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let aO = null;
function kx(t, e, n) {
  let i = t.cursor(Bt.IncludeAnonymous);
  for (i.moveTo(e); ; )
    if (!(n < 0 ? i.childBefore(e) : i.childAfter(e)))
      for (; ; ) {
        if ((n < 0 ? i.to < e : i.from > e) && !i.type.isError)
          return n < 0 ? Math.max(0, Math.min(
            i.to - 1,
            e - 25
            /* Lookahead.Margin */
          )) : Math.min(t.length, Math.max(
            i.from + 1,
            e + 25
            /* Lookahead.Margin */
          ));
        if (n < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return n < 0 ? 0 : t.length;
      }
}
class hoe {
  constructor(e, n) {
    this.fragments = e, this.nodeSet = n, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? kx(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? kx(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let n = this.trees.length - 1;
      if (n < 0)
        return this.nextFragment(), null;
      let i = this.trees[n], r = this.index[n];
      if (r == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let o = i.children[r], s = this.start[n] + i.positions[r];
      if (s > e)
        return this.nextStart = s, null;
      if (o instanceof tn) {
        if (s == e) {
          if (s < this.safeFrom)
            return null;
          let a = s + o.length;
          if (a <= this.safeTo) {
            let l = o.prop(dt.lookAhead);
            if (!l || a + l < this.fragment.to)
              return o;
          }
        }
        this.index[n]++, s + o.length >= Math.max(this.safeFrom, e) && (this.trees.push(o), this.start.push(s), this.index.push(0));
      } else
        this.index[n]++, this.nextStart = s + o.length;
    }
  }
}
class foe {
  constructor(e, n) {
    this.stream = n, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((i) => new Jh());
  }
  getActions(e) {
    let n = 0, i = null, { parser: r } = e.p, { tokenizers: o } = r, s = r.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let u = 0; u < o.length; u++) {
      if (!(1 << u & s))
        continue;
      let c = o[u], d = this.tokens[u];
      if (!(i && !c.fallback) && ((c.contextual || d.start != e.pos || d.mask != s || d.context != a) && (this.updateCachedToken(d, c, e), d.mask = s, d.context = a), d.lookAhead > d.end + 25 && (l = Math.max(d.lookAhead, l)), d.value != 0)) {
        let h = n;
        if (d.extended > -1 && (n = this.addActions(e, d.extended, d.end, n)), n = this.addActions(e, d.value, d.end, n), !c.extend && (i = d, n > h))
          break;
      }
    }
    for (; this.actions.length > n; )
      this.actions.pop();
    return l && e.setLookAhead(l), !i && e.pos == this.stream.end && (i = new Jh(), i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, n = this.addActions(e, i.value, i.end, n)), this.mainToken = i, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let n = new Jh(), { pos: i, p: r } = e;
    return n.start = i, n.end = Math.min(i + 1, r.stream.end), n.value = i == r.stream.end ? r.parser.eofTerm : 0, n;
  }
  updateCachedToken(e, n, i) {
    let r = this.stream.clipPos(i.pos);
    if (n.token(this.stream.reset(r, e), i), e.value > -1) {
      let { parser: o } = i.p;
      for (let s = 0; s < o.specialized.length; s++)
        if (o.specialized[s] == e.value) {
          let a = o.specializers[s](this.stream.read(e.start, e.end), i);
          if (a >= 0 && i.p.parser.dialect.allows(a >> 1)) {
            a & 1 ? e.extended = a >> 1 : e.value = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(r + 1);
  }
  putAction(e, n, i, r) {
    for (let o = 0; o < r; o += 3)
      if (this.actions[o] == e)
        return r;
    return this.actions[r++] = e, this.actions[r++] = n, this.actions[r++] = i, r;
  }
  addActions(e, n, i, r) {
    let { state: o } = e, { parser: s } = e.p, { data: a } = s;
    for (let l = 0; l < 2; l++)
      for (let u = s.stateSlot(
        o,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; u += 3) {
        if (a[u] == 65535)
          if (a[u + 1] == 1)
            u = $o(a, u + 2);
          else {
            r == 0 && a[u + 1] == 2 && (r = this.putAction($o(a, u + 2), n, i, r));
            break;
          }
        a[u] == n && (r = this.putAction($o(a, u + 1), n, i, r));
      }
    return r;
  }
}
class poe {
  constructor(e, n, i, r) {
    this.parser = e, this.input = n, this.ranges = r, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new coe(n, r), this.tokens = new foe(e, this.stream), this.topTerm = e.top[1];
    let { from: o } = r[0];
    this.stacks = [Mp.start(this, e.top[0], o)], this.fragments = i.length && this.stream.end - o > e.bufferLength * 4 ? new hoe(i, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, n = this.minStackPos, i = this.stacks = [], r, o;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [s] = e;
      for (; s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > n)
          i.push(a);
        else {
          if (this.advanceStack(a, i, e))
            continue;
          {
            r || (r = [], o = []), r.push(a);
            let l = this.tokens.getMainToken(a);
            o.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let s = r && goe(r);
      if (s)
        return Ai && console.log("Finish with " + this.stackID(s)), this.stackToTree(s);
      if (this.parser.strict)
        throw Ai && r && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + n);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && r) {
      let s = this.stoppedAt != null && r[0].pos > this.stoppedAt ? r[0] : this.runRecovery(r, o, i);
      if (s)
        return Ai && console.log("Force-finish " + this.stackID(s)), this.stackToTree(s.forceAll());
    }
    if (this.recovering) {
      let s = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > s)
        for (i.sort((a, l) => l.score - a.score); i.length > s; )
          i.pop();
      i.some((a) => a.reducePos > n) && this.recovering--;
    } else if (i.length > 1) {
      e:
        for (let s = 0; s < i.length - 1; s++) {
          let a = i[s];
          for (let l = s + 1; l < i.length; l++) {
            let u = i[l];
            if (a.sameState(u) || a.buffer.length > 500 && u.buffer.length > 500)
              if ((a.score - u.score || a.buffer.length - u.buffer.length) > 0)
                i.splice(l--, 1);
              else {
                i.splice(s--, 1);
                continue e;
              }
          }
        }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let s = 1; s < i.length; s++)
      i[s].pos < this.minStackPos && (this.minStackPos = i[s].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, n, i) {
    let r = e.pos, { parser: o } = this, s = Ai ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && r > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let u = e.curContext && e.curContext.tracker.strict, c = u ? e.curContext.hash : 0;
      for (let d = this.fragments.nodeAt(r); d; ) {
        let h = this.parser.nodeSet.types[d.type.id] == d.type ? o.getGoto(e.state, d.type.id) : -1;
        if (h > -1 && d.length && (!u || (d.prop(dt.contextHash) || 0) == c))
          return e.useNode(d, h), Ai && console.log(s + this.stackID(e) + ` (via reuse of ${o.getName(d.type.id)})`), !0;
        if (!(d instanceof tn) || d.children.length == 0 || d.positions[0] > 0)
          break;
        let f = d.children[0];
        if (f instanceof tn && d.positions[0] == 0)
          d = f;
        else
          break;
      }
    }
    let a = o.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), Ai && console.log(s + this.stackID(e) + ` (via always-reduce ${o.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let u = 0; u < l.length; ) {
      let c = l[u++], d = l[u++], h = l[u++], f = u == l.length || !i, p = f ? e : e.split(), m = this.tokens.mainToken;
      if (p.apply(c, d, m ? m.start : p.pos, h), Ai && console.log(s + this.stackID(p) + ` (via ${c & 65536 ? `reduce of ${o.getName(
        c & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${o.getName(d)} @ ${r}${p == e ? "" : ", split"})`), f)
        return !0;
      p.pos > r ? n.push(p) : i.push(p);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, n) {
    let i = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > i)
        return Sx(e, n), !0;
    }
  }
  runRecovery(e, n, i) {
    let r = null, o = !1;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], l = n[s << 1], u = n[(s << 1) + 1], c = Ai ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (o || (o = !0, a.restart(), Ai && console.log(c + this.stackID(a) + " (restarted)"), this.advanceFully(a, i))))
        continue;
      let d = a.split(), h = c;
      for (let f = 0; d.forceReduce() && f < 10 && (Ai && console.log(h + this.stackID(d) + " (via force-reduce)"), !this.advanceFully(d, i)); f++)
        Ai && (h = this.stackID(d) + " -> ");
      for (let f of a.recoverByInsert(l))
        Ai && console.log(c + this.stackID(f) + " (via recover-insert)"), this.advanceFully(f, i);
      this.stream.end > a.pos ? (u == a.pos && (u++, l = 0), a.recoverByDelete(l, u), Ai && console.log(c + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), Sx(a, i)) : (!r || r.score < a.score) && (r = a);
    }
    return r;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), tn.build({
      buffer: Ep.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let n = (aO || (aO = /* @__PURE__ */ new WeakMap())).get(e);
    return n || aO.set(e, n = String.fromCodePoint(this.nextStackID++)), n + e;
  }
}
function Sx(t, e) {
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    if (i.pos == t.pos && i.sameState(t)) {
      e[n].score < t.score && (e[n] = t);
      return;
    }
  }
  e.push(t);
}
class moe {
  constructor(e, n, i) {
    this.source = e, this.flags = n, this.disabled = i;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const lO = (t) => t;
class oD {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || lO, this.reduce = e.reduce || lO, this.reuse = e.reuse || lO, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class du extends kA {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let n = e.nodeNames.split(" ");
    this.minRepeatTerm = n.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      n.push("");
    let i = Object.keys(e.topRules).map((a) => e.topRules[a][1]), r = [];
    for (let a = 0; a < n.length; a++)
      r.push([]);
    function o(a, l, u) {
      r[a].push([l, l.deserialize(String(u))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = dt[l]);
        for (let u = 1; u < a.length; ) {
          let c = a[u++];
          if (c >= 0)
            o(c, l, a[u++]);
          else {
            let d = a[u + -c];
            for (let h = -c; h > 0; h--)
              o(a[u++], l, d);
            u++;
          }
        }
      }
    this.nodeSet = new S0(n.map((a, l) => pi.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: r[l],
      top: i.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = OA;
    let s = oc(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(_x), this.states = oc(e.states, Uint32Array), this.data = oc(e.stateData), this.goto = oc(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new El(s, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, n, i) {
    let r = new poe(this, e, n, i);
    for (let o of this.wrappers)
      r = o(r, e, n, i);
    return r;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, n, i = !1) {
    let r = this.goto;
    if (n >= r[0])
      return -1;
    for (let o = r[n + 1]; ; ) {
      let s = r[o++], a = s & 1, l = r[o++];
      if (a && i)
        return l;
      for (let u = o + (s >> 1); o < u; o++)
        if (r[o] == e)
          return l;
      if (a)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, n) {
    let i = this.data;
    for (let r = 0; r < 2; r++)
      for (let o = this.stateSlot(
        e,
        r ? 2 : 1
        /* ParseState.Actions */
      ), s; ; o += 3) {
        if ((s = i[o]) == 65535)
          if (i[o + 1] == 1)
            s = i[o = $o(i, o + 2)];
          else {
            if (i[o + 1] == 2)
              return $o(i, o + 2);
            break;
          }
        if (s == n || s == 0)
          return $o(i, o + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, n) {
    return this.states[e * 6 + n];
  }
  /**
  @internal
  */
  stateFlag(e, n) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & n) > 0;
  }
  /**
  @internal
  */
  validAction(e, n) {
    return !!this.allActions(e, (i) => i == n ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, n) {
    let i = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), r = i ? n(i) : void 0;
    for (let o = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); r == null; o += 3) {
      if (this.data[o] == 65535)
        if (this.data[o + 1] == 1)
          o = $o(this.data, o + 2);
        else
          break;
      r = n($o(this.data, o + 1));
    }
    return r;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let n = [];
    for (let i = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = $o(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let r = this.data[i + 1];
        n.some((o, s) => s & 1 && o == r) || n.push(this.data[i], r);
      }
    }
    return n;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let n = Object.assign(Object.create(du.prototype), this);
    if (e.props && (n.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let i = this.topRules[e.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      n.top = i;
    }
    return e.tokenizers && (n.tokenizers = this.tokenizers.map((i) => {
      let r = e.tokenizers.find((o) => o.from == i);
      return r ? r.to : i;
    })), e.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((i, r) => {
      let o = e.specializers.find((a) => a.from == i.external);
      if (!o)
        return i;
      let s = Object.assign(Object.assign({}, i), { external: o.to });
      return n.specializers[r] = _x(s), s;
    })), e.contextTracker && (n.context = e.contextTracker), e.dialect && (n.dialect = this.parseDialect(e.dialect)), e.strict != null && (n.strict = e.strict), e.wrap && (n.wrappers = n.wrappers.concat(e.wrap)), e.bufferLength != null && (n.bufferLength = e.bufferLength), n;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let n = Object.keys(this.dialects), i = n.map(() => !1);
    if (e)
      for (let o of e.split(" ")) {
        let s = n.indexOf(o);
        s >= 0 && (i[s] = !0);
      }
    let r = null;
    for (let o = 0; o < n.length; o++)
      if (!i[o])
        for (let s = this.dialects[n[o]], a; (a = this.data[s++]) != 65535; )
          (r || (r = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new moe(e, i, r);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new du(e);
  }
}
function $o(t, e) {
  return t[e] | t[e + 1] << 16;
}
function goe(t) {
  let e = null;
  for (let n of t) {
    let i = n.p.stoppedAt;
    (n.pos == n.p.stream.end || i != null && n.pos > i) && n.p.parser.stateFlag(
      n.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < n.score) && (e = n);
  }
  return e;
}
function _x(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (n, i) => t.external(n, i) << 1 | e;
  }
  return t.get;
}
const Ooe = 54, voe = 1, yoe = 55, boe = 2, woe = 56, koe = 3, xx = 4, Soe = 5, Rp = 6, sD = 7, aD = 8, lD = 9, uD = 10, _oe = 11, xoe = 12, Coe = 13, uO = 57, Toe = 14, Cx = 58, cD = 20, $oe = 22, dD = 23, Poe = 24, Cy = 26, hD = 27, Moe = 28, Eoe = 31, Aoe = 34, Roe = 36, Doe = 37, Qoe = 0, Noe = 1, Ioe = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, Loe = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, Tx = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function Voe(t) {
  return t == 45 || t == 46 || t == 58 || t >= 65 && t <= 90 || t == 95 || t >= 97 && t <= 122 || t >= 161;
}
function fD(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
let $x = null, Px = null, Mx = 0;
function Ty(t, e) {
  let n = t.pos + e;
  if (Mx == n && Px == t)
    return $x;
  let i = t.peek(e);
  for (; fD(i); )
    i = t.peek(++e);
  let r = "";
  for (; Voe(i); )
    r += String.fromCharCode(i), i = t.peek(++e);
  return Px = t, Mx = n, $x = r ? r.toLowerCase() : i == Boe || i == Zoe ? void 0 : null;
}
const pD = 60, Dp = 62, Y0 = 47, Boe = 63, Zoe = 33, Foe = 45;
function Ex(t, e) {
  this.name = t, this.parent = e;
}
const qoe = [Rp, uD, sD, aD, lD], Woe = new oD({
  start: null,
  shift(t, e, n, i) {
    return qoe.indexOf(e) > -1 ? new Ex(Ty(i, 1) || "", t) : t;
  },
  reduce(t, e) {
    return e == cD && t ? t.parent : t;
  },
  reuse(t, e, n, i) {
    let r = e.type.id;
    return r == Rp || r == Roe ? new Ex(Ty(i, 1) || "", t) : t;
  },
  strict: !1
}), Xoe = new ur((t, e) => {
  if (t.next != pD) {
    t.next < 0 && e.context && t.acceptToken(uO);
    return;
  }
  t.advance();
  let n = t.next == Y0;
  n && t.advance();
  let i = Ty(t, 0);
  if (i === void 0)
    return;
  if (!i)
    return t.acceptToken(n ? Toe : Rp);
  let r = e.context ? e.context.name : null;
  if (n) {
    if (i == r)
      return t.acceptToken(_oe);
    if (r && Loe[r])
      return t.acceptToken(uO, -2);
    if (e.dialectEnabled(Qoe))
      return t.acceptToken(xoe);
    for (let o = e.context; o; o = o.parent)
      if (o.name == i)
        return;
    t.acceptToken(Coe);
  } else {
    if (i == "script")
      return t.acceptToken(sD);
    if (i == "style")
      return t.acceptToken(aD);
    if (i == "textarea")
      return t.acceptToken(lD);
    if (Ioe.hasOwnProperty(i))
      return t.acceptToken(uD);
    r && Tx[r] && Tx[r][i] ? t.acceptToken(uO, -1) : t.acceptToken(Rp);
  }
}, { contextual: !0 }), zoe = new ur((t) => {
  for (let e = 0, n = 0; ; n++) {
    if (t.next < 0) {
      n && t.acceptToken(Cx);
      break;
    }
    if (t.next == Foe)
      e++;
    else if (t.next == Dp && e >= 2) {
      n >= 3 && t.acceptToken(Cx, -2);
      break;
    } else
      e = 0;
    t.advance();
  }
});
function joe(t) {
  for (; t; t = t.parent)
    if (t.name == "svg" || t.name == "math")
      return !0;
  return !1;
}
const Yoe = new ur((t, e) => {
  if (t.next == Y0 && t.peek(1) == Dp) {
    let n = e.dialectEnabled(Noe) || joe(e.context);
    t.acceptToken(n ? Soe : xx, 2);
  } else
    t.next == Dp && t.acceptToken(xx, 1);
});
function H0(t, e, n) {
  let i = 2 + t.length;
  return new ur((r) => {
    for (let o = 0, s = 0, a = 0; ; a++) {
      if (r.next < 0) {
        a && r.acceptToken(e);
        break;
      }
      if (o == 0 && r.next == pD || o == 1 && r.next == Y0 || o >= 2 && o < i && r.next == t.charCodeAt(o - 2))
        o++, s++;
      else if ((o == 2 || o == i) && fD(r.next))
        s++;
      else if (o == i && r.next == Dp) {
        a > s ? r.acceptToken(e, -s) : r.acceptToken(n, -(s - 2));
        break;
      } else if ((r.next == 10 || r.next == 13) && a) {
        r.acceptToken(e, 1);
        break;
      } else
        o = s = 0;
      r.advance();
    }
  });
}
const Hoe = H0("script", Ooe, voe), Uoe = H0("style", yoe, boe), Goe = H0("textarea", woe, koe), Koe = Cm({
  "Text RawText": ee.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": ee.angleBracket,
  TagName: ee.tagName,
  "MismatchedCloseTag/TagName": [ee.tagName, ee.invalid],
  AttributeName: ee.attributeName,
  "AttributeValue UnquotedAttributeValue": ee.attributeValue,
  Is: ee.definitionOperator,
  "EntityReference CharacterReference": ee.character,
  Comment: ee.blockComment,
  ProcessingInst: ee.processingInstruction,
  DoctypeDecl: ee.documentMeta
}), Joe = du.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: Woe,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [Koe],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [Hoe, Uoe, Goe, Yoe, Xoe, zoe, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 509 },
  tokenPrec: 511
});
function mD(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let i of t.getChildren(dD)) {
    let r = i.getChild(Poe), o = i.getChild(Cy) || i.getChild(hD);
    r && (n[e.read(r.from, r.to)] = o ? o.type.id == Cy ? e.read(o.from + 1, o.to - 1) : e.read(o.from, o.to) : "");
  }
  return n;
}
function Ax(t, e) {
  let n = t.getChild($oe);
  return n ? e.read(n.from, n.to) : " ";
}
function cO(t, e, n) {
  let i;
  for (let r of n)
    if (!r.attrs || r.attrs(i || (i = mD(t.node.parent.firstChild, e))))
      return { parser: r.parser };
  return null;
}
function gD(t = [], e = []) {
  let n = [], i = [], r = [], o = [];
  for (let a of t)
    (a.tag == "script" ? n : a.tag == "style" ? i : a.tag == "textarea" ? r : o).push(a);
  let s = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let a of e)
    (s[a.name] || (s[a.name] = [])).push(a);
  return ate((a, l) => {
    let u = a.type.id;
    if (u == Moe)
      return cO(a, l, n);
    if (u == Eoe)
      return cO(a, l, i);
    if (u == Aoe)
      return cO(a, l, r);
    if (u == cD && o.length) {
      let c = a.node, d = c.firstChild, h = d && Ax(d, l), f;
      if (h) {
        for (let p of o)
          if (p.tag == h && (!p.attrs || p.attrs(f || (f = mD(d, l))))) {
            let m = c.lastChild, g = m.type.id == Doe ? m.from : c.to;
            if (g > d.to)
              return { parser: p.parser, overlay: [{ from: d.to, to: g }] };
          }
      }
    }
    if (s && u == dD) {
      let c = a.node, d;
      if (d = c.firstChild) {
        let h = s[l.read(d.from, d.to)];
        if (h)
          for (let f of h) {
            if (f.tagName && f.tagName != Ax(c.parent, l))
              continue;
            let p = c.lastChild;
            if (p.type.id == Cy) {
              let m = p.from + 1, g = p.lastChild, O = p.to - (g && g.isError ? 0 : 1);
              if (O > m)
                return { parser: f.parser, overlay: [{ from: m, to: O }] };
            } else if (p.type.id == hD)
              return { parser: f.parser, overlay: [{ from: p.from, to: p.to }] };
          }
      }
    }
    return null;
  });
}
const ese = 99, Rx = 1, tse = 100, nse = 101, Dx = 2, OD = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], ise = 58, rse = 40, vD = 95, ose = 91, ef = 45, sse = 46, ase = 35, lse = 37, use = 38, cse = 92, dse = 10;
function Od(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 161;
}
function yD(t) {
  return t >= 48 && t <= 57;
}
const hse = new ur((t, e) => {
  for (let n = !1, i = 0, r = 0; ; r++) {
    let { next: o } = t;
    if (Od(o) || o == ef || o == vD || n && yD(o))
      !n && (o != ef || r > 0) && (n = !0), i === r && o == ef && i++, t.advance();
    else if (o == cse && t.peek(1) != dse)
      t.advance(), t.next > -1 && t.advance(), n = !0;
    else {
      n && t.acceptToken(o == rse ? tse : i == 2 && e.canShift(Dx) ? Dx : nse);
      break;
    }
  }
}), fse = new ur((t) => {
  if (OD.includes(t.peek(-1))) {
    let { next: e } = t;
    (Od(e) || e == vD || e == ase || e == sse || e == ose || e == ise && Od(t.peek(1)) || e == ef || e == use) && t.acceptToken(ese);
  }
}), pse = new ur((t) => {
  if (!OD.includes(t.peek(-1))) {
    let { next: e } = t;
    if (e == lse && (t.advance(), t.acceptToken(Rx)), Od(e)) {
      do
        t.advance();
      while (Od(t.next) || yD(t.next));
      t.acceptToken(Rx);
    }
  }
}), mse = Cm({
  "AtKeyword import charset namespace keyframes media supports": ee.definitionKeyword,
  "from to selector": ee.keyword,
  NamespaceName: ee.namespace,
  KeyframeName: ee.labelName,
  KeyframeRangeName: ee.operatorKeyword,
  TagName: ee.tagName,
  ClassName: ee.className,
  PseudoClassName: ee.constant(ee.className),
  IdName: ee.labelName,
  "FeatureName PropertyName": ee.propertyName,
  AttributeName: ee.attributeName,
  NumberLiteral: ee.number,
  KeywordQuery: ee.keyword,
  UnaryQueryOp: ee.operatorKeyword,
  "CallTag ValueName": ee.atom,
  VariableName: ee.variableName,
  Callee: ee.operatorKeyword,
  Unit: ee.unit,
  "UniversalSelector NestingSelector": ee.definitionOperator,
  MatchOp: ee.compareOperator,
  "ChildOp SiblingOp, LogicOp": ee.logicOperator,
  BinOp: ee.arithmeticOperator,
  Important: ee.modifier,
  Comment: ee.blockComment,
  ColorLiteral: ee.color,
  "ParenthesizedContent StringLiteral": ee.string,
  ":": ee.punctuation,
  "PseudoOp #": ee.derefOperator,
  "; ,": ee.separator,
  "( )": ee.paren,
  "[ ]": ee.squareBracket,
  "{ }": ee.brace
}), gse = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 138 }, Ose = { __proto__: null, "@import": 118, "@media": 142, "@charset": 146, "@namespace": 150, "@keyframes": 156, "@supports": 168 }, vse = { __proto__: null, not: 132, only: 132 }, yse = du.deserialize({
  version: 14,
  states: ":jQYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO-kQdO,59}O-{Q[O'#E^O.YQWO,5;_O.YQWO,5;_POOO'#EV'#EVP.eO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO/[QXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/iQ`O1G/^O0SQXO1G/aO0jQXO1G/cO1QQXO1G/dO1hQWO,59|O1mQ[O'#DSO1tQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1{QpO,59]OOQS,59_,59_O${QdO,59aO2TQWO1G/mOOQS,59c,59cO2YQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2eQ[O,59jOOQS,59j,59jO2mQWO'#DjO2xQWO,5:VO2}QWO,5:]O&`Q[O,5:XO&`Q[O'#E_O3VQWO,5;`O3bQWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3sQWO1G0OO3xQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO4TQtO1G/iOOQO1G/i1G/iOOQO,5:x,5:xO4kQ[O,5:xOOQO-E8[-E8[O4xQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO5TQXO'#ErO5[QWO,59nO5aQtO'#EXO6XQdO'#EoO6cQWO,59ZO6hQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XOOQS1G/P1G/PO6pQWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6uQWO,5:yOOQO-E8]-E8]O7TQXO1G/xOOQS7+%j7+%jO7[QYO'#CsOOQO'#EQ'#EQO7gQ`O'#EPOOQO'#EP'#EPO7rQWO'#E`O7zQdO,5:jOOQS,5:j,5:jO8VQtO'#E]O${QdO'#E]O9WQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9kQpO<<HdO9sQWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9{QWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO:TQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3{QdO'#EaO7rQWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO:[QtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO;]QdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
  stateData: ";o~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!X#rO!Y!Va#U!Va!S!Va~P${O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#xO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.pOp#zO|#{O~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/qOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/qOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/qO!S#|O~Oa#fP~P(aOa#cP~P${Oa$TOj#XO~O!Y$VO~Oa$WOh$XOo$XO~Op$ZO#X#]O~O]!`Xa!^X!b!^X~O]$[O~Oa$]O!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$bO~O!S$iO#X$dO#e$cO~Oj#XOt$kO!X$mO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$qO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$sOa#cX~P${Oa$uO~Oj#XOp$vO~Oa$wO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$yO~P.pOP#WOtgX!TgX~O#e$cOt!sX!T!sX~Ot${O!TwO~O!S%PO#X$dO#e$cO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$kO!X%SO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%TO~OtoOa#fa~Ot$sOa#ca~Oa%WO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
  goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#tkYOPdhotuvw!n#R#h#tkSOPdhotuvw!n#R#h#tQmTR!tnQ{VR!xqQ!x}Q#Z!XR#y!zq![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%Up![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%UU$f#m$h${R$z$eq!XZ]!T!m#S#U#X#q#{$Q$[$k$l$s$x%Up![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%UQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#y!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ$}$gR%Z$|SgPwQ!phQ#s!nR$n#tZfPhw!n#ta!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$g#m$hR%X${V$e#m$h${Q!rjR#w!rQdOShPwU!ldh#tR#t!nQ$Q#SU$r$Q$x%UQ$x$[R%U$sQ#_!ZR$Y#_Q$t$QR%V$tQpUS!vp$pR$p#}Q$l#qR%R$lQ!ogS#u!o#vR#v!pQ#f!_R$`#fQ$h#mR%O$hQ$|$gR%Y$|_cOPdhw!n#t^UOPdhw!n#tQ!uoQ!}tQ#OuQ#PvQ#}#RR$a#hR$R#SQ!VZQ!d]Q#V!TQ#q!m[$P#S$Q$[$s$x%UQ$S#UQ$U#XS$j#q$lQ$o#{R%Q$kR$O#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$^#dR$_#e",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 117,
  nodeProps: [
    ["isolate", -2, 3, 24, ""],
    ["openedBy", 17, "(", 32, "[", 50, "{"],
    ["closedBy", 18, ")", 33, "]", 51, "}"]
  ],
  propSources: [mse],
  skippedNodes: [0, 3, 87],
  repeatNodeCount: 11,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [fse, pse, hse, 1, 2, 3, 4, new Ap("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 86] },
  specialized: [{ term: 100, get: (t) => gse[t] || -1 }, { term: 58, get: (t) => Ose[t] || -1 }, { term: 101, get: (t) => vse[t] || -1 }],
  tokenPrec: 1219
});
let dO = null;
function hO() {
  if (!dO && typeof document == "object" && document.body) {
    let { style: t } = document.body, e = [], n = /* @__PURE__ */ new Set();
    for (let i in t)
      i != "cssText" && i != "cssFloat" && typeof t[i] == "string" && (/[A-Z]/.test(i) && (i = i.replace(/[A-Z]/g, (r) => "-" + r.toLowerCase())), n.has(i) || (e.push(i), n.add(i)));
    dO = e.sort().map((i) => ({ type: "property", label: i, apply: i + ": " }));
  }
  return dO || [];
}
const Qx = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((t) => ({ type: "class", label: t })), Nx = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((t) => ({ type: "keyword", label: t })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((t) => ({ type: "constant", label: t }))), bse = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((t) => ({ type: "type", label: t })), wse = /* @__PURE__ */ [
  "@charset",
  "@color-profile",
  "@container",
  "@counter-style",
  "@font-face",
  "@font-feature-values",
  "@font-palette-values",
  "@import",
  "@keyframes",
  "@layer",
  "@media",
  "@namespace",
  "@page",
  "@position-try",
  "@property",
  "@scope",
  "@starting-style",
  "@supports",
  "@view-transition"
].map((t) => ({ type: "keyword", label: t })), ko = /^(\w[\w-]*|-\w[\w-]*|)$/, kse = /^-(-[\w-]*)?$/;
function Sse(t, e) {
  var n;
  if ((t.name == "(" || t.type.isError) && (t = t.parent || t), t.name != "ArgList")
    return !1;
  let i = (n = t.parent) === null || n === void 0 ? void 0 : n.firstChild;
  return (i == null ? void 0 : i.name) != "Callee" ? !1 : e.sliceString(i.from, i.to) == "var";
}
const Ix = /* @__PURE__ */ new wA(), _se = ["Declaration"];
function xse(t) {
  for (let e = t; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return t;
  }
}
function bD(t, e, n) {
  if (e.to - e.from > 4096) {
    let i = Ix.get(e);
    if (i)
      return i;
    let r = [], o = /* @__PURE__ */ new Set(), s = e.cursor(Bt.IncludeAnonymous);
    if (s.firstChild())
      do
        for (let a of bD(t, s.node, n))
          o.has(a.label) || (o.add(a.label), r.push(a));
      while (s.nextSibling());
    return Ix.set(e, r), r;
  } else {
    let i = [], r = /* @__PURE__ */ new Set();
    return e.cursor().iterate((o) => {
      var s;
      if (n(o) && o.matchContext(_se) && ((s = o.node.nextSibling) === null || s === void 0 ? void 0 : s.name) == ":") {
        let a = t.sliceString(o.from, o.to);
        r.has(a) || (r.add(a), i.push({ label: a, type: "variable" }));
      }
    }), i;
  }
}
const Cse = (t) => (e) => {
  let { state: n, pos: i } = e, r = hn(n).resolveInner(i, -1), o = r.type.isError && r.from == r.to - 1 && n.doc.sliceString(r.from, r.to) == "-";
  if (r.name == "PropertyName" || (o || r.name == "TagName") && /^(Block|Styles)$/.test(r.resolve(r.to).name))
    return { from: r.from, options: hO(), validFor: ko };
  if (r.name == "ValueName")
    return { from: r.from, options: Nx, validFor: ko };
  if (r.name == "PseudoClassName")
    return { from: r.from, options: Qx, validFor: ko };
  if (t(r) || (e.explicit || o) && Sse(r, n.doc))
    return {
      from: t(r) || o ? r.from : i,
      options: bD(n.doc, xse(r), t),
      validFor: kse
    };
  if (r.name == "TagName") {
    for (let { parent: l } = r; l; l = l.parent)
      if (l.name == "Block")
        return { from: r.from, options: hO(), validFor: ko };
    return { from: r.from, options: bse, validFor: ko };
  }
  if (r.name == "AtKeyword")
    return { from: r.from, options: wse, validFor: ko };
  if (!e.explicit)
    return null;
  let s = r.resolve(i), a = s.childBefore(i);
  return a && a.name == ":" && s.name == "PseudoClassSelector" ? { from: i, options: Qx, validFor: ko } : a && a.name == ":" && s.name == "Declaration" || s.name == "ArgList" ? { from: i, options: Nx, validFor: ko } : s.name == "Block" || s.name == "Styles" ? { from: i, options: hO(), validFor: ko } : null;
}, Tse = /* @__PURE__ */ Cse((t) => t.name == "VariableName"), Qp = /* @__PURE__ */ au.define({
  name: "css",
  parser: /* @__PURE__ */ yse.configure({
    props: [
      /* @__PURE__ */ $m.add({
        Declaration: /* @__PURE__ */ Gh()
      }),
      /* @__PURE__ */ Pm.add({
        "Block KeyframeList": PA
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function $se() {
  return new $0(Qp, Qp.data.of({ autocomplete: Tse }));
}
const Pse = 314, Mse = 315, Lx = 1, Ese = 2, Ase = 3, Rse = 4, Dse = 316, Qse = 318, Nse = 319, Ise = 5, Lse = 6, Vse = 0, $y = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], wD = 125, Bse = 59, Py = 47, Zse = 42, Fse = 43, qse = 45, Wse = 60, Xse = 44, zse = 63, jse = 46, Yse = 91, Hse = new oD({
  start: !1,
  shift(t, e) {
    return e == Ise || e == Lse || e == Qse ? t : e == Nse;
  },
  strict: !1
}), Use = new ur((t, e) => {
  let { next: n } = t;
  (n == wD || n == -1 || e.context) && t.acceptToken(Dse);
}, { contextual: !0, fallback: !0 }), Gse = new ur((t, e) => {
  let { next: n } = t, i;
  $y.indexOf(n) > -1 || n == Py && ((i = t.peek(1)) == Py || i == Zse) || n != wD && n != Bse && n != -1 && !e.context && t.acceptToken(Pse);
}, { contextual: !0 }), Kse = new ur((t, e) => {
  t.next == Yse && !e.context && t.acceptToken(Mse);
}, { contextual: !0 }), Jse = new ur((t, e) => {
  let { next: n } = t;
  if (n == Fse || n == qse) {
    if (t.advance(), n == t.next) {
      t.advance();
      let i = !e.context && e.canShift(Lx);
      t.acceptToken(i ? Lx : Ese);
    }
  } else
    n == zse && t.peek(1) == jse && (t.advance(), t.advance(), (t.next < 48 || t.next > 57) && t.acceptToken(Ase));
}, { contextual: !0 });
function fO(t, e) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t == 95 || t >= 192 || !e && t >= 48 && t <= 57;
}
const eae = new ur((t, e) => {
  if (t.next != Wse || !e.dialectEnabled(Vse) || (t.advance(), t.next == Py))
    return;
  let n = 0;
  for (; $y.indexOf(t.next) > -1; )
    t.advance(), n++;
  if (fO(t.next, !0)) {
    for (t.advance(), n++; fO(t.next, !1); )
      t.advance(), n++;
    for (; $y.indexOf(t.next) > -1; )
      t.advance(), n++;
    if (t.next == Xse)
      return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!fO(t.next, !0))
          return;
        break;
      }
      if (t.next != "extends".charCodeAt(i))
        break;
      t.advance(), n++;
    }
  }
  t.acceptToken(Rse, -n);
}), tae = Cm({
  "get set async static": ee.modifier,
  "for while do if else switch try catch finally return throw break continue default case": ee.controlKeyword,
  "in of await yield void typeof delete instanceof": ee.operatorKeyword,
  "let var const using function class extends": ee.definitionKeyword,
  "import export from": ee.moduleKeyword,
  "with debugger as new": ee.keyword,
  TemplateString: ee.special(ee.string),
  super: ee.atom,
  BooleanLiteral: ee.bool,
  this: ee.self,
  null: ee.null,
  Star: ee.modifier,
  VariableName: ee.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": ee.function(ee.variableName),
  VariableDefinition: ee.definition(ee.variableName),
  Label: ee.labelName,
  PropertyName: ee.propertyName,
  PrivatePropertyName: ee.special(ee.propertyName),
  "CallExpression/MemberExpression/PropertyName": ee.function(ee.propertyName),
  "FunctionDeclaration/VariableDefinition": ee.function(ee.definition(ee.variableName)),
  "ClassDeclaration/VariableDefinition": ee.definition(ee.className),
  "NewExpression/VariableName": ee.className,
  PropertyDefinition: ee.definition(ee.propertyName),
  PrivatePropertyDefinition: ee.definition(ee.special(ee.propertyName)),
  UpdateOp: ee.updateOperator,
  "LineComment Hashbang": ee.lineComment,
  BlockComment: ee.blockComment,
  Number: ee.number,
  String: ee.string,
  Escape: ee.escape,
  ArithOp: ee.arithmeticOperator,
  LogicOp: ee.logicOperator,
  BitOp: ee.bitwiseOperator,
  CompareOp: ee.compareOperator,
  RegExp: ee.regexp,
  Equals: ee.definitionOperator,
  Arrow: ee.function(ee.punctuation),
  ": Spread": ee.punctuation,
  "( )": ee.paren,
  "[ ]": ee.squareBracket,
  "{ }": ee.brace,
  "InterpolationStart InterpolationEnd": ee.special(ee.brace),
  ".": ee.derefOperator,
  ", ;": ee.separator,
  "@": ee.meta,
  TypeName: ee.typeName,
  TypeDefinition: ee.definition(ee.typeName),
  "type enum interface implements namespace module declare": ee.definitionKeyword,
  "abstract global Privacy readonly override": ee.modifier,
  "is keyof unique infer asserts": ee.operatorKeyword,
  JSXAttributeValue: ee.attributeValue,
  JSXText: ee.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": ee.angleBracket,
  "JSXIdentifier JSXNameSpacedName": ee.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": ee.attributeName,
  "JSXBuiltin/JSXIdentifier": ee.standard(ee.tagName)
}), nae = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, const: 52, extends: 56, this: 60, true: 68, false: 68, null: 80, void: 84, typeof: 88, super: 104, new: 138, delete: 150, yield: 159, await: 163, class: 168, public: 231, private: 231, protected: 231, readonly: 233, instanceof: 252, satisfies: 255, in: 256, import: 290, keyof: 347, unique: 351, infer: 357, asserts: 393, is: 395, abstract: 415, implements: 417, type: 419, let: 422, var: 424, using: 427, interface: 433, enum: 437, namespace: 443, module: 445, declare: 449, global: 453, for: 472, of: 481, while: 484, with: 488, do: 492, if: 496, else: 498, switch: 502, case: 508, try: 514, catch: 518, finally: 522, return: 526, throw: 530, break: 534, continue: 538, debugger: 542 }, iae = { __proto__: null, async: 125, get: 127, set: 129, declare: 191, public: 193, private: 193, protected: 193, static: 195, abstract: 197, override: 199, readonly: 205, accessor: 207, new: 399 }, rae = { __proto__: null, "<": 189 }, oae = du.deserialize({
  version: 14,
  states: "$EOQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#D_O.QQlO'#DeO.bQlO'#DpO%[QlO'#DxO0fQlO'#EQOOQ!0Lf'#EY'#EYO1PQ`O'#EVOOQO'#En'#EnOOQO'#Ij'#IjO1XQ`O'#GrO1dQ`O'#EmO1iQ`O'#EmO3hQ!0MxO'#JpO6[Q!0MxO'#JqO6uQ`O'#F[O6zQ,UO'#FsOOQ!0Lf'#Fe'#FeO7VO7dO'#FeO7eQMhO'#F{O9UQ`O'#FzOOQ!0Lf'#Jq'#JqOOQ!0Lb'#Jp'#JpO9ZQ`O'#GvOOQ['#K]'#K]O9fQ`O'#IWO9kQ!0LrO'#IXOOQ['#J^'#J^OOQ['#I]'#I]Q`QlOOQ`QlOOO9sQ!L^O'#DtO9zQlO'#D|O:RQlO'#EOO9aQ`O'#GrO:YQMhO'#CoO:hQ`O'#ElO:sQ`O'#EwO:xQMhO'#FdO;gQ`O'#GrOOQO'#K^'#K^O;lQ`O'#K^O;zQ`O'#GzO;zQ`O'#G{O;zQ`O'#G}O9aQ`O'#HQO<qQ`O'#HTO>YQ`O'#CeO>jQ`O'#HaO>rQ`O'#HgO>rQ`O'#HiO`QlO'#HkO>rQ`O'#HmO>rQ`O'#HpO>wQ`O'#HvO>|Q!0LsO'#H|O%[QlO'#IOO?XQ!0LsO'#IQO?dQ!0LsO'#ISO9kQ!0LrO'#IUO?oQ!0MxO'#CiO@qQpO'#DjQOQ`OOO%[QlO'#EOOAXQ`O'#ERO:YQMhO'#ElOAdQ`O'#ElOAoQ!bO'#FdOOQ['#Cg'#CgOOQ!0Lb'#Do'#DoOOQ!0Lb'#Jt'#JtO%[QlO'#JtOOQO'#Jw'#JwOOQO'#If'#IfOBoQpO'#EeOOQ!0Lb'#Ed'#EdOOQ!0Lb'#J{'#J{OCkQ!0MSO'#EeOCuQpO'#EUOOQO'#Jv'#JvODZQpO'#JwOEhQpO'#EUOCuQpO'#EePEuO&2DjO'#CbPOOO)CD{)CD{OOOO'#I^'#I^OFQO#tO,59UOOQ!0Lh,59U,59UOOOO'#I_'#I_OF`O&jO,59UOFnQ!L^O'#DaOOOO'#Ia'#IaOFuO#@ItO,59yOOQ!0Lf,59y,59yOGTQlO'#IbOGhQ`O'#JrOIgQ!fO'#JrO+}QlO'#JrOInQ`O,5:POJUQ`O'#EnOJcQ`O'#KROJnQ`O'#KQOJnQ`O'#KQOJvQ`O,5;[OJ{Q`O'#KPOOQ!0Ln,5:[,5:[OKSQlO,5:[OMQQ!0MxO,5:dOMqQ`O,5:lON[Q!0LrO'#KOONcQ`O'#J}O9ZQ`O'#J}ONwQ`O'#J}O! PQ`O,5;ZO! UQ`O'#J}O!#ZQ!fO'#JqOOQ!0Lh'#Ci'#CiO%[QlO'#EQO!#yQ!fO,5:qOOQS'#Jx'#JxOOQO-E<h-E<hO9aQ`O,5=^O!$aQ`O,5=^O!$fQlO,5;XO!&iQMhO'#EiO!(SQ`O,5;XO!(XQlO'#DwO!(cQpO,5;bO!(kQpO,5;bO%[QlO,5;bOOQ['#FS'#FSOOQ['#FU'#FUO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cOOQ['#FY'#FYO!(yQlO,5;sOOQ!0Lf,5;x,5;xOOQ!0Lf,5;y,5;yOOQ!0Lf,5;{,5;{O%[QlO'#InO!*|Q!0LrO,5<hO%[QlO,5;cO!&iQMhO,5;cO!+kQMhO,5;cO!-]QMhO'#E[O%[QlO,5;vOOQ!0Lf,5;z,5;zO!-dQ,UO'#FiO!.aQ,UO'#KVO!-{Q,UO'#KVO!.hQ,UO'#KVOOQO'#KV'#KVO!.|Q,UO,5<ROOOW,5<_,5<_O!/_QlO'#FuOOOW'#Im'#ImO7VO7dO,5<PO!/fQ,UO'#FwOOQ!0Lf,5<P,5<PO!0VQ$IUO'#CwOOQ!0Lh'#C{'#C{O!0jO#@ItO'#DPO!1WQMjO,5<dO!1_Q`O,5<gO!2zQ(CWO'#GWO!3XQ`O'#GXO!3^Q`O'#GXO!4|Q(CWO'#G]O!6RQpO'#GaOOQO'#Gm'#GmO!+rQMhO'#GlOOQO'#Go'#GoO!+rQMhO'#GnO!6tQ$IUO'#JjOOQ!0Lh'#Jj'#JjO!7OQ`O'#JiO!7^Q`O'#JhO!7fQ`O'#CuOOQ!0Lh'#Cy'#CyO!7qQ`O'#C{OOQ!0Lh'#DT'#DTOOQ!0Lh'#DV'#DVO1SQ`O'#DXO!+rQMhO'#GOO!+rQMhO'#GQO!7vQ`O'#GSO!7{Q`O'#GTO!3^Q`O'#GZO!+rQMhO'#G`O;zQ`O'#JiO!8QQ`O'#EoO!8oQ`O,5<fOOQ!0Lb'#Cr'#CrO!8wQ`O'#EpO!9qQpO'#EqOOQ!0Lb'#KP'#KPO!9xQ!0LrO'#K_O9kQ!0LrO,5=bO`QlO,5>rOOQ['#Jf'#JfOOQ[,5>s,5>sOOQ[-E<Z-E<ZO!;wQ!0MxO,5:`O!9lQpO,5:^O!>bQ!0MxO,5:hO%[QlO,5:hO!@xQ!0MxO,5:jOOQO,5@x,5@xO!AiQMhO,5=^O!AwQ!0LrO'#JgO9UQ`O'#JgO!BYQ!0LrO,59ZO!BeQpO,59ZO!BmQMhO,59ZO:YQMhO,59ZO!BxQ`O,5;XO!CQQ`O'#H`O!CfQ`O'#KbO%[QlO,5;|O!9lQpO,5<OO!CnQ`O,5=yO!CsQ`O,5=yO!CxQ`O,5=yO9kQ!0LrO,5=yO;zQ`O,5=iOOQO'#Cw'#CwO!DWQpO,5=fO!D`QMhO,5=gO!DkQ`O,5=iO!DpQ!bO,5=lO!DxQ`O'#K^O>wQ`O'#HVO9aQ`O'#HXO!D}Q`O'#HXO:YQMhO'#HZO!ESQ`O'#HZOOQ[,5=o,5=oO!EXQ`O'#H[O!EjQ`O'#CoO!EoQ`O,59PO!EyQ`O,59PO!HOQlO,59POOQ[,59P,59PO!H`Q!0LrO,59PO%[QlO,59PO!JkQlO'#HcOOQ['#Hd'#HdOOQ['#He'#HeO`QlO,5={O!KRQ`O,5={O`QlO,5>RO`QlO,5>TO!KWQ`O,5>VO`QlO,5>XO!K]Q`O,5>[O!KbQlO,5>bOOQ[,5>h,5>hO%[QlO,5>hO9kQ!0LrO,5>jOOQ[,5>l,5>lO# lQ`O,5>lOOQ[,5>n,5>nO# lQ`O,5>nOOQ[,5>p,5>pO#!YQpO'#D]O%[QlO'#JtO#!{QpO'#JtO##VQpO'#DkO##hQpO'#DkO#%yQlO'#DkO#&QQ`O'#JsO#&YQ`O,5:UO#&_Q`O'#ErO#&mQ`O'#KSO#&uQ`O,5;]O#&zQpO'#DkO#'XQpO'#ETOOQ!0Lf,5:m,5:mO%[QlO,5:mO#'`Q`O,5:mO>wQ`O,5;WO!BeQpO,5;WO!BmQMhO,5;WO:YQMhO,5;WO#'hQ`O,5@`O#'mQ07dO,5:qOOQO-E<d-E<dO#(sQ!0MSO,5;POCuQpO,5:pO#(}QpO,5:pOCuQpO,5;PO!BYQ!0LrO,5:pOOQ!0Lb'#Eh'#EhOOQO,5;P,5;PO%[QlO,5;PO#)[Q!0LrO,5;PO#)gQ!0LrO,5;PO!BeQpO,5:pOOQO,5;V,5;VO#)uQ!0LrO,5;PPOOO'#I['#I[P#*ZO&2DjO,58|POOO,58|,58|OOOO-E<[-E<[OOQ!0Lh1G.p1G.pOOOO-E<]-E<]OOOO,59{,59{O#*fQ!bO,59{OOOO-E<_-E<_OOQ!0Lf1G/e1G/eO#*kQ!fO,5>|O+}QlO,5>|OOQO,5?S,5?SO#*uQlO'#IbOOQO-E<`-E<`O#+SQ`O,5@^O#+[Q!fO,5@^O#+cQ`O,5@lOOQ!0Lf1G/k1G/kO%[QlO,5@mO#+kQ`O'#IhOOQO-E<f-E<fO#+cQ`O,5@lOOQ!0Lb1G0v1G0vOOQ!0Ln1G/v1G/vOOQ!0Ln1G0W1G0WO%[QlO,5@jO#,PQ!0LrO,5@jO#,bQ!0LrO,5@jO#,iQ`O,5@iO9ZQ`O,5@iO#,qQ`O,5@iO#-PQ`O'#IkO#,iQ`O,5@iOOQ!0Lb1G0u1G0uO!(cQpO,5:sO!(nQpO,5:sOOQS,5:u,5:uO#-qQdO,5:uO#-yQMhO1G2xO9aQ`O1G2xOOQ!0Lf1G0s1G0sO#.XQ!0MxO1G0sO#/^Q!0MvO,5;TOOQ!0Lh'#GV'#GVO#/zQ!0MzO'#JjO!$fQlO1G0sO#2VQ!fO'#JuO%[QlO'#JuO#2aQ`O,5:cOOQ!0Lh'#D]'#D]OOQ!0Lf1G0|1G0|O%[QlO1G0|OOQ!0Lf1G1e1G1eO#2fQ`O1G0|O#4zQ!0MxO1G0}O#5RQ!0MxO1G0}O#7iQ!0MxO1G0}O#7pQ!0MxO1G0}O#:WQ!0MxO1G0}O#<nQ!0MxO1G0}O#<uQ!0MxO1G0}O#<|Q!0MxO1G0}O#?dQ!0MxO1G0}O#?kQ!0MxO1G0}O#AxQ?MtO'#CiO#CsQ?MtO1G1_O#CzQ?MtO'#JqO#D_Q!0MxO,5?YOOQ!0Lb-E<l-E<lO#FlQ!0MxO1G0}O#GiQ!0MzO1G0}OOQ!0Lf1G0}1G0}O#HlQMjO'#JzO#HvQ`O,5:vO#H{Q!0MxO1G1bO#IoQ,UO,5<VO#IwQ,UO,5<WO#JPQ,UO'#FnO#JhQ`O'#FmOOQO'#KW'#KWOOQO'#Il'#IlO#JmQ,UO1G1mOOQ!0Lf1G1m1G1mOOOW1G1x1G1xO#KOQ?MtO'#JpO#KYQ`O,5<aO!(yQlO,5<aOOOW-E<k-E<kOOQ!0Lf1G1k1G1kO#K_QpO'#KVOOQ!0Lf,5<c,5<cO#KgQpO,5<cO#KlQMhO'#DROOOO'#I`'#I`O#KsO#@ItO,59kOOQ!0Lh,59k,59kO%[QlO1G2OO!7{Q`O'#IpO#LOQ`O,5<yOOQ!0Lh,5<v,5<vO!+rQMhO'#IsO#LlQMjO,5=WO!+rQMhO'#IuO#M_QMjO,5=YO!&iQMhO,5=[OOQO1G2R1G2RO#MiQ!dO'#CrO#M|Q(CWO'#EpO$ RQpO'#GaO$ iQ!dO,5<rO$ pQ`O'#KYO9ZQ`O'#KYO$!OQ`O,5<tO!+rQMhO,5<sO$!TQ`O'#GYO$!fQ`O,5<sO$!kQ!dO'#GVO$!xQ!dO'#KZO$#SQ`O'#KZO!&iQMhO'#KZO$#XQ`O,5<wO$#^QlO'#JtO$#hQpO'#GbO##hQpO'#GbO$#yQ`O'#GfO!3^Q`O'#GjO$$OQ!0LrO'#IrO$$ZQpO,5<{OOQ!0Lp,5<{,5<{O$$bQpO'#GbO$$oQpO'#GcO$%QQpO'#GcO$%VQMjO,5=WO$%gQMjO,5=YOOQ!0Lh,5=],5=]O!+rQMhO,5@TO!+rQMhO,5@TO$%wQ`O'#IwO$&VQ`O,5@SO$&_Q`O,59aOOQ!0Lh,59g,59gO$'UQ$IYO,59sOOQ!0Lh'#Jn'#JnO$'wQMjO,5<jO$(jQMjO,5<lO@iQ`O,5<nOOQ!0Lh,5<o,5<oO$(tQ`O,5<uO$(yQMjO,5<zO$)ZQ`O,5@TO$)iQ`O'#J}O!$fQlO1G2QO$)nQ`O1G2QO9ZQ`O'#KQO9ZQ`O'#ErO%[QlO'#ErO9ZQ`O'#IyO$)sQ!0LrO,5@yOOQ[1G2|1G2|OOQ[1G4^1G4^OOQ!0Lf1G/z1G/zOOQ!0Lf1G/x1G/xO$+uQ!0MxO1G0SOOQ[1G2x1G2xO!&iQMhO1G2xO%[QlO1G2xO#-|Q`O1G2xO$-yQMhO'#EiOOQ!0Lb,5@R,5@RO$.WQ!0LrO,5@ROOQ[1G.u1G.uO!BYQ!0LrO1G.uO!BeQpO1G.uO!BmQMhO1G.uO$.iQ`O1G0sO$.nQ`O'#CiO$.yQ`O'#KcO$/RQ`O,5=zO$/WQ`O'#KcO$/]Q`O'#KcO$/kQ`O'#JPO$/yQ`O,5@|O$0RQ!fO1G1hOOQ!0Lf1G1j1G1jO9aQ`O1G3eO@iQ`O1G3eO$0YQ`O1G3eO$0_Q`O1G3eOOQ[1G3e1G3eO!DkQ`O1G3TO!&iQMhO1G3QO$0dQ`O1G3QOOQ[1G3R1G3RO!&iQMhO1G3RO$0iQ`O1G3RO$0qQpO'#HPOOQ[1G3T1G3TO!5|QpO'#I{O!DpQ!bO1G3WOOQ[1G3W1G3WOOQ[,5=q,5=qO$0yQMhO,5=sO9aQ`O,5=sO$#yQ`O,5=uO9UQ`O,5=uO!BeQpO,5=uO!BmQMhO,5=uO:YQMhO,5=uO$1XQ`O'#KaO$1dQ`O,5=vOOQ[1G.k1G.kO$1iQ!0LrO1G.kO@iQ`O1G.kO$1tQ`O1G.kO9kQ!0LrO1G.kO$3|Q!fO,5AOO$4ZQ`O,5AOO9ZQ`O,5AOO$4fQlO,5=}O$4mQ`O,5=}OOQ[1G3g1G3gO`QlO1G3gOOQ[1G3m1G3mOOQ[1G3o1G3oO>rQ`O1G3qO$4rQlO1G3sO$8vQlO'#HrOOQ[1G3v1G3vO$9TQ`O'#HxO>wQ`O'#HzOOQ[1G3|1G3|O$9]QlO1G3|O9kQ!0LrO1G4SOOQ[1G4U1G4UOOQ!0Lb'#G^'#G^O9kQ!0LrO1G4WO9kQ!0LrO1G4YO$=dQ`O,5@`O!(yQlO,5;^O9ZQ`O,5;^O>wQ`O,5:VO!(yQlO,5:VO!BeQpO,5:VO$=iQ?MtO,5:VOOQO,5;^,5;^O$=sQpO'#IcO$>ZQ`O,5@_OOQ!0Lf1G/p1G/pO$>cQpO'#IiO$>mQ`O,5@nOOQ!0Lb1G0w1G0wO##hQpO,5:VOOQO'#Ie'#IeO$>uQpO,5:oOOQ!0Ln,5:o,5:oO#'cQ`O1G0XOOQ!0Lf1G0X1G0XO%[QlO1G0XOOQ!0Lf1G0r1G0rO>wQ`O1G0rO!BeQpO1G0rO!BmQMhO1G0rOOQ!0Lb1G5z1G5zO!BYQ!0LrO1G0[OOQO1G0k1G0kO%[QlO1G0kO$>|Q!0LrO1G0kO$?XQ!0LrO1G0kO!BeQpO1G0[OCuQpO1G0[O$?gQ!0LrO1G0kOOQO1G0[1G0[O$?{Q!0MxO1G0kPOOO-E<Y-E<YPOOO1G.h1G.hOOOO1G/g1G/gO$@VQ!bO,5<hO$@_Q!fO1G4hOOQO1G4n1G4nO%[QlO,5>|O$@iQ`O1G5xO$@qQ`O1G6WO$@yQ!fO1G6XO9ZQ`O,5?SO$ATQ!0MxO1G6UO%[QlO1G6UO$AeQ!0LrO1G6UO$AvQ`O1G6TO$AvQ`O1G6TO9ZQ`O1G6TO$BOQ`O,5?VO9ZQ`O,5?VOOQO,5?V,5?VO$BdQ`O,5?VO$)iQ`O,5?VOOQO-E<i-E<iOOQS1G0_1G0_OOQS1G0a1G0aO#-tQ`O1G0aOOQ[7+(d7+(dO!&iQMhO7+(dO%[QlO7+(dO$BrQ`O7+(dO$B}QMhO7+(dO$C]Q!0MzO,5=WO$EhQ!0MzO,5=YO$GsQ!0MzO,5=WO$JUQ!0MzO,5=YO$LgQ!0MzO,59sO$NlQ!0MzO,5<jO%!wQ!0MzO,5<lO%%SQ!0MzO,5<zOOQ!0Lf7+&_7+&_O%'eQ!0MxO7+&_O%(XQlO'#IdO%(fQ`O,5@aO%(nQ!fO,5@aOOQ!0Lf1G/}1G/}O%(xQ`O7+&hOOQ!0Lf7+&h7+&hO%(}Q?MtO,5:dO%[QlO7+&yO%)XQ?MtO,5:`O%)fQ?MtO,5:hO%)pQ?MtO,5:jO%)zQMhO'#IgO%*UQ`O,5@fOOQ!0Lh1G0b1G0bOOQO1G1q1G1qOOQO1G1r1G1rO%*^Q!jO,5<YO!(yQlO,5<XOOQO-E<j-E<jOOQ!0Lf7+'X7+'XOOOW7+'d7+'dOOOW1G1{1G1{O%*iQ`O1G1{OOQ!0Lf1G1}1G1}OOOO,59m,59mO%*nQ!dO,59mOOOO-E<^-E<^OOQ!0Lh1G/V1G/VO%*uQ!0MxO7+'jOOQ!0Lh,5?[,5?[O%+iQMhO1G2eP%+pQ`O'#IpPOQ!0Lh-E<n-E<nO%,^QMjO,5?_OOQ!0Lh-E<q-E<qO%-PQMjO,5?aOOQ!0Lh-E<s-E<sO%-ZQ!dO1G2vO%-bQ!dO'#CrO%-xQMhO'#KQO$#^QlO'#JtOOQ!0Lh1G2^1G2^O%.PQ`O'#IoO%.eQ`O,5@tO%.eQ`O,5@tO%.mQ`O,5@tO%.xQ`O,5@tOOQO1G2`1G2`O%/WQMjO1G2_O!+rQMhO1G2_O%/hQ(CWO'#IqO%/uQ`O,5@uO!&iQMhO,5@uO%/}Q!dO,5@uOOQ!0Lh1G2c1G2cO%2_Q!fO'#CiO%2iQ`O,5=OOOQ!0Lb,5<|,5<|O%2qQpO,5<|OOQ!0Lb,5<},5<}OCfQ`O,5<|O%2|QpO,5<|OOQ!0Lb,5=Q,5=QO$)iQ`O,5=UOOQO,5?^,5?^OOQO-E<p-E<pOOQ!0Lp1G2g1G2gO##hQpO,5<|O$#^QlO,5=OO%3[Q`O,5<}O%3gQpO,5<}O!+rQMhO'#IsO%4aQMjO1G2rO!+rQMhO'#IuO%5SQMjO1G2tO%5^QMjO1G5oO%5hQMjO1G5oOOQO,5?c,5?cOOQO-E<u-E<uOOQO1G.{1G.{O!9lQpO,59uO%[QlO,59uOOQ!0Lh,5<i,5<iO%5uQ`O1G2YO!+rQMhO1G2aO!+rQMhO1G5oO!+rQMhO1G5oO%5zQ!0MxO7+'lOOQ!0Lf7+'l7+'lO!$fQlO7+'lO%6nQ`O,5;^OOQ!0Lb,5?e,5?eOOQ!0Lb-E<w-E<wO%6sQ!dO'#K[O#'cQ`O7+(dO4UQ!fO7+(dO$BuQ`O7+(dO%6}Q!0MvO'#CiO%7nQ!0LrO,5=RO%8PQ!0MvO,5=RO%8dQ`O,5=ROOQ!0Lb1G5m1G5mOOQ[7+$a7+$aO!BYQ!0LrO7+$aO!BeQpO7+$aO!$fQlO7+&_O%8lQ`O'#JOO%9TQ`O,5@}OOQO1G3f1G3fO9aQ`O,5@}O%9TQ`O,5@}O%9]Q`O,5@}OOQO,5?k,5?kOOQO-E<}-E<}OOQ!0Lf7+'S7+'SO%9bQ`O7+)PO9kQ!0LrO7+)PO9aQ`O7+)PO@iQ`O7+)POOQ[7+(o7+(oO%9gQ!0MvO7+(lO!&iQMhO7+(lO!DfQ`O7+(mOOQ[7+(m7+(mO!&iQMhO7+(mO%9qQ`O'#K`O%9|Q`O,5=kOOQO,5?g,5?gOOQO-E<y-E<yOOQ[7+(r7+(rO%;`QpO'#HYOOQ[1G3_1G3_O!&iQMhO1G3_O%[QlO1G3_O%;gQ`O1G3_O%;rQMhO1G3_O9kQ!0LrO1G3aO$#yQ`O1G3aO9UQ`O1G3aO!BeQpO1G3aO!BmQMhO1G3aO%<QQ`O'#I}O%<fQ`O,5@{O%<nQpO,5@{OOQ!0Lb1G3b1G3bOOQ[7+$V7+$VO@iQ`O7+$VO9kQ!0LrO7+$VO%<yQ`O7+$VO%[QlO1G6jO%[QlO1G6kO%=OQ!0LrO1G6jO%=YQlO1G3iO%=aQ`O1G3iO%=fQlO1G3iOOQ[7+)R7+)RO9kQ!0LrO7+)]O`QlO7+)_OOQ['#Kf'#KfOOQ['#JQ'#JQO%=mQlO,5>^OOQ[,5>^,5>^O%[QlO'#HsO%=zQ`O'#HuOOQ[,5>d,5>dO9ZQ`O,5>dOOQ[,5>f,5>fOOQ[7+)h7+)hOOQ[7+)n7+)nOOQ[7+)r7+)rOOQ[7+)t7+)tO%>PQpO1G5zO%>kQ?MtO1G0xO%>uQ`O1G0xOOQO1G/q1G/qO%?QQ?MtO1G/qO>wQ`O1G/qO!(yQlO'#DkOOQO,5>},5>}OOQO-E<a-E<aOOQO,5?T,5?TOOQO-E<g-E<gO!BeQpO1G/qOOQO-E<c-E<cOOQ!0Ln1G0Z1G0ZOOQ!0Lf7+%s7+%sO#'cQ`O7+%sOOQ!0Lf7+&^7+&^O>wQ`O7+&^O!BeQpO7+&^OOQO7+%v7+%vO$?{Q!0MxO7+&VOOQO7+&V7+&VO%[QlO7+&VO%?[Q!0LrO7+&VO!BYQ!0LrO7+%vO!BeQpO7+%vO%?gQ!0LrO7+&VO%?uQ!0MxO7++pO%[QlO7++pO%@VQ`O7++oO%@VQ`O7++oOOQO1G4q1G4qO9ZQ`O1G4qO%@_Q`O1G4qOOQS7+%{7+%{O#'cQ`O<<LOO4UQ!fO<<LOO%@mQ`O<<LOOOQ[<<LO<<LOO!&iQMhO<<LOO%[QlO<<LOO%@uQ`O<<LOO%AQQ!0MzO,5?_O%C]Q!0MzO,5?aO%EhQ!0MzO1G2_O%GyQ!0MzO1G2rO%JUQ!0MzO1G2tO%LaQ!fO,5?OO%[QlO,5?OOOQO-E<b-E<bO%LkQ`O1G5{OOQ!0Lf<<JS<<JSO%LsQ?MtO1G0sO%NzQ?MtO1G0}O& RQ?MtO1G0}O&#SQ?MtO1G0}O&#ZQ?MtO1G0}O&%[Q?MtO1G0}O&']Q?MtO1G0}O&'dQ?MtO1G0}O&'kQ?MtO1G0}O&)lQ?MtO1G0}O&)sQ?MtO1G0}O&)zQ!0MxO<<JeO&+rQ?MtO1G0}O&,oQ?MvO1G0}O&-rQ?MvO'#JjO&/xQ?MtO1G1bO&0VQ?MtO1G0SO&0aQMjO,5?ROOQO-E<e-E<eO!(yQlO'#FpOOQO'#KX'#KXOOQO1G1t1G1tO&0kQ`O1G1sO&0pQ?MtO,5?YOOOW7+'g7+'gOOOO1G/X1G/XO&0zQ!dO1G4vOOQ!0Lh7+(P7+(PP!&iQMhO,5?[O!+rQMhO7+(bO&1RQ`O,5?ZO9ZQ`O,5?ZOOQO-E<m-E<mO&1aQ`O1G6`O&1aQ`O1G6`O&1iQ`O1G6`O&1tQMjO7+'yO&2UQ!dO,5?]O&2`Q`O,5?]O!&iQMhO,5?]OOQO-E<o-E<oO&2eQ!dO1G6aO&2oQ`O1G6aO&2wQ`O1G2jO!&iQMhO1G2jOOQ!0Lb1G2h1G2hOOQ!0Lb1G2i1G2iO%2qQpO1G2hO!BeQpO1G2hOCfQ`O1G2hOOQ!0Lb1G2p1G2pO&2|QpO1G2hO&3[Q`O1G2jO$)iQ`O1G2iOCfQ`O1G2iO$#^QlO1G2jO&3dQ`O1G2iO&4WQMjO,5?_OOQ!0Lh-E<r-E<rO&4yQMjO,5?aOOQ!0Lh-E<t-E<tO!+rQMhO7++ZOOQ!0Lh1G/a1G/aO&5TQ`O1G/aOOQ!0Lh7+'t7+'tO&5YQMjO7+'{O&5jQMjO7++ZO&5tQMjO7++ZO&6RQ!0MxO<<KWOOQ!0Lf<<KW<<KWO&6uQ`O1G0xO!&iQMhO'#IxO&6zQ`O,5@vO&8|Q!fO<<LOO!&iQMhO1G2mO&9TQ!0LrO1G2mOOQ[<<G{<<G{O!BYQ!0LrO<<G{O&9fQ!0MxO<<IyOOQ!0Lf<<Iy<<IyOOQO,5?j,5?jO&:YQ`O,5?jO&:_Q`O,5?jOOQO-E<|-E<|O&:mQ`O1G6iO&:mQ`O1G6iO9aQ`O1G6iO@iQ`O<<LkOOQ[<<Lk<<LkO&:uQ`O<<LkO9kQ!0LrO<<LkOOQ[<<LW<<LWO%9gQ!0MvO<<LWOOQ[<<LX<<LXO!DfQ`O<<LXO&:zQpO'#IzO&;VQ`O,5@zO!(yQlO,5@zOOQ[1G3V1G3VOOQO'#I|'#I|O9kQ!0LrO'#I|O&;_QpO,5=tOOQ[,5=t,5=tO&;fQpO'#EeO&;mQpO'#GdO&;rQ`O7+(yO&;wQ`O7+(yOOQ[7+(y7+(yO!&iQMhO7+(yO%[QlO7+(yO&<PQ`O7+(yOOQ[7+({7+({O9kQ!0LrO7+({O$#yQ`O7+({O9UQ`O7+({O!BeQpO7+({O&<[Q`O,5?iOOQO-E<{-E<{OOQO'#H]'#H]O&<gQ`O1G6gO9kQ!0LrO<<GqOOQ[<<Gq<<GqO@iQ`O<<GqO&<oQ`O7+,UO&<tQ`O7+,VO%[QlO7+,UO%[QlO7+,VOOQ[7+)T7+)TO&<yQ`O7+)TO&=OQlO7+)TO&=VQ`O7+)TOOQ[<<Lw<<LwOOQ[<<Ly<<LyOOQ[-E=O-E=OOOQ[1G3x1G3xO&=[Q`O,5>_OOQ[,5>a,5>aO&=aQ`O1G4OO9ZQ`O7+&dO!(yQlO7+&dOOQO7+%]7+%]O&=fQ?MtO1G6XO>wQ`O7+%]OOQ!0Lf<<I_<<I_OOQ!0Lf<<Ix<<IxO>wQ`O<<IxOOQO<<Iq<<IqO$?{Q!0MxO<<IqO%[QlO<<IqOOQO<<Ib<<IbO!BYQ!0LrO<<IbO&=pQ!0LrO<<IqO&={Q!0MxO<= [O&>]Q`O<= ZOOQO7+*]7+*]O9ZQ`O7+*]OOQ[ANAjANAjO&>eQ!fOANAjO!&iQMhOANAjO#'cQ`OANAjO4UQ!fOANAjO&>lQ`OANAjO%[QlOANAjO&>tQ!0MzO7+'yO&AVQ!0MzO,5?_O&CbQ!0MzO,5?aO&EmQ!0MzO7+'{O&HOQ!fO1G4jO&HYQ?MtO7+&_O&J^Q?MvO,5=WO&LeQ?MvO,5=YO&LuQ?MvO,5=WO&MVQ?MvO,5=YO&MgQ?MvO,59sO' mQ?MvO,5<jO'#pQ?MvO,5<lO'&UQ?MvO,5<zO''zQ?MtO7+'jO'(XQ?MtO7+'lO'(fQ`O,5<[OOQO7+'_7+'_OOQ!0Lh7+*b7+*bO'(kQMjO<<K|OOQO1G4u1G4uO'(rQ`O1G4uO'(}Q`O1G4uO')]Q`O7++zO')]Q`O7++zO!&iQMhO1G4wO')eQ!dO1G4wO')oQ`O7++{O')wQ`O7+(UO'*SQ!dO7+(UOOQ!0Lb7+(S7+(SOOQ!0Lb7+(T7+(TO!BeQpO7+(SOCfQ`O7+(SO'*^Q`O7+(UO!&iQMhO7+(UO$)iQ`O7+(TO'*cQ`O7+(UOCfQ`O7+(TO'*kQMjO<<NuOOQ!0Lh7+${7+${O!+rQMhO<<NuO'*uQ!dO,5?dOOQO-E<v-E<vO'+PQ!0MvO7+(XO!&iQMhO7+(XOOQ[AN=gAN=gO9aQ`O1G5UOOQO1G5U1G5UO'+aQ`O1G5UO'+fQ`O7+,TO'+fQ`O7+,TO9kQ!0LrOANBVO@iQ`OANBVOOQ[ANBVANBVOOQ[ANArANArOOQ[ANAsANAsO'+nQ`O,5?fOOQO-E<x-E<xO'+yQ?MtO1G6fOOQO,5?h,5?hOOQO-E<z-E<zOOQ[1G3`1G3`O',TQ`O,5=OOOQ[<<Le<<LeO!&iQMhO<<LeO&;rQ`O<<LeO',YQ`O<<LeO%[QlO<<LeOOQ[<<Lg<<LgO9kQ!0LrO<<LgO$#yQ`O<<LgO9UQ`O<<LgO',bQpO1G5TO',mQ`O7+,ROOQ[AN=]AN=]O9kQ!0LrOAN=]OOQ[<= p<= pOOQ[<= q<= qO',uQ`O<= pO',zQ`O<= qOOQ[<<Lo<<LoO'-PQ`O<<LoO'-UQlO<<LoOOQ[1G3y1G3yO>wQ`O7+)jO'-]Q`O<<JOO'-hQ?MtO<<JOOOQO<<Hw<<HwOOQ!0LfAN?dAN?dOOQOAN?]AN?]O$?{Q!0MxOAN?]OOQOAN>|AN>|O%[QlOAN?]OOQO<<Mw<<MwOOQ[G27UG27UO!&iQMhOG27UO#'cQ`OG27UO'-rQ!fOG27UO4UQ!fOG27UO'-yQ`OG27UO'.RQ?MtO<<JeO'.`Q?MvO1G2_O'0UQ?MvO,5?_O'2XQ?MvO,5?aO'4[Q?MvO1G2rO'6_Q?MvO1G2tO'8bQ?MtO<<KWO'8oQ?MtO<<IyOOQO1G1v1G1vO!+rQMhOANAhOOQO7+*a7+*aO'8|Q`O7+*aO'9XQ`O<= fO'9aQ!dO7+*cOOQ!0Lb<<Kp<<KpO$)iQ`O<<KpOCfQ`O<<KpO'9kQ`O<<KpO!&iQMhO<<KpOOQ!0Lb<<Kn<<KnO!BeQpO<<KnO'9vQ!dO<<KpOOQ!0Lb<<Ko<<KoO':QQ`O<<KpO!&iQMhO<<KpO$)iQ`O<<KoO':VQMjOANDaO':aQ!0MvO<<KsOOQO7+*p7+*pO9aQ`O7+*pO':qQ`O<= oOOQ[G27qG27qO9kQ!0LrOG27qO!(yQlO1G5QO':yQ`O7+,QO';RQ`O1G2jO&;rQ`OANBPOOQ[ANBPANBPO!&iQMhOANBPO';WQ`OANBPOOQ[ANBRANBRO9kQ!0LrOANBRO$#yQ`OANBROOQO'#H^'#H^OOQO7+*o7+*oOOQ[G22wG22wOOQ[ANE[ANE[OOQ[ANE]ANE]OOQ[ANBZANBZO';`Q`OANBZOOQ[<<MU<<MUO!(yQlOAN?jOOQOG24wG24wO$?{Q!0MxOG24wO#'cQ`OLD,pOOQ[LD,pLD,pO!&iQMhOLD,pO';eQ!fOLD,pO';lQ?MvO7+'yO'=bQ?MvO,5?_O'?eQ?MvO,5?aO'AhQ?MvO7+'{O'C^QMjOG27SOOQO<<M{<<M{OOQ!0LbANA[ANA[O$)iQ`OANA[OCfQ`OANA[O'CnQ!dOANA[OOQ!0LbANAYANAYO'CuQ`OANA[O!&iQMhOANA[O'DQQ!dOANA[OOQ!0LbANAZANAZOOQO<<N[<<N[OOQ[LD-]LD-]O'D[Q?MtO7+*lOOQO'#Ge'#GeOOQ[G27kG27kO&;rQ`OG27kO!&iQMhOG27kOOQ[G27mG27mO9kQ!0LrOG27mOOQ[G27uG27uO'DfQ?MtOG25UOOQOLD*cLD*cOOQ[!$(![!$(![O#'cQ`O!$(![O!&iQMhO!$(![O'DpQ!0MzOG27SOOQ!0LbG26vG26vO$)iQ`OG26vO'GRQ`OG26vOCfQ`OG26vO'G^Q!dOG26vO!&iQMhOG26vOOQ[LD-VLD-VO&;rQ`OLD-VOOQ[LD-XLD-XOOQ[!)9Ev!)9EvO#'cQ`O!)9EvOOQ!0LbLD,bLD,bO$)iQ`OLD,bOCfQ`OLD,bO'GeQ`OLD,bO'GpQ!dOLD,bOOQ[!$(!q!$(!qOOQ[!.K;b!.K;bO'GwQ?MvOG27SOOQ!0Lb!$( |!$( |O$)iQ`O!$( |OCfQ`O!$( |O'ImQ`O!$( |OOQ!0Lb!)9Eh!)9EhO$)iQ`O!)9EhOCfQ`O!)9EhOOQ!0Lb!.K;S!.K;SO$)iQ`O!.K;SOOQ!0Lb!4/0n!4/0nO!(yQlO'#DxO1PQ`O'#EVO'IxQ!fO'#JpO'JPQ!L^O'#DtO'JWQlO'#D|O'J_Q!fO'#CiO'LuQ!fO'#CiO!(yQlO'#EOO'MVQlO,5;XO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO'#InO( YQ`O,5<hO!(yQlO,5;cO( bQMhO,5;cO(!{QMhO,5;cO!(yQlO,5;vO!&iQMhO'#GlO( bQMhO'#GlO!&iQMhO'#GnO( bQMhO'#GnO1SQ`O'#DXO1SQ`O'#DXO!&iQMhO'#GOO( bQMhO'#GOO!&iQMhO'#GQO( bQMhO'#GQO!&iQMhO'#G`O( bQMhO'#G`O!(yQlO,5:hO(#SQpO'#D]O(#^QpO'#JtO!(yQlO,5@mO'MVQlO1G0sO(#hQ?MtO'#CiO!(yQlO1G2OO!&iQMhO'#IsO( bQMhO'#IsO!&iQMhO'#IuO( bQMhO'#IuO(#rQ!dO'#CrO!&iQMhO,5<sO( bQMhO,5<sO'MVQlO1G2QO!(yQlO7+&yO!&iQMhO1G2_O( bQMhO1G2_O!&iQMhO'#IsO( bQMhO'#IsO!&iQMhO'#IuO( bQMhO'#IuO!&iQMhO1G2aO( bQMhO1G2aO'MVQlO7+'lO'MVQlO7+&_O!&iQMhOANAhO( bQMhOANAhO($VQ`O'#EmO($[Q`O'#EmO($dQ`O'#F[O($iQ`O'#EwO($nQ`O'#KRO($yQ`O'#KPO(%UQ`O,5;XO(%ZQMjO,5<dO(%bQ`O'#GXO(%gQ`O'#GXO(%lQ`O,5<fO(%tQ`O,5;XO(%|Q?MtO1G1_O(&TQ`O,5<sO(&YQ`O,5<sO(&_Q`O,5<uO(&dQ`O,5<uO(&iQ`O1G2QO(&nQ`O1G0sO(&sQMjO<<K|O(&zQMjO<<K|O7eQMhO'#F{O9UQ`O'#FzOAdQ`O'#ElO!(yQlO,5;sO!3^Q`O'#GXO!3^Q`O'#GXO!3^Q`O'#GZO!3^Q`O'#GZO!+rQMhO7+(bO!+rQMhO7+(bO%-ZQ!dO1G2vO%-ZQ!dO1G2vO!&iQMhO,5=[O!&iQMhO,5=[",
  stateData: "((P~O'zOS'{OSTOS'|RQ~OPYOQYOSfOY!VOaqOdzOeyOj!POnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]XO!guO!jZO!mYO!nYO!oYO!qvO!swO!vxO!z]O$V|O$miO%g}O%i!QO%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO%x!UO&U!WO&[!XO&^!YO&`!ZO&b![O&e!]O&k!^O&q!_O&s!`O&u!aO&w!bO&y!cO(RSO(TTO(WUO(_VO(m[O~OWtO~P`OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oa!wOq!nO!Q!oO!`!yO!a!vO!b!vO!z;wO#R!pO#S!pO#T!xO#U!pO#V!pO#Y!zO#Z!zO(S!lO(TTO(WUO(c!mO(m!sO~O'|!{O~OP]XR]X[]Xa]Xp]X!O]X!Q]X!Z]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X'x]X(_]X(p]X(w]X(x]X~O!e%QX~P(qO_!}O(T#PO(U!}O(V#PO~O_#QO(V#PO(W#PO(X#QO~Ov#SO!S#TO(`#TO(a#VO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R;{O(TTO(WUO(_VO(m[O~O!Y#ZO!Z#WO!W(fP!W(tP~P+}O![#cO~P`OPYOQYOSfOd!jOe!iOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(TTO(WUO(_VO(m[O~On#mO!Y#iO!z]O#g#lO#h#iO(R;|O!i(qP~P.iO!j#oO(R#nO~O!v#sO!z]O%g#tO~O#i#uO~O!e#vO#i#uO~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!Z$_O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~Oa(dX'x(dX'u(dX!i(dX!W(dX!](dX%h(dX!e(dX~P1qO#Q$dO#^$eO$P$eOP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#t(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX!](eX%h(eX~Oa(eX'x(eX'u(eX!W(eX!i(eXt(eX!e(eX~P4UO#^$eO~O$[$hO$^$gO$e$mO~OSfO!]$nO$h$oO$j$qO~Oh%VOj%cOn%WOp%XOq$tOr$tOx%YOz%ZO|%[O!Q${O!]$|O!g%aO!j$xO#h%bO$V%_O$s%]O$u%^O$x%`O(R$sO(TTO(WUO(_$uO(w$}O(x%POg([P~O!j%dO~O!Q%gO!]%hO(R%fO~O!e%lO~Oa%mO'x%mO~O!O%qO~P%[O(S!lO~P%[O%m%uO~P%[Oh%VO!j%dO(R%fO(S!lO~Oe%|O!j%dO(R%fO~O#t$RO~O!O&RO!]&OO!j&QO%i&UO(R%fO(S!lO(TTO(WUO`)UP~O!v#sO~O%r&WO!Q)QX!])QX(R)QX~O(R&XO~Oj!PO!s&^O%i!QO%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO~Od&cOe&bO!v&`O%g&aO%z&_O~P<POd&fOeyOj!PO!]&eO!s&^O!vxO!z]O%g}O%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO%x!UO~Ob&iO#^&lO%i&gO(S!lO~P=UO!j&mO!s&qO~O!j#oO~O!]XO~Oa%mO'v&yO'x%mO~Oa%mO'v&|O'x%mO~Oa%mO'v'OO'x%mO~O'u]X!W]Xt]X!i]X&Y]X!]]X%h]X!e]X~P(qO!`']O!a'UO!b'UO(S!lO(TTO(WUO~Oq'SO!Q'RO!Y'VO(c'QO![(gP![(vP~P@]Ol'`O!]'^O(R%fO~Oe'eO!j%dO(R%fO~O!O&RO!j&QO~Oq!nO!Q!oO!z;wO#R!pO#S!pO#U!pO#V!pO(S!lO(TTO(WUO(c!mO(m!sO~O!`'kO!a'jO!b'jO#T!pO#Y'lO#Z'lO~PAwOa%mOh%VO!e#vO!j%dO'x%mO(p'nO~O!n'rO#^'pO~PCVOq!nO!Q!oO(TTO(WUO(c!mO(m!sO~O!]XOq(kX!Q(kX!`(kX!a(kX!b(kX!z(kX#R(kX#S(kX#T(kX#U(kX#V(kX#Y(kX#Z(kX(S(kX(T(kX(W(kX(c(kX(m(kX~O!a'jO!b'jO(S!lO~PCuO'}'vO(O'vO(P'xO~O_!}O(T'zO(U!}O(V'zO~O_#QO(V'zO(W'zO(X#QO~Ot'|O~P%[Ov#SO!S#TO(`#TO(a(PO~O!Y(RO!W'UX!W'[X!Z'UX!Z'[X~P+}O!Z(TO!W(fX~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!Z(TO!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~O!W(fX~PGpO!W(YO~O!W(sX!Z(sX!e(sX!i(sX(p(sX~O#^(sX#i#bX![(sX~PIsO#^(ZO!W(uX!Z(uX~O!Z([O!W(tX~O!W(_O~O#^$eO~PIsO![(`O~P`OR#zO!O#yO!Q#{O!j#xO(_VOP!la[!lap!la!Z!la!n!la#P!la#l!la#m!la#n!la#o!la#p!la#q!la#r!la#s!la#t!la#u!la#w!la#y!la#z!la(p!la(w!la(x!la~Oa!la'x!la'u!la!W!la!i!lat!la!]!la%h!la!e!la~PKZO!i(aO~O!e#vO#^(bO(p'nO!Z(rXa(rX'x(rX~O!i(rX~PMvO!Q%gO!]%hO!z]O#g(gO#h(fO(R%fO~O!Z(hO!i(qX~O!i(jO~O!Q%gO!]%hO#h(fO(R%fO~OP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#t(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX~O!e#vO!i(eX~P! dOR(lO!O(kO!j#xO#Q$dO!z!ya!Q!ya~O!v!ya%g!ya!]!ya#g!ya#h!ya(R!ya~P!#eO!v(pO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]XO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~O#i(vO~O!Y(xO!i(iP~P%[O(c(zO(m[O~O!Q(|O!j#xO(c(zO(m[O~OP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]!eO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(R)ZO(TTO(WUO(_VO(m[O~O!Z$_Oa$pa'x$pa'u$pa!i$pa!W$pa!]$pa%h$pa!e$pa~Oj)bO~P!&iOh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|%[O!Q${O!]$|O!g%aO!j$xO#h%bO$V%_O$s%]O$u%^O$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~Og(nP~P!+rO!O)gO!e)fO!]$]X$Y$]X$[$]X$^$]X$e$]X~O!e)fO!](yX$Y(yX$[(yX$^(yX$e(yX~O!O)gO~P!-{O!O)gO!](yX$Y(yX$[(yX$^(yX$e(yX~O!])iO$Y)mO$[)hO$^)hO$e)nO~O!Y)qO~P!(yO$[$hO$^$gO$e)uO~Ol$yX!O$yX#Q$yX'w$yX(w$yX(x$yX~OgkXg$yXlkX!ZkX#^kX~P!/qOv)wO(`)xO(a)zO~Ol*TO!O)|O'w)}O(w$}O(x%PO~Og){O~P!0uOg*UO~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q*WO!]*XO!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(TTO(WUO(_$uO(w$}O(x%PO~O!Y*[O(R*VO!i(|P~P!1dO#i*^O~O!j*_O~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(R*aO(TTO(WUO(_$uO(w$}O(x%PO~O!Y*dO!W(}P~P!3cOp*pOq!nO!Q*fO!`*nO!a*hO!b*hO!j*_O#Y*oO%_*jO(S!lO(TTO(WUO(c!mO~O![*mO~P!5WO#Q$dOl(^X!O(^X'w(^X(w(^X(x(^X!Z(^X#^(^X~Og(^X#}(^X~P!6YOl*uO#^*tOg(]X!Z(]X~O!Z*vOg([X~Oj%cO(R&XOg([P~Oq*yO~O!j+OO~O(R(tO~On+TO!Q%gO!Y#iO!]%hO!z]O#g#lO#h#iO(R%fO!i(qP~O!e#vO#i+UO~O!Q%gO!Y+WO!Z([O!]%hO(R%fO!W(tP~Oq'YO!Q+YO!Y+XO(TTO(WUO(c(zO~O![(vP~P!9]O!Z+ZOa)RX'x)RX~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~Oa!ha!Z!ha'x!ha'u!ha!W!ha!i!hat!ha!]!ha%h!ha!e!ha~P!:TOR#zO!O#yO!Q#{O!j#xO(_VOP!pa[!pap!pa!Z!pa!n!pa#P!pa#l!pa#m!pa#n!pa#o!pa#p!pa#q!pa#r!pa#s!pa#t!pa#u!pa#w!pa#y!pa#z!pa(p!pa(w!pa(x!pa~Oa!pa'x!pa'u!pa!W!pa!i!pat!pa!]!pa%h!pa!e!pa~P!<kOR#zO!O#yO!Q#{O!j#xO(_VOP!ra[!rap!ra!Z!ra!n!ra#P!ra#l!ra#m!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#w!ra#y!ra#z!ra(p!ra(w!ra(x!ra~Oa!ra'x!ra'u!ra!W!ra!i!rat!ra!]!ra%h!ra!e!ra~P!?ROh%VOl+dO!]'^O%h+cO~O!e+fOa(ZX!](ZX'x(ZX!Z(ZX~Oa%mO!]XO'x%mO~Oh%VO!j%dO~Oh%VO!j%dO(R%fO~O!e#vO#i(vO~Ob+qO%i+rO(R+nO(TTO(WUO![)VP~O!Z+sO`)UX~O[+wO~O`+xO~O!]&OO(R%fO(S!lO`)UP~Oh%VO#^+}O~Oh%VOl,QO!]$|O~O!],SO~O!O,UO!]XO~O%m%uO~O!v,ZO~Oe,`O~Ob,aO(R#nO(TTO(WUO![)TP~Oe%|O~O%i!QO(R&XO~P=UO[,fO`,eO~OPYOQYOSfOdzOeyOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!guO!jZO!mYO!nYO!oYO!qvO!vxO!z]O$miO%g}O(TTO(WUO(_VO(m[O~O!]!eO!s!gO$V!kO(R!dO~P!FRO`,eOa%mO'x%mO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oa,kOj!OO!swO%k!OO%l!OO%m!OO~P!HkO!j&mO~O&[,qO~O!],sO~O&m,uO&o,vOP&jaQ&jaS&jaY&jaa&jad&jae&jaj&jan&jap&jaq&jar&jax&jaz&ja|&ja!Q&ja!U&ja!V&ja!]&ja!g&ja!j&ja!m&ja!n&ja!o&ja!q&ja!s&ja!v&ja!z&ja$V&ja$m&ja%g&ja%i&ja%k&ja%l&ja%m&ja%p&ja%r&ja%u&ja%v&ja%x&ja&U&ja&[&ja&^&ja&`&ja&b&ja&e&ja&k&ja&q&ja&s&ja&u&ja&w&ja&y&ja'u&ja(R&ja(T&ja(W&ja(_&ja(m&ja![&ja&c&jab&ja&h&ja~O(R,{O~Oh!cX!Z!PX![!PX!e!PX!e!cX!j!cX#^!PX~O!Z!cX![!cX~P# qO!e-QO#^-POh(hX!Z#fX![#fX!e(hX!j(hX~O!Z(hX![(hX~P#!dOh%VO!e-SO!j%dO!Z!_X![!_X~Oq!nO!Q!oO(TTO(WUO(c!mO~OP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]!eO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(TTO(WUO(_VO(m[O~O(R<rO~P##yO!Z-WO![(gX~O![-YO~O!e-QO#^-PO!Z#fX![#fX~O!Z-ZO![(vX~O![-]O~O!a-^O!b-^O(S!lO~P##hO![-aO~P'_Ol-dO!]'^O~O!W-iO~Oq!ya!`!ya!a!ya!b!ya#R!ya#S!ya#T!ya#U!ya#V!ya#Y!ya#Z!ya(S!ya(T!ya(W!ya(c!ya(m!ya~P!#eO!n-nO#^-lO~PCVO!a-pO!b-pO(S!lO~PCuOa%mO#^-lO'x%mO~Oa%mO!e#vO#^-lO'x%mO~Oa%mO!e#vO!n-nO#^-lO'x%mO(p'nO~O'}'vO(O'vO(P-uO~Ot-vO~O!W'Ua!Z'Ua~P!:TO!Y-zO!W'UX!Z'UX~P%[O!Z(TO!W(fa~O!W(fa~PGpO!Z([O!W(ta~O!Q%gO!Y.OO!]%hO(R%fO!W'[X!Z'[X~O#^.QO!Z(ra!i(raa(ra'x(ra~O!e#vO~P#,PO!Z(hO!i(qa~O!Q%gO!]%hO#h.UO(R%fO~On.ZO!Q%gO!Y.WO!]%hO!z]O#g.YO#h.WO(R%fO!Z'_X!i'_X~OR._O!j#xO~Oh%VOl.bO!]'^O%h.aO~Oa#ai!Z#ai'x#ai'u#ai!W#ai!i#ait#ai!]#ai%h#ai!e#ai~P!:TOl=|O!O)|O'w)}O(w$}O(x%PO~O#i#]aa#]a#^#]a'x#]a!Z#]a!i#]a!]#]a!W#]a~P#.{O#i(^XP(^XR(^X[(^Xa(^Xp(^X!Q(^X!j(^X!n(^X#P(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#s(^X#t(^X#u(^X#w(^X#y(^X#z(^X'x(^X(_(^X(p(^X!i(^X!W(^X'u(^Xt(^X!](^X%h(^X!e(^X~P!6YO!Z.oO!i(iX~P!:TO!i.rO~O!W.tO~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O(_VO[#kia#kip#ki!Z#ki#P#ki#m#ki#n#ki#o#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#l#ki~P#2kO#l$OO~P#2kOP$[OR#zOp$aO!O#yO!Q#{O!j#xO!n$[O#l$OO#m$PO#n$PO#o$PO(_VO[#kia#ki!Z#ki#P#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#p#ki~P#5YO#p$QO~P#5YOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO(_VOa#ki!Z#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#u#ki~P#7wOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO(_VO(x#}Oa#ki!Z#ki#y#ki#z#ki'x#ki(p#ki(w#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#w$UO~P#:_O#w#ki~P#:_O#u$SO~P#7wOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO(_VO(w#|O(x#}Oa#ki!Z#ki#z#ki'x#ki(p#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#y#ki~P#=TO#y$WO~P#=TOP]XR]X[]Xp]X!O]X!Q]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X!Z]X![]X~O#}]X~P#?rOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO#w<VO#y<XO#z<YO(_VO(p$YO(w#|O(x#}O~O#}.vO~P#BPO#Q$dO#^<`O$P<`O#}(eX![(eX~P! dOa'ba!Z'ba'x'ba'u'ba!i'ba!W'bat'ba!]'ba%h'ba!e'ba~P!:TO[#kia#kip#ki!Z#ki#P#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O#l$OO#m$PO#n$PO#o$PO(_VO(w#ki(x#ki~P#EROl=|O!O)|O'w)}O(w$}O(x%POP#kiR#ki!Q#ki!j#ki!n#ki#l#ki#m#ki#n#ki#o#ki(_#ki~P#ERO!Z.zOg(nX~P!0uOg.|O~Oa$Oi!Z$Oi'x$Oi'u$Oi!W$Oi!i$Oit$Oi!]$Oi%h$Oi!e$Oi~P!:TO$[.}O$^.}O~O$[/OO$^/OO~O!e)fO#^/PO!]$bX$Y$bX$[$bX$^$bX$e$bX~O!Y/QO~O!])iO$Y/SO$[)hO$^)hO$e/TO~O!Z<ZO![(dX~P#BPO![/UO~O!e)fO$e(yX~O$e/WO~Ot/XO~P!&iOv)wO(`)xO(a/[O~O!Q/_O~O(w$}Ol%`a!O%`a'w%`a(x%`a!Z%`a#^%`a~Og%`a#}%`a~P#LTO(x%POl%ba!O%ba'w%ba(w%ba!Z%ba#^%ba~Og%ba#}%ba~P#LvO!ZfX!efX!ifX!i$yX(pfX~P!/qO!Y/hO!Z([O(R/gO!W(tP!W(}P~P!1dOp*pO!`*nO!a*hO!b*hO!j*_O#Y*oO%_*jO(S!lO(TTO(WUO~Oq<oO!Q/iO!Y+XO![*mO(c<nO![(vP~P#NaO!i/jO~P#.{O!Z/kO!e#vO(p'nO!i(|X~O!i/pO~O!Q%gO!Y*[O!]%hO(R%fO!i(|P~O#i/rO~O!W$yX!Z$yX!e%QX~P!/qO!Z/sO!W(}X~P#.{O!e/uO~O!W/wO~OnkO(R/xO~P.iOh%VOp/}O!e#vO!j%dO(p'nO~O!e+fO~Oa%mO!Z0RO'x%mO~O![0TO~P!5WO!a0UO!b0UO(S!lO~P##hOq!nO!Q0VO(TTO(WUO(c!mO~O#Y0XO~Og%`a!Z%`a#^%`a#}%`a~P!0uOg%ba!Z%ba#^%ba#}%ba~P!0uOj%cO(R&XOg'kX!Z'kX~O!Z*vOg([a~Og0bO~OR0cO!O0cO!Q0dO#Q$dOl{a'w{a(w{a(x{a!Z{a#^{a~Og{a#}{a~P$&dO!O)|O'w)}Ol$ra(w$ra(x$ra!Z$ra#^$ra~Og$ra#}$ra~P$'`O!O)|O'w)}Ol$ta(w$ta(x$ta!Z$ta#^$ta~Og$ta#}$ta~P$(RO#i0gO~Og%Sa!Z%Sa#^%Sa#}%Sa~P!0uOl0iO#^0hOg(]a!Z(]a~O!e#vO~O#i0lO~O!Z+ZOa)Ra'x)Ra~OR#zO!O#yO!Q#{O!j#xO(_VOP!pi[!pip!pi!Z!pi!n!pi#P!pi#l!pi#m!pi#n!pi#o!pi#p!pi#q!pi#r!pi#s!pi#t!pi#u!pi#w!pi#y!pi#z!pi(p!pi(w!pi(x!pi~Oa!pi'x!pi'u!pi!W!pi!i!pit!pi!]!pi%h!pi!e!pi~P$*OOh%VOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(TTO(WUO(_$uO(w$}O(x%PO~On0vO%[0wO(R0tO~P$,fO!e+fOa(Za!](Za'x(Za!Z(Za~O#i0|O~O[]X!ZfX![fX~O!Z0}O![)VX~O![1PO~O[1QO~Ob1SO(R+nO(TTO(WUO~O!]&OO(R%fO`'sX!Z'sX~O!Z+sO`)Ua~O!i1VO~P!:TO[1YO~O`1ZO~O#^1^O~Ol1aO!]$|O~O(c(zO![)SP~Oh%VOl1jO!]1gO%h1iO~O[1tO!Z1rO![)TX~O![1uO~O`1wOa%mO'x%mO~O(R#nO(TTO(WUO~O#Q$dO#^$eO$P$eOP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX~O#t1zO&Y1{Oa(eX~P$2PO#^$eO#t1zO&Y1{O~Oa1}O~P%[Oa2PO~O&c2SOP&aiQ&aiS&aiY&aia&aid&aie&aij&ain&aip&aiq&air&aix&aiz&ai|&ai!Q&ai!U&ai!V&ai!]&ai!g&ai!j&ai!m&ai!n&ai!o&ai!q&ai!s&ai!v&ai!z&ai$V&ai$m&ai%g&ai%i&ai%k&ai%l&ai%m&ai%p&ai%r&ai%u&ai%v&ai%x&ai&U&ai&[&ai&^&ai&`&ai&b&ai&e&ai&k&ai&q&ai&s&ai&u&ai&w&ai&y&ai'u&ai(R&ai(T&ai(W&ai(_&ai(m&ai![&aib&ai&h&ai~Ob2YO![2WO&h2XO~P`O!]XO!j2[O~O&o,vOP&jiQ&jiS&jiY&jia&jid&jie&jij&jin&jip&jiq&jir&jix&jiz&ji|&ji!Q&ji!U&ji!V&ji!]&ji!g&ji!j&ji!m&ji!n&ji!o&ji!q&ji!s&ji!v&ji!z&ji$V&ji$m&ji%g&ji%i&ji%k&ji%l&ji%m&ji%p&ji%r&ji%u&ji%v&ji%x&ji&U&ji&[&ji&^&ji&`&ji&b&ji&e&ji&k&ji&q&ji&s&ji&u&ji&w&ji&y&ji'u&ji(R&ji(T&ji(W&ji(_&ji(m&ji![&ji&c&jib&ji&h&ji~O!W2bO~O!Z!_a![!_a~P#BPOq!nO!Q!oO!Y2hO(c!mO!Z'VX!['VX~P@]O!Z-WO![(ga~O!Z']X![']X~P!9]O!Z-ZO![(va~O![2oO~P'_Oa%mO#^2xO'x%mO~Oa%mO!e#vO#^2xO'x%mO~Oa%mO!e#vO!n2|O#^2xO'x%mO(p'nO~Oa%mO'x%mO~P!:TO!Z$_Ot$pa~O!W'Ui!Z'Ui~P!:TO!Z(TO!W(fi~O!Z([O!W(ti~O!W(ui!Z(ui~P!:TO!Z(ri!i(ria(ri'x(ri~P!:TO#^3OO!Z(ri!i(ria(ri'x(ri~O!Z(hO!i(qi~O!Q%gO!]%hO!z]O#g3TO#h3SO(R%fO~O!Q%gO!]%hO#h3SO(R%fO~Ol3[O!]'^O%h3ZO~Oh%VOl3[O!]'^O%h3ZO~O#i%`aP%`aR%`a[%`aa%`ap%`a!Q%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a'x%`a(_%`a(p%`a!i%`a!W%`a'u%`at%`a!]%`a%h%`a!e%`a~P#LTO#i%baP%baR%ba[%baa%bap%ba!Q%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba'x%ba(_%ba(p%ba!i%ba!W%ba'u%bat%ba!]%ba%h%ba!e%ba~P#LvO#i%`aP%`aR%`a[%`aa%`ap%`a!Q%`a!Z%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a'x%`a(_%`a(p%`a!i%`a!W%`a'u%`a#^%`at%`a!]%`a%h%`a!e%`a~P#.{O#i%baP%baR%ba[%baa%bap%ba!Q%ba!Z%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba'x%ba(_%ba(p%ba!i%ba!W%ba'u%ba#^%bat%ba!]%ba%h%ba!e%ba~P#.{O#i{aP{a[{aa{ap{a!j{a!n{a#P{a#l{a#m{a#n{a#o{a#p{a#q{a#r{a#s{a#t{a#u{a#w{a#y{a#z{a'x{a(_{a(p{a!i{a!W{a'u{at{a!]{a%h{a!e{a~P$&dO#i$raP$raR$ra[$raa$rap$ra!Q$ra!j$ra!n$ra#P$ra#l$ra#m$ra#n$ra#o$ra#p$ra#q$ra#r$ra#s$ra#t$ra#u$ra#w$ra#y$ra#z$ra'x$ra(_$ra(p$ra!i$ra!W$ra'u$rat$ra!]$ra%h$ra!e$ra~P$'`O#i$taP$taR$ta[$taa$tap$ta!Q$ta!j$ta!n$ta#P$ta#l$ta#m$ta#n$ta#o$ta#p$ta#q$ta#r$ta#s$ta#t$ta#u$ta#w$ta#y$ta#z$ta'x$ta(_$ta(p$ta!i$ta!W$ta'u$tat$ta!]$ta%h$ta!e$ta~P$(RO#i%SaP%SaR%Sa[%Saa%Sap%Sa!Q%Sa!Z%Sa!j%Sa!n%Sa#P%Sa#l%Sa#m%Sa#n%Sa#o%Sa#p%Sa#q%Sa#r%Sa#s%Sa#t%Sa#u%Sa#w%Sa#y%Sa#z%Sa'x%Sa(_%Sa(p%Sa!i%Sa!W%Sa'u%Sa#^%Sat%Sa!]%Sa%h%Sa!e%Sa~P#.{Oa#aq!Z#aq'x#aq'u#aq!W#aq!i#aqt#aq!]#aq%h#aq!e#aq~P!:TO!Y3dO!Z'WX!i'WX~P%[O!Z.oO!i(ia~O!Z.oO!i(ia~P!:TO!W3gO~O#}!la![!la~PKZO#}!ha!Z!ha![!ha~P#BPO#}!pa![!pa~P!<kO#}!ra![!ra~P!?ROg'ZX!Z'ZX~P!+rO!Z.zOg(na~OSfO!]3{O$c3|O~O![4QO~Ot4RO~P#.{Oa$lq!Z$lq'x$lq'u$lq!W$lq!i$lqt$lq!]$lq%h$lq!e$lq~P!:TO!W4TO~P!&iO!Q4UO~O!O)|O'w)}O(x%POl'ga(w'ga!Z'ga#^'ga~Og'ga#}'ga~P%+uO!O)|O'w)}Ol'ia(w'ia(x'ia!Z'ia#^'ia~Og'ia#}'ia~P%,hO(p$YO~P#.{O!WfX!W$yX!ZfX!Z$yX!e%QX#^fX~P!/qO(R<xO~P!1dO!Q%gO!Y4XO!]%hO(R%fO!Z'cX!i'cX~O!Z/kO!i(|a~O!Z/kO!e#vO!i(|a~O!Z/kO!e#vO(p'nO!i(|a~Og${i!Z${i#^${i#}${i~P!0uO!Y4aO!W'eX!Z'eX~P!3cO!Z/sO!W(}a~O!Z/sO!W(}a~P#.{OP]XR]X[]Xp]X!O]X!Q]X!W]X!Z]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X~O!e%XX#t%XX~P%0XO!e#vO#t4fO~Oh%VO!e#vO!j%dO~Oh%VOp4kO!j%dO(p'nO~Op4pO!e#vO(p'nO~Oq!nO!Q4qO(TTO(WUO(c!mO~O(w$}Ol%`i!O%`i'w%`i(x%`i!Z%`i#^%`i~Og%`i#}%`i~P%3xO(x%POl%bi!O%bi'w%bi(w%bi!Z%bi#^%bi~Og%bi#}%bi~P%4kOg(]i!Z(]i~P!0uO#^4wOg(]i!Z(]i~P!0uO!i4zO~Oa$nq!Z$nq'x$nq'u$nq!W$nq!i$nqt$nq!]$nq%h$nq!e$nq~P!:TO!W5QO~O!Z5RO!])OX~P#.{Oa]Xa$yX!]]X!]$yX%]]X'x]X'x$yX!Z]X!Z$yX~P!/qO%]5UOa%Za!]%Za'x%Za!Z%Za~OlmX!OmX'wmX(wmX(xmX~P%7nOn5VO(R#nO~Ob5]O%i5^O(R+nO(TTO(WUO!Z'rX!['rX~O!Z0}O![)Va~O[5bO~O`5cO~Oa%mO'x%mO~P#.{O!Z5kO#^5mO![)SX~O![5nO~Op5tOq!nO!Q*fO!`!yO!a!vO!b!vO!z;wO#R!pO#S!pO#T!pO#U!pO#V!pO#Y5sO#Z!zO(S!lO(TTO(WUO(c!mO(m!sO~O![5rO~P%:ROl5yO!]1gO%h5xO~Oh%VOl5yO!]1gO%h5xO~Ob6QO(R#nO(TTO(WUO!Z'qX!['qX~O!Z1rO![)Ta~O(TTO(WUO(c6SO~O`6WO~O#t6ZO&Y6[O~PMvO!i6]O~P%[Oa6_O~Oa6_O~P%[Ob2YO![6dO&h2XO~P`O!e6fO~O!e6hOh(hi!Z(hi![(hi!e(hi!j(hip(hi(p(hi~O!Z#fi![#fi~P#BPO#^6iO!Z#fi![#fi~O!Z!_i![!_i~P#BPOa%mO#^6rO'x%mO~Oa%mO!e#vO#^6rO'x%mO~O!Z(rq!i(rqa(rq'x(rq~P!:TO!Z(hO!i(qq~O!Q%gO!]%hO#h6yO(R%fO~O!]'^O%h6|O~Ol7QO!]'^O%h6|O~O#i'gaP'gaR'ga['gaa'gap'ga!Q'ga!j'ga!n'ga#P'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#t'ga#u'ga#w'ga#y'ga#z'ga'x'ga(_'ga(p'ga!i'ga!W'ga'u'gat'ga!]'ga%h'ga!e'ga~P%+uO#i'iaP'iaR'ia['iaa'iap'ia!Q'ia!j'ia!n'ia#P'ia#l'ia#m'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#w'ia#y'ia#z'ia'x'ia(_'ia(p'ia!i'ia!W'ia'u'iat'ia!]'ia%h'ia!e'ia~P%,hO#i${iP${iR${i[${ia${ip${i!Q${i!Z${i!j${i!n${i#P${i#l${i#m${i#n${i#o${i#p${i#q${i#r${i#s${i#t${i#u${i#w${i#y${i#z${i'x${i(_${i(p${i!i${i!W${i'u${i#^${it${i!]${i%h${i!e${i~P#.{O#i%`iP%`iR%`i[%`ia%`ip%`i!Q%`i!j%`i!n%`i#P%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#t%`i#u%`i#w%`i#y%`i#z%`i'x%`i(_%`i(p%`i!i%`i!W%`i'u%`it%`i!]%`i%h%`i!e%`i~P%3xO#i%biP%biR%bi[%bia%bip%bi!Q%bi!j%bi!n%bi#P%bi#l%bi#m%bi#n%bi#o%bi#p%bi#q%bi#r%bi#s%bi#t%bi#u%bi#w%bi#y%bi#z%bi'x%bi(_%bi(p%bi!i%bi!W%bi'u%bit%bi!]%bi%h%bi!e%bi~P%4kO!Z'Wa!i'Wa~P!:TO!Z.oO!i(ii~O#}#ai!Z#ai![#ai~P#BPOP$[OR#zO!O#yO!Q#{O!j#xO!n$[O(_VO[#kip#ki#P#ki#m#ki#n#ki#o#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#l#ki~P%MQO#l<PO~P%MQOP$[OR#zOp<]O!O#yO!Q#{O!j#xO!n$[O#l<PO#m<QO#n<QO#o<QO(_VO[#ki#P#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#p#ki~P& YO#p<RO~P& YOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO(_VO#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#u#ki~P&#bOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO(_VO(x#}O#y#ki#z#ki#}#ki(p#ki(w#ki!Z#ki![#ki~O#w<VO~P&%cO#w#ki~P&%cO#u<TO~P&#bOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO#w<VO(_VO(w#|O(x#}O#z#ki#}#ki(p#ki!Z#ki![#ki~O#y#ki~P&'rO#y<XO~P&'rOa#{y!Z#{y'x#{y'u#{y!W#{y!i#{yt#{y!]#{y%h#{y!e#{y~P!:TO[#kip#ki#P#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki!Z#ki![#ki~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O#l<PO#m<QO#n<QO#o<QO(_VO(w#ki(x#ki~P&*nOl=}O!O)|O'w)}O(w$}O(x%POP#kiR#ki!Q#ki!j#ki!n#ki#l#ki#m#ki#n#ki#o#ki(_#ki~P&*nO#Q$dOP(^XR(^X[(^Xl(^Xp(^X!O(^X!Q(^X!j(^X!n(^X#P(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#s(^X#t(^X#u(^X#w(^X#y(^X#z(^X#}(^X'w(^X(_(^X(p(^X(w(^X(x(^X!Z(^X![(^X~O#}$Oi!Z$Oi![$Oi~P#BPO#}!pi![!pi~P$*OOg'Za!Z'Za~P!0uO![7dO~O!Z'ba!['ba~P#BPO!W7eO~P#.{O!e#vO(p'nO!Z'ca!i'ca~O!Z/kO!i(|i~O!Z/kO!e#vO!i(|i~Og${q!Z${q#^${q#}${q~P!0uO!W'ea!Z'ea~P#.{O!e7lO~O!Z/sO!W(}i~P#.{O!Z/sO!W(}i~O!W7oO~Oh%VOp7tO!j%dO(p'nO~O!e#vO#t7vO~Op7yO!e#vO(p'nO~O!O)|O'w)}O(x%POl'ha(w'ha!Z'ha#^'ha~Og'ha#}'ha~P&3oO!O)|O'w)}Ol'ja(w'ja(x'ja!Z'ja#^'ja~Og'ja#}'ja~P&4bO!W7{O~Og$}q!Z$}q#^$}q#}$}q~P!0uOg(]q!Z(]q~P!0uO#^7|Og(]q!Z(]q~P!0uOa$ny!Z$ny'x$ny'u$ny!W$ny!i$nyt$ny!]$ny%h$ny!e$ny~P!:TO!e6hO~O!Z5RO!])Oa~O!]'^OP$SaR$Sa[$Sap$Sa!O$Sa!Q$Sa!Z$Sa!j$Sa!n$Sa#P$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#t$Sa#u$Sa#w$Sa#y$Sa#z$Sa(_$Sa(p$Sa(w$Sa(x$Sa~O%h6|O~P&7SO%]8QOa%Zi!]%Zi'x%Zi!Z%Zi~Oa#ay!Z#ay'x#ay'u#ay!W#ay!i#ayt#ay!]#ay%h#ay!e#ay~P!:TO[8SO~Ob8UO(R+nO(TTO(WUO~O!Z0}O![)Vi~O`8YO~O(c(zO!Z'nX!['nX~O!Z5kO![)Sa~O![8cO~P%:RO(m!sO~P$$oO#Y8dO~O!]1gO~O!]1gO%h8fO~Ol8iO!]1gO%h8fO~O[8nO!Z'qa!['qa~O!Z1rO![)Ti~O!i8rO~O!i8sO~O!i8vO~O!i8vO~P%[Oa8xO~O!e8yO~O!i8zO~O!Z(ui![(ui~P#BPOa%mO#^9SO'x%mO~O!Z(ry!i(rya(ry'x(ry~P!:TO!Z(hO!i(qy~O%h9VO~P&7SO!]'^O%h9VO~O#i${qP${qR${q[${qa${qp${q!Q${q!Z${q!j${q!n${q#P${q#l${q#m${q#n${q#o${q#p${q#q${q#r${q#s${q#t${q#u${q#w${q#y${q#z${q'x${q(_${q(p${q!i${q!W${q'u${q#^${qt${q!]${q%h${q!e${q~P#.{O#i'haP'haR'ha['haa'hap'ha!Q'ha!j'ha!n'ha#P'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#w'ha#y'ha#z'ha'x'ha(_'ha(p'ha!i'ha!W'ha'u'hat'ha!]'ha%h'ha!e'ha~P&3oO#i'jaP'jaR'ja['jaa'jap'ja!Q'ja!j'ja!n'ja#P'ja#l'ja#m'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#w'ja#y'ja#z'ja'x'ja(_'ja(p'ja!i'ja!W'ja'u'jat'ja!]'ja%h'ja!e'ja~P&4bO#i$}qP$}qR$}q[$}qa$}qp$}q!Q$}q!Z$}q!j$}q!n$}q#P$}q#l$}q#m$}q#n$}q#o$}q#p$}q#q$}q#r$}q#s$}q#t$}q#u$}q#w$}q#y$}q#z$}q'x$}q(_$}q(p$}q!i$}q!W$}q'u$}q#^$}qt$}q!]$}q%h$}q!e$}q~P#.{O!Z'Wi!i'Wi~P!:TO#}#aq!Z#aq![#aq~P#BPO(w$}OP%`aR%`a[%`ap%`a!Q%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a#}%`a(_%`a(p%`a!Z%`a![%`a~Ol%`a!O%`a'w%`a(x%`a~P&HgO(x%POP%baR%ba[%bap%ba!Q%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba#}%ba(_%ba(p%ba!Z%ba![%ba~Ol%ba!O%ba'w%ba(w%ba~P&JnOl=}O!O)|O'w)}O(x%PO~P&HgOl=}O!O)|O'w)}O(w$}O~P&JnOR0cO!O0cO!Q0dO#Q$dOP{a[{al{ap{a!j{a!n{a#P{a#l{a#m{a#n{a#o{a#p{a#q{a#r{a#s{a#t{a#u{a#w{a#y{a#z{a#}{a'w{a(_{a(p{a(w{a(x{a!Z{a![{a~O!O)|O'w)}OP$raR$ra[$ral$rap$ra!Q$ra!j$ra!n$ra#P$ra#l$ra#m$ra#n$ra#o$ra#p$ra#q$ra#r$ra#s$ra#t$ra#u$ra#w$ra#y$ra#z$ra#}$ra(_$ra(p$ra(w$ra(x$ra!Z$ra![$ra~O!O)|O'w)}OP$taR$ta[$tal$tap$ta!Q$ta!j$ta!n$ta#P$ta#l$ta#m$ta#n$ta#o$ta#p$ta#q$ta#r$ta#s$ta#t$ta#u$ta#w$ta#y$ta#z$ta#}$ta(_$ta(p$ta(w$ta(x$ta!Z$ta![$ta~Ol=}O!O)|O'w)}O(w$}O(x%PO~OP%SaR%Sa[%Sap%Sa!Q%Sa!j%Sa!n%Sa#P%Sa#l%Sa#m%Sa#n%Sa#o%Sa#p%Sa#q%Sa#r%Sa#s%Sa#t%Sa#u%Sa#w%Sa#y%Sa#z%Sa#}%Sa(_%Sa(p%Sa!Z%Sa![%Sa~P'%sO#}$lq!Z$lq![$lq~P#BPO#}$nq!Z$nq![$nq~P#BPO![9dO~O#}9eO~P!0uO!e#vO!Z'ci!i'ci~O!e#vO(p'nO!Z'ci!i'ci~O!Z/kO!i(|q~O!W'ei!Z'ei~P#.{O!Z/sO!W(}q~Op9lO!e#vO(p'nO~O[9nO!W9mO~P#.{O!W9mO~O!e#vO#t9tO~Og(]y!Z(]y~P!0uO!Z'la!]'la~P#.{Oa%Zq!]%Zq'x%Zq!Z%Zq~P#.{O[9yO~O!Z0}O![)Vq~O#^9}O!Z'na!['na~O!Z5kO![)Si~P#BPO!Q:PO~O!]1gO%h:SO~O(TTO(WUO(c:XO~O!Z1rO![)Tq~O!i:[O~O!i:]O~O!i:^O~O!i:^O~P%[O#^:aO!Z#fy![#fy~O!Z#fy![#fy~P#BPO%h:fO~P&7SO!]'^O%h:fO~O#}#{y!Z#{y![#{y~P#BPOP${iR${i[${ip${i!Q${i!j${i!n${i#P${i#l${i#m${i#n${i#o${i#p${i#q${i#r${i#s${i#t${i#u${i#w${i#y${i#z${i#}${i(_${i(p${i!Z${i![${i~P'%sO!O)|O'w)}O(x%POP'gaR'ga['gal'gap'ga!Q'ga!j'ga!n'ga#P'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#t'ga#u'ga#w'ga#y'ga#z'ga#}'ga(_'ga(p'ga(w'ga!Z'ga!['ga~O!O)|O'w)}OP'iaR'ia['ial'iap'ia!Q'ia!j'ia!n'ia#P'ia#l'ia#m'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#w'ia#y'ia#z'ia#}'ia(_'ia(p'ia(w'ia(x'ia!Z'ia!['ia~O(w$}OP%`iR%`i[%`il%`ip%`i!O%`i!Q%`i!j%`i!n%`i#P%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#t%`i#u%`i#w%`i#y%`i#z%`i#}%`i'w%`i(_%`i(p%`i(x%`i!Z%`i![%`i~O(x%POP%biR%bi[%bil%bip%bi!O%bi!Q%bi!j%bi!n%bi#P%bi#l%bi#m%bi#n%bi#o%bi#p%bi#q%bi#r%bi#s%bi#t%bi#u%bi#w%bi#y%bi#z%bi#}%bi'w%bi(_%bi(p%bi(w%bi!Z%bi![%bi~O#}$ny!Z$ny![$ny~P#BPO#}#ay!Z#ay![#ay~P#BPO!e#vO!Z'cq!i'cq~O!Z/kO!i(|y~O!W'eq!Z'eq~P#.{Op:pO!e#vO(p'nO~O[:tO!W:sO~P#.{O!W:sO~Og(]!R!Z(]!R~P!0uOa%Zy!]%Zy'x%Zy!Z%Zy~P#.{O!Z0}O![)Vy~O!Z5kO![)Sq~O(R:zO~O!]1gO%h:}O~O!i;QO~O%h;VO~P&7SOP${qR${q[${qp${q!Q${q!j${q!n${q#P${q#l${q#m${q#n${q#o${q#p${q#q${q#r${q#s${q#t${q#u${q#w${q#y${q#z${q#}${q(_${q(p${q!Z${q![${q~P'%sO!O)|O'w)}O(x%POP'haR'ha['hal'hap'ha!Q'ha!j'ha!n'ha#P'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#w'ha#y'ha#z'ha#}'ha(_'ha(p'ha(w'ha!Z'ha!['ha~O!O)|O'w)}OP'jaR'ja['jal'jap'ja!Q'ja!j'ja!n'ja#P'ja#l'ja#m'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#w'ja#y'ja#z'ja#}'ja(_'ja(p'ja(w'ja(x'ja!Z'ja!['ja~OP$}qR$}q[$}qp$}q!Q$}q!j$}q!n$}q#P$}q#l$}q#m$}q#n$}q#o$}q#p$}q#q$}q#r$}q#s$}q#t$}q#u$}q#w$}q#y$}q#z$}q#}$}q(_$}q(p$}q!Z$}q![$}q~P'%sOg%d!Z!Z%d!Z#^%d!Z#}%d!Z~P!0uO!W;ZO~P#.{Op;[O!e#vO(p'nO~O[;^O!W;ZO~P#.{O!Z'nq!['nq~P#BPO!Z#f!Z![#f!Z~P#BPO#i%d!ZP%d!ZR%d!Z[%d!Za%d!Zp%d!Z!Q%d!Z!Z%d!Z!j%d!Z!n%d!Z#P%d!Z#l%d!Z#m%d!Z#n%d!Z#o%d!Z#p%d!Z#q%d!Z#r%d!Z#s%d!Z#t%d!Z#u%d!Z#w%d!Z#y%d!Z#z%d!Z'x%d!Z(_%d!Z(p%d!Z!i%d!Z!W%d!Z'u%d!Z#^%d!Zt%d!Z!]%d!Z%h%d!Z!e%d!Z~P#.{Op;fO!e#vO(p'nO~O!W;gO~P#.{Op;nO!e#vO(p'nO~O!W;oO~P#.{OP%d!ZR%d!Z[%d!Zp%d!Z!Q%d!Z!j%d!Z!n%d!Z#P%d!Z#l%d!Z#m%d!Z#n%d!Z#o%d!Z#p%d!Z#q%d!Z#r%d!Z#s%d!Z#t%d!Z#u%d!Z#w%d!Z#y%d!Z#z%d!Z#}%d!Z(_%d!Z(p%d!Z!Z%d!Z![%d!Z~P'%sOp;rO!e#vO(p'nO~Ot(dX~P1qO!O%qO~P!(yO(S!lO~P!(yO!WfX!ZfX#^fX~P%0XOP]XR]X[]Xp]X!O]X!Q]X!Z]X!ZfX!j]X!n]X#P]X#Q]X#^]X#^fX#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X~O!efX!i]X!ifX(pfX~P'JlOP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]XO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(R)ZO(TTO(WUO(_VO(m[O~O!Z<ZO![$pa~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<fO!Q${O!]$|O!g=wO!j$xO#h<lO$V%_O$s<hO$u<jO$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~Oj)bO~P( bOp!cX(p!cX~P# qOp(hX(p(hX~P#!dO![]X![fX~P'JlO!WfX!W$yX!ZfX!Z$yX#^fX~P!/qO#i<OO~O!e#vO#i<OO~O#^<`O~O#t<SO~O#^<pO!Z(uX![(uX~O#^<`O!Z(sX![(sX~O#i<qO~Og<sO~P!0uO#i<yO~O#i<zO~O!e#vO#i<{O~O!e#vO#i<qO~O#}<|O~P#BPO#i<}O~O#i=OO~O#i=TO~O#i=UO~O#i=VO~O#i=WO~O#}=XO~P!0uO#}=YO~P!0uO#Q#R#S#U#V#Y#g#h#s$m$s$u$x%[%]%g%h%i%p%r%u%v%x%z~'|T#m!V'z(S#nq#l#op!O'{$['{(R$^(c~",
  goto: "$8f)ZPPPPPP)[PP)_P)pP+Q/VPPPP6aPP6wPP<oP@cP@yP@yPPP@yPCRP@yP@yP@yPCVPC[PCyPHsPPPHwPPPPHwKzPPPLQLrPHwPHwPP! QHwPPPHwPHwP!#XHwP!&o!'t!'}P!(q!(u!(q!,SPPPPPPP!,s!'tPP!-T!.uP!2RHwHw!2W!5d!:Q!:Q!>PPPP!>XHwPPPPPPPPPP!AhP!BuPPHw!DWPHwPHwHwHwHwHwPHw!EjP!HtP!KzP!LO!LY!L^!L^P!HqP!Lb!LbP# hP# lHwPHw# r#$wCV@yP@yP@y@yP#&U@y@y#(h@y#+`@y#-l@y@y#.[#0p#0p#0u#1O#0p#1ZPP#0pP@y#1s@y#5r@y@y6aPPP#9wPPP#:b#:bP#:bP#:x#:bPP#;OP#:uP#:u#;c#:u#;}#<T#<W)_#<Z)_P#<b#<b#<bP)_P)_P)_P)_PP)_P#<h#<kP#<k)_P#<oP#<rP)_P)_P)_P)_P)_P)_)_PP#<x#=O#=Z#=a#=g#=m#=s#>R#>X#>c#>i#>s#>y#?Z#?a#@R#@e#@k#@q#AP#Af#CZ#Ci#Cp#E[#Ej#G[#Gj#Gp#Gv#G|#HW#H^#Hd#Hn#IQ#IWPPPPPPPPPPP#I^PPPPPPP#JR#MY#Nr#Ny$ RPPP$&mP$&v$)o$0Y$0]$0`$1_$1b$1i$1qP$1w$1zP$2h$2l$3d$4r$4w$5_PP$5d$5j$5n$5q$5u$5y$6u$7^$7u$7y$7|$8P$8V$8Y$8^$8bR!|RoqOXst!Z#d%l&p&r&s&u,n,s2S2VY!vQ'^-`1g5qQ%svQ%{yQ&S|Q&h!VS'U!e-WQ'd!iS'j!r!yU*h$|*X*lQ+l%|Q+y&UQ,_&bQ-^']Q-h'eQ-p'kQ0U*nQ1q,`R<m;z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9SS#q];w!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU*{%[<e<fQ+q&OQ,a&eQ,h&mQ0r+dQ0u+fQ1S+rQ1y,fQ3W.bQ5V0wQ5]0}Q6Q1rQ7O3[Q8U5^R9Y7Q'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s!S!nQ!r!v!y!z$|'U']'^'j'k'l*h*l*n*o-W-^-`-p0U0X1g5q5s%[$ti#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q&V|Q'S!eS'Y%h-ZQ+q&OQ,a&eQ0f+OQ1S+rQ1X+xQ1x,eQ1y,fQ5]0}Q5f1ZQ6Q1rQ6T1tQ6U1wQ8U5^Q8X5cQ8q6WQ9|8YQ:Y8nR<o*XrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR,c&i&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=r=s[#]WZ#W#Z'V(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ%vxQ%zyS&P|&UQ&]!TQ'a!hQ'c!iQ(o#sS+k%{%|Q+o&OQ,Y&`Q,^&bS-g'd'eQ.d(pQ0{+lQ1R+rQ1T+sQ1W+wQ1l,ZS1p,_,`Q2t-hQ5[0}Q5`1QQ5e1YQ6P1qQ8T5^Q8W5bQ9x8SR:w9y!U$zi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y!^%xy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pQ+e%vQ,O&YQ,R&ZQ,]&bQ.c(oQ1k,YU1o,^,_,`Q3].dQ5z1lS6O1p1qQ8m6P#f=t#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o=u<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YW%Ti%V*v=pS&Y!Q&gQ&Z!RQ&[!SQ+S%cR+|&W%]%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}T)x$u)yV*{%[<e<fW'Y!e%h*X-ZS({#y#zQ+`%qQ+v&RS.](k(lQ1b,SQ4x0cR8^5k'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s$i$^c#Y#e%p%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.w.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ'W!eR2i-W!W!nQ!e!r!v!y!z$|'U']'^'j'k'l*X*h*l*n*o-W-^-`-p0U0X1g5q5sR1d,UnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&w!^Q't!xS(q#u<OQ+i%yQ,W&]Q,X&_Q-e'bQ-r'mS.m(v<qS0k+U<{Q0y+jQ1f,VQ2Z,uQ2],vQ2e-RQ2r-fQ2u-jS5P0l=VQ5W0zS5Z0|=WQ6j2gQ6n2sQ6s2zQ8R5XQ8}6lQ9O6oQ9R6tR:`8z$d$]c#Y#e%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gS(m#p'gQ(}#zS+_%p.wS.^(l(nR3U._'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS#q];wQ&r!XQ&s!YQ&u![Q&v!]R2R,qQ'_!hQ+b%vQ-c'aS.`(o+eQ2p-bW3Y.c.d0q0sQ6m2qW6z3V3X3]5TU9U6{6}7PU:e9W9X9ZS;T:d:gQ;b;UR;j;cU!wQ'^-`T5o1g5q!Q_OXZ`st!V!Z#d#h%d%l&g&i&p&r&s&u(h,n,s.V2S2V]!pQ!r'^-`1g5qT#q];w%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS({#y#zS.](k(l!s=^$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU$fd)],hS(n#p'gU*s%R(u3vU0e*z.i7]Q5T0rQ6{3WQ9X7OR:g9Ym!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sQ'r!uS(d#g1|S-n'i'uQ/n*ZQ/{*gQ2|-qQ4]/oQ4i/}Q4j0OQ4o0WQ7h4WS7s4k4mS7w4p4rQ9g7iQ9k7oQ9p7tQ9u7yS:o9l9mS;Y:p:sS;e;Z;[S;m;f;gS;q;n;oR;t;rQ#wbQ'q!uS(c#g1|S(e#m+TQ+V%eQ+g%wQ+m%}U-m'i'r'uQ.R(dQ/m*ZQ/|*gQ0P*iQ0x+hQ1m,[S2y-n-qQ3R.ZS4[/n/oQ4e/yS4h/{0WQ4l0QQ5|1nQ6u2|Q7g4WQ7k4]U7r4i4o4rQ7u4nQ8k5}S9f7h7iQ9j7oQ9r7wQ9s7xQ:V8lQ:m9gS:n9k9mQ:v9uQ;P:WS;X:o:sS;d;Y;ZS;l;e;gS;p;m;oQ;s;qQ;u;tQ=a=[Q=l=eR=m=fV!wQ'^-`%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS#wz!j!r=Z$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=a=r%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SQ%ej!^%wy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pS%}z!jQ+h%xQ,[&bW1n,],^,_,`U5}1o1p1qS8l6O6PQ:W8m!r=[$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ=e=qR=f=r%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SY#bWZ#W#Z(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ,i&m!p=]$Z$n)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=`'VU'Z!e%h*XR2k-Z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9S!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ,h&mQ0r+dQ3W.bQ7O3[R9Y7Q!b$Tc#Y%p(Q(W(r(w)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!P<U)[)o-U.w2c2f3h3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!f$Vc#Y%p(Q(W(r(w)U)V)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!T<W)[)o-U.w2c2f3h3n3o3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!^$Zc#Y%p(Q(W(r(w)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;xQ4V/fz=s)[)o-U.w2c2f3h3w4P6k7W7a7b8`8|9[9b9c:y;R=gQ=x=zR=y={'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS$oh$pR3|/P'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$kf$qQ$ifS)h$l)lR)t$qT$jf$qT)j$l)l'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$oh$pQ$rhR)s$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9S!s=q$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s#glOPXZst!Z!`!o#S#d#o#{$n%l&i&l&m&p&r&s&u&y'R'`(|)q*f+Y+d,k,n,s-d.b/Q/i0V0d1j1z1{1}2P2S2V2X3[3{4q5y6Z6[6_7Q8i8x!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}Q+P%`Q/^)|o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!U$yi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yQ*`$zU*i$|*X*lQ+Q%aQ0Q*j#f=c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n=d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YQ=h=tQ=i=uQ=j=vR=k=w!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YnoOXst!Z#d%l&p&r&s&u,n,s2S2VS*c${*WQ,|&|Q,}'OR4`/s%[%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q,P&ZQ1`,RQ5i1_R8]5jV*k$|*X*lU*k$|*X*lT5p1g5qS/y*f/iQ4n0VT7x4q:PQ+g%wQ0P*iQ0x+hQ1m,[Q5|1nQ8k5}Q:V8lR;P:W!U%Oi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yx*P$v)c*Q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=oS0Y*q0Z#f<a#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<b<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!d<t(s)a*Y*b.e.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={`<u3u7X7[7`9]:h:k;kS=P.g3aT=Q7Z9`!U%Qi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y|*R$v)c*S*q+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=oS0[*r0]#f<c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!h<v(s)a*Y*b.f.g.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={d<w3u7Y7Z7`9]9^:h:i:k;kS=R.h3bT=S7[9arnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ&d!UR,k&mrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR&d!UQ,T&[R1[+|snOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ1h,YS5w1k1lU8e5u5v5zS:R8g8hS:{:Q:TQ;_:|R;i;`Q&k!VR,d&gR6T1tR:Y8nS&P|&UR1T+sQ&p!WR,n&qR,t&vT2T,s2VR,x&wQ,w&wR2^,xQ'w!{R-t'wSsOtQ#dXT%os#dQ#OTR'y#OQ#RUR'{#RQ)y$uR/Z)yQ#UVR(O#UQ#XWU(U#X(V-{Q(V#YR-{(WQ-X'WR2j-XQ.p(wS3e.p3fR3f.qQ-`'^R2n-`Y!rQ'^-`1g5qR'h!rQ.{)cR3z.{U#_W%g*WU(]#_(^-|Q(^#`R-|(XQ-['ZR2l-[t`OXst!V!Z#d%l&g&i&p&r&s&u,n,s2S2VS#hZ%dU#r`#h.VR.V(hQ(i#jQ.S(eW.[(i.S3P6wQ3P.TR6w3QQ)l$lR/R)lQ$phR)r$pQ$`cU)_$`-w<[Q-w;xR<[)oQ/l*ZW4Y/l4Z7j9hU4Z/m/n/oS7j4[4]R9h7k$e*O$v(s)a)c*Y*b*q*r*|*}+R.g.h.j.k.l/Y/b/d/f/q/v0^0_0p1]3^3_3`3u3y4S4^4_4c4s4u4{4|4}5h7R7S7T7U7Z7[7^7_7`7f7m7p7z7}8P9]9^9_9i9q9v9w:h:i:j:k:l:q:u;W;];h;k=b=n=o=z={Q/t*bU4b/t4d7nQ4d/vR7n4cS*l$|*XR0S*lx*Q$v)c*q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=o!d.e(s)a*Y*b.g.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/c*Q.e7Xa7X3u7Z7[7`9]:h:k;kQ0Z*qQ3a.gU4t0Z3a9`R9`7Z|*S$v)c*q*r+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=o!h.f(s)a*Y*b.g.h.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/e*S.f7Ye7Y3u7Z7[7`9]9^:h:i:k;kQ0]*rQ3b.hU4v0]3b9aR9a7[Q*w%UR0a*wQ5S0pR8O5SQ+[%jR0o+[Q5l1bS8_5l:OR:O8`Q,V&]R1e,VQ5q1gR8b5qQ1s,aS6R1s8oR8o6TQ1O+oW5_1O5a8V9zQ5a1RQ8V5`R9z8WQ+t&PR1U+tQ2V,sR6c2VYrOXst#dQ&t!ZQ+^%lQ,m&pQ,o&rQ,p&sQ,r&uQ2Q,nS2T,s2VR6b2SQ%npQ&x!_Q&{!aQ&}!bQ'P!cQ'o!uQ+]%kQ+i%yQ+{&VQ,c&kQ,z&zW-k'i'q'r'uQ-r'mQ0R*kQ0y+jS1v,d,gQ2_,yQ2`,|Q2a,}Q2u-jW2w-m-n-q-sQ5W0zQ5d1XQ5g1]Q5{1mQ6V1xQ6a2RU6p2v2y2|Q6s2zQ8R5XQ8Z5fQ8[5hQ8a5pQ8j5|Q8p6US9P6q6uQ9R6tQ9{8XQ:U8kQ:Z8qQ:b9QQ:x9|Q;O:VQ;S:cR;a;PQ%yyQ'b!iQ'm!uU+j%z%{%|Q-R'TU-f'c'd'eS-j'i'sQ/z*gS0z+k+lQ2g-TS2s-g-hQ2z-oS4g/{0OQ5X0{Q6l2mQ6o2tQ6t2{U7q4i4j4mQ9o7sR:r9pS$wi=pR*x%VU%Ui%V=pR0`*vQ$viS(s#v+fS)a$b$cQ)c$dQ*Y$xS*b${*WQ*q%OQ*r%QQ*|%]Q*}%^Q+R%bQ.g<aQ.h<cQ.j<gQ.k<iQ.l<kQ/Y)wQ/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*ul0p+c,Q.a1a1i3Z5x6|8f9V:S:f:};VQ1]+}Q3^<tQ3_<vQ3`<yS3u<^<_Q3y.zS4S/_4UQ4^/rQ4_/sQ4c/uQ4s0YQ4u0[Q4{0gQ4|0hQ4}0iQ5h1^Q7R<}Q7S=PQ7T=RQ7U=TQ7Z<bQ7[<dQ7^<hQ7_<jQ7`<lQ7f4VQ7m4aQ7p4fQ7z4wQ7}5RQ8P5UQ9]<zQ9^<uQ9_<wQ9i7lQ9q7vQ9v7|Q9w8QQ:h=OQ:i=QQ:j=SQ:k=UQ:l9eQ:q9nQ:u9tQ;W=XQ;]:tQ;h;^Q;k=YQ=b=pQ=n=xQ=o=yQ=z=|R={=}Q*z%[Q.i<eR7]<fnpOXst!Z#d%l&p&r&s&u,n,s2S2VQ!fPS#fZ#oQ&z!`W'f!o*f0V4qQ'}#SQ)O#{Q)p$nS,g&i&lQ,l&mQ,y&yS-O'R/iQ-b'`Q.s(|Q/V)qQ0m+YQ0s+dQ2O,kQ2q-dQ3X.bQ4O/QQ4y0dQ5v1jQ6X1zQ6Y1{Q6^1}Q6`2PQ6e2XQ7P3[Q7c3{Q8h5yQ8t6ZQ8u6[Q8w6_Q9Z7QQ:T8iR:_8x#[cOPXZst!Z!`!o#d#o#{%l&i&l&m&p&r&s&u&y'R'`(|*f+Y+d,k,n,s-d.b/i0V0d1j1z1{1}2P2S2V2X3[4q5y6Z6[6_7Q8i8xQ#YWQ#eYQ%puQ%rvS%tw!gS(Q#W(TQ(W#ZQ(r#uQ(w#xQ)P$OQ)Q$PQ)R$QQ)S$RQ)T$SQ)U$TQ)V$UQ)W$VQ)X$WQ)Y$XQ)[$ZQ)^$_Q)`$aQ)e$eW)o$n)q/Q3{Q+a%sQ+u&QS-U'V2hQ-s'pS-x(R-zQ-}(ZQ.P(bQ.n(vQ.q(xQ.u;vQ.w;yQ.x;zQ.y;}Q/]){Q0j+UQ2c-PQ2f-SQ2v-lQ2}.QQ3c.oQ3h<OQ3i<PQ3j<QQ3k<RQ3l<SQ3m<TQ3n<UQ3o<VQ3p<WQ3q<XQ3r<YQ3s.vQ3t<]Q3w<`Q3x<mQ4P<ZQ5O0lQ5Y0|Q6k<pQ6q2xQ6v3OQ7V3dQ7W<qQ7a<sQ7b<{Q8`5mQ8|6iQ9Q6rQ9[<|Q9b=VQ9c=WQ:c9SQ:y9}Q;R:aQ;x#SR=g=sR#[WR'X!el!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sS'T!e-WU*g$|*X*lS-T'U']S0O*h*nQ0W*oQ2m-^Q4m0UR4r0XR(y#xQ!fQT-_'^-`]!qQ!r'^-`1g5qQ#p]R'g;wR)d$dY!uQ'^-`1g5qQ'i!rS's!v!yS'u!z5sS-o'j'kQ-q'lR2{-pT#kZ%dS#jZ%dS%jm,jU(e#h#i#lS.T(f(gQ.X(hQ0n+ZQ3Q.UU3R.V.W.YS6x3S3TR9T6yd#^W#W#Z%g(R([*W+W.O/hr#gZm#h#i#l%d(f(g(h+Z.U.V.W.Y3S3T6yS*Z$x*_Q/o*[Q1|,jQ2d-QQ4W/kQ6g2[Q7i4XQ8{6hT=_'V+XV#aW%g*WU#`W%g*WS(S#W([U(X#Z+W/hS-V'V+XT-y(R.OV'[!e%h*XQ$lfR)v$qT)k$l)lR3}/PT*]$x*_T*e${*WQ0q+cQ1_,QQ3V.aQ5j1aQ5u1iQ6}3ZQ8g5xQ9W6|Q:Q8fQ:d9VQ:|:SQ;U:fQ;`:}R;c;VnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&j!VR,c&gtmOXst!U!V!Z#d%l&g&p&r&s&u,n,s2S2VR,j&mT%km,jR1c,SR,b&eQ&T|R+z&UR+p&OT&n!W&qT&o!W&qT2U,s2V",
  nodeNames: "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 378,
  context: Hse,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 35, 37, 49, 51, 53, ""],
    ["group", -26, 9, 17, 19, 66, 206, 210, 214, 215, 217, 220, 223, 233, 235, 241, 243, 245, 247, 250, 256, 262, 264, 266, 268, 270, 272, 273, "Statement", -34, 13, 14, 30, 33, 34, 40, 49, 52, 53, 55, 60, 68, 70, 74, 78, 80, 82, 83, 108, 109, 118, 119, 135, 138, 140, 141, 142, 143, 144, 146, 147, 166, 168, 170, "Expression", -23, 29, 31, 35, 39, 41, 43, 172, 174, 176, 177, 179, 180, 181, 183, 184, 185, 187, 188, 189, 200, 202, 204, 205, "Type", -3, 86, 101, 107, "ClassItem"],
    ["openedBy", 23, "<", 36, "InterpolationStart", 54, "[", 58, "{", 71, "(", 159, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 167, ">", 38, "InterpolationEnd", 48, "]", 59, "}", 72, ")", 164, "JSXEndTag"]
  ],
  propSources: [tae],
  skippedNodes: [0, 5, 6, 276],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(X!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(X!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(UpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(UpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Up(X!b'z0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(V#S$h&j'{0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Up(X!b'{0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!n),Q(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(T':f$h&j(X!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(X!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(X!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(X!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(X!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Up(X!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Up(X!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(X!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(X!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(UpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(UpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Up(X!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(m%1l(Up(X!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Up(X!b$[#t(R,2j(c$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Up(X!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Up(X!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(x+JY$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(W';W$h&j(UpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(UpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(UpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(UpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(UpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!j/.^$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!i!Lf$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Up(X!b(S%&f#o(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Up(X!b#l(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Up(X!bp+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Z+Jf$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Up(X!b!O.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!Y!L^$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Up(X!b#m(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(X!b!V7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!V7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!V7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!V7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!V7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(X!b!V7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(X!b!V7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(X!b!V7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(X!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(X!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Up!V7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Up!V7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Up!V7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Up!V7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(UpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(UpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Up(X!b!V7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Up(X!b!V7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Up(X!b!V7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Up(X!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Up(X!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Up(X!b'|0/l!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Up(X!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(X!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(X!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(UpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(UpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Up(X!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!e$b$h&j#})Lv(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#P-<U(Up(X!b$m7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#p(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#q(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#^*!Y$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#i(Cl$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#q(Ch$e#|$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#q(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#p(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#p(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(p(Ct$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!z$Ip$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!Q0,v$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!W#)l$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Up(X!b(_+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Up(X!b(R,2j$^#t(c$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Up(X!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!]#Hb(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(w+JY$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_![(CdtBr$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!o7`$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Up(X!b'z0/l$[#t(R,2j(c$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Up(X!b'{0/l$[#t(R,2j(c$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [Gse, Kse, Jse, eae, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, Use, new Ap("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOv~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!S~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(a~~", 141, 338), new Ap("j~RQYZXz{^~^O(O~~aP!P!Qd~iO(P~~", 25, 321)],
  topRules: { Script: [0, 7], SingleExpression: [1, 274], SingleClassItem: [2, 275] },
  dialects: { jsx: 0, ts: 15091 },
  dynamicPrecedences: { 78: 1, 80: 1, 92: 1, 168: 1, 198: 1 },
  specialized: [{ term: 325, get: (t) => nae[t] || -1 }, { term: 341, get: (t) => iae[t] || -1 }, { term: 93, get: (t) => rae[t] || -1 }],
  tokenPrec: 15116
}), kD = [
  /* @__PURE__ */ Oi("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Oi("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Oi("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Oi("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Oi("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Oi(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ Oi("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Oi(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Oi(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Oi('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ Oi('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], sae = /* @__PURE__ */ kD.concat([
  /* @__PURE__ */ Oi("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Oi("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Oi("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), Vx = /* @__PURE__ */ new wA(), SD = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Wu(t) {
  return (e, n) => {
    let i = e.node.getChild("VariableDefinition");
    return i && n(i, t), !0;
  };
}
const aae = ["FunctionDeclaration"], lae = {
  FunctionDeclaration: /* @__PURE__ */ Wu("function"),
  ClassDeclaration: /* @__PURE__ */ Wu("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ Wu("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ Wu("type"),
  NamespaceDeclaration: /* @__PURE__ */ Wu("namespace"),
  VariableDefinition(t, e) {
    t.matchContext(aae) || e(t, "variable");
  },
  TypeDefinition(t, e) {
    e(t, "type");
  },
  __proto__: null
};
function _D(t, e) {
  let n = Vx.get(e);
  if (n)
    return n;
  let i = [], r = !0;
  function o(s, a) {
    let l = t.sliceString(s.from, s.to);
    i.push({ label: l, type: a });
  }
  return e.cursor(Bt.IncludeAnonymous).iterate((s) => {
    if (r)
      r = !1;
    else if (s.name) {
      let a = lae[s.name];
      if (a && a(s, o) || SD.has(s.name))
        return !1;
    } else if (s.to - s.from > 8192) {
      for (let a of _D(t, s.node))
        i.push(a);
      return !1;
    }
  }), Vx.set(e, i), i;
}
const Bx = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, xD = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function uae(t) {
  let e = hn(t.state).resolveInner(t.pos, -1);
  if (xD.indexOf(e.name) > -1)
    return null;
  let n = e.name == "VariableName" || e.to - e.from < 20 && Bx.test(t.state.sliceDoc(e.from, e.to));
  if (!n && !t.explicit)
    return null;
  let i = [];
  for (let r = e; r; r = r.parent)
    SD.has(r.name) && (i = i.concat(_D(t.state.doc, r)));
  return {
    options: i,
    from: n ? e.from : t.pos,
    validFor: Bx
  };
}
const oo = /* @__PURE__ */ au.define({
  name: "javascript",
  parser: /* @__PURE__ */ oae.configure({
    props: [
      /* @__PURE__ */ $m.add({
        IfStatement: /* @__PURE__ */ Gh({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Gh({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: Ate,
        SwitchBody: (t) => {
          let e = t.textAfter, n = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (n ? 0 : i ? 1 : 2) * t.unit;
        },
        Block: /* @__PURE__ */ Ete({ closing: "}" }),
        ArrowFunction: (t) => t.baseIndent + t.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ Gh({ except: /^{/ }),
        JSXElement(t) {
          let e = /^\s*<\//.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        JSXEscape(t) {
          let e = /\s*\}/.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        }
      }),
      /* @__PURE__ */ Pm.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": PA,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), CD = {
  test: (t) => /^JSX/.test(t.name),
  facet: /* @__PURE__ */ xA({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, TD = /* @__PURE__ */ oo.configure({ dialect: "ts" }, "typescript"), $D = /* @__PURE__ */ oo.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ T0.add((t) => t.isTop ? [CD] : void 0)]
}), PD = /* @__PURE__ */ oo.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ T0.add((t) => t.isTop ? [CD] : void 0)]
}, "typescript");
let MD = (t) => ({ label: t, type: "keyword" });
const ED = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(MD), cae = /* @__PURE__ */ ED.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(MD));
function dae(t = {}) {
  let e = t.jsx ? t.typescript ? PD : $D : t.typescript ? TD : oo, n = t.typescript ? sae.concat(cae) : kD.concat(ED);
  return new $0(e, [
    oo.data.of({
      autocomplete: ure(xD, jR(n))
    }),
    oo.data.of({
      autocomplete: uae
    }),
    t.jsx ? pae : []
  ]);
}
function hae(t) {
  for (; ; ) {
    if (t.name == "JSXOpenTag" || t.name == "JSXSelfClosingTag" || t.name == "JSXFragmentTag")
      return t;
    if (t.name == "JSXEscape" || !t.parent)
      return null;
    t = t.parent;
  }
}
function Zx(t, e, n = t.length) {
  for (let i = e == null ? void 0 : e.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return t.sliceString(i.from, Math.min(i.to, n));
  return "";
}
const fae = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), pae = /* @__PURE__ */ Le.inputHandler.of((t, e, n, i, r) => {
  if ((fae ? t.composing : t.compositionStarted) || t.state.readOnly || e != n || i != ">" && i != "/" || !oo.isActiveAt(t.state, e, -1))
    return !1;
  let o = r(), { state: s } = o, a = s.changeByRange((l) => {
    var u;
    let { head: c } = l, d = hn(s).resolveInner(c - 1, -1), h;
    if (d.name == "JSXStartTag" && (d = d.parent), !(s.doc.sliceString(c - 1, c) != i || d.name == "JSXAttributeValue" && d.to > c)) {
      if (i == ">" && d.name == "JSXFragmentTag")
        return { range: l, changes: { from: c, insert: "</>" } };
      if (i == "/" && d.name == "JSXStartCloseTag") {
        let f = d.parent, p = f.parent;
        if (p && f.from == c - 2 && ((h = Zx(s.doc, p.firstChild, c)) || ((u = p.firstChild) === null || u === void 0 ? void 0 : u.name) == "JSXFragmentTag")) {
          let m = `${h}>`;
          return { range: ve.cursor(c + m.length, -1), changes: { from: c, insert: m } };
        }
      } else if (i == ">") {
        let f = hae(d);
        if (f && f.name == "JSXOpenTag" && !/^\/?>|^<\//.test(s.doc.sliceString(c, c + 2)) && (h = Zx(s.doc, f, c)))
          return { range: l, changes: { from: c, insert: `</${h}>` } };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (t.dispatch([
    o,
    s.update(a, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), Xu = ["_blank", "_self", "_top", "_parent"], pO = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], mO = ["get", "post", "put", "delete"], gO = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Ri = ["true", "false"], Ye = {}, mae = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Xu,
      hreflang: null
    }
  },
  abbr: Ye,
  address: Ye,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: Ye,
  aside: Ye,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: Ye,
  base: { attrs: { href: null, target: Xu } },
  bdi: Ye,
  bdo: Ye,
  blockquote: { attrs: { cite: null } },
  body: Ye,
  br: Ye,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: gO,
      formmethod: mO,
      formnovalidate: ["novalidate"],
      formtarget: Xu,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: Ye,
  center: Ye,
  cite: Ye,
  code: Ye,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: Ye,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: Ye,
  div: Ye,
  dl: Ye,
  dt: Ye,
  em: Ye,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: Ye,
  figure: Ye,
  footer: Ye,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": pO,
      autocomplete: ["on", "off"],
      enctype: gO,
      method: mO,
      novalidate: ["novalidate"],
      target: Xu
    }
  },
  h1: Ye,
  h2: Ye,
  h3: Ye,
  h4: Ye,
  h5: Ye,
  h6: Ye,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: Ye,
  hgroup: Ye,
  hr: Ye,
  html: {
    attrs: { manifest: null }
  },
  i: Ye,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: gO,
      formmethod: mO,
      formnovalidate: ["novalidate"],
      formtarget: Xu,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: Ye,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: Ye,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: Ye,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: pO,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: Ye,
  noscript: Ye,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: Ye,
  param: { attrs: { name: null, value: null } },
  pre: Ye,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: Ye,
  rt: Ye,
  ruby: Ye,
  samp: Ye,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: pO
    }
  },
  section: Ye,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: Ye,
  source: { attrs: { src: null, type: null, media: null } },
  span: Ye,
  strong: Ye,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: Ye,
  summary: Ye,
  sup: Ye,
  table: Ye,
  tbody: Ye,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: Ye,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: Ye,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: Ye,
  time: { attrs: { datetime: null } },
  title: Ye,
  tr: Ye,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: Ye,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: Ye
}, AD = {
  accesskey: null,
  class: null,
  contenteditable: Ri,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Ri,
  autocorrect: Ri,
  autocapitalize: Ri,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Ri,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Ri,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Ri,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Ri,
  "aria-hidden": Ri,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Ri,
  "aria-multiselectable": Ri,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Ri,
  "aria-relevant": null,
  "aria-required": Ri,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, RD = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((t) => "on" + t);
for (let t of RD)
  AD[t] = null;
class Np {
  constructor(e, n) {
    this.tags = Object.assign(Object.assign({}, mae), e), this.globalAttrs = Object.assign(Object.assign({}, AD), n), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
Np.default = /* @__PURE__ */ new Np();
function hu(t, e, n = t.length) {
  if (!e)
    return "";
  let i = e.firstChild, r = i && i.getChild("TagName");
  return r ? t.sliceString(r.from, Math.min(r.to, n)) : "";
}
function fu(t, e = !1) {
  for (; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function DD(t, e, n) {
  let i = n.tags[hu(t, fu(e))];
  return (i == null ? void 0 : i.children) || n.allTags;
}
function U0(t, e) {
  let n = [];
  for (let i = fu(e); i && !i.type.isTop; i = fu(i.parent)) {
    let r = hu(t, i);
    if (r && i.lastChild.name == "CloseTag")
      break;
    r && n.indexOf(r) < 0 && (e.name == "EndTag" || e.from >= i.firstChild.to) && n.push(r);
  }
  return n;
}
const QD = /^[:\-\.\w\u00b7-\uffff]*$/;
function Fx(t, e, n, i, r) {
  let o = /\s*>/.test(t.sliceDoc(r, r + 5)) ? "" : ">", s = fu(n, !0);
  return {
    from: i,
    to: r,
    options: DD(t.doc, s, e).map((a) => ({ label: a, type: "type" })).concat(U0(t.doc, n).map((a, l) => ({
      label: "/" + a,
      apply: "/" + a + o,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function qx(t, e, n, i) {
  let r = /\s*>/.test(t.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: n,
    to: i,
    options: U0(t.doc, e).map((o, s) => ({ label: o, apply: o + r, type: "type", boost: 99 - s })),
    validFor: QD
  };
}
function gae(t, e, n, i) {
  let r = [], o = 0;
  for (let s of DD(t.doc, n, e))
    r.push({ label: "<" + s, type: "type" });
  for (let s of U0(t.doc, n))
    r.push({ label: "</" + s + ">", type: "type", boost: 99 - o++ });
  return { from: i, to: i, options: r, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function Oae(t, e, n, i, r) {
  let o = fu(n), s = o ? e.tags[hu(t.doc, o)] : null, a = s && s.attrs ? Object.keys(s.attrs) : [], l = s && s.globalAttrs === !1 ? a : a.length ? a.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: i,
    to: r,
    options: l.map((u) => ({ label: u, type: "property" })),
    validFor: QD
  };
}
function vae(t, e, n, i, r) {
  var o;
  let s = (o = n.parent) === null || o === void 0 ? void 0 : o.getChild("AttributeName"), a = [], l;
  if (s) {
    let u = t.sliceDoc(s.from, s.to), c = e.globalAttrs[u];
    if (!c) {
      let d = fu(n), h = d ? e.tags[hu(t.doc, d)] : null;
      c = (h == null ? void 0 : h.attrs) && h.attrs[u];
    }
    if (c) {
      let d = t.sliceDoc(i, r).toLowerCase(), h = '"', f = '"';
      /^['"]/.test(d) ? (l = d[0] == '"' ? /^[^"]*$/ : /^[^']*$/, h = "", f = t.sliceDoc(r, r + 1) == d[0] ? "" : d[0], d = d.slice(1), i++) : l = /^[^\s<>='"]*$/;
      for (let p of c)
        a.push({ label: p, apply: h + p + f, type: "constant" });
    }
  }
  return { from: i, to: r, options: a, validFor: l };
}
function yae(t, e) {
  let { state: n, pos: i } = e, r = hn(n).resolveInner(i, -1), o = r.resolve(i);
  for (let s = i, a; o == r && (a = r.childBefore(s)); ) {
    let l = a.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    o = r = a, s = l.from;
  }
  return r.name == "TagName" ? r.parent && /CloseTag$/.test(r.parent.name) ? qx(n, r, r.from, i) : Fx(n, t, r, r.from, i) : r.name == "StartTag" ? Fx(n, t, r, i, i) : r.name == "StartCloseTag" || r.name == "IncompleteCloseTag" ? qx(n, r, i, i) : r.name == "OpenTag" || r.name == "SelfClosingTag" || r.name == "AttributeName" ? Oae(n, t, r, r.name == "AttributeName" ? r.from : i, i) : r.name == "Is" || r.name == "AttributeValue" || r.name == "UnquotedAttributeValue" ? vae(n, t, r, r.name == "Is" ? i : r.from, i) : e.explicit && (o.name == "Element" || o.name == "Text" || o.name == "Document") ? gae(n, t, r, i) : null;
}
function bae(t) {
  let { extraTags: e, extraGlobalAttributes: n } = t, i = n || e ? new Np(e, n) : Np.default;
  return (r) => yae(i, r);
}
const wae = /* @__PURE__ */ oo.parser.configure({ top: "SingleExpression" }), ND = [
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript" || t.lang == "ts",
    parser: TD.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/babel" || t.type == "text/jsx",
    parser: $D.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript-jsx",
    parser: PD.parser
  },
  {
    tag: "script",
    attrs(t) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(t.type);
    },
    parser: wae
  },
  {
    tag: "script",
    attrs(t) {
      return !t.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type);
    },
    parser: oo.parser
  },
  {
    tag: "style",
    attrs(t) {
      return (!t.lang || t.lang == "css") && (!t.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t.type));
    },
    parser: Qp.parser
  }
], ID = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ Qp.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ RD.map((t) => ({ name: t, parser: oo.parser }))), LD = /* @__PURE__ */ au.define({
  name: "html",
  parser: /* @__PURE__ */ Joe.configure({
    props: [
      /* @__PURE__ */ $m.add({
        Element(t) {
          let e = /^(\s*)(<\/)?/.exec(t.textAfter);
          return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.node.from) + (e[2] ? 0 : t.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        },
        Document(t) {
          if (t.pos + /\s*/.exec(t.textAfter)[0].length < t.node.to)
            return t.continue();
          let e = null, n;
          for (let i = t.node; ; ) {
            let r = i.lastChild;
            if (!r || r.name != "Element" || r.to != i.to)
              break;
            e = i = r;
          }
          return e && !((n = e.lastChild) && (n.name == "CloseTag" || n.name == "SelfClosingTag")) ? t.lineIndent(e.from) + t.unit : null;
        }
      }),
      /* @__PURE__ */ Pm.add({
        Element(t) {
          let e = t.firstChild, n = t.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: n.name == "CloseTag" ? n.from : t.to };
        }
      }),
      /* @__PURE__ */ FA.add({
        "OpenTag CloseTag": (t) => t.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), tf = /* @__PURE__ */ LD.configure({
  wrap: /* @__PURE__ */ gD(ND, ID)
});
function kae(t = {}) {
  let e = "", n;
  t.matchClosingTags === !1 && (e = "noMatch"), t.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (t.nestedLanguages && t.nestedLanguages.length || t.nestedAttributes && t.nestedAttributes.length) && (n = gD((t.nestedLanguages || []).concat(ND), (t.nestedAttributes || []).concat(ID)));
  let i = n ? LD.configure({ wrap: n, dialect: e }) : e ? tf.configure({ dialect: e }) : tf;
  return new $0(i, [
    tf.data.of({ autocomplete: bae(t) }),
    t.autoCloseTags !== !1 ? Sae : [],
    dae().support,
    $se().support
  ]);
}
const Wx = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), Sae = /* @__PURE__ */ Le.inputHandler.of((t, e, n, i, r) => {
  if (t.composing || t.state.readOnly || e != n || i != ">" && i != "/" || !tf.isActiveAt(t.state, e, -1))
    return !1;
  let o = r(), { state: s } = o, a = s.changeByRange((l) => {
    var u, c, d;
    let h = s.doc.sliceString(l.from - 1, l.to) == i, { head: f } = l, p = hn(s).resolveInner(f, -1), m;
    if (h && i == ">" && p.name == "EndTag") {
      let g = p.parent;
      if (((c = (u = g.parent) === null || u === void 0 ? void 0 : u.lastChild) === null || c === void 0 ? void 0 : c.name) != "CloseTag" && (m = hu(s.doc, g.parent, f)) && !Wx.has(m)) {
        let O = f + (s.doc.sliceString(f, f + 1) === ">" ? 1 : 0), y = `</${m}>`;
        return { range: l, changes: { from: f, to: O, insert: y } };
      }
    } else if (h && i == "/" && p.name == "IncompleteCloseTag") {
      let g = p.parent;
      if (p.from == f - 2 && ((d = g.lastChild) === null || d === void 0 ? void 0 : d.name) != "CloseTag" && (m = hu(s.doc, g, f)) && !Wx.has(m)) {
        let O = f + (s.doc.sliceString(f, f + 1) === ">" ? 1 : 0), y = `${m}>`;
        return {
          range: ve.cursor(f + y.length, -1),
          changes: { from: f, to: O, insert: y }
        };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (t.dispatch([
    o,
    s.update(a, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), _ae = { key: 0 }, xae = { class: "mt-text-editor__box" }, Cae = { class: "mt-text-editor__footer" }, Tae = { class: "mt-text-editor__footer-left" }, $ae = { class: "mt-text-editor__footer-right" }, Pae = /* @__PURE__ */ Te({
  __name: "mt-text-editor",
  props: {
    modelValue: {
      type: String,
      default: "",
      required: !0
    },
    /**
     * Enable inline edit mode
     */
    isInlineEdit: {
      type: Boolean,
      default: !1
    },
    /**
     * Add custom configuration for the tip tap editor
     */
    tipTapConfig: {
      type: Object,
      default: () => ({})
    },
    /**
     * Custom buttons to be added to the toolbar
     */
    customButtons: {
      type: Array,
      default: () => []
    },
    /**
     * Excluded buttons from the toolbar
     */
    excludedButtons: {
      type: Array,
      default: () => []
    },
    /**
     * Add disabled state to the editor
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * Add placeholder text to the editor
     */
    placeholder: {
      type: String,
      default: ""
    },
    /**
     * An error in your business logic related to this field.
     *
     * @example {"code": 500, "detail": "Error while saving"}
     */
    error: {
      type: Object,
      required: !1,
      default: null
    },
    /**
     * A label for your text field. Usually used to guide the user what value this field controls.
     */
    label: {
      type: String,
      required: !1,
      default: null
    }
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const { t: n } = Lt({
      useScope: "global",
      messages: {
        en: {
          "mt-text-editor": {
            buttons: {
              "toggle-code": "Toggle code"
            },
            footer: {
              characters: "{characters} characters"
            }
          }
        },
        de: {
          "mt-text-editor": {
            buttons: {
              "toggle-code": "Codeansicht umschalten"
            },
            footer: {
              characters: "{characters} Zeichen"
            }
          }
        }
      }
    }), i = e, r = t, o = J(() => ({
      "mt-text-editor--inline-edit": r.isInlineEdit,
      "mt-text-editor--disabled": r.disabled,
      "mt-text-editor--error": !!r.error
    })), s = n6({
      ...r.tipTapConfig,
      extensions: [
        nG,
        iG,
        rG,
        oG,
        sG.configure({
          types: ["paragraph", "heading"]
        }),
        lG,
        aG,
        EG.configure({
          openOnClick: !1
        }),
        AG.configure({}),
        Q9.configure({
          resizable: !0
        }),
        L9,
        I9,
        N9,
        V9.configure({
          placeholder: r.placeholder,
          showOnlyWhenEditable: !0
        }),
        ...r.tipTapConfig.extensions ?? []
      ],
      content: r.modelValue,
      editorProps: {
        attributes: {
          class: "mt-text-editor__content-editor"
        }
      },
      onUpdate: ({ editor: m }) => {
        i("update:modelValue", m.getHTML());
      },
      editable: !r.disabled
    });
    gt(
      () => r.modelValue,
      (m) => {
        var O, y;
        h.value || ((O = s.value) == null ? void 0 : O.getHTML()) === m || (y = s.value) == null || y.commands.setContent(m, !1);
      }
    ), gt(
      () => r.disabled,
      (m) => {
        var g;
        (g = s.value) == null || g.setEditable(!m);
      }
    );
    const a = J(() => r.disabled || h.value), l = J(() => [...[
      H9,
      eK,
      oK,
      {
        name: "toggle-code",
        label: "mt-text-editor.buttons.toggle-code",
        icon: "regular-code-xs",
        action: () => h.value = !h.value,
        alignment: "right",
        position: 3e3,
        disabled: () => !1
      }
    ], ...r.customButtons]), u = Bs([]), c = (m) => {
      u.splice(0, u.length, ...m);
    }, d = J(() => r.isInlineEdit ? ir(J7) : ir("div")), h = re(!1), f = kae();
    gt(
      () => h.value,
      (m, g) => {
        var O;
        !m && g && ((O = s.value) == null || O.commands.setContent(r.modelValue, !1));
      }
    );
    const p = zo();
    return (m, g) => E(s) ? (_(), Z("div", {
      key: 0,
      class: Ae(["mt-text-editor", o.value])
    }, [
      t.label ? (_(), Z("label", _ae, Pe(t.label), 1)) : W("", !0),
      X("div", xae, [
        (_(), ue(ar(d.value), {
          editor: E(s),
          tippyOptions: {
            maxWidth: "none",
            zIndex: 1e3
          },
          key: t.isInlineEdit
        }, {
          default: H(() => [
            fe(j9, {
              editor: E(s),
              "custom-buttons": l.value,
              disabled: a.value,
              onUpdateContextualButtons: c,
              excludedButtons: t.excludedButtons
            }, un({
              "button_text-color": H(({ editor: O, disabled: y, button: b }) => [
                fe(G9, {
                  editor: O,
                  disabled: y,
                  button: b
                }, null, 8, ["editor", "disabled", "button"])
              ]),
              button_link: H(({ editor: O, disabled: y, button: b }) => [
                fe(nK, {
                  editor: O,
                  disabled: y,
                  button: b
                }, null, 8, ["editor", "disabled", "button"])
              ]),
              button_table: H(({ editor: O, disabled: y, button: b }) => [
                fe(aK, {
                  editor: O,
                  disabled: y,
                  button: b
                }, null, 8, ["editor", "disabled", "button"])
              ]),
              _: 2
            }, [
              Ge(E(p), (O, y) => ({
                name: y,
                fn: H((b) => [
                  ne(m.$slots, y, Ct(Zt(b)), void 0, !0)
                ])
              }))
            ]), 1032, ["editor", "custom-buttons", "disabled", "excludedButtons"])
          ]),
          _: 3
        }, 8, ["editor"])),
        h.value ? (_(), ue(E(loe), {
          key: 1,
          lang: E(f),
          modelValue: t.modelValue,
          "onUpdate:modelValue": g[0] || (g[0] = (O) => i("update:modelValue", O)),
          class: "mt-text-editor__code-editor",
          wrap: "",
          basic: "",
          disabled: t.disabled
        }, null, 8, ["lang", "modelValue", "disabled"])) : (_(), ue(E(t6), {
          key: 0,
          editor: E(s),
          class: "mt-text-editor__content"
        }, null, 8, ["editor"])),
        X("div", Cae, [
          X("div", Tae, [
            t.disabled ? W("", !0) : ne(m.$slots, "contextual-buttons", {
              key: 0,
              editor: E(s),
              buttons: u
            }, () => [
              (_(!0), Z(Qe, null, Ge(u, (O) => (_(), Z(Qe, {
                key: O.name
              }, [
                O.children ? (_(), ue(Qs, { key: 0 }, {
                  trigger: H(({ toggleFloatingUi: y }) => [
                    fe(vs, {
                      button: O,
                      editor: E(s),
                      onClick: y,
                      disabled: a.value
                    }, null, 8, ["button", "editor", "onClick", "disabled"])
                  ]),
                  "popover-items__base": H(({ toggleFloatingUi: y }) => [
                    (_(!0), Z(Qe, null, Ge(O.children, (b) => (_(), ue(Zo, {
                      key: b.name,
                      label: b.label,
                      icon: b.icon,
                      type: b.isActive && b.isActive(E(s)) ? "active" : "default",
                      onLabelClick: () => {
                        var v;
                        (v = O.action) == null || v.call(O, E(s)), y();
                      }
                    }, null, 8, ["label", "icon", "type", "onLabelClick"]))), 128))
                  ]),
                  _: 2
                }, 1024)) : (_(), ue(vs, {
                  key: 1,
                  button: O,
                  editor: E(s),
                  disabled: a.value,
                  onClick: (y) => {
                    var b;
                    return (b = O.action) == null ? void 0 : b.call(O, E(s));
                  }
                }, null, 8, ["button", "editor", "disabled", "onClick"]))
              ], 64))), 128))
            ], !0),
            ne(m.$slots, "footer-left", { editor: E(s) }, void 0, !0)
          ]),
          X("div", $ae, [
            ne(m.$slots, "footer-right", { editor: E(s) }, () => {
              var O;
              return [
                He(Pe(E(n)("mt-text-editor.footer.characters", {
                  characters: (O = E(s)) == null ? void 0 : O.storage.characterCount.characters()
                })), 1)
              ];
            }, !0)
          ])
        ])
      ]),
      t.error ? (_(), ue(Xs, {
        key: 1,
        error: t.error
      }, null, 8, ["error"])) : W("", !0)
    ], 2)) : W("", !0);
  }
});
const ule = /* @__PURE__ */ je(Pae, [["__scopeId", "data-v-5dc464fb"]]);
export {
  zae as DeviceHelperPlugin,
  Dae as MtBanner,
  Sr as MtButton,
  lW as MtCard,
  em as MtCheckbox,
  eF as MtColorpicker,
  Zae as MtDataTable,
  Rae as MtDatepicker,
  Nae as MtEmailField,
  hW as MtEmptyState,
  gb as MtFloatingUi,
  mt as MtIcon,
  VX as MtInset,
  lF as MtLink,
  rb as MtLoader,
  h$ as MtModal,
  Wae as MtModalAction,
  yb as MtModalClose,
  f$ as MtModalRoot,
  qae as MtModalTrigger,
  NO as MtNumberField,
  NW as MtPagination,
  Iae as MtPasswordField,
  Qs as MtPopover,
  Zo as MtPopoverItem,
  r$ as MtPopoverItemResult,
  Qae as MtProgressBar,
  uq as MtSelect,
  iX as MtSkeletonBar,
  Lae as MtSlider,
  rm as MtSwitch,
  Bae as MtTabs,
  Pi as MtText,
  ule as MtTextEditor,
  vs as MtTextEditorToolbarButton,
  im as MtTextField,
  Vae as MtTextarea,
  Xae as MtThemeProvider,
  Fae as MtToast,
  jae as MtTooltip,
  Dae as SwBanner,
  Sr as SwButton,
  lW as SwCard,
  em as SwCheckbox,
  eF as SwColorpicker,
  Zae as SwDataTable,
  Rae as SwDatepicker,
  Nae as SwEmailField,
  mt as SwIcon,
  rb as SwLoader,
  NO as SwNumberField,
  NW as SwPagination,
  Iae as SwPasswordField,
  Qae as SwProgressBar,
  uq as SwSelect,
  iX as SwSkeletonBar,
  rm as SwSwitch,
  Bae as SwTabs,
  im as SwTextField,
  Vae as SwTextarea,
  ja as TooltipDirective
};
//# sourceMappingURL=index.js.map
